Classfile /Users/mw/Projects/slang-braindump/.jar/jar11/assemble/slang-braindump/assemble/content/org/sireum/Library_Ext$.class
  Last modified May 29, 2022; size 1057146 bytes
  SHA-256 checksum 2f119a4ed964b2912b2df67bcc690a58d6e70cb09004dbfec28db42618430e90
  Compiled from "Library_Ext.scala"
public final class org.sireum.Library_Ext$
  minor version: 0
  major version: 52
  flags: (0x0031) ACC_PUBLIC, ACC_FINAL, ACC_SUPER
  this_class: #2                          // org/sireum/Library_Ext$
  super_class: #4                         // java/lang/Object
  interfaces: 0, fields: 1, methods: 105, attributes: 5
Constant pool:
    #1 = Utf8               org/sireum/Library_Ext$
    #2 = Class              #1            // org/sireum/Library_Ext$
    #3 = Utf8               java/lang/Object
    #4 = Class              #3            // java/lang/Object
    #5 = Utf8               Library_Ext.scala
    #6 = Utf8               java/lang/invoke/MethodHandles$Lookup
    #7 = Class              #6            // java/lang/invoke/MethodHandles$Lookup
    #8 = Utf8               java/lang/invoke/MethodHandles
    #9 = Class              #8            // java/lang/invoke/MethodHandles
   #10 = Utf8               Lookup
   #11 = Utf8               org/sireum/$internal/PackageTrait$ISZ$
   #12 = Class              #11           // org/sireum/$internal/PackageTrait$ISZ$
   #13 = Utf8               org/sireum/$internal/PackageTrait
   #14 = Class              #13           // org/sireum/$internal/PackageTrait
   #15 = Utf8               ISZ$
   #16 = Utf8               org/sireum/$internal/Trie$Node
   #17 = Class              #16           // org/sireum/$internal/Trie$Node
   #18 = Utf8               org/sireum/$internal/Trie
   #19 = Class              #18           // org/sireum/$internal/Trie
   #20 = Utf8               Node
   #21 = Utf8               MODULE$
   #22 = Utf8               Lorg/sireum/Library_Ext$;
   #23 = Utf8               <clinit>
   #24 = Utf8               ()V
   #25 = Utf8               <init>
   #26 = NameAndType        #25:#24       // "<init>":()V
   #27 = Methodref          #2.#26        // org/sireum/Library_Ext$."<init>":()V
   #28 = NameAndType        #21:#22       // MODULE$:Lorg/sireum/Library_Ext$;
   #29 = Fieldref           #2.#28        // org/sireum/Library_Ext$.MODULE$:Lorg/sireum/Library_Ext$;
   #30 = Utf8               sharedMap
   #31 = Utf8               ()Lscala/collection/Map;
   #32 = Utf8               ()Lscala/collection/Map<Lscala/collection/immutable/Vector<Ljava/lang/String;>;Ljava/lang/String;>;
   #33 = Utf8               scala/collection/immutable/ListMap$
   #34 = Class              #33           // scala/collection/immutable/ListMap$
   #35 = Utf8               Lscala/collection/immutable/ListMap$;
   #36 = NameAndType        #21:#35       // MODULE$:Lscala/collection/immutable/ListMap$;
   #37 = Fieldref           #34.#36       // scala/collection/immutable/ListMap$.MODULE$:Lscala/collection/immutable/ListMap$;
   #38 = Utf8               scala/runtime/ScalaRunTime$
   #39 = Class              #38           // scala/runtime/ScalaRunTime$
   #40 = Utf8               Lscala/runtime/ScalaRunTime$;
   #41 = NameAndType        #21:#40       // MODULE$:Lscala/runtime/ScalaRunTime$;
   #42 = Fieldref           #39.#41       // scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
   #43 = Utf8               scala/Tuple2
   #44 = Class              #43           // scala/Tuple2
   #45 = Utf8               scala/package$
   #46 = Class              #45           // scala/package$
   #47 = Utf8               Lscala/package$;
   #48 = NameAndType        #21:#47       // MODULE$:Lscala/package$;
   #49 = Fieldref           #46.#48       // scala/package$.MODULE$:Lscala/package$;
   #50 = Utf8               Vector
   #51 = Utf8               ()Lscala/collection/immutable/Vector$;
   #52 = NameAndType        #50:#51       // Vector:()Lscala/collection/immutable/Vector$;
   #53 = Methodref          #46.#52       // scala/package$.Vector:()Lscala/collection/immutable/Vector$;
   #54 = Utf8               java/lang/String
   #55 = Class              #54           // java/lang/String
   #56 = Utf8               org
   #57 = String             #56           // org
   #58 = Utf8               sireum
   #59 = String             #58           // sireum
   #60 = Utf8               HashBag.scala
   #61 = String             #60           // HashBag.scala
   #62 = Utf8               [Ljava/lang/Object;
   #63 = Class              #62           // "[Ljava/lang/Object;"
   #64 = Utf8               wrapRefArray
   #65 = Utf8               ([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
   #66 = NameAndType        #64:#65       // wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
   #67 = Methodref          #39.#66       // scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
   #68 = Utf8               scala/collection/immutable/Vector$
   #69 = Class              #68           // scala/collection/immutable/Vector$
   #70 = Utf8               apply
   #71 = Utf8               (Lscala/collection/immutable/Seq;)Ljava/lang/Object;
   #72 = NameAndType        #70:#71       // apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
   #73 = Methodref          #69.#72       // scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
   #74 = Utf8               f0$1
   #75 = Utf8               ()Ljava/lang/String;
   #76 = NameAndType        #74:#75       // f0$1:()Ljava/lang/String;
   #77 = Methodref          #2.#76        // org/sireum/Library_Ext$.f0$1:()Ljava/lang/String;
   #78 = Utf8               (Ljava/lang/Object;Ljava/lang/Object;)V
   #79 = NameAndType        #25:#78       // "<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
   #80 = Methodref          #44.#79       // scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
   #81 = Utf8               Indexable.scala
   #82 = String             #81           // Indexable.scala
   #83 = Utf8               f0$2
   #84 = NameAndType        #83:#75       // f0$2:()Ljava/lang/String;
   #85 = Methodref          #2.#84        // org/sireum/Library_Ext$.f0$2:()Ljava/lang/String;
   #86 = Utf8               Either.scala
   #87 = String             #86           // Either.scala
   #88 = Utf8               f0$3
   #89 = NameAndType        #88:#75       // f0$3:()Ljava/lang/String;
   #90 = Methodref          #2.#89        // org/sireum/Library_Ext$.f0$3:()Ljava/lang/String;
   #91 = Utf8               crypto
   #92 = String             #91           // crypto
   #93 = Utf8               SHA3.scala
   #94 = String             #93           // SHA3.scala
   #95 = Utf8               f0$4
   #96 = NameAndType        #95:#75       // f0$4:()Ljava/lang/String;
   #97 = Methodref          #2.#96        // org/sireum/Library_Ext$.f0$4:()Ljava/lang/String;
   #98 = Utf8               Hash.scala
   #99 = String             #98           // Hash.scala
  #100 = Utf8               f0$5
  #101 = NameAndType        #100:#75      // f0$5:()Ljava/lang/String;
  #102 = Methodref          #2.#101       // org/sireum/Library_Ext$.f0$5:()Ljava/lang/String;
  #103 = Utf8               CircularQueue.scala
  #104 = String             #103          // CircularQueue.scala
  #105 = Utf8               f0$6
  #106 = NameAndType        #105:#75      // f0$6:()Ljava/lang/String;
  #107 = Methodref          #2.#106       // org/sireum/Library_Ext$.f0$6:()Ljava/lang/String;
  #108 = Utf8               Library.scala
  #109 = String             #108          // Library.scala
  #110 = Utf8               f0$7
  #111 = NameAndType        #110:#75      // f0$7:()Ljava/lang/String;
  #112 = Methodref          #2.#111       // org/sireum/Library_Ext$.f0$7:()Ljava/lang/String;
  #113 = Utf8               UnionFind.scala
  #114 = String             #113          // UnionFind.scala
  #115 = Utf8               f0$8
  #116 = NameAndType        #115:#75      // f0$8:()Ljava/lang/String;
  #117 = Methodref          #2.#116       // org/sireum/Library_Ext$.f0$8:()Ljava/lang/String;
  #118 = Utf8               extension
  #119 = String             #118          // extension
  #120 = Utf8               Time.scala
  #121 = String             #120          // Time.scala
  #122 = Utf8               f0$9
  #123 = NameAndType        #122:#75      // f0$9:()Ljava/lang/String;
  #124 = Methodref          #2.#123       // org/sireum/Library_Ext$.f0$9:()Ljava/lang/String;
  #125 = Utf8               Console.scala
  #126 = String             #125          // Console.scala
  #127 = Utf8               f0$10
  #128 = NameAndType        #127:#75      // f0$10:()Ljava/lang/String;
  #129 = Methodref          #2.#128       // org/sireum/Library_Ext$.f0$10:()Ljava/lang/String;
  #130 = Utf8               Debug.scala
  #131 = String             #130          // Debug.scala
  #132 = Utf8               f0$11
  #133 = NameAndType        #132:#75      // f0$11:()Ljava/lang/String;
  #134 = Methodref          #2.#133       // org/sireum/Library_Ext$.f0$11:()Ljava/lang/String;
  #135 = Utf8               Cancel.scala
  #136 = String             #135          // Cancel.scala
  #137 = Utf8               f0$12
  #138 = NameAndType        #137:#75      // f0$12:()Ljava/lang/String;
  #139 = Methodref          #2.#138       // org/sireum/Library_Ext$.f0$12:()Ljava/lang/String;
  #140 = Utf8               BitsRangeTypes.scala
  #141 = String             #140          // BitsRangeTypes.scala
  #142 = Utf8               f0$13
  #143 = NameAndType        #142:#75      // f0$13:()Ljava/lang/String;
  #144 = Methodref          #2.#143       // org/sireum/Library_Ext$.f0$13:()Ljava/lang/String;
  #145 = Utf8               Stack.scala
  #146 = String             #145          // Stack.scala
  #147 = Utf8               f0$14
  #148 = NameAndType        #147:#75      // f0$14:()Ljava/lang/String;
  #149 = Methodref          #2.#148       // org/sireum/Library_Ext$.f0$14:()Ljava/lang/String;
  #150 = Utf8               Option.scala
  #151 = String             #150          // Option.scala
  #152 = Utf8               f0$15
  #153 = NameAndType        #152:#75      // f0$15:()Ljava/lang/String;
  #154 = Methodref          #2.#153       // org/sireum/Library_Ext$.f0$15:()Ljava/lang/String;
  #155 = Utf8               conversions
  #156 = String             #155          // conversions
  #157 = Utf8               Collection.scala
  #158 = String             #157          // Collection.scala
  #159 = Utf8               f0$16
  #160 = NameAndType        #159:#75      // f0$16:()Ljava/lang/String;
  #161 = Methodref          #2.#160       // org/sireum/Library_Ext$.f0$16:()Ljava/lang/String;
  #162 = Utf8               conversions.scala
  #163 = String             #162          // conversions.scala
  #164 = Utf8               java/lang/StringBuilder
  #165 = Class              #164          // java/lang/StringBuilder
  #166 = Integer            0
  #167 = Utf8               (I)V
  #168 = NameAndType        #25:#167      // "<init>":(I)V
  #169 = Methodref          #165.#168     // java/lang/StringBuilder."<init>":(I)V
  #170 = Utf8               f0$17
  #171 = NameAndType        #170:#75      // f0$17:()Ljava/lang/String;
  #172 = Methodref          #2.#171       // org/sireum/Library_Ext$.f0$17:()Ljava/lang/String;
  #173 = Utf8               append
  #174 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;
  #175 = NameAndType        #173:#174     // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
  #176 = Methodref          #165.#175     // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
  #177 = Utf8               f1$1
  #178 = NameAndType        #177:#75      // f1$1:()Ljava/lang/String;
  #179 = Methodref          #2.#178       // org/sireum/Library_Ext$.f1$1:()Ljava/lang/String;
  #180 = Utf8               f2$1
  #181 = NameAndType        #180:#75      // f2$1:()Ljava/lang/String;
  #182 = Methodref          #2.#181       // org/sireum/Library_Ext$.f2$1:()Ljava/lang/String;
  #183 = Utf8               f3$1
  #184 = NameAndType        #183:#75      // f3$1:()Ljava/lang/String;
  #185 = Methodref          #2.#184       // org/sireum/Library_Ext$.f3$1:()Ljava/lang/String;
  #186 = Utf8               f4$1
  #187 = NameAndType        #186:#75      // f4$1:()Ljava/lang/String;
  #188 = Methodref          #2.#187       // org/sireum/Library_Ext$.f4$1:()Ljava/lang/String;
  #189 = Utf8               f5$1
  #190 = NameAndType        #189:#75      // f5$1:()Ljava/lang/String;
  #191 = Methodref          #2.#190       // org/sireum/Library_Ext$.f5$1:()Ljava/lang/String;
  #192 = Utf8               toString
  #193 = NameAndType        #192:#75      // toString:()Ljava/lang/String;
  #194 = Methodref          #165.#193     // java/lang/StringBuilder.toString:()Ljava/lang/String;
  #195 = Utf8               HashMap.scala
  #196 = String             #195          // HashMap.scala
  #197 = Utf8               f0$18
  #198 = NameAndType        #197:#75      // f0$18:()Ljava/lang/String;
  #199 = Methodref          #2.#198       // org/sireum/Library_Ext$.f0$18:()Ljava/lang/String;
  #200 = Utf8               Jen.scala
  #201 = String             #200          // Jen.scala
  #202 = Utf8               f0$19
  #203 = NameAndType        #202:#75      // f0$19:()Ljava/lang/String;
  #204 = Methodref          #2.#203       // org/sireum/Library_Ext$.f0$19:()Ljava/lang/String;
  #205 = Utf8               MOption.scala
  #206 = String             #205          // MOption.scala
  #207 = Utf8               f0$20
  #208 = NameAndType        #207:#75      // f0$20:()Ljava/lang/String;
  #209 = Methodref          #2.#208       // org/sireum/Library_Ext$.f0$20:()Ljava/lang/String;
  #210 = Utf8               HashSet.scala
  #211 = String             #210          // HashSet.scala
  #212 = Utf8               f0$21
  #213 = NameAndType        #212:#75      // f0$21:()Ljava/lang/String;
  #214 = Methodref          #2.#213       // org/sireum/Library_Ext$.f0$21:()Ljava/lang/String;
  #215 = Utf8               BuiltInTypes.slang
  #216 = String             #215          // BuiltInTypes.slang
  #217 = Utf8               f0$22
  #218 = NameAndType        #217:#75      // f0$22:()Ljava/lang/String;
  #219 = Methodref          #2.#218       // org/sireum/Library_Ext$.f0$22:()Ljava/lang/String;
  #220 = Utf8               message
  #221 = String             #220          // message
  #222 = Utf8               Message.scala
  #223 = String             #222          // Message.scala
  #224 = Utf8               f0$23
  #225 = NameAndType        #224:#75      // f0$23:()Ljava/lang/String;
  #226 = Methodref          #2.#225       // org/sireum/Library_Ext$.f0$23:()Ljava/lang/String;
  #227 = Utf8               Reporter.scala
  #228 = String             #227          // Reporter.scala
  #229 = Utf8               f0$24
  #230 = NameAndType        #229:#75      // f0$24:()Ljava/lang/String;
  #231 = Methodref          #2.#230       // org/sireum/Library_Ext$.f0$24:()Ljava/lang/String;
  #232 = Utf8               ObjPrinter.scala
  #233 = String             #232          // ObjPrinter.scala
  #234 = Utf8               f0$25
  #235 = NameAndType        #234:#75      // f0$25:()Ljava/lang/String;
  #236 = Methodref          #2.#235       // org/sireum/Library_Ext$.f0$25:()Ljava/lang/String;
  #237 = Utf8               cli
  #238 = String             #237          // cli
  #239 = Utf8               JSON.scala
  #240 = String             #239          // JSON.scala
  #241 = Utf8               f0$26
  #242 = NameAndType        #241:#75      // f0$26:()Ljava/lang/String;
  #243 = Methodref          #2.#242       // org/sireum/Library_Ext$.f0$26:()Ljava/lang/String;
  #244 = Utf8               f1$2
  #245 = NameAndType        #244:#75      // f1$2:()Ljava/lang/String;
  #246 = Methodref          #2.#245       // org/sireum/Library_Ext$.f1$2:()Ljava/lang/String;
  #247 = Utf8               CliOpt.scala
  #248 = String             #247          // CliOpt.scala
  #249 = Utf8               f0$27
  #250 = NameAndType        #249:#75      // f0$27:()Ljava/lang/String;
  #251 = Methodref          #2.#250       // org/sireum/Library_Ext$.f0$27:()Ljava/lang/String;
  #252 = Utf8               MEither.scala
  #253 = String             #252          // MEither.scala
  #254 = Utf8               f0$28
  #255 = NameAndType        #254:#75      // f0$28:()Ljava/lang/String;
  #256 = Methodref          #2.#255       // org/sireum/Library_Ext$.f0$28:()Ljava/lang/String;
  #257 = Utf8               parser
  #258 = String             #257          // parser
  #259 = Utf8               ParseTree.scala
  #260 = String             #259          // ParseTree.scala
  #261 = Utf8               f0$29
  #262 = NameAndType        #261:#75      // f0$29:()Ljava/lang/String;
  #263 = Methodref          #2.#262       // org/sireum/Library_Ext$.f0$29:()Ljava/lang/String;
  #264 = Utf8               JsonParser.scala
  #265 = String             #264          // JsonParser.scala
  #266 = Utf8               f0$30
  #267 = NameAndType        #266:#75      // f0$30:()Ljava/lang/String;
  #268 = Methodref          #2.#267       // org/sireum/Library_Ext$.f0$30:()Ljava/lang/String;
  #269 = Utf8               f1$3
  #270 = NameAndType        #269:#75      // f1$3:()Ljava/lang/String;
  #271 = Methodref          #2.#270       // org/sireum/Library_Ext$.f1$3:()Ljava/lang/String;
  #272 = Utf8               Json.scala
  #273 = String             #272          // Json.scala
  #274 = Utf8               f0$31
  #275 = NameAndType        #274:#75      // f0$31:()Ljava/lang/String;
  #276 = Methodref          #2.#275       // org/sireum/Library_Ext$.f0$31:()Ljava/lang/String;
  #277 = Utf8               f1$4
  #278 = NameAndType        #277:#75      // f1$4:()Ljava/lang/String;
  #279 = Methodref          #2.#278       // org/sireum/Library_Ext$.f1$4:()Ljava/lang/String;
  #280 = Utf8               f2$2
  #281 = NameAndType        #280:#75      // f2$2:()Ljava/lang/String;
  #282 = Methodref          #2.#281       // org/sireum/Library_Ext$.f2$2:()Ljava/lang/String;
  #283 = Utf8               f3$2
  #284 = NameAndType        #283:#75      // f3$2:()Ljava/lang/String;
  #285 = Methodref          #2.#284       // org/sireum/Library_Ext$.f3$2:()Ljava/lang/String;
  #286 = Utf8               MBox.scala
  #287 = String             #286          // MBox.scala
  #288 = Utf8               f0$32
  #289 = NameAndType        #288:#75      // f0$32:()Ljava/lang/String;
  #290 = Methodref          #2.#289       // org/sireum/Library_Ext$.f0$32:()Ljava/lang/String;
  #291 = Utf8               Graph.scala
  #292 = String             #291          // Graph.scala
  #293 = Utf8               f0$33
  #294 = NameAndType        #293:#75      // f0$33:()Ljava/lang/String;
  #295 = Methodref          #2.#294       // org/sireum/Library_Ext$.f0$33:()Ljava/lang/String;
  #296 = Utf8               project
  #297 = String             #296          // project
  #298 = Utf8               f0$34
  #299 = NameAndType        #298:#75      // f0$34:()Ljava/lang/String;
  #300 = Methodref          #2.#299       // org/sireum/Library_Ext$.f0$34:()Ljava/lang/String;
  #301 = Utf8               Project.scala
  #302 = String             #301          // Project.scala
  #303 = Utf8               f0$35
  #304 = NameAndType        #303:#75      // f0$35:()Ljava/lang/String;
  #305 = Methodref          #2.#304       // org/sireum/Library_Ext$.f0$35:()Ljava/lang/String;
  #306 = Utf8               Bag.scala
  #307 = String             #306          // Bag.scala
  #308 = Utf8               f0$36
  #309 = NameAndType        #308:#75      // f0$36:()Ljava/lang/String;
  #310 = Methodref          #2.#309       // org/sireum/Library_Ext$.f0$36:()Ljava/lang/String;
  #311 = Utf8               presentasi
  #312 = String             #311          // presentasi
  #313 = Utf8               f0$37
  #314 = NameAndType        #313:#75      // f0$37:()Ljava/lang/String;
  #315 = Methodref          #2.#314       // org/sireum/Library_Ext$.f0$37:()Ljava/lang/String;
  #316 = Utf8               Presentation.scala
  #317 = String             #316          // Presentation.scala
  #318 = Utf8               f0$38
  #319 = NameAndType        #318:#75      // f0$38:()Ljava/lang/String;
  #320 = Methodref          #2.#319       // org/sireum/Library_Ext$.f0$38:()Ljava/lang/String;
  #321 = Utf8               MessagePack.scala
  #322 = String             #321          // MessagePack.scala
  #323 = Utf8               f0$39
  #324 = NameAndType        #323:#75      // f0$39:()Ljava/lang/String;
  #325 = Methodref          #2.#324       // org/sireum/Library_Ext$.f0$39:()Ljava/lang/String;
  #326 = Utf8               f1$5
  #327 = NameAndType        #326:#75      // f1$5:()Ljava/lang/String;
  #328 = Methodref          #2.#327       // org/sireum/Library_Ext$.f1$5:()Ljava/lang/String;
  #329 = Utf8               f2$3
  #330 = NameAndType        #329:#75      // f2$3:()Ljava/lang/String;
  #331 = Methodref          #2.#330       // org/sireum/Library_Ext$.f2$3:()Ljava/lang/String;
  #332 = Utf8               f3$3
  #333 = NameAndType        #332:#75      // f3$3:()Ljava/lang/String;
  #334 = Methodref          #2.#333       // org/sireum/Library_Ext$.f3$3:()Ljava/lang/String;
  #335 = Utf8               justification.scala
  #336 = String             #335          // justification.scala
  #337 = Utf8               f0$40
  #338 = NameAndType        #337:#75      // f0$40:()Ljava/lang/String;
  #339 = Methodref          #2.#338       // org/sireum/Library_Ext$.f0$40:()Ljava/lang/String;
  #340 = Utf8               HashSMap.scala
  #341 = String             #340          // HashSMap.scala
  #342 = Utf8               f0$41
  #343 = NameAndType        #342:#75      // f0$41:()Ljava/lang/String;
  #344 = Methodref          #2.#343       // org/sireum/Library_Ext$.f0$41:()Ljava/lang/String;
  #345 = Utf8               SeqUtil.scala
  #346 = String             #345          // SeqUtil.scala
  #347 = Utf8               f0$42
  #348 = NameAndType        #347:#75      // f0$42:()Ljava/lang/String;
  #349 = Methodref          #2.#348       // org/sireum/Library_Ext$.f0$42:()Ljava/lang/String;
  #350 = Utf8               MJen.scala
  #351 = String             #350          // MJen.scala
  #352 = Utf8               f0$43
  #353 = NameAndType        #352:#75      // f0$43:()Ljava/lang/String;
  #354 = Methodref          #2.#353       // org/sireum/Library_Ext$.f0$43:()Ljava/lang/String;
  #355 = Utf8               HashSSet.scala
  #356 = String             #355          // HashSSet.scala
  #357 = Utf8               f0$44
  #358 = NameAndType        #357:#75      // f0$44:()Ljava/lang/String;
  #359 = Methodref          #2.#358       // org/sireum/Library_Ext$.f0$44:()Ljava/lang/String;
  #360 = Utf8               bitcodec
  #361 = String             #360          // bitcodec
  #362 = Utf8               Runtime.scala
  #363 = String             #362          // Runtime.scala
  #364 = Utf8               f0$45
  #365 = NameAndType        #364:#75      // f0$45:()Ljava/lang/String;
  #366 = Methodref          #2.#365       // org/sireum/Library_Ext$.f0$45:()Ljava/lang/String;
  #367 = Utf8               Spec.scala
  #368 = String             #367          // Spec.scala
  #369 = Utf8               f0$46
  #370 = NameAndType        #369:#75      // f0$46:()Ljava/lang/String;
  #371 = Methodref          #2.#370       // org/sireum/Library_Ext$.f0$46:()Ljava/lang/String;
  #372 = Utf8               f1$6
  #373 = NameAndType        #372:#75      // f1$6:()Ljava/lang/String;
  #374 = Methodref          #2.#373       // org/sireum/Library_Ext$.f1$6:()Ljava/lang/String;
  #375 = Utf8               ops
  #376 = String             #375          // ops
  #377 = Utf8               COps.scala
  #378 = String             #377          // COps.scala
  #379 = Utf8               f0$47
  #380 = NameAndType        #379:#75      // f0$47:()Ljava/lang/String;
  #381 = Methodref          #2.#380       // org/sireum/Library_Ext$.f0$47:()Ljava/lang/String;
  #382 = Utf8               StringOps.scala
  #383 = String             #382          // StringOps.scala
  #384 = Utf8               f0$48
  #385 = NameAndType        #384:#75      // f0$48:()Ljava/lang/String;
  #386 = Methodref          #2.#385       // org/sireum/Library_Ext$.f0$48:()Ljava/lang/String;
  #387 = Utf8               GraphOps.scala
  #388 = String             #387          // GraphOps.scala
  #389 = Utf8               f0$49
  #390 = NameAndType        #389:#75      // f0$49:()Ljava/lang/String;
  #391 = Methodref          #2.#390       // org/sireum/Library_Ext$.f0$49:()Ljava/lang/String;
  #392 = Utf8               SOps.scala
  #393 = String             #392          // SOps.scala
  #394 = Utf8               f0$50
  #395 = NameAndType        #394:#75      // f0$50:()Ljava/lang/String;
  #396 = Methodref          #2.#395       // org/sireum/Library_Ext$.f0$50:()Ljava/lang/String;
  #397 = Utf8               f1$7
  #398 = NameAndType        #397:#75      // f1$7:()Ljava/lang/String;
  #399 = Methodref          #2.#398       // org/sireum/Library_Ext$.f1$7:()Ljava/lang/String;
  #400 = Utf8               f2$4
  #401 = NameAndType        #400:#75      // f2$4:()Ljava/lang/String;
  #402 = Methodref          #2.#401       // org/sireum/Library_Ext$.f2$4:()Ljava/lang/String;
  #403 = Utf8               Bits.scala
  #404 = String             #403          // Bits.scala
  #405 = Utf8               f0$51
  #406 = NameAndType        #405:#75      // f0$51:()Ljava/lang/String;
  #407 = Methodref          #2.#406       // org/sireum/Library_Ext$.f0$51:()Ljava/lang/String;
  #408 = Utf8               f1$8
  #409 = NameAndType        #408:#75      // f1$8:()Ljava/lang/String;
  #410 = Methodref          #2.#409       // org/sireum/Library_Ext$.f1$8:()Ljava/lang/String;
  #411 = Utf8               f2$5
  #412 = NameAndType        #411:#75      // f2$5:()Ljava/lang/String;
  #413 = Methodref          #2.#412       // org/sireum/Library_Ext$.f2$5:()Ljava/lang/String;
  #414 = Utf8               f3$4
  #415 = NameAndType        #414:#75      // f3$4:()Ljava/lang/String;
  #416 = Methodref          #2.#415       // org/sireum/Library_Ext$.f3$4:()Ljava/lang/String;
  #417 = Utf8               f4$2
  #418 = NameAndType        #417:#75      // f4$2:()Ljava/lang/String;
  #419 = Methodref          #2.#418       // org/sireum/Library_Ext$.f4$2:()Ljava/lang/String;
  #420 = Utf8               f5$2
  #421 = NameAndType        #420:#75      // f5$2:()Ljava/lang/String;
  #422 = Methodref          #2.#421       // org/sireum/Library_Ext$.f5$2:()Ljava/lang/String;
  #423 = Utf8               f6$1
  #424 = NameAndType        #423:#75      // f6$1:()Ljava/lang/String;
  #425 = Methodref          #2.#424       // org/sireum/Library_Ext$.f6$1:()Ljava/lang/String;
  #426 = Utf8               f7$1
  #427 = NameAndType        #426:#75      // f7$1:()Ljava/lang/String;
  #428 = Methodref          #2.#427       // org/sireum/Library_Ext$.f7$1:()Ljava/lang/String;
  #429 = Utf8               f8$1
  #430 = NameAndType        #429:#75      // f8$1:()Ljava/lang/String;
  #431 = Methodref          #2.#430       // org/sireum/Library_Ext$.f8$1:()Ljava/lang/String;
  #432 = Utf8               f9$1
  #433 = NameAndType        #432:#75      // f9$1:()Ljava/lang/String;
  #434 = Methodref          #2.#433       // org/sireum/Library_Ext$.f9$1:()Ljava/lang/String;
  #435 = Utf8               f10$1
  #436 = NameAndType        #435:#75      // f10$1:()Ljava/lang/String;
  #437 = Methodref          #2.#436       // org/sireum/Library_Ext$.f10$1:()Ljava/lang/String;
  #438 = Utf8               f11$1
  #439 = NameAndType        #438:#75      // f11$1:()Ljava/lang/String;
  #440 = Methodref          #2.#439       // org/sireum/Library_Ext$.f11$1:()Ljava/lang/String;
  #441 = Utf8               f12$1
  #442 = NameAndType        #441:#75      // f12$1:()Ljava/lang/String;
  #443 = Methodref          #2.#442       // org/sireum/Library_Ext$.f12$1:()Ljava/lang/String;
  #444 = Utf8               f13$1
  #445 = NameAndType        #444:#75      // f13$1:()Ljava/lang/String;
  #446 = Methodref          #2.#445       // org/sireum/Library_Ext$.f13$1:()Ljava/lang/String;
  #447 = Utf8               f14$1
  #448 = NameAndType        #447:#75      // f14$1:()Ljava/lang/String;
  #449 = Methodref          #2.#448       // org/sireum/Library_Ext$.f14$1:()Ljava/lang/String;
  #450 = Utf8               Map.scala
  #451 = String             #450          // Map.scala
  #452 = Utf8               f0$52
  #453 = NameAndType        #452:#75      // f0$52:()Ljava/lang/String;
  #454 = Methodref          #2.#453       // org/sireum/Library_Ext$.f0$52:()Ljava/lang/String;
  #455 = Utf8               HashSBag.scala
  #456 = String             #455          // HashSBag.scala
  #457 = Utf8               f0$53
  #458 = NameAndType        #457:#75      // f0$53:()Ljava/lang/String;
  #459 = Methodref          #2.#458       // org/sireum/Library_Ext$.f0$53:()Ljava/lang/String;
  #460 = Utf8               OsProto.scala
  #461 = String             #460          // OsProto.scala
  #462 = Utf8               f0$54
  #463 = NameAndType        #462:#75      // f0$54:()Ljava/lang/String;
  #464 = Methodref          #2.#463       // org/sireum/Library_Ext$.f0$54:()Ljava/lang/String;
  #465 = Utf8               Set.scala
  #466 = String             #465          // Set.scala
  #467 = Utf8               f0$55
  #468 = NameAndType        #467:#75      // f0$55:()Ljava/lang/String;
  #469 = Methodref          #2.#468       // org/sireum/Library_Ext$.f0$55:()Ljava/lang/String;
  #470 = Utf8               ContractUtil.scala
  #471 = String             #470          // ContractUtil.scala
  #472 = Utf8               f0$56
  #473 = NameAndType        #472:#75      // f0$56:()Ljava/lang/String;
  #474 = Methodref          #2.#473       // org/sireum/Library_Ext$.f0$56:()Ljava/lang/String;
  #475 = Utf8               Poset.scala
  #476 = String             #475          // Poset.scala
  #477 = Utf8               f0$57
  #478 = NameAndType        #477:#75      // f0$57:()Ljava/lang/String;
  #479 = Methodref          #2.#478       // org/sireum/Library_Ext$.f0$57:()Ljava/lang/String;
  #480 = Methodref          #34.#72       // scala/collection/immutable/ListMap$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
  #481 = Utf8               scala/collection/immutable/Map
  #482 = Class              #481          // scala/collection/immutable/Map
  #483 = Utf8               this
  #484 = Utf8               jvmMap
  #485 = Utf8               Asm.scala
  #486 = String             #485          // Asm.scala
  #487 = Utf8               f0$58
  #488 = NameAndType        #487:#75      // f0$58:()Ljava/lang/String;
  #489 = Methodref          #2.#488       // org/sireum/Library_Ext$.f0$58:()Ljava/lang/String;
  #490 = Utf8               ProjectUtil.scala
  #491 = String             #490          // ProjectUtil.scala
  #492 = Utf8               f0$59
  #493 = NameAndType        #492:#75      // f0$59:()Ljava/lang/String;
  #494 = Methodref          #2.#493       // org/sireum/Library_Ext$.f0$59:()Ljava/lang/String;
  #495 = Utf8               DependencyManager.scala
  #496 = String             #495          // DependencyManager.scala
  #497 = Utf8               f0$60
  #498 = NameAndType        #497:#75      // f0$60:()Ljava/lang/String;
  #499 = Methodref          #2.#498       // org/sireum/Library_Ext$.f0$60:()Ljava/lang/String;
  #500 = Utf8               GitHub.scala
  #501 = String             #500          // GitHub.scala
  #502 = Utf8               f0$61
  #503 = NameAndType        #502:#75      // f0$61:()Ljava/lang/String;
  #504 = Methodref          #2.#503       // org/sireum/Library_Ext$.f0$61:()Ljava/lang/String;
  #505 = Utf8               Os.scala
  #506 = String             #505          // Os.scala
  #507 = Utf8               f0$62
  #508 = NameAndType        #507:#75      // f0$62:()Ljava/lang/String;
  #509 = Methodref          #2.#508       // org/sireum/Library_Ext$.f0$62:()Ljava/lang/String;
  #510 = Utf8               f1$9
  #511 = NameAndType        #510:#75      // f1$9:()Ljava/lang/String;
  #512 = Methodref          #2.#511       // org/sireum/Library_Ext$.f1$9:()Ljava/lang/String;
  #513 = Utf8               Coursier.scala
  #514 = String             #513          // Coursier.scala
  #515 = Utf8               f0$63
  #516 = NameAndType        #515:#75      // f0$63:()Ljava/lang/String;
  #517 = Methodref          #2.#516       // org/sireum/Library_Ext$.f0$63:()Ljava/lang/String;
  #518 = Utf8               trie
  #519 = Utf8               ()Lorg/sireum/$internal/Trie$Node;
  #520 = Utf8               ()Lorg/sireum/$internal/Trie$Node<Ljava/lang/String;Ljava/lang/String;>;
  #521 = Utf8               org/sireum/$internal/RC$
  #522 = Class              #521          // org/sireum/$internal/RC$
  #523 = Utf8               Lorg/sireum/$internal/RC$;
  #524 = NameAndType        #21:#523      // MODULE$:Lorg/sireum/$internal/RC$;
  #525 = Fieldref           #522.#524     // org/sireum/$internal/RC$.MODULE$:Lorg/sireum/$internal/RC$;
  #526 = NameAndType        #30:#31       // sharedMap:()Lscala/collection/Map;
  #527 = Methodref          #2.#526       // org/sireum/Library_Ext$.sharedMap:()Lscala/collection/Map;
  #528 = NameAndType        #484:#31      // jvmMap:()Lscala/collection/Map;
  #529 = Methodref          #2.#528       // org/sireum/Library_Ext$.jvmMap:()Lscala/collection/Map;
  #530 = Utf8               scala/collection/Map
  #531 = Class              #530          // scala/collection/Map
  #532 = Utf8               $plus$plus
  #533 = Utf8               (Lscala/collection/IterableOnce;)Lscala/collection/IterableOps;
  #534 = NameAndType        #532:#533     // $plus$plus:(Lscala/collection/IterableOnce;)Lscala/collection/IterableOps;
  #535 = InterfaceMethodref #531.#534     // scala/collection/Map.$plus$plus:(Lscala/collection/IterableOnce;)Lscala/collection/IterableOps;
  #536 = Utf8               toTrie
  #537 = Utf8               (Lscala/collection/Map;)Lorg/sireum/$internal/Trie$Node;
  #538 = NameAndType        #536:#537     // toTrie:(Lscala/collection/Map;)Lorg/sireum/$internal/Trie$Node;
  #539 = Methodref          #522.#538     // org/sireum/$internal/RC$.toTrie:(Lscala/collection/Map;)Lorg/sireum/$internal/Trie$Node;
  #540 = Utf8               sharedFiles
  #541 = Utf8               ()Lorg/sireum/IS;
  #542 = Utf8               ()Lorg/sireum/IS<Lorg/sireum/Z;Lscala/Tuple2<Lorg/sireum/Option<Lorg/sireum/String;>;Lorg/sireum/String;>;>;
  #543 = Utf8               org/sireum/package$
  #544 = Class              #543          // org/sireum/package$
  #545 = Utf8               Lorg/sireum/package$;
  #546 = NameAndType        #21:#545      // MODULE$:Lorg/sireum/package$;
  #547 = Fieldref           #544.#546     // org/sireum/package$.MODULE$:Lorg/sireum/package$;
  #548 = Utf8               ISZ
  #549 = Utf8               ()Lorg/sireum/$internal/PackageTrait$ISZ$;
  #550 = NameAndType        #548:#549     // ISZ:()Lorg/sireum/$internal/PackageTrait$ISZ$;
  #551 = Methodref          #544.#550     // org/sireum/package$.ISZ:()Lorg/sireum/$internal/PackageTrait$ISZ$;
  #552 = Utf8               toSeq
  #553 = Utf8               ()Lscala/collection/immutable/Seq;
  #554 = NameAndType        #552:#553     // toSeq:()Lscala/collection/immutable/Seq;
  #555 = InterfaceMethodref #531.#554     // scala/collection/Map.toSeq:()Lscala/collection/immutable/Seq;
  #556 = Utf8               (Ljava/lang/Object;)Ljava/lang/Object;
  #557 = MethodType         #556          //  (Ljava/lang/Object;)Ljava/lang/Object;
  #558 = Utf8               $anonfun$sharedFiles$1
  #559 = Utf8               (Lscala/Tuple2;)Lscala/Tuple2;
  #560 = NameAndType        #558:#559     // $anonfun$sharedFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
  #561 = Methodref          #2.#560       // org/sireum/Library_Ext$.$anonfun$sharedFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
  #562 = MethodHandle       6:#561        // REF_invokeStatic org/sireum/Library_Ext$.$anonfun$sharedFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
  #563 = MethodType         #559          //  (Lscala/Tuple2;)Lscala/Tuple2;
  #564 = Integer            5
  #565 = Integer            1
  #566 = Utf8               java/lang/invoke/LambdaMetafactory
  #567 = Class              #566          // java/lang/invoke/LambdaMetafactory
  #568 = Utf8               altMetafactory
  #569 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  #570 = NameAndType        #568:#569     // altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  #571 = Methodref          #567.#570     // java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  #572 = MethodHandle       6:#571        // REF_invokeStatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  #573 = Utf8               ()Lscala/Function1;
  #574 = NameAndType        #70:#573      // apply:()Lscala/Function1;
  #575 = InvokeDynamic      #0:#574       // #0:apply:()Lscala/Function1;
  #576 = Utf8               scala/collection/immutable/Seq
  #577 = Class              #576          // scala/collection/immutable/Seq
  #578 = Utf8               map
  #579 = Utf8               (Lscala/Function1;)Ljava/lang/Object;
  #580 = NameAndType        #578:#579     // map:(Lscala/Function1;)Ljava/lang/Object;
  #581 = InterfaceMethodref #577.#580     // scala/collection/immutable/Seq.map:(Lscala/Function1;)Ljava/lang/Object;
  #582 = Utf8               (Lscala/collection/immutable/Seq;)Lorg/sireum/IS;
  #583 = NameAndType        #70:#582      // apply:(Lscala/collection/immutable/Seq;)Lorg/sireum/IS;
  #584 = Methodref          #12.#583      // org/sireum/$internal/PackageTrait$ISZ$.apply:(Lscala/collection/immutable/Seq;)Lorg/sireum/IS;
  #585 = Utf8               jvmFiles
  #586 = Utf8               $anonfun$jvmFiles$1
  #587 = NameAndType        #586:#559     // $anonfun$jvmFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
  #588 = Methodref          #2.#587       // org/sireum/Library_Ext$.$anonfun$jvmFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
  #589 = MethodHandle       6:#588        // REF_invokeStatic org/sireum/Library_Ext$.$anonfun$jvmFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
  #590 = InvokeDynamic      #1:#574       // #1:apply:()Lscala/Function1;
  #591 = Utf8               files
  #592 = NameAndType        #540:#541     // sharedFiles:()Lorg/sireum/IS;
  #593 = Methodref          #2.#592       // org/sireum/Library_Ext$.sharedFiles:()Lorg/sireum/IS;
  #594 = NameAndType        #585:#541     // jvmFiles:()Lorg/sireum/IS;
  #595 = Methodref          #2.#594       // org/sireum/Library_Ext$.jvmFiles:()Lorg/sireum/IS;
  #596 = Utf8               org/sireum/IS
  #597 = Class              #596          // org/sireum/IS
  #598 = Utf8               (Lorg/sireum/IS;)Lorg/sireum/IS;
  #599 = NameAndType        #532:#598     // $plus$plus:(Lorg/sireum/IS;)Lorg/sireum/IS;
  #600 = Methodref          #597.#599     // org/sireum/IS.$plus$plus:(Lorg/sireum/IS;)Lorg/sireum/IS;
  #601 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject HashBag {\n\n  @pure def empty[T]: HashBag[T] = {\n    return HashBag(HashMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashBag[T] = {\n    return HashBag(HashMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashBag[T] = {\n    return HashBag.empty[T] ++ s\n  }\n\n}\n\n@datatype class HashBag[T](val map: HashMap[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): HashBag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def +#(p: (T, Z)): HashBag[T] = {\n    return addN(p._1, p._2)\n  }\n\n  @pure def addN(e: T, n: Z): HashBag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def ++[I](es: IS[I, T]): HashBag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashBag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](s: IS[I, T]): HashBag[T] = {\n    var r = this\n    for (e <- s) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def -#(p: (T, Z)): HashBag[T] = {\n    return removeN(p._1, p._2)\n  }\n\n  @pure def removeN(e: T, n: Z): HashBag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def \\(other: HashBag[T]): HashBag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: HashBag[T]): HashBag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashBag[T]): HashBag[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashBag[T]): HashBag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashBag[T]): HashBag[T] = {\n    var r = HashBag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r.addN(e._1, n)\n      } else {\n        r = r.addN(e._1, m)\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
  #602 = String             #601          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject HashBag {\n\n  @pure def empty[T]: HashBag[T] = {\n    return HashBag(HashMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashBag[T] = {\n    return HashBag(HashMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashBag[T] = {\n    return HashBag.empty[T] ++ s\n  }\n\n}\n\n@datatype class HashBag[T](val map: HashMap[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): HashBag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def +#(p: (T, Z)): HashBag[T] = {\n    return addN(p._1, p._2)\n  }\n\n  @pure def addN(e: T, n: Z): HashBag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def ++[I](es: IS[I, T]): HashBag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashBag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](s: IS[I, T]): HashBag[T] = {\n    var r = this\n    for (e <- s) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def -#(p: (T, Z)): HashBag[T] = {\n    return removeN(p._1, p._2)\n  }\n\n  @pure def removeN(e: T, n: Z): HashBag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def \\(other: HashBag[T]): HashBag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: HashBag[T]): HashBag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashBag[T]): HashBag[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashBag[T]): HashBag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashBag[T]): HashBag[T] = {\n    var r = HashBag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r.addN(e._1, n)\n      } else {\n        r = r.addN(e._1, m)\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
  #603 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.U64._\n\n@sig trait Indexable[T] {\n  @pure def at(i: Z): T\n  @pure def has(i: Z): B\n}\n\nobject Indexable {\n\n  @sig trait Pos[T] extends Indexable[T] {\n    @pure def posOpt(offset: Z, length: Z): Option[message.Position]\n  }\n\n  @datatype class Isz[T](val is: ISZ[T]) extends Indexable[T] {\n    @strictpure override def at(i: Z): T = is(i)\n    @strictpure override def has(i: Z): B = i < is.size\n  }\n\n  @datatype class IszDocInfo[T](val is: ISZ[T], val info: message.DocInfo) extends Indexable.Pos[T] {\n    @strictpure override def at(i: Z): T = is(i)\n    @strictpure override def has(i: Z): B = i < is.size\n    @strictpure def posOpt(offset: Z, length: Z): Option[message.Position] =\n      Some(message.PosInfo(info, (conversions.Z.toU64(offset) << u64\"32\") | conversions.Z.toU64(length)))\n  }\n\n  @strictpure def fromIsz[T](is: ISZ[T]): Indexable[T] = Isz(is)\n\n  @strictpure def fromIszDocInfo[T](is: ISZ[T], info: message.DocInfo): Indexable.Pos[T] = IszDocInfo(is, info)\n}\n
  #604 = String             #603          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.U64._\n\n@sig trait Indexable[T] {\n  @pure def at(i: Z): T\n  @pure def has(i: Z): B\n}\n\nobject Indexable {\n\n  @sig trait Pos[T] extends Indexable[T] {\n    @pure def posOpt(offset: Z, length: Z): Option[message.Position]\n  }\n\n  @datatype class Isz[T](val is: ISZ[T]) extends Indexable[T] {\n    @strictpure override def at(i: Z): T = is(i)\n    @strictpure override def has(i: Z): B = i < is.size\n  }\n\n  @datatype class IszDocInfo[T](val is: ISZ[T], val info: message.DocInfo) extends Indexable.Pos[T] {\n    @strictpure override def at(i: Z): T = is(i)\n    @strictpure override def has(i: Z): B = i < is.size\n    @strictpure def posOpt(offset: Z, length: Z): Option[message.Position] =\n      Some(message.PosInfo(info, (conversions.Z.toU64(offset) << u64\"32\") | conversions.Z.toU64(length)))\n  }\n\n  @strictpure def fromIsz[T](is: ISZ[T]): Indexable[T] = Isz(is)\n\n  @strictpure def fromIszDocInfo[T](is: ISZ[T], info: message.DocInfo): Indexable.Pos[T] = IszDocInfo(is, info)\n}\n
  #605 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@datatype trait Either[L, R] {\n\n  @pure def isLeft: B = Contract.Only(Ensures(Res == ∃{e: L => Either.Left[L, R](e) == this}))\n\n  @pure def isRight: B = Contract.Only(Ensures(!isLeft))\n\n  @pure def leftOpt: Option[L] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Either.Left[L, R](Res[Option[L]].get) == this)\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Res == None[L]())\n    ),\n  )\n\n  @pure def left: L = Contract.Only(\n    Requires(isLeft),\n    Ensures(Either.Left[L, R](Res) == this)\n  )\n\n  @pure def rightOpt: Option[R] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Res == None[R]())\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Either.Right[L, R](Res[Option[R]].get) == this)\n    )\n  )\n\n  @pure def right: R = Contract.Only(\n    Requires(isRight),\n    Ensures(Either.Right[L, R](Res) == this)\n  )\n}\n\nobject Either {\n\n  @datatype class Left[L, R](val value: L) extends Either[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def leftOpt: Option[L] = {\n      Contract(Ensures(Res == Some(value)))\n      return Some(value)\n    }\n\n    @pure override def left: L = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n    @pure override def rightOpt: Option[R] = {\n      Contract(Ensures(Res == None[R]()))\n      return None()\n    }\n\n    @pure override def right: R = {\n      Contract(Requires(F))\n      halt(\"Invalid \'Either.Left\' operation \'right\'.\")\n    }\n\n  }\n\n  @datatype class Right[L, R](val value: R) extends Either[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def leftOpt: Option[L] = {\n      Contract(Ensures(Res == None[L]()))\n      return None()\n    }\n\n    @pure override def left: L = {\n      Contract(Requires(F))\n      halt(\"Invalid \'Either.Right\' operation \'left\'.\")\n    }\n\n    @pure override def rightOpt: Option[R] = {\n      Contract(Ensures(Res == Some(value)))\n      return Some(value)\n    }\n\n    @pure override def right: R = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n  }\n\n  @strictpure def left[L, R](value: L): Either[L, R] = Left[L, R](value)\n\n  @strictpure def right[L, R](value: R): Either[L, R] = Right[L, R](value)\n\n}\n
  #606 = String             #605          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@datatype trait Either[L, R] {\n\n  @pure def isLeft: B = Contract.Only(Ensures(Res == ∃{e: L => Either.Left[L, R](e) == this}))\n\n  @pure def isRight: B = Contract.Only(Ensures(!isLeft))\n\n  @pure def leftOpt: Option[L] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Either.Left[L, R](Res[Option[L]].get) == this)\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Res == None[L]())\n    ),\n  )\n\n  @pure def left: L = Contract.Only(\n    Requires(isLeft),\n    Ensures(Either.Left[L, R](Res) == this)\n  )\n\n  @pure def rightOpt: Option[R] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Res == None[R]())\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Either.Right[L, R](Res[Option[R]].get) == this)\n    )\n  )\n\n  @pure def right: R = Contract.Only(\n    Requires(isRight),\n    Ensures(Either.Right[L, R](Res) == this)\n  )\n}\n\nobject Either {\n\n  @datatype class Left[L, R](val value: L) extends Either[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def leftOpt: Option[L] = {\n      Contract(Ensures(Res == Some(value)))\n      return Some(value)\n    }\n\n    @pure override def left: L = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n    @pure override def rightOpt: Option[R] = {\n      Contract(Ensures(Res == None[R]()))\n      return None()\n    }\n\n    @pure override def right: R = {\n      Contract(Requires(F))\n      halt(\"Invalid \'Either.Left\' operation \'right\'.\")\n    }\n\n  }\n\n  @datatype class Right[L, R](val value: R) extends Either[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def leftOpt: Option[L] = {\n      Contract(Ensures(Res == None[L]()))\n      return None()\n    }\n\n    @pure override def left: L = {\n      Contract(Requires(F))\n      halt(\"Invalid \'Either.Right\' operation \'left\'.\")\n    }\n\n    @pure override def rightOpt: Option[R] = {\n      Contract(Ensures(Res == Some(value)))\n      return Some(value)\n    }\n\n    @pure override def right: R = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n  }\n\n  @strictpure def left[L, R](value: L): Either[L, R] = Left[L, R](value)\n\n  @strictpure def right[L, R](value: R): Either[L, R] = Right[L, R](value)\n\n}\n
  #607 = Utf8               // #Sireum\n/*\n MIT License\n\n Copyright (c) 2020 brainhub\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n\npackage org.sireum.crypto\n\nimport org.sireum._\nimport org.sireum.U8._\nimport org.sireum.U64._\n\n// Adapted from https://github.com/brainhub/SHA3IUF\n\nobject SHA3 {\n\n  val spongeWords: Z = 25\n  val rounds: Z = 24\n\n  // @formatter:off\n  val rndc: ISZ[U64] = ISZ(\n    u64\"0x0000000000000001\", u64\"0x0000000000008082\",\n    u64\"0x800000000000808a\", u64\"0x8000000080008000\",\n    u64\"0x000000000000808b\", u64\"0x0000000080000001\",\n    u64\"0x8000000080008081\", u64\"0x8000000000008009\",\n    u64\"0x000000000000008a\", u64\"0x0000000000000088\",\n    u64\"0x0000000080008009\", u64\"0x000000008000000a\",\n    u64\"0x000000008000808b\", u64\"0x800000000000008b\",\n    u64\"0x8000000000008089\", u64\"0x8000000000008003\",\n    u64\"0x8000000000008002\", u64\"0x8000000000000080\",\n    u64\"0x000000000000800a\", u64\"0x800000008000000a\",\n    u64\"0x8000000080008081\", u64\"0x8000000000008080\",\n    u64\"0x0000000080000001\", u64\"0x8000000080008008\"\n  )\n\n  val rotc: ISZ[U64] = ISZ(\n    u64\"1\", u64\"3\", u64\"6\", u64\"10\", u64\"15\", u64\"21\", u64\"28\", u64\"36\",\n    u64\"45\", u64\"55\", u64\"2\", u64\"14\", u64\"27\", u64\"41\", u64\"56\", u64\"8\",\n    u64\"25\", u64\"43\", u64\"62\", u64\"18\", u64\"39\", u64\"61\", u64\"20\", u64\"44\"\n  )\n\n  val piln: ISZ[Z] = ISZ(\n    10,  7, 11, 17, 18,  3,  5, 16,\n     8, 21, 24,  4, 15, 23, 19, 13,\n    12,  2, 20, 14, 22,  9,  6,  1\n  )\n  // @formatter:on\n\n  @pure def rotl(x: U64, y: U64): U64 = {\n    return (x << y) | (x >> (u64\"64\" - y))\n  }\n\n  def keccakf(s: MSZ[U64]): Unit = {\n    var t = u64\"0\"\n    val bc = MSZ.create(5, u64\"0\")\n\n    for (round <- z\"0\" until rounds) {\n      /* Theta */\n      for (i <- 0 until 5) {\n        bc(i) = s(i) |^ s(i + 5) |^ s(i + 10) |^ s(i + 15) |^ s(i + 20)\n      }\n\n      for (i <- 0 until 5) {\n        t = bc((i + 4) % 5) |^ rotl(bc((i + 1) % 5), u64\"1\")\n        for (j <- 0 until 25 by 5) {\n          s(j + i) = s(j + i) |^ t\n        }\n      }\n\n      /* Rho Pi */\n      t = s(1)\n      for (i <- 0 until 24) {\n        val j = piln(i)\n        bc(0) = s(j)\n        s(j) = rotl(t, rotc(i))\n        t = bc(0)\n      }\n\n      /* Chi */\n      for (j <- 0 until 25 by 5) {\n        for (i <- 0 until 5) {\n          bc(i) = s(j + i)\n        }\n        for (i <- 0 until 5) {\n          s(j + i) = s(j + i) |^ ((~bc((i + 1) % 5)) & bc((i + 2) % 5))\n        }\n      }\n\n      /* Iota */\n      s(0) = s(0) |^ rndc(round)\n    }\n  }\n\n  @pure def init256: SHA3 = {\n    return SHA3(8)\n  }\n\n  @pure def init384: SHA3 = {\n    return SHA3(12)\n  }\n\n  @pure def init512: SHA3 = {\n    return SHA3(16)\n  }\n\n  @pure def sum256(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init256\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n  @pure def sum384(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init384\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n  @pure def sum512(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init512\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n}\n\nimport SHA3._\n\n@record class SHA3(val capacityWords: Z) {\n  var saved: U64 = u64\"0\"\n  var byteIndex: U64 = u64\"0\"\n  var wordIndex: Z = 0\n  var s: MSZ[U64] = MS.create[Z, U64](25, u64\"0\")\n\n  def update(buf: ISZ[U8]): Unit = {\n\n    assert(byteIndex < u64\"8\")\n    assert(wordIndex < 25)\n\n    var oldTail = (8 - conversions.U64.toZ(byteIndex)) % 8\n    var len = buf.size\n\n    var index = 0\n    if (len < oldTail) {\n      while (len > 0) {\n        saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n        byteIndex = byteIndex + u64\"1\"\n        index = index + 1\n        len = len - 1\n      }\n      assert(byteIndex < u64\"8\")\n      return\n    }\n\n    if (oldTail > 0) {\n      len = len - oldTail\n      while (oldTail > 0) {\n        saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n        byteIndex = byteIndex + u64\"1\"\n        index = index + 1\n        oldTail = oldTail - 1\n      }\n      s(wordIndex) = s(wordIndex) |^ saved\n      assert(byteIndex == u64\"8\")\n      byteIndex = u64\"0\"\n      saved = u64\"0\"\n      wordIndex = wordIndex + 1\n      if (wordIndex == spongeWords - capacityWords) {\n        keccakf(s)\n        wordIndex = 0\n      }\n    }\n\n    assert(byteIndex == u64\"0\")\n\n    val words = len / 8\n    for (_ <- z\"0\" until words) {\n      val t = conversions.U8.toU64(buf(index)) |\n        (conversions.U8.toU64(buf(index + 1)) << u64\"8\") |\n        (conversions.U8.toU64(buf(index + 2)) << u64\"16\") |\n        (conversions.U8.toU64(buf(index + 3)) << u64\"24\") |\n        (conversions.U8.toU64(buf(index + 4)) << u64\"32\") |\n        (conversions.U8.toU64(buf(index + 5)) << u64\"40\") |\n        (conversions.U8.toU64(buf(index + 6)) << u64\"48\") |\n        (conversions.U8.toU64(buf(index + 7)) << u64\"56\")\n      s(wordIndex) = s(wordIndex) |^ t\n      wordIndex = wordIndex + 1\n      if (wordIndex == spongeWords - capacityWords) {\n        keccakf(s)\n        wordIndex = 0\n      }\n      index = index + 8\n    }\n\n    var tail = len - words * 8\n    assert(byteIndex == u64\"0\" && tail < 8)\n    while (tail > 0) {\n      saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n      byteIndex = byteIndex + u64\"1\"\n      index = index + 1\n      tail = tail - 1\n    }\n    assert(byteIndex < u64\"8\")\n  }\n\n  def finalise(): ISZ[U8] = {\n    s(wordIndex) = s(wordIndex) |^ (saved |^ ((u64\"0x02\" | (u64\"1\" << u64\"2\")) << (byteIndex * u64\"8\")))\n    s(spongeWords - capacityWords - 1) = s(spongeWords - capacityWords - 1) |^ u64\"0x8000000000000000\"\n    keccakf(s)\n\n    val sb = MSZ.create(capacityWords * 4, u8\"0\")\n    for (i <- z\"0\" until (capacityWords / 2)) {\n      val t = s(i)\n      sb(i * 8) = conversions.U64.toU8(t & u64\"0xFF\")\n      sb(i * 8 + 1) = conversions.U64.toU8((t >> u64\"8\") & u64\"0xFF\")\n      sb(i * 8 + 2) = conversions.U64.toU8((t >> u64\"16\") & u64\"0xFF\")\n      sb(i * 8 + 3) = conversions.U64.toU8((t >> u64\"24\") & u64\"0xFF\")\n      sb(i * 8 + 4) = conversions.U64.toU8((t >> u64\"32\") & u64\"0xFF\")\n      sb(i * 8 + 5) = conversions.U64.toU8((t >> u64\"40\") & u64\"0xFF\")\n      sb(i * 8 + 6) = conversions.U64.toU8((t >> u64\"48\") & u64\"0xFF\")\n      sb(i * 8 + 7) = conversions.U64.toU8((t >> u64\"56\") & u64\"0xFF\")\n    }\n    return sb.toIS\n  }\n}\n
  #608 = String             #607          // // #Sireum\n/*\n MIT License\n\n Copyright (c) 2020 brainhub\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n\npackage org.sireum.crypto\n\nimport org.sireum._\nimport org.sireum.U8._\nimport org.sireum.U64._\n\n// Adapted from https://github.com/brainhub/SHA3IUF\n\nobject SHA3 {\n\n  val spongeWords: Z = 25\n  val rounds: Z = 24\n\n  // @formatter:off\n  val rndc: ISZ[U64] = ISZ(\n    u64\"0x0000000000000001\", u64\"0x0000000000008082\",\n    u64\"0x800000000000808a\", u64\"0x8000000080008000\",\n    u64\"0x000000000000808b\", u64\"0x0000000080000001\",\n    u64\"0x8000000080008081\", u64\"0x8000000000008009\",\n    u64\"0x000000000000008a\", u64\"0x0000000000000088\",\n    u64\"0x0000000080008009\", u64\"0x000000008000000a\",\n    u64\"0x000000008000808b\", u64\"0x800000000000008b\",\n    u64\"0x8000000000008089\", u64\"0x8000000000008003\",\n    u64\"0x8000000000008002\", u64\"0x8000000000000080\",\n    u64\"0x000000000000800a\", u64\"0x800000008000000a\",\n    u64\"0x8000000080008081\", u64\"0x8000000000008080\",\n    u64\"0x0000000080000001\", u64\"0x8000000080008008\"\n  )\n\n  val rotc: ISZ[U64] = ISZ(\n    u64\"1\", u64\"3\", u64\"6\", u64\"10\", u64\"15\", u64\"21\", u64\"28\", u64\"36\",\n    u64\"45\", u64\"55\", u64\"2\", u64\"14\", u64\"27\", u64\"41\", u64\"56\", u64\"8\",\n    u64\"25\", u64\"43\", u64\"62\", u64\"18\", u64\"39\", u64\"61\", u64\"20\", u64\"44\"\n  )\n\n  val piln: ISZ[Z] = ISZ(\n    10,  7, 11, 17, 18,  3,  5, 16,\n     8, 21, 24,  4, 15, 23, 19, 13,\n    12,  2, 20, 14, 22,  9,  6,  1\n  )\n  // @formatter:on\n\n  @pure def rotl(x: U64, y: U64): U64 = {\n    return (x << y) | (x >> (u64\"64\" - y))\n  }\n\n  def keccakf(s: MSZ[U64]): Unit = {\n    var t = u64\"0\"\n    val bc = MSZ.create(5, u64\"0\")\n\n    for (round <- z\"0\" until rounds) {\n      /* Theta */\n      for (i <- 0 until 5) {\n        bc(i) = s(i) |^ s(i + 5) |^ s(i + 10) |^ s(i + 15) |^ s(i + 20)\n      }\n\n      for (i <- 0 until 5) {\n        t = bc((i + 4) % 5) |^ rotl(bc((i + 1) % 5), u64\"1\")\n        for (j <- 0 until 25 by 5) {\n          s(j + i) = s(j + i) |^ t\n        }\n      }\n\n      /* Rho Pi */\n      t = s(1)\n      for (i <- 0 until 24) {\n        val j = piln(i)\n        bc(0) = s(j)\n        s(j) = rotl(t, rotc(i))\n        t = bc(0)\n      }\n\n      /* Chi */\n      for (j <- 0 until 25 by 5) {\n        for (i <- 0 until 5) {\n          bc(i) = s(j + i)\n        }\n        for (i <- 0 until 5) {\n          s(j + i) = s(j + i) |^ ((~bc((i + 1) % 5)) & bc((i + 2) % 5))\n        }\n      }\n\n      /* Iota */\n      s(0) = s(0) |^ rndc(round)\n    }\n  }\n\n  @pure def init256: SHA3 = {\n    return SHA3(8)\n  }\n\n  @pure def init384: SHA3 = {\n    return SHA3(12)\n  }\n\n  @pure def init512: SHA3 = {\n    return SHA3(16)\n  }\n\n  @pure def sum256(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init256\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n  @pure def sum384(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init384\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n  @pure def sum512(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init512\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n}\n\nimport SHA3._\n\n@record class SHA3(val capacityWords: Z) {\n  var saved: U64 = u64\"0\"\n  var byteIndex: U64 = u64\"0\"\n  var wordIndex: Z = 0\n  var s: MSZ[U64] = MS.create[Z, U64](25, u64\"0\")\n\n  def update(buf: ISZ[U8]): Unit = {\n\n    assert(byteIndex < u64\"8\")\n    assert(wordIndex < 25)\n\n    var oldTail = (8 - conversions.U64.toZ(byteIndex)) % 8\n    var len = buf.size\n\n    var index = 0\n    if (len < oldTail) {\n      while (len > 0) {\n        saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n        byteIndex = byteIndex + u64\"1\"\n        index = index + 1\n        len = len - 1\n      }\n      assert(byteIndex < u64\"8\")\n      return\n    }\n\n    if (oldTail > 0) {\n      len = len - oldTail\n      while (oldTail > 0) {\n        saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n        byteIndex = byteIndex + u64\"1\"\n        index = index + 1\n        oldTail = oldTail - 1\n      }\n      s(wordIndex) = s(wordIndex) |^ saved\n      assert(byteIndex == u64\"8\")\n      byteIndex = u64\"0\"\n      saved = u64\"0\"\n      wordIndex = wordIndex + 1\n      if (wordIndex == spongeWords - capacityWords) {\n        keccakf(s)\n        wordIndex = 0\n      }\n    }\n\n    assert(byteIndex == u64\"0\")\n\n    val words = len / 8\n    for (_ <- z\"0\" until words) {\n      val t = conversions.U8.toU64(buf(index)) |\n        (conversions.U8.toU64(buf(index + 1)) << u64\"8\") |\n        (conversions.U8.toU64(buf(index + 2)) << u64\"16\") |\n        (conversions.U8.toU64(buf(index + 3)) << u64\"24\") |\n        (conversions.U8.toU64(buf(index + 4)) << u64\"32\") |\n        (conversions.U8.toU64(buf(index + 5)) << u64\"40\") |\n        (conversions.U8.toU64(buf(index + 6)) << u64\"48\") |\n        (conversions.U8.toU64(buf(index + 7)) << u64\"56\")\n      s(wordIndex) = s(wordIndex) |^ t\n      wordIndex = wordIndex + 1\n      if (wordIndex == spongeWords - capacityWords) {\n        keccakf(s)\n        wordIndex = 0\n      }\n      index = index + 8\n    }\n\n    var tail = len - words * 8\n    assert(byteIndex == u64\"0\" && tail < 8)\n    while (tail > 0) {\n      saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n      byteIndex = byteIndex + u64\"1\"\n      index = index + 1\n      tail = tail - 1\n    }\n    assert(byteIndex < u64\"8\")\n  }\n\n  def finalise(): ISZ[U8] = {\n    s(wordIndex) = s(wordIndex) |^ (saved |^ ((u64\"0x02\" | (u64\"1\" << u64\"2\")) << (byteIndex * u64\"8\")))\n    s(spongeWords - capacityWords - 1) = s(spongeWords - capacityWords - 1) |^ u64\"0x8000000000000000\"\n    keccakf(s)\n\n    val sb = MSZ.create(capacityWords * 4, u8\"0\")\n    for (i <- z\"0\" until (capacityWords / 2)) {\n      val t = s(i)\n      sb(i * 8) = conversions.U64.toU8(t & u64\"0xFF\")\n      sb(i * 8 + 1) = conversions.U64.toU8((t >> u64\"8\") & u64\"0xFF\")\n      sb(i * 8 + 2) = conversions.U64.toU8((t >> u64\"16\") & u64\"0xFF\")\n      sb(i * 8 + 3) = conversions.U64.toU8((t >> u64\"24\") & u64\"0xFF\")\n      sb(i * 8 + 4) = conversions.U64.toU8((t >> u64\"32\") & u64\"0xFF\")\n      sb(i * 8 + 5) = conversions.U64.toU8((t >> u64\"40\") & u64\"0xFF\")\n      sb(i * 8 + 6) = conversions.U64.toU8((t >> u64\"48\") & u64\"0xFF\")\n      sb(i * 8 + 7) = conversions.U64.toU8((t >> u64\"56\") & u64\"0xFF\")\n    }\n    return sb.toIS\n  }\n}\n
  #609 = Utf8               // #Sireum\npackage org.sireum\n\nimport U32._\nimport U64._\n\nobject Hash {\n\n  @pure def murmur3a(data: ISZ[U8], seed: U32): U32 = {\n\n    /*\n     Copyright (c) 2017-2022, Robby, Kansas State University\n     All rights reserved.\n\n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions are met:\n\n     1. Redistributions of source code must retain the above copyright notice, this\n        list of conditions and the following disclaimer.\n     2. Redistributions in binary form must reproduce the above copyright notice,\n        this list of conditions and the following disclaimer in the documentation\n        and/or other materials provided with the distribution.\n\n     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n\n    @pure def process(d0: U32, h: U32): U32 = {\n      var d = d0\n      d = d * u32\"0xCC9E2D51\"\n      d = (d << u32\"15\") | (d >>> u32\"17\")\n      d = d * u32\"0x1B873593\"\n      return h |^ d\n    }\n\n    val dataSize = data.size\n    var h = seed\n\n    var i: Z = 0\n    if (dataSize > 3) {\n      while (dataSize - i >= 4) {\n        val d =\n          conversions.U8.toU32(data(i)) |\n            (conversions.U8.toU32(data(i + 1)) << u32\"8\") |\n            (conversions.U8.toU32(data(i + 2)) << u32\"16\") |\n            (conversions.U8.toU32(data(i + 3)) << u32\"24\")\n        i = i + 4\n        h = process(d, h)\n        h = (h << u32\"13\") | (h >> u32\"19\")\n        h = (h * u32\"5\") + u32\"0xE6546B64\"\n      }\n    }\n\n    dataSize - i match {\n      case z\"1\" =>\n        val d = conversions.U8.toU32(data(i))\n        h = process(d, h)\n      case z\"2\" =>\n        val d = conversions.U8.toU32(data(i)) |\n          (conversions.U8.toU32(data(i + 1)) << u32\"8\")\n        h = process(d, h)\n      case z\"3\" =>\n        val d = conversions.U8.toU32(data(i)) |\n          (conversions.U8.toU32(data(i + 1)) << u32\"8\") |\n          (conversions.U8.toU32(data(i + 2)) << u32\"16\")\n        h = process(d, h)\n      case _ =>\n    }\n\n    h = h |^ conversions.Z.toU32(dataSize)\n    h = h |^ (h >> u32\"16\")\n    h = h * u32\"0x85EBCA6B\"\n    h = h |^ (h >> u32\"13\")\n    h = h * u32\"0xC2B2AE35\"\n    h = h |^ (h >> u32\"16\")\n\n    return h\n  }\n\n  @pure def t1ha0(data: ISZ[U8], seed: U64): U64 = {\n\n    // Adapted from: https://github.com/leo-yuriev/t1ha/tree/v2.0.2\n    /*\n     *  Copyright (c) 2016-2018 Positive Technologies, https://www.ptsecurity.com,\n     *  Fast Positive Hash.\n     *\n     *  Portions Copyright (c) 2010-2018 Leonid Yuriev <leo@yuriev.ru>,\n     *  The 1Hippeus project (t1h).\n     *\n     *  This software is provided \'as-is\', without any express or implied\n     *  warranty. In no event will the authors be held liable for any damages\n     *  arising from the use of this software.\n     *\n     *  Permission is granted to anyone to use this software for any purpose,\n     *  including commercial applications, and to alter it and redistribute it\n     *  freely, subject to the following restrictions:\n     *\n     *  1. The origin of this software must not be misrepresented; you must not\n     *     claim that you wrote the original software. If you use this software\n     *     in a product, an acknowledgement in the product documentation would be\n     *     appreciated but is not required.\n     *  2. Altered source versions must be plainly marked as such, and must not be\n     *     misrepresented as being the original software.\n     *  3. This notice may not be removed or altered from any source distribution.\n     */\n\n    @pure def rot(n: U32, m: U32): U32 = {\n      return (n >>> m) | (n << (u32\"32\" - m))\n    }\n\n    @pure def fetch(i: Z): U32 = {\n      return conversions.U8.toU32(data(i)) |\n        conversions.U8.toU32(data(i + 1)) << u32\"8\" |\n        conversions.U8.toU32(data(i + 2)) << u32\"16\" |\n        conversions.U8.toU32(data(i + 3)) << u32\"24\"\n    }\n\n    @pure def tail(i: Z): U32 = {\n      data.size - i match {\n        case z\"1\" =>\n          return conversions.U8.toU32(data(i))\n        case z\"2\" =>\n          return conversions.U8.toU32(data(i)) |\n            conversions.U8.toU32(data(i + 1)) << u32\"8\"\n        case z\"3\" =>\n          return conversions.U8.toU32(data(i)) |\n            conversions.U8.toU32(data(i + 1)) << u32\"8\" |\n            conversions.U8.toU32(data(i + 2)) << u32\"16\"\n        case _ => fetch(i)\n      }\n    }\n\n    val prime0: U32 = u32\"0x92D78269\"\n    val prime1: U32 = u32\"0xCA9B4735\"\n    val prime2: U32 = u32\"0xA4ABA1C3\"\n    val prime3: U32 = u32\"0xF6499843\"\n    val prime4: U32 = u32\"0x86F0FD61\"\n    val prime5: U32 = u32\"0xCA2DA6FB\"\n    val prime6: U32 = u32\"0xC4BB3575\"\n\n    val dataSize = data.size\n    val dataSize32 = conversions.Z.toU32(dataSize)\n\n    var a: U32 = rot(dataSize32, u32\"17\") + conversions.U64.toU32(seed & u64\"0xFFFFFFFF\")\n    var b: U32 = dataSize32 |^ conversions.U64.toU32(seed >>> u64\"32\")\n\n    var i = 0\n    if (dataSize > 16) {\n      var c = ~a\n      var d = rot(b, u32\"5\")\n\n      while (dataSize - i >= 16) {\n        val w0 = fetch(i)\n        val w1 = fetch(i + 4)\n        val w2 = fetch(i + 8)\n        val w3 = fetch(i + 12)\n\n        val c02 = w0 |^ rot(w2 + c, u32\"11\")\n        val d13 = w1 + rot(w3 + d, u32\"17\")\n        c = c |^ rot(b + w1, u32\"7\")\n        d = d |^ rot(a + w0, u32\"3\")\n        b = prime1 * (c02 + w3)\n        a = prime0 * (d13 |^ w2)\n        i = i + 16\n      }\n\n      c = c + a\n      d = d + b\n      a = a |^ (prime6 * (rot(c, u32\"16\") + d))\n      b = b |^ (prime5 * (c + rot(d, u32\"16\")))\n    }\n\n    val len = dataSize - i\n    (len - 1) / 4 match {\n      case z\"3\" =>\n        var l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime4)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + fetch(i)) * conversions.U32.toU64(prime3)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case z\"2\" =>\n        var l = conversions.U32.toU64(a + fetch(i)) * conversions.U32.toU64(prime3)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case z\"1\" =>\n        var l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case _ =>\n        if (len > 0) {\n          val l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n          b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n          a = a + conversions.U64.toU32(l >>> u64\"32\")\n        }\n    }\n\n    var l = conversions.U32.toU64(b |^ rot(a, u32\"13\")) | (conversions.U32.toU64(a) << u64\"32\")\n    l = l * u64\"0xEC99BF0D8372CAAB\"\n    l = l |^ (l >> u64\"41\")\n    l = l * u64\"0x9C06FAF4D023E3AB\"\n    l = l |^ (l >> u64\"47\")\n    l = l * u64\"0xCB5AF53AE3AAAC31\"\n\n    return l\n  }\n\n  @pure def t1ha(isFirst: B, data: ISZ[U8], seed: U64): U64 = {\n\n    @pure def mullu(a: U64, b: U64): (U64, U64) = {\n      // Adapted from: https://golang.org/src/runtime/softfloat64.go (mullu)\n      /*\n        Copyright (c) 2009 The Go Authors. All rights reserved.\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions are\n        met:\n\n        * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following disclaimer\n        in the documentation and/or other materials provided with the\n        distribution.\n        * Neither the name of Google Inc. nor the names of its\n        contributors may be used to endorse or promote products derived from\n        this software without specific prior written permission.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n        \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n       */\n\n      val s = u64\"32\"\n      val mask = (u64\"1\" << s) - u64\"1\"\n      val a0 = a & mask\n      val a1 = a >> s\n      val b0 = b & mask\n      val b1 = b >> s\n      val w0 = a0 * b0\n      val t = a1 * b0 + (w0 >> s)\n      var w1 = t & mask\n      val w2 = t >> s\n      w1 = w1 + a0 * b1\n      return (a * b, a1 * b1 + w2 + (w1 >> s))\n    }\n\n    // Adapted from: https://github.com/leo-yuriev/t1ha/tree/v2.0.2\n    /*\n     *  Copyright (c) 2016-2018 Positive Technologies, https://www.ptsecurity.com,\n     *  Fast Positive Hash.\n     *\n     *  Portions Copyright (c) 2010-2018 Leonid Yuriev <leo@yuriev.ru>,\n     *  The 1Hippeus project (t1h).\n     *\n     *  This software is provided \'as-is\', without any express or implied\n     *  warranty. In no event will the authors be held liable for any damages\n     *  arising from the use of this software.\n     *\n     *  Permission is granted to anyone to use this software for any purpose,\n     *  including commercial applications, and to alter it and redistribute it\n     *  freely, subject to the following restrictions:\n     *\n     *  1. The origin of this software must not be misrepresented; you must not\n     *     claim that you wrote the original software. If you use this software\n     *     in a product, an acknowledgement in the product documentation would be\n     *     appreciated but is not required.\n     *  2. Altered source versions must be plainly marked as such, and must not be\n     *     misrepresented as being the original software.\n     *  3. This notice may not be removed or altered from any source distribution.\n     */\n\n    @pure def rot(n: U64, m: U64): U64 = {\n      return (n >>> m) | (n << (u64\"64\" - m))\n    }\n\n    @pure def mix(v: U64, p: U64): U64 = {\n      val v2 = v * p\n      return v2 |^ rot(v2, u64\"41\")\n    }\n\n    @pure def mux(v: U64, prime: U64): U64 = {\n      val p = mullu(v, prime)\n      return p._1 |^ p._2\n    }\n\n    @pure def fetch(i: Z): U64 = {\n      return conversions.U8.toU64(data(i)) |\n        conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n        conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n        conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n        conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n        conversions.U8.toU64(data(i + 5)) << u64\"40\" |\n        conversions.U8.toU64(data(i + 6)) << u64\"48\" |\n        conversions.U8.toU64(data(i + 7)) << u64\"56\"\n    }\n\n    @pure def tail(i: Z): U64 = {\n      data.size - i match {\n        case z\"1\" =>\n          return conversions.U8.toU64(data(i))\n        case z\"2\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\"\n        case z\"3\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\"\n        case z\"4\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\"\n        case z\"5\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\"\n        case z\"6\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n            conversions.U8.toU64(data(i + 5)) << u64\"40\"\n        case z\"7\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n            conversions.U8.toU64(data(i + 5)) << u64\"40\" |\n            conversions.U8.toU64(data(i + 6)) << u64\"48\"\n        case _ => return fetch(i)\n      }\n    }\n\n    val prime0: U64 = u64\"0xEC99BF0D8372CAAB\"\n    val prime1: U64 = u64\"0x82434FE90EDCEF39\"\n    val prime2: U64 = u64\"0xD4F06DB99D67BE4B\"\n    val prime3: U64 = u64\"0xBD9CACC22C6E9571\"\n    val prime4: U64 = u64\"0x9C06FAF4D023E3AB\"\n    val prime5: U64 = u64\"0xC060724A8424F345\"\n    val prime6: U64 = u64\"0xCB5AF53AE3AAAC31\"\n\n    @pure def first(): U64 = {\n      val dataSize = data.size\n      val dataSize64 = conversions.Z.toU64(dataSize)\n\n      var a: U64 = seed\n      var b: U64 = conversions.Z.toU64(dataSize)\n\n      var i = 0\n      if (dataSize > 32) {\n        var c = rot(dataSize64, u64\"17\") + seed\n        var d = dataSize64 |^ rot(seed, u64\"17\")\n\n        while (dataSize - i >= 32) {\n          val w0 = fetch(i)\n          val w1 = fetch(i + 8)\n          val w2 = fetch(i + 16)\n          val w3 = fetch(i + 24)\n\n          val d02 = w0 |^ rot(w2 + d, u64\"17\")\n          val c13 = w1 |^ rot(w3 + c, u64\"17\")\n          c = c + (a |^ rot(w0, u64\"41\"))\n          d = d - (b |^ rot(w1, u64\"31\"))\n          a = a |^ (prime1 * (d02 + w3))\n          b = b |^ (prime0 * (c13 + w2))\n          i = i + 32\n        }\n\n        a = a |^ (prime6 * (rot(c, u64\"17\") + d))\n        b = b |^ (prime5 * (c + rot(d, u64\"17\")))\n      }\n\n      val len = dataSize - i\n      (len - 1) / 8 match {\n        case z\"3\" =>\n          b = b + mux(fetch(i), prime4)\n          i = i + 8\n          a = a + mux(fetch(i), prime3)\n          i = i + 8\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case z\"2\" =>\n          a = a + mux(fetch(i), prime3)\n          i = i + 8\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case z\"1\" =>\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case _ =>\n          if (len > 0) {\n            a = a + mux(tail(i), prime1)\n          }\n      }\n\n      return mux(rot(a + b, u64\"17\"), prime4) + mix(a |^ b, prime0)\n    }\n\n    @pure def second(): U64 = {\n      val dataSize = data.size\n      val dataSize64 = conversions.Z.toU64(dataSize)\n\n      var a: U64 = seed\n      var b: U64 = dataSize64\n\n      var i = 0\n      if (dataSize > 32) {\n        var c: U64 = rot(dataSize64, u64\"23\") + ~seed\n        var d: U64 = ~dataSize64 + rot(seed, u64\"19\")\n\n        while (dataSize - i >= 32) {\n          val w0 = fetch(i + 0)\n          val w1 = fetch(i + 8)\n          val w2 = fetch(i + 16)\n          val w3 = fetch(i + 24)\n\n          val d02 = w0 + rot(w2 + d, u64\"56\")\n          val c13 = w1 + rot(w3 + c, u64\"19\")\n          d = d |^ (b + rot(w1, u64\"38\"))\n          c = c |^ (a + rot(w0, u64\"57\"))\n          b = b |^ (prime6 * (c13 + w2))\n          a = a |^ (prime5 * (d02 + w3))\n          i = i + 32\n        }\n\n        a = a |^ (prime6 * (c + rot(d, u64\"23\")))\n        b = b |^ (prime5 * (rot(c, u64\"19\") + d))\n      }\n\n      val len = dataSize - i\n      (len - 1) / 8 match {\n        case z\"3\" =>\n          var p = mullu(b + fetch(i), prime4)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + fetch(i), prime3)\n          b = b |^ p._1\n          a = a + p._2\n          i = i + 8\n          p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case z\"2\" =>\n          var p = mullu(a + fetch(i), prime3)\n          b = b |^ p._1\n          a = a + p._2\n          i = i + 8\n          p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case z\"1\" =>\n          var p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case _ =>\n          if (len > 0) {\n            val p = mullu(a + tail(i), prime1)\n            b = b |^ p._1\n            a = a + p._2\n          }\n      }\n\n      return mux(((a + rot(b, u64\"41\")) * prime0) |^ ((rot(a, u64\"23\") + b) * prime6), prime5)\n    }\n\n    return if (isFirst) first() else second()\n  }\n\n}\n
  #610 = String             #609          // // #Sireum\npackage org.sireum\n\nimport U32._\nimport U64._\n\nobject Hash {\n\n  @pure def murmur3a(data: ISZ[U8], seed: U32): U32 = {\n\n    /*\n     Copyright (c) 2017-2022, Robby, Kansas State University\n     All rights reserved.\n\n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions are met:\n\n     1. Redistributions of source code must retain the above copyright notice, this\n        list of conditions and the following disclaimer.\n     2. Redistributions in binary form must reproduce the above copyright notice,\n        this list of conditions and the following disclaimer in the documentation\n        and/or other materials provided with the distribution.\n\n     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n\n    @pure def process(d0: U32, h: U32): U32 = {\n      var d = d0\n      d = d * u32\"0xCC9E2D51\"\n      d = (d << u32\"15\") | (d >>> u32\"17\")\n      d = d * u32\"0x1B873593\"\n      return h |^ d\n    }\n\n    val dataSize = data.size\n    var h = seed\n\n    var i: Z = 0\n    if (dataSize > 3) {\n      while (dataSize - i >= 4) {\n        val d =\n          conversions.U8.toU32(data(i)) |\n            (conversions.U8.toU32(data(i + 1)) << u32\"8\") |\n            (conversions.U8.toU32(data(i + 2)) << u32\"16\") |\n            (conversions.U8.toU32(data(i + 3)) << u32\"24\")\n        i = i + 4\n        h = process(d, h)\n        h = (h << u32\"13\") | (h >> u32\"19\")\n        h = (h * u32\"5\") + u32\"0xE6546B64\"\n      }\n    }\n\n    dataSize - i match {\n      case z\"1\" =>\n        val d = conversions.U8.toU32(data(i))\n        h = process(d, h)\n      case z\"2\" =>\n        val d = conversions.U8.toU32(data(i)) |\n          (conversions.U8.toU32(data(i + 1)) << u32\"8\")\n        h = process(d, h)\n      case z\"3\" =>\n        val d = conversions.U8.toU32(data(i)) |\n          (conversions.U8.toU32(data(i + 1)) << u32\"8\") |\n          (conversions.U8.toU32(data(i + 2)) << u32\"16\")\n        h = process(d, h)\n      case _ =>\n    }\n\n    h = h |^ conversions.Z.toU32(dataSize)\n    h = h |^ (h >> u32\"16\")\n    h = h * u32\"0x85EBCA6B\"\n    h = h |^ (h >> u32\"13\")\n    h = h * u32\"0xC2B2AE35\"\n    h = h |^ (h >> u32\"16\")\n\n    return h\n  }\n\n  @pure def t1ha0(data: ISZ[U8], seed: U64): U64 = {\n\n    // Adapted from: https://github.com/leo-yuriev/t1ha/tree/v2.0.2\n    /*\n     *  Copyright (c) 2016-2018 Positive Technologies, https://www.ptsecurity.com,\n     *  Fast Positive Hash.\n     *\n     *  Portions Copyright (c) 2010-2018 Leonid Yuriev <leo@yuriev.ru>,\n     *  The 1Hippeus project (t1h).\n     *\n     *  This software is provided \'as-is\', without any express or implied\n     *  warranty. In no event will the authors be held liable for any damages\n     *  arising from the use of this software.\n     *\n     *  Permission is granted to anyone to use this software for any purpose,\n     *  including commercial applications, and to alter it and redistribute it\n     *  freely, subject to the following restrictions:\n     *\n     *  1. The origin of this software must not be misrepresented; you must not\n     *     claim that you wrote the original software. If you use this software\n     *     in a product, an acknowledgement in the product documentation would be\n     *     appreciated but is not required.\n     *  2. Altered source versions must be plainly marked as such, and must not be\n     *     misrepresented as being the original software.\n     *  3. This notice may not be removed or altered from any source distribution.\n     */\n\n    @pure def rot(n: U32, m: U32): U32 = {\n      return (n >>> m) | (n << (u32\"32\" - m))\n    }\n\n    @pure def fetch(i: Z): U32 = {\n      return conversions.U8.toU32(data(i)) |\n        conversions.U8.toU32(data(i + 1)) << u32\"8\" |\n        conversions.U8.toU32(data(i + 2)) << u32\"16\" |\n        conversions.U8.toU32(data(i + 3)) << u32\"24\"\n    }\n\n    @pure def tail(i: Z): U32 = {\n      data.size - i match {\n        case z\"1\" =>\n          return conversions.U8.toU32(data(i))\n        case z\"2\" =>\n          return conversions.U8.toU32(data(i)) |\n            conversions.U8.toU32(data(i + 1)) << u32\"8\"\n        case z\"3\" =>\n          return conversions.U8.toU32(data(i)) |\n            conversions.U8.toU32(data(i + 1)) << u32\"8\" |\n            conversions.U8.toU32(data(i + 2)) << u32\"16\"\n        case _ => fetch(i)\n      }\n    }\n\n    val prime0: U32 = u32\"0x92D78269\"\n    val prime1: U32 = u32\"0xCA9B4735\"\n    val prime2: U32 = u32\"0xA4ABA1C3\"\n    val prime3: U32 = u32\"0xF6499843\"\n    val prime4: U32 = u32\"0x86F0FD61\"\n    val prime5: U32 = u32\"0xCA2DA6FB\"\n    val prime6: U32 = u32\"0xC4BB3575\"\n\n    val dataSize = data.size\n    val dataSize32 = conversions.Z.toU32(dataSize)\n\n    var a: U32 = rot(dataSize32, u32\"17\") + conversions.U64.toU32(seed & u64\"0xFFFFFFFF\")\n    var b: U32 = dataSize32 |^ conversions.U64.toU32(seed >>> u64\"32\")\n\n    var i = 0\n    if (dataSize > 16) {\n      var c = ~a\n      var d = rot(b, u32\"5\")\n\n      while (dataSize - i >= 16) {\n        val w0 = fetch(i)\n        val w1 = fetch(i + 4)\n        val w2 = fetch(i + 8)\n        val w3 = fetch(i + 12)\n\n        val c02 = w0 |^ rot(w2 + c, u32\"11\")\n        val d13 = w1 + rot(w3 + d, u32\"17\")\n        c = c |^ rot(b + w1, u32\"7\")\n        d = d |^ rot(a + w0, u32\"3\")\n        b = prime1 * (c02 + w3)\n        a = prime0 * (d13 |^ w2)\n        i = i + 16\n      }\n\n      c = c + a\n      d = d + b\n      a = a |^ (prime6 * (rot(c, u32\"16\") + d))\n      b = b |^ (prime5 * (c + rot(d, u32\"16\")))\n    }\n\n    val len = dataSize - i\n    (len - 1) / 4 match {\n      case z\"3\" =>\n        var l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime4)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + fetch(i)) * conversions.U32.toU64(prime3)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case z\"2\" =>\n        var l = conversions.U32.toU64(a + fetch(i)) * conversions.U32.toU64(prime3)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case z\"1\" =>\n        var l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case _ =>\n        if (len > 0) {\n          val l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n          b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n          a = a + conversions.U64.toU32(l >>> u64\"32\")\n        }\n    }\n\n    var l = conversions.U32.toU64(b |^ rot(a, u32\"13\")) | (conversions.U32.toU64(a) << u64\"32\")\n    l = l * u64\"0xEC99BF0D8372CAAB\"\n    l = l |^ (l >> u64\"41\")\n    l = l * u64\"0x9C06FAF4D023E3AB\"\n    l = l |^ (l >> u64\"47\")\n    l = l * u64\"0xCB5AF53AE3AAAC31\"\n\n    return l\n  }\n\n  @pure def t1ha(isFirst: B, data: ISZ[U8], seed: U64): U64 = {\n\n    @pure def mullu(a: U64, b: U64): (U64, U64) = {\n      // Adapted from: https://golang.org/src/runtime/softfloat64.go (mullu)\n      /*\n        Copyright (c) 2009 The Go Authors. All rights reserved.\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions are\n        met:\n\n        * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following disclaimer\n        in the documentation and/or other materials provided with the\n        distribution.\n        * Neither the name of Google Inc. nor the names of its\n        contributors may be used to endorse or promote products derived from\n        this software without specific prior written permission.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n        \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n       */\n\n      val s = u64\"32\"\n      val mask = (u64\"1\" << s) - u64\"1\"\n      val a0 = a & mask\n      val a1 = a >> s\n      val b0 = b & mask\n      val b1 = b >> s\n      val w0 = a0 * b0\n      val t = a1 * b0 + (w0 >> s)\n      var w1 = t & mask\n      val w2 = t >> s\n      w1 = w1 + a0 * b1\n      return (a * b, a1 * b1 + w2 + (w1 >> s))\n    }\n\n    // Adapted from: https://github.com/leo-yuriev/t1ha/tree/v2.0.2\n    /*\n     *  Copyright (c) 2016-2018 Positive Technologies, https://www.ptsecurity.com,\n     *  Fast Positive Hash.\n     *\n     *  Portions Copyright (c) 2010-2018 Leonid Yuriev <leo@yuriev.ru>,\n     *  The 1Hippeus project (t1h).\n     *\n     *  This software is provided \'as-is\', without any express or implied\n     *  warranty. In no event will the authors be held liable for any damages\n     *  arising from the use of this software.\n     *\n     *  Permission is granted to anyone to use this software for any purpose,\n     *  including commercial applications, and to alter it and redistribute it\n     *  freely, subject to the following restrictions:\n     *\n     *  1. The origin of this software must not be misrepresented; you must not\n     *     claim that you wrote the original software. If you use this software\n     *     in a product, an acknowledgement in the product documentation would be\n     *     appreciated but is not required.\n     *  2. Altered source versions must be plainly marked as such, and must not be\n     *     misrepresented as being the original software.\n     *  3. This notice may not be removed or altered from any source distribution.\n     */\n\n    @pure def rot(n: U64, m: U64): U64 = {\n      return (n >>> m) | (n << (u64\"64\" - m))\n    }\n\n    @pure def mix(v: U64, p: U64): U64 = {\n      val v2 = v * p\n      return v2 |^ rot(v2, u64\"41\")\n    }\n\n    @pure def mux(v: U64, prime: U64): U64 = {\n      val p = mullu(v, prime)\n      return p._1 |^ p._2\n    }\n\n    @pure def fetch(i: Z): U64 = {\n      return conversions.U8.toU64(data(i)) |\n        conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n        conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n        conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n        conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n        conversions.U8.toU64(data(i + 5)) << u64\"40\" |\n        conversions.U8.toU64(data(i + 6)) << u64\"48\" |\n        conversions.U8.toU64(data(i + 7)) << u64\"56\"\n    }\n\n    @pure def tail(i: Z): U64 = {\n      data.size - i match {\n        case z\"1\" =>\n          return conversions.U8.toU64(data(i))\n        case z\"2\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\"\n        case z\"3\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\"\n        case z\"4\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\"\n        case z\"5\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\"\n        case z\"6\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n            conversions.U8.toU64(data(i + 5)) << u64\"40\"\n        case z\"7\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n            conversions.U8.toU64(data(i + 5)) << u64\"40\" |\n            conversions.U8.toU64(data(i + 6)) << u64\"48\"\n        case _ => return fetch(i)\n      }\n    }\n\n    val prime0: U64 = u64\"0xEC99BF0D8372CAAB\"\n    val prime1: U64 = u64\"0x82434FE90EDCEF39\"\n    val prime2: U64 = u64\"0xD4F06DB99D67BE4B\"\n    val prime3: U64 = u64\"0xBD9CACC22C6E9571\"\n    val prime4: U64 = u64\"0x9C06FAF4D023E3AB\"\n    val prime5: U64 = u64\"0xC060724A8424F345\"\n    val prime6: U64 = u64\"0xCB5AF53AE3AAAC31\"\n\n    @pure def first(): U64 = {\n      val dataSize = data.size\n      val dataSize64 = conversions.Z.toU64(dataSize)\n\n      var a: U64 = seed\n      var b: U64 = conversions.Z.toU64(dataSize)\n\n      var i = 0\n      if (dataSize > 32) {\n        var c = rot(dataSize64, u64\"17\") + seed\n        var d = dataSize64 |^ rot(seed, u64\"17\")\n\n        while (dataSize - i >= 32) {\n          val w0 = fetch(i)\n          val w1 = fetch(i + 8)\n          val w2 = fetch(i + 16)\n          val w3 = fetch(i + 24)\n\n          val d02 = w0 |^ rot(w2 + d, u64\"17\")\n          val c13 = w1 |^ rot(w3 + c, u64\"17\")\n          c = c + (a |^ rot(w0, u64\"41\"))\n          d = d - (b |^ rot(w1, u64\"31\"))\n          a = a |^ (prime1 * (d02 + w3))\n          b = b |^ (prime0 * (c13 + w2))\n          i = i + 32\n        }\n\n        a = a |^ (prime6 * (rot(c, u64\"17\") + d))\n        b = b |^ (prime5 * (c + rot(d, u64\"17\")))\n      }\n\n      val len = dataSize - i\n      (len - 1) / 8 match {\n        case z\"3\" =>\n          b = b + mux(fetch(i), prime4)\n          i = i + 8\n          a = a + mux(fetch(i), prime3)\n          i = i + 8\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case z\"2\" =>\n          a = a + mux(fetch(i), prime3)\n          i = i + 8\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case z\"1\" =>\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case _ =>\n          if (len > 0) {\n            a = a + mux(tail(i), prime1)\n          }\n      }\n\n      return mux(rot(a + b, u64\"17\"), prime4) + mix(a |^ b, prime0)\n    }\n\n    @pure def second(): U64 = {\n      val dataSize = data.size\n      val dataSize64 = conversions.Z.toU64(dataSize)\n\n      var a: U64 = seed\n      var b: U64 = dataSize64\n\n      var i = 0\n      if (dataSize > 32) {\n        var c: U64 = rot(dataSize64, u64\"23\") + ~seed\n        var d: U64 = ~dataSize64 + rot(seed, u64\"19\")\n\n        while (dataSize - i >= 32) {\n          val w0 = fetch(i + 0)\n          val w1 = fetch(i + 8)\n          val w2 = fetch(i + 16)\n          val w3 = fetch(i + 24)\n\n          val d02 = w0 + rot(w2 + d, u64\"56\")\n          val c13 = w1 + rot(w3 + c, u64\"19\")\n          d = d |^ (b + rot(w1, u64\"38\"))\n          c = c |^ (a + rot(w0, u64\"57\"))\n          b = b |^ (prime6 * (c13 + w2))\n          a = a |^ (prime5 * (d02 + w3))\n          i = i + 32\n        }\n\n        a = a |^ (prime6 * (c + rot(d, u64\"23\")))\n        b = b |^ (prime5 * (rot(c, u64\"19\") + d))\n      }\n\n      val len = dataSize - i\n      (len - 1) / 8 match {\n        case z\"3\" =>\n          var p = mullu(b + fetch(i), prime4)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + fetch(i), prime3)\n          b = b |^ p._1\n          a = a + p._2\n          i = i + 8\n          p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case z\"2\" =>\n          var p = mullu(a + fetch(i), prime3)\n          b = b |^ p._1\n          a = a + p._2\n          i = i + 8\n          p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case z\"1\" =>\n          var p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case _ =>\n          if (len > 0) {\n            val p = mullu(a + tail(i), prime1)\n            b = b |^ p._1\n            a = a + p._2\n          }\n      }\n\n      return mux(((a + rot(b, u64\"41\")) * prime0) |^ ((rot(a, u64\"23\") + b) * prime6), prime5)\n    }\n\n    return if (isFirst) first() else second()\n  }\n\n}\n
  #611 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nimport ContractUtil._\n\n@record trait CircularQueue[E] {\n\n  @spec var rep: MSZ[E] = $\n\n  @spec def repInv = Invariant(rep.size <= max)\n\n  @pure def max: Z\n\n  @pure def default: E\n\n  @pure def scrub: B\n\n  @pure def policy: CircularQueue.Policy.Type\n\n  def size: Z = Contract.Only(Ensures(Res == rep.size))\n\n  def isEmpty: B = Contract.Only(Ensures(Res == (rep.size == 0)))\n\n  def nonEmpty: B = Contract.Only(Ensures(Res == (rep.size != 0)))\n\n  def isFull: B = Contract.Only(Ensures(Res == (rep.size == max)))\n\n  def enqueue(element: E): Unit = Contract.Only(\n    Modifies(rep),\n    Case(\"Non-full\",\n      Requires(rep.size < max),\n      Ensures(rep == In(rep) :+ element)\n    ),\n    Case(\"Drop front policy and full\",\n      Requires(\n        policy == CircularQueue.Policy.DropFront,\n        rep.size == max\n      ),\n      Ensures(\n        rep.size == In(rep).size,\n        All(1 until rep.size)(i => rep(i - 1) == In(rep)(i)),\n        rep(rep.size - 1) == element\n      )\n    ),\n    Case(\"Drop rear policy and full\",\n      Requires(\n        policy == CircularQueue.Policy.DropRear,\n        rep.size == max\n      ),\n      Ensures(\n        rep.size == In(rep).size,\n        msEqualExcept(rep, In(rep), rep.size - 1),\n        rep(rep.size - 1) == element\n      )\n    )\n  )\n\n  def dequeue(): E = Contract.Only(\n    Requires(rep.size > 0),\n    Modifies(rep),\n    Ensures(\n      rep.size == In(rep).size - 1,\n      All(1 until In(rep).size)(i => rep(i - 1) == In(rep)(i)),\n      Res == In(rep)(0)\n    )\n  )\n\n  def elements: MSZ[E] = Contract.Only(Ensures(Res == rep))\n\n  override def string: String = {\n    return elements.string\n  }\n}\n\nobject CircularQueue {\n\n  @enum object Policy {\n    \"NoDrop\"\n    \"DropFront\"\n    \"DropRear\"\n  }\n\n  @strictpure def inv[E](max: Z, default: E, scrub: B, queue: MSZ[E], front: Z, rear: Z, numOfElements: Z): B =\n    max > 0 &\n      max + 1 == queue.size &\n      queue.isInBound(front) &\n      queue.isInBound(rear) &\n      0 <= numOfElements &\n      numOfElements <= max &\n      (rear >= front) === (numOfElements == rear - front) &\n      (rear < front) === (numOfElements == rear + queue.size - front) &\n      (scrub ->: All(0 until queue.size - numOfElements)(i => queue(modPos(rear + i, queue.size)) == default))\n\n  @strictpure def refinement[E](rep: MSZ[E], queue: MSZ[E], numOfElements: Z, front: Z): B =\n    rep.size == numOfElements &\n      All(rep.indices)(i => rep(i) == queue(modPos(front + i, queue.size)))\n\n  @strictpure def createEnsures[E](res: CircularQueue[E], max: Z, default: E, scrub: B, policy: Policy.Type): B =\n    res.max == max &\n      res.default == default &\n      res.scrub == scrub &\n      res.policy == policy\n\n  object NoDrop {\n\n    @pure def create[E](max: Z, default: E, scrub: B): NoDrop[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[NoDrop[E]].rep == MSZ[E]()\n        )\n      )\n\n      return NoDrop(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: NoDrop[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class NoDrop[E](val max: Z,\n                          val default: E,\n                          val scrub: B,\n                          val queue: MSZ[E],\n                          var front: Z,\n                          var rear: Z,\n                          var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.NoDrop\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Requires(numOfElements != max),\n        Modifies(queue, rear, front, numOfElements),\n        Ensures(\n          queue(In(rear)) == element,\n          rear == modPos(In(rear) + 1, queue.size),\n          numOfElements == In(numOfElements) + 1,\n          msEqualExcept(queue, In(queue), In(rear))\n        )\n      )\n\n      queue(rear) = element\n      rear = modPos(rear + 1, queue.size)\n      numOfElements = numOfElements + 1\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  object DropFront {\n\n    @pure def create[E](max: Z, default: E, scrub: B): DropFront[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[DropFront[E]].rep == MSZ[E]()\n        )\n      )\n\n      return DropFront(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: DropFront[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class DropFront[E](val max: Z,\n                             val default: E,\n                             val scrub: B,\n                             val queue: MSZ[E],\n                             var front: Z,\n                             var rear: Z,\n                             var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.DropFront\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Modifies(queue, rear, front, numOfElements),\n        Ensures(\n          queue(In(rear)) == element,\n          rear == modPos(In(rear) + 1, queue.size),\n          (In(numOfElements) < max) === (numOfElements == In(numOfElements) + 1),\n          (In(numOfElements) == max) === (numOfElements == In(numOfElements)),\n          msEqualExcept(queue, In(queue), In(rear))\n        )\n      )\n\n      if (isFull) {\n        dequeue()\n      }\n      queue(rear) = element\n      rear = modPos(rear + 1, queue.size)\n      numOfElements = numOfElements + 1\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  object DropRear {\n\n    @pure def create[E](max: Z, default: E, scrub: B): DropRear[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[DropRear[E]].rep == MSZ[E]()\n        )\n      )\n      return DropRear(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: DropRear[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class DropRear[E](val max: Z,\n                            val default: E,\n                            val scrub: B,\n                            val queue: MSZ[E],\n                            var front: Z,\n                            var rear: Z,\n                            var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.DropRear\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Modifies(queue, rear, front, numOfElements),\n        Case(\"Non-full and rear is not the last index\",\n          Requires(\n            In(numOfElements) < max,\n            rear < max\n          ),\n          Ensures(\n            numOfElements == In(numOfElements) + 1,\n            rear == In(rear) + 1,\n            queue(In(rear)) == element,\n            msEqualExcept(queue, In(queue), In(rear))\n          )\n        ),\n        Case(\"Non-full and rear is the last index\",\n          Requires(\n            In(numOfElements) < max,\n            rear == max\n          ),\n          Ensures(\n            numOfElements == In(numOfElements) + 1,\n            rear == 0,\n            queue(max) == element,\n            msEqualExcept(queue, In(queue), max)\n          )\n        ),\n        Case(\"Full and rear is the first index\",\n          Requires(\n            numOfElements == max,\n            rear == 0\n          ),\n          Ensures(\n            numOfElements == In(numOfElements),\n            rear == In(rear),\n            queue(max) == element,\n            msEqualExcept(queue, In(queue), max)\n          )\n        ),\n        Case(\"Full and rear is not the first index\",\n          Requires(\n            In(numOfElements) == max,\n            rear > 0\n          ),\n          Ensures(\n            numOfElements == In(numOfElements),\n            rear == In(rear),\n            queue(rear - 1) == element,\n            msEqualExcept(queue, In(queue), rear - 1)\n          )\n        )\n      )\n\n      if (isFull) {\n        queue(modNeg(rear - 1, queue.size)) = element\n      } else {\n        queue(rear) = element\n        rear = modPos(rear + 1, queue.size)\n        numOfElements = numOfElements + 1\n      }\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  @pure def create[E](max: Z, default: E, scrub: B, policy: Policy.Type): CircularQueue[E] = {\n    Contract(Ensures(createEnsures(Res, max, default, scrub, policy)))\n\n    policy match {\n      case Policy.NoDrop => return NoDrop.create(max, default, scrub)\n      case Policy.DropFront => return DropFront.create(max, default, scrub)\n      case Policy.DropRear => return DropRear.create(max, default, scrub)\n    }\n  }\n\n}\n
  #612 = String             #611          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nimport ContractUtil._\n\n@record trait CircularQueue[E] {\n\n  @spec var rep: MSZ[E] = $\n\n  @spec def repInv = Invariant(rep.size <= max)\n\n  @pure def max: Z\n\n  @pure def default: E\n\n  @pure def scrub: B\n\n  @pure def policy: CircularQueue.Policy.Type\n\n  def size: Z = Contract.Only(Ensures(Res == rep.size))\n\n  def isEmpty: B = Contract.Only(Ensures(Res == (rep.size == 0)))\n\n  def nonEmpty: B = Contract.Only(Ensures(Res == (rep.size != 0)))\n\n  def isFull: B = Contract.Only(Ensures(Res == (rep.size == max)))\n\n  def enqueue(element: E): Unit = Contract.Only(\n    Modifies(rep),\n    Case(\"Non-full\",\n      Requires(rep.size < max),\n      Ensures(rep == In(rep) :+ element)\n    ),\n    Case(\"Drop front policy and full\",\n      Requires(\n        policy == CircularQueue.Policy.DropFront,\n        rep.size == max\n      ),\n      Ensures(\n        rep.size == In(rep).size,\n        All(1 until rep.size)(i => rep(i - 1) == In(rep)(i)),\n        rep(rep.size - 1) == element\n      )\n    ),\n    Case(\"Drop rear policy and full\",\n      Requires(\n        policy == CircularQueue.Policy.DropRear,\n        rep.size == max\n      ),\n      Ensures(\n        rep.size == In(rep).size,\n        msEqualExcept(rep, In(rep), rep.size - 1),\n        rep(rep.size - 1) == element\n      )\n    )\n  )\n\n  def dequeue(): E = Contract.Only(\n    Requires(rep.size > 0),\n    Modifies(rep),\n    Ensures(\n      rep.size == In(rep).size - 1,\n      All(1 until In(rep).size)(i => rep(i - 1) == In(rep)(i)),\n      Res == In(rep)(0)\n    )\n  )\n\n  def elements: MSZ[E] = Contract.Only(Ensures(Res == rep))\n\n  override def string: String = {\n    return elements.string\n  }\n}\n\nobject CircularQueue {\n\n  @enum object Policy {\n    \"NoDrop\"\n    \"DropFront\"\n    \"DropRear\"\n  }\n\n  @strictpure def inv[E](max: Z, default: E, scrub: B, queue: MSZ[E], front: Z, rear: Z, numOfElements: Z): B =\n    max > 0 &\n      max + 1 == queue.size &\n      queue.isInBound(front) &\n      queue.isInBound(rear) &\n      0 <= numOfElements &\n      numOfElements <= max &\n      (rear >= front) === (numOfElements == rear - front) &\n      (rear < front) === (numOfElements == rear + queue.size - front) &\n      (scrub ->: All(0 until queue.size - numOfElements)(i => queue(modPos(rear + i, queue.size)) == default))\n\n  @strictpure def refinement[E](rep: MSZ[E], queue: MSZ[E], numOfElements: Z, front: Z): B =\n    rep.size == numOfElements &\n      All(rep.indices)(i => rep(i) == queue(modPos(front + i, queue.size)))\n\n  @strictpure def createEnsures[E](res: CircularQueue[E], max: Z, default: E, scrub: B, policy: Policy.Type): B =\n    res.max == max &\n      res.default == default &\n      res.scrub == scrub &\n      res.policy == policy\n\n  object NoDrop {\n\n    @pure def create[E](max: Z, default: E, scrub: B): NoDrop[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[NoDrop[E]].rep == MSZ[E]()\n        )\n      )\n\n      return NoDrop(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: NoDrop[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class NoDrop[E](val max: Z,\n                          val default: E,\n                          val scrub: B,\n                          val queue: MSZ[E],\n                          var front: Z,\n                          var rear: Z,\n                          var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.NoDrop\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Requires(numOfElements != max),\n        Modifies(queue, rear, front, numOfElements),\n        Ensures(\n          queue(In(rear)) == element,\n          rear == modPos(In(rear) + 1, queue.size),\n          numOfElements == In(numOfElements) + 1,\n          msEqualExcept(queue, In(queue), In(rear))\n        )\n      )\n\n      queue(rear) = element\n      rear = modPos(rear + 1, queue.size)\n      numOfElements = numOfElements + 1\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  object DropFront {\n\n    @pure def create[E](max: Z, default: E, scrub: B): DropFront[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[DropFront[E]].rep == MSZ[E]()\n        )\n      )\n\n      return DropFront(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: DropFront[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class DropFront[E](val max: Z,\n                             val default: E,\n                             val scrub: B,\n                             val queue: MSZ[E],\n                             var front: Z,\n                             var rear: Z,\n                             var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.DropFront\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Modifies(queue, rear, front, numOfElements),\n        Ensures(\n          queue(In(rear)) == element,\n          rear == modPos(In(rear) + 1, queue.size),\n          (In(numOfElements) < max) === (numOfElements == In(numOfElements) + 1),\n          (In(numOfElements) == max) === (numOfElements == In(numOfElements)),\n          msEqualExcept(queue, In(queue), In(rear))\n        )\n      )\n\n      if (isFull) {\n        dequeue()\n      }\n      queue(rear) = element\n      rear = modPos(rear + 1, queue.size)\n      numOfElements = numOfElements + 1\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  object DropRear {\n\n    @pure def create[E](max: Z, default: E, scrub: B): DropRear[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[DropRear[E]].rep == MSZ[E]()\n        )\n      )\n      return DropRear(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: DropRear[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class DropRear[E](val max: Z,\n                            val default: E,\n                            val scrub: B,\n                            val queue: MSZ[E],\n                            var front: Z,\n                            var rear: Z,\n                            var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.DropRear\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Modifies(queue, rear, front, numOfElements),\n        Case(\"Non-full and rear is not the last index\",\n          Requires(\n            In(numOfElements) < max,\n            rear < max\n          ),\n          Ensures(\n            numOfElements == In(numOfElements) + 1,\n            rear == In(rear) + 1,\n            queue(In(rear)) == element,\n            msEqualExcept(queue, In(queue), In(rear))\n          )\n        ),\n        Case(\"Non-full and rear is the last index\",\n          Requires(\n            In(numOfElements) < max,\n            rear == max\n          ),\n          Ensures(\n            numOfElements == In(numOfElements) + 1,\n            rear == 0,\n            queue(max) == element,\n            msEqualExcept(queue, In(queue), max)\n          )\n        ),\n        Case(\"Full and rear is the first index\",\n          Requires(\n            numOfElements == max,\n            rear == 0\n          ),\n          Ensures(\n            numOfElements == In(numOfElements),\n            rear == In(rear),\n            queue(max) == element,\n            msEqualExcept(queue, In(queue), max)\n          )\n        ),\n        Case(\"Full and rear is not the first index\",\n          Requires(\n            In(numOfElements) == max,\n            rear > 0\n          ),\n          Ensures(\n            numOfElements == In(numOfElements),\n            rear == In(rear),\n            queue(rear - 1) == element,\n            msEqualExcept(queue, In(queue), rear - 1)\n          )\n        )\n      )\n\n      if (isFull) {\n        queue(modNeg(rear - 1, queue.size)) = element\n      } else {\n        queue(rear) = element\n        rear = modPos(rear + 1, queue.size)\n        numOfElements = numOfElements + 1\n      }\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  @pure def create[E](max: Z, default: E, scrub: B, policy: Policy.Type): CircularQueue[E] = {\n    Contract(Ensures(createEnsures(Res, max, default, scrub, policy)))\n\n    policy match {\n      case Policy.NoDrop => return NoDrop.create(max, default, scrub)\n      case Policy.DropFront => return DropFront.create(max, default, scrub)\n      case Policy.DropRear => return DropRear.create(max, default, scrub)\n    }\n  }\n\n}\n
  #613 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n@ext object Library {\n\n  def sharedFiles: ISZ[(Option[String], String)] = $\n\n  def files: ISZ[(Option[String], String)] = $\n\n}\n
  #614 = String             #613          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n@ext object Library {\n\n  def sharedFiles: ISZ[(Option[String], String)] = $\n\n  def files: ISZ[(Option[String], String)] = $\n\n}\n
  #615 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject UnionFind {\n\n  type Index = Z\n\n  object Internal {\n\n    @pure def find[T](ds: UnionFind[T], e: Index): Index = {\n      var root = e\n      while (ds.parentOf(root) != root) {\n        root = ds.parentOf(root)\n      }\n      return root\n    }\n\n    @pure def findCompress[T](ds: UnionFind[T], e: Index): (UnionFind[T], Index) = {\n      var root = e\n      var newParentOf = ds.parentOf\n      while (newParentOf(root) != root) {\n        newParentOf = newParentOf(root ~> newParentOf(newParentOf(root)))\n        root = newParentOf(root)\n      }\n      return (ds(parentOf = newParentOf), root)\n    }\n\n    @pure def merge[T](ds: UnionFind[T], e1: Index, e2: Index): UnionFind[T] = {\n      var newDs = ds\n      val rootN: Index = {\n        val pe1 = findCompress(newDs, e1)\n        newDs = pe1._1\n        pe1._2\n      }\n      val rootM: Index = {\n        val pe2 = findCompress(newDs, e2)\n        newDs = pe2._1\n        pe2._2\n      }\n      val (rep, other): (Index, Index) =\n        if (newDs.sizeOf(rootM) > newDs.sizeOf(rootN)) (rootM, rootN) else (rootN, rootM)\n      return newDs(\n        parentOf = newDs.parentOf(other ~> rep),\n        sizeOf = newDs.sizeOf(rep ~> (newDs.sizeOf(rep) + newDs.sizeOf(other)))\n      )\n    }\n  }\n\n  @pure def create[T](elements: ISZ[T]): UnionFind[T] = {\n    val size = elements.size\n    var es = HashSMap.emptyInit[T, Index](size)\n    for (e <- elements) {\n      es = es + e ~> es.size\n    }\n    val parentOf: IS[Index, Index] = for (i <- z\"0\" until size) yield i\n    val sizeOf = IS.create[Index, Index](size, 1)\n    return UnionFind(es, elements, parentOf, sizeOf)\n  }\n}\n\n@datatype class UnionFind[T](\n  val elements: HashSMap[T, UnionFind.Index],\n  val elementsInverse: IS[UnionFind.Index, T],\n  val parentOf: IS[UnionFind.Index, UnionFind.Index],\n  val sizeOf: IS[UnionFind.Index, UnionFind.Index]\n) {\n\n  @pure def size: Z = {\n    return elements.size\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: UnionFind[T]): B = {\n    if (elementsInverse.size != other.elementsInverse.size) {\n      return F\n    }\n    if ((HashSSet ++ elementsInverse) != (HashSSet ++ other.elementsInverse)) {\n      return F\n    }\n    var seen = HashSSet.emptyInit[(T, T)](size)\n    for (element1 <- elementsInverse; element2 <- elementsInverse if element1 != element2) {\n      val p = (element1, element2)\n      if (!seen.contains(p)) {\n        seen = seen + p + ((element2, element1))\n        if (inSameSet(element1, element2) != inSameSet(element1, element2)) {\n          return F\n        }\n      }\n    }\n    return T\n  }\n\n  @pure def inSameSet(element1: T, element2: T): B = {\n    return UnionFind.Internal.find(this, elements.get(element1).get) == UnionFind.Internal\n      .find(this, elements.get(element2).get)\n  }\n\n  @pure def inSameSetCompress(element1: T, element2: T): (UnionFind[T], B) = {\n    val e1 = elements.get(element1).get\n    val e2 = elements.get(element2).get\n    var newDs = this\n    val rep1: UnionFind.Index = {\n      val p1 = UnionFind.Internal.findCompress(newDs, e1)\n      newDs = p1._1\n      p1._2\n    }\n    val rep2: UnionFind.Index = {\n      val p2 = UnionFind.Internal.findCompress(newDs, e2)\n      newDs = p2._1\n      p2._2\n    }\n    return (newDs, rep1 == rep2)\n  }\n\n  @pure def find(element: T): T = {\n    val n = elements.get(element).get\n    val rep = UnionFind.Internal.find(this, n)\n    return elementsInverse(rep)\n  }\n\n  @pure def findCompress(element: T): (UnionFind[T], T) = {\n    val n = elements.get(element).get\n    val (newDs, rep) = UnionFind.Internal.findCompress(this, n)\n    return (newDs, elementsInverse(rep))\n  }\n\n  @pure def merge(element1: T, element2: T): UnionFind[T] = {\n    val e1 = elements.get(element1).get\n    val e2 = elements.get(element2).get\n    return UnionFind.Internal.merge(this, e1, e2)\n  }\n\n  @pure def toST(f: T => ST): ST = {\n    var map = HashSMap.emptyInit[UnionFind.Index, ISZ[ST]](size)\n    for (element <- elementsInverse) {\n      val rep = UnionFind.Internal.find(this, elements.get(element).get)\n      map = map + rep ~> (map.get(rep).getOrElse(ISZ[ST]()) :+ f(element))\n    }\n    val sets: ISZ[ST] = for (sts <- map.values) yield st\"\"\"{\n    |  ${(sts, \",\\n\")}\n    |}\"\"\"\n    val r =\n      st\"\"\"{\n      |  ${(sets, \",\\n\")}\n      |}\"\"\"\n    return r\n  }\n\n  @pure override def string: String = {\n    return toST(e => st\"$e\").render\n  }\n\n}\n
  #616 = String             #615          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject UnionFind {\n\n  type Index = Z\n\n  object Internal {\n\n    @pure def find[T](ds: UnionFind[T], e: Index): Index = {\n      var root = e\n      while (ds.parentOf(root) != root) {\n        root = ds.parentOf(root)\n      }\n      return root\n    }\n\n    @pure def findCompress[T](ds: UnionFind[T], e: Index): (UnionFind[T], Index) = {\n      var root = e\n      var newParentOf = ds.parentOf\n      while (newParentOf(root) != root) {\n        newParentOf = newParentOf(root ~> newParentOf(newParentOf(root)))\n        root = newParentOf(root)\n      }\n      return (ds(parentOf = newParentOf), root)\n    }\n\n    @pure def merge[T](ds: UnionFind[T], e1: Index, e2: Index): UnionFind[T] = {\n      var newDs = ds\n      val rootN: Index = {\n        val pe1 = findCompress(newDs, e1)\n        newDs = pe1._1\n        pe1._2\n      }\n      val rootM: Index = {\n        val pe2 = findCompress(newDs, e2)\n        newDs = pe2._1\n        pe2._2\n      }\n      val (rep, other): (Index, Index) =\n        if (newDs.sizeOf(rootM) > newDs.sizeOf(rootN)) (rootM, rootN) else (rootN, rootM)\n      return newDs(\n        parentOf = newDs.parentOf(other ~> rep),\n        sizeOf = newDs.sizeOf(rep ~> (newDs.sizeOf(rep) + newDs.sizeOf(other)))\n      )\n    }\n  }\n\n  @pure def create[T](elements: ISZ[T]): UnionFind[T] = {\n    val size = elements.size\n    var es = HashSMap.emptyInit[T, Index](size)\n    for (e <- elements) {\n      es = es + e ~> es.size\n    }\n    val parentOf: IS[Index, Index] = for (i <- z\"0\" until size) yield i\n    val sizeOf = IS.create[Index, Index](size, 1)\n    return UnionFind(es, elements, parentOf, sizeOf)\n  }\n}\n\n@datatype class UnionFind[T](\n  val elements: HashSMap[T, UnionFind.Index],\n  val elementsInverse: IS[UnionFind.Index, T],\n  val parentOf: IS[UnionFind.Index, UnionFind.Index],\n  val sizeOf: IS[UnionFind.Index, UnionFind.Index]\n) {\n\n  @pure def size: Z = {\n    return elements.size\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: UnionFind[T]): B = {\n    if (elementsInverse.size != other.elementsInverse.size) {\n      return F\n    }\n    if ((HashSSet ++ elementsInverse) != (HashSSet ++ other.elementsInverse)) {\n      return F\n    }\n    var seen = HashSSet.emptyInit[(T, T)](size)\n    for (element1 <- elementsInverse; element2 <- elementsInverse if element1 != element2) {\n      val p = (element1, element2)\n      if (!seen.contains(p)) {\n        seen = seen + p + ((element2, element1))\n        if (inSameSet(element1, element2) != inSameSet(element1, element2)) {\n          return F\n        }\n      }\n    }\n    return T\n  }\n\n  @pure def inSameSet(element1: T, element2: T): B = {\n    return UnionFind.Internal.find(this, elements.get(element1).get) == UnionFind.Internal\n      .find(this, elements.get(element2).get)\n  }\n\n  @pure def inSameSetCompress(element1: T, element2: T): (UnionFind[T], B) = {\n    val e1 = elements.get(element1).get\n    val e2 = elements.get(element2).get\n    var newDs = this\n    val rep1: UnionFind.Index = {\n      val p1 = UnionFind.Internal.findCompress(newDs, e1)\n      newDs = p1._1\n      p1._2\n    }\n    val rep2: UnionFind.Index = {\n      val p2 = UnionFind.Internal.findCompress(newDs, e2)\n      newDs = p2._1\n      p2._2\n    }\n    return (newDs, rep1 == rep2)\n  }\n\n  @pure def find(element: T): T = {\n    val n = elements.get(element).get\n    val rep = UnionFind.Internal.find(this, n)\n    return elementsInverse(rep)\n  }\n\n  @pure def findCompress(element: T): (UnionFind[T], T) = {\n    val n = elements.get(element).get\n    val (newDs, rep) = UnionFind.Internal.findCompress(this, n)\n    return (newDs, elementsInverse(rep))\n  }\n\n  @pure def merge(element1: T, element2: T): UnionFind[T] = {\n    val e1 = elements.get(element1).get\n    val e2 = elements.get(element2).get\n    return UnionFind.Internal.merge(this, e1, e2)\n  }\n\n  @pure def toST(f: T => ST): ST = {\n    var map = HashSMap.emptyInit[UnionFind.Index, ISZ[ST]](size)\n    for (element <- elementsInverse) {\n      val rep = UnionFind.Internal.find(this, elements.get(element).get)\n      map = map + rep ~> (map.get(rep).getOrElse(ISZ[ST]()) :+ f(element))\n    }\n    val sets: ISZ[ST] = for (sts <- map.values) yield st\"\"\"{\n    |  ${(sts, \",\\n\")}\n    |}\"\"\"\n    val r =\n      st\"\"\"{\n      |  ${(sets, \",\\n\")}\n      |}\"\"\"\n    return r\n  }\n\n  @pure override def string: String = {\n    return toST(e => st\"$e\").render\n  }\n\n}\n
  #617 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Time {\n  def currentMillis: Z = $\n}\n
  #618 = String             #617          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Time {\n  def currentMillis: Z = $\n}\n
  #619 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\nobject Console {\n\n  def pause(prompt: String): Unit = {\n    readLine(prompt)\n  }\n\n  def readLine(prompt: String): String = {\n    if (prompt.size > 0) {\n      print(prompt)\n    }\n    return Ext.readLine()\n  }\n\n  @ext(\"Console_Ext\") object Ext {\n    def readLine(): String = $\n  }\n}\n
  #620 = String             #619          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\nobject Console {\n\n  def pause(prompt: String): Unit = {\n    readLine(prompt)\n  }\n\n  def readLine(prompt: String): String = {\n    if (prompt.size > 0) {\n      print(prompt)\n    }\n    return Ext.readLine()\n  }\n\n  @ext(\"Console_Ext\") object Ext {\n    def readLine(): String = $\n  }\n}\n
  #621 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Debug {\n  def onError[T](f: => T, handler: String => Unit): T = $\n}\n
  #622 = String             #621          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Debug {\n  def onError[T](f: => T, handler: String => Unit): T = $\n}\n
  #623 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Cancel {\n  def handleCancellable[T](p: () => T): Unit = $\n  def cancellable[T](p: () => T): T = $\n}\n
  #624 = String             #623          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Cancel {\n  def handleCancellable[T](p: () => T): Unit = $\n  def cancellable[T](p: () => T): T = $\n}\n
  #625 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@range(min = -128, max = 127) class Z8\n\n@range(min = -32768, max = 32767) class Z16\n\n@range(min = -2147483648, max = 2147483647) class Z32\n\n@range(min = -9223372036854775808L, max = 9223372036854775807L) class Z64\n\n@range(min = 0) class N\n\n@range(min = 0, max = 255) class N8\n\n@range(min = 0, max = 65535) class N16\n\n@range(min = 0, max = 4294967295L) class N32\n\n@range(min = 0, max = z\"18,446,744,073,709,551,617\") class N64\n\n@bits(signed = T, width = 8) class S8\n\n@bits(signed = T, width = 16) class S16\n\n@bits(signed = T, width = 32) class S32\n\n@bits(signed = T, width = 64) class S64\n\n@bits(signed = F, width = 8, min = 0, max = 1) class U1\n\n@bits(signed = F, width = 8, min = 0, max = 3) class U2\n\n@bits(signed = F, width = 8, min = 0, max = 7) class U3\n\n@bits(signed = F, width = 8, min = 0, max = 15) class U4\n\n@bits(signed = F, width = 8, min = 0, max = 31) class U5\n\n@bits(signed = F, width = 8, min = 0, max = 63) class U6\n\n@bits(signed = F, width = 8, min = 0, max = 127) class U7\n\n@bits(signed = F, width = 8) class U8\n\n@bits(signed = F, width = 16, min = 0, max = 511) class U9\n\n@bits(signed = F, width = 16, min = 0, max = 1023) class U10\n\n@bits(signed = F, width = 16, min = 0, max = 2047) class U11\n\n@bits(signed = F, width = 16, min = 0, max = 4095) class U12\n\n@bits(signed = F, width = 16, min = 0, max = 8191) class U13\n\n@bits(signed = F, width = 16, min = 0, max = 16383) class U14\n\n@bits(signed = F, width = 16, min = 0, max = 32767) class U15\n\n@bits(signed = F, width = 16) class U16\n\n@bits(signed = F, width = 32, min = 0, max = 131071) class U17\n\n@bits(signed = F, width = 32, min = 0, max = 262143) class U18\n\n@bits(signed = F, width = 32, min = 0, max = 524287) class U19\n\n@bits(signed = F, width = 32, min = 0, max = 1048575) class U20\n\n@bits(signed = F, width = 32, min = 0, max = 2097151) class U21\n\n@bits(signed = F, width = 32, min = 0, max = 4194303) class U22\n\n@bits(signed = F, width = 32, min = 0, max = 8388607) class U23\n\n@bits(signed = F, width = 32, min = 0, max = 16777215) class U24\n\n@bits(signed = F, width = 32, min = 0, max = 33554431) class U25\n\n@bits(signed = F, width = 32, min = 0, max = 67108863) class U26\n\n@bits(signed = F, width = 32, min = 0, max = 134217727) class U27\n\n@bits(signed = F, width = 32, min = 0, max = 268435455) class U28\n\n@bits(signed = F, width = 32, min = 0, max = 536870911) class U29\n\n@bits(signed = F, width = 32, min = 0, max = 1073741823) class U30\n\n@bits(signed = F, width = 32, min = 0, max = 2147483647) class U31\n\n@bits(signed = F, width = 32) class U32\n\n@bits(signed = F, width = 64, min = 0, max = 8589934591L) class U33\n\n@bits(signed = F, width = 64, min = 0, max = 17179869183L) class U34\n\n@bits(signed = F, width = 64, min = 0, max = 34359738367L) class U35\n\n@bits(signed = F, width = 64, min = 0, max = 68719476735L) class U36\n\n@bits(signed = F, width = 64, min = 0, max = 137438953471L) class U37\n\n@bits(signed = F, width = 64, min = 0, max = 274877906943L) class U38\n\n@bits(signed = F, width = 64, min = 0, max = 549755813887L) class U39\n\n@bits(signed = F, width = 64, min = 0, max = 1099511627775L) class U40\n\n@bits(signed = F, width = 64, min = 0, max = 2199023255551L) class U41\n\n@bits(signed = F, width = 64, min = 0, max = 4398046511103L) class U42\n\n@bits(signed = F, width = 64, min = 0, max = 8796093022207L) class U43\n\n@bits(signed = F, width = 64, min = 0, max = 17592186044415L) class U44\n\n@bits(signed = F, width = 64, min = 0, max = 35184372088831L) class U45\n\n@bits(signed = F, width = 64, min = 0, max = 70368744177663L) class U46\n\n@bits(signed = F, width = 64, min = 0, max = 140737488355327L) class U47\n\n@bits(signed = F, width = 64, min = 0, max = 281474976710655L) class U48\n\n@bits(signed = F, width = 64, min = 0, max = 562949953421311L) class U49\n\n@bits(signed = F, width = 64, min = 0, max = 1125899906842623L) class U50\n\n@bits(signed = F, width = 64, min = 0, max = 2251799813685247L) class U51\n\n@bits(signed = F, width = 64, min = 0, max = 4503599627370495L) class U52\n\n@bits(signed = F, width = 64, min = 0, max = 9007199254740991L) class U53\n\n@bits(signed = F, width = 64, min = 0, max = 18014398509481983L) class U54\n\n@bits(signed = F, width = 64, min = 0, max = 36028797018963967L) class U55\n\n@bits(signed = F, width = 64, min = 0, max = 72057594037927935L) class U56\n\n@bits(signed = F, width = 64, min = 0, max = 144115188075855871L) class U57\n\n@bits(signed = F, width = 64, min = 0, max = 288230376151711743L) class U58\n\n@bits(signed = F, width = 64, min = 0, max = 576460752303423487L) class U59\n\n@bits(signed = F, width = 64, min = 0, max = 1152921504606846975L) class U60\n\n@bits(signed = F, width = 64, min = 0, max = 2305843009213693951L) class U61\n\n@bits(signed = F, width = 64, min = 0, max = 4611686018427387903L) class U62\n\n@bits(signed = F, width = 64, min = 0, max = 9223372036854775807L) class U63\n\n@bits(signed = F, width = 64) class U64\n
  #626 = String             #625          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@range(min = -128, max = 127) class Z8\n\n@range(min = -32768, max = 32767) class Z16\n\n@range(min = -2147483648, max = 2147483647) class Z32\n\n@range(min = -9223372036854775808L, max = 9223372036854775807L) class Z64\n\n@range(min = 0) class N\n\n@range(min = 0, max = 255) class N8\n\n@range(min = 0, max = 65535) class N16\n\n@range(min = 0, max = 4294967295L) class N32\n\n@range(min = 0, max = z\"18,446,744,073,709,551,617\") class N64\n\n@bits(signed = T, width = 8) class S8\n\n@bits(signed = T, width = 16) class S16\n\n@bits(signed = T, width = 32) class S32\n\n@bits(signed = T, width = 64) class S64\n\n@bits(signed = F, width = 8, min = 0, max = 1) class U1\n\n@bits(signed = F, width = 8, min = 0, max = 3) class U2\n\n@bits(signed = F, width = 8, min = 0, max = 7) class U3\n\n@bits(signed = F, width = 8, min = 0, max = 15) class U4\n\n@bits(signed = F, width = 8, min = 0, max = 31) class U5\n\n@bits(signed = F, width = 8, min = 0, max = 63) class U6\n\n@bits(signed = F, width = 8, min = 0, max = 127) class U7\n\n@bits(signed = F, width = 8) class U8\n\n@bits(signed = F, width = 16, min = 0, max = 511) class U9\n\n@bits(signed = F, width = 16, min = 0, max = 1023) class U10\n\n@bits(signed = F, width = 16, min = 0, max = 2047) class U11\n\n@bits(signed = F, width = 16, min = 0, max = 4095) class U12\n\n@bits(signed = F, width = 16, min = 0, max = 8191) class U13\n\n@bits(signed = F, width = 16, min = 0, max = 16383) class U14\n\n@bits(signed = F, width = 16, min = 0, max = 32767) class U15\n\n@bits(signed = F, width = 16) class U16\n\n@bits(signed = F, width = 32, min = 0, max = 131071) class U17\n\n@bits(signed = F, width = 32, min = 0, max = 262143) class U18\n\n@bits(signed = F, width = 32, min = 0, max = 524287) class U19\n\n@bits(signed = F, width = 32, min = 0, max = 1048575) class U20\n\n@bits(signed = F, width = 32, min = 0, max = 2097151) class U21\n\n@bits(signed = F, width = 32, min = 0, max = 4194303) class U22\n\n@bits(signed = F, width = 32, min = 0, max = 8388607) class U23\n\n@bits(signed = F, width = 32, min = 0, max = 16777215) class U24\n\n@bits(signed = F, width = 32, min = 0, max = 33554431) class U25\n\n@bits(signed = F, width = 32, min = 0, max = 67108863) class U26\n\n@bits(signed = F, width = 32, min = 0, max = 134217727) class U27\n\n@bits(signed = F, width = 32, min = 0, max = 268435455) class U28\n\n@bits(signed = F, width = 32, min = 0, max = 536870911) class U29\n\n@bits(signed = F, width = 32, min = 0, max = 1073741823) class U30\n\n@bits(signed = F, width = 32, min = 0, max = 2147483647) class U31\n\n@bits(signed = F, width = 32) class U32\n\n@bits(signed = F, width = 64, min = 0, max = 8589934591L) class U33\n\n@bits(signed = F, width = 64, min = 0, max = 17179869183L) class U34\n\n@bits(signed = F, width = 64, min = 0, max = 34359738367L) class U35\n\n@bits(signed = F, width = 64, min = 0, max = 68719476735L) class U36\n\n@bits(signed = F, width = 64, min = 0, max = 137438953471L) class U37\n\n@bits(signed = F, width = 64, min = 0, max = 274877906943L) class U38\n\n@bits(signed = F, width = 64, min = 0, max = 549755813887L) class U39\n\n@bits(signed = F, width = 64, min = 0, max = 1099511627775L) class U40\n\n@bits(signed = F, width = 64, min = 0, max = 2199023255551L) class U41\n\n@bits(signed = F, width = 64, min = 0, max = 4398046511103L) class U42\n\n@bits(signed = F, width = 64, min = 0, max = 8796093022207L) class U43\n\n@bits(signed = F, width = 64, min = 0, max = 17592186044415L) class U44\n\n@bits(signed = F, width = 64, min = 0, max = 35184372088831L) class U45\n\n@bits(signed = F, width = 64, min = 0, max = 70368744177663L) class U46\n\n@bits(signed = F, width = 64, min = 0, max = 140737488355327L) class U47\n\n@bits(signed = F, width = 64, min = 0, max = 281474976710655L) class U48\n\n@bits(signed = F, width = 64, min = 0, max = 562949953421311L) class U49\n\n@bits(signed = F, width = 64, min = 0, max = 1125899906842623L) class U50\n\n@bits(signed = F, width = 64, min = 0, max = 2251799813685247L) class U51\n\n@bits(signed = F, width = 64, min = 0, max = 4503599627370495L) class U52\n\n@bits(signed = F, width = 64, min = 0, max = 9007199254740991L) class U53\n\n@bits(signed = F, width = 64, min = 0, max = 18014398509481983L) class U54\n\n@bits(signed = F, width = 64, min = 0, max = 36028797018963967L) class U55\n\n@bits(signed = F, width = 64, min = 0, max = 72057594037927935L) class U56\n\n@bits(signed = F, width = 64, min = 0, max = 144115188075855871L) class U57\n\n@bits(signed = F, width = 64, min = 0, max = 288230376151711743L) class U58\n\n@bits(signed = F, width = 64, min = 0, max = 576460752303423487L) class U59\n\n@bits(signed = F, width = 64, min = 0, max = 1152921504606846975L) class U60\n\n@bits(signed = F, width = 64, min = 0, max = 2305843009213693951L) class U61\n\n@bits(signed = F, width = 64, min = 0, max = 4611686018427387903L) class U62\n\n@bits(signed = F, width = 64, min = 0, max = 9223372036854775807L) class U63\n\n@bits(signed = F, width = 64) class U64\n
  #627 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.ops.ISZOps\n\n\nobject Stack {\n  @pure def empty[T]: Stack[T] = {\n    return Stack[T](ISZ())\n  }\n}\n\n@datatype class Stack[T](val elements: ISZ[T]) {\n\n  @pure def size: Z = {\n    return elements.size\n  }\n\n  @pure def isEmpty: B = {\n    return elements.isEmpty\n  }\n\n  @pure def nonEmpty: B = {\n    return elements.nonEmpty\n  }\n\n  @pure def peek: Option[T] = {\n    if (nonEmpty) {\n      return Some(elements(elements.size - 1))\n    } else {\n      return None()\n    }\n  }\n\n  @pure def push(e: T): Stack[T] = {\n    return Stack(elements :+ e)\n  }\n\n  @pure def pop: Option[(T, Stack[T])] = {\n    if (nonEmpty) {\n      return Some((elements(elements.size - 1), Stack(ISZOps(elements).dropRight(1))))\n    } else {\n      return None()\n    }\n  }\n}\n
  #628 = String             #627          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.ops.ISZOps\n\n\nobject Stack {\n  @pure def empty[T]: Stack[T] = {\n    return Stack[T](ISZ())\n  }\n}\n\n@datatype class Stack[T](val elements: ISZ[T]) {\n\n  @pure def size: Z = {\n    return elements.size\n  }\n\n  @pure def isEmpty: B = {\n    return elements.isEmpty\n  }\n\n  @pure def nonEmpty: B = {\n    return elements.nonEmpty\n  }\n\n  @pure def peek: Option[T] = {\n    if (nonEmpty) {\n      return Some(elements(elements.size - 1))\n    } else {\n      return None()\n    }\n  }\n\n  @pure def push(e: T): Stack[T] = {\n    return Stack(elements :+ e)\n  }\n\n  @pure def pop: Option[(T, Stack[T])] = {\n    if (nonEmpty) {\n      return Some((elements(elements.size - 1), Stack(ISZOps(elements).dropRight(1))))\n    } else {\n      return None()\n    }\n  }\n}\n
  #629 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Option {\n\n  @strictpure def some[T](value: T): Option[T] = Some(value)\n\n  @strictpure def none[T](): Option[T] = None()\n}\n\n@datatype trait Option[T] {\n\n  @pure def isEmpty: B = Contract.Only(\n    Ensures(Res == (this == None[T]()))\n  )\n\n  @pure def nonEmpty: B = Contract.Only(\n    Ensures(Res == !isEmpty)\n  )\n\n  @pure def map[T2](f: T => T2 @pure): Option[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == None[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == Some(f(get)))\n    )\n  )\n\n  @pure def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == None[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def forall(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == T)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def exists(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == F)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def get: T = Contract.Only(\n    Requires(nonEmpty),\n    Ensures(Some(Res) == this)\n  )\n\n  @pure def getOrElse(default: => T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Some(Res) == this)\n    )\n  )\n\n  @pure def getOrElseEager(default: T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Some(Res) == this)\n    )\n  )\n\n  @pure def toIS: ISZ[T] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == ISZ[T]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == ISZ[T](get))\n    )\n  )\n\n  def foreach[V](f: T => V): Unit\n}\n\n@datatype class None[T] extends Option[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): Option[T2] = {\n    Contract(Ensures(Res == None[T2]()))\n    return None[T2]()\n  }\n\n  @pure override def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = {\n    Contract(Ensures(Res == None[T2]()))\n    return None[T2]()\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def get: T = {\n    Contract(Requires(F))\n    halt(\"Invalid \'None\' operation \'get\'.\")\n  }\n\n  @pure override def toIS: IS[Z, T] = {\n    Contract(Ensures(Res[ISZ[T]].size == 0))\n    return IS[Z, T]()\n  }\n\n  override def foreach[V](f: T => V): Unit = {}\n}\n\n@datatype class Some[T](val value: T) extends Option[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): Option[T2] = {\n    Contract(Ensures(Res == Some(f(value))))\n    return Some(f(value))\n  }\n\n  @pure override def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def get: T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def toIS: IS[Z, T] = {\n    Contract(Ensures(Res == ISZ(value)))\n    return ISZ(value)\n  }\n\n  override def foreach[V](f: T => V): Unit = {\n    f(value)\n  }\n}\n
  #630 = String             #629          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Option {\n\n  @strictpure def some[T](value: T): Option[T] = Some(value)\n\n  @strictpure def none[T](): Option[T] = None()\n}\n\n@datatype trait Option[T] {\n\n  @pure def isEmpty: B = Contract.Only(\n    Ensures(Res == (this == None[T]()))\n  )\n\n  @pure def nonEmpty: B = Contract.Only(\n    Ensures(Res == !isEmpty)\n  )\n\n  @pure def map[T2](f: T => T2 @pure): Option[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == None[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == Some(f(get)))\n    )\n  )\n\n  @pure def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == None[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def forall(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == T)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def exists(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == F)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def get: T = Contract.Only(\n    Requires(nonEmpty),\n    Ensures(Some(Res) == this)\n  )\n\n  @pure def getOrElse(default: => T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Some(Res) == this)\n    )\n  )\n\n  @pure def getOrElseEager(default: T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Some(Res) == this)\n    )\n  )\n\n  @pure def toIS: ISZ[T] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == ISZ[T]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == ISZ[T](get))\n    )\n  )\n\n  def foreach[V](f: T => V): Unit\n}\n\n@datatype class None[T] extends Option[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): Option[T2] = {\n    Contract(Ensures(Res == None[T2]()))\n    return None[T2]()\n  }\n\n  @pure override def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = {\n    Contract(Ensures(Res == None[T2]()))\n    return None[T2]()\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def get: T = {\n    Contract(Requires(F))\n    halt(\"Invalid \'None\' operation \'get\'.\")\n  }\n\n  @pure override def toIS: IS[Z, T] = {\n    Contract(Ensures(Res[ISZ[T]].size == 0))\n    return IS[Z, T]()\n  }\n\n  override def foreach[V](f: T => V): Unit = {}\n}\n\n@datatype class Some[T](val value: T) extends Option[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): Option[T2] = {\n    Contract(Ensures(Res == Some(f(value))))\n    return Some(f(value))\n  }\n\n  @pure override def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def get: T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def toIS: IS[Z, T] = {\n    Contract(Ensures(Res == ISZ(value)))\n    return ISZ(value)\n  }\n\n  override def foreach[V](f: T => V): Unit = {\n    f(value)\n  }\n}\n
  #631 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.conversions\n\nimport org.sireum._\n\nobject Collection {\n\n  @pure def mapToHashMap[K, W](map: Map[K, W]): HashMap[K, W] = {\n    var r = HashMap.emptyInit[K, W](map.size)\n    for (kv <- map.entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def mapToHashSMap[K, W](map: Map[K, W]): HashSMap[K, W] = {\n    var r = HashSMap.emptyInit[K, W](map.size)\n    for (kv <- map.entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def bagToHashBag[T](bag: Bag[T]): HashBag[T] = {\n    return HashBag(mapToHashMap(bag.map))\n  }\n\n}\n
  #632 = String             #631          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.conversions\n\nimport org.sireum._\n\nobject Collection {\n\n  @pure def mapToHashMap[K, W](map: Map[K, W]): HashMap[K, W] = {\n    var r = HashMap.emptyInit[K, W](map.size)\n    for (kv <- map.entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def mapToHashSMap[K, W](map: Map[K, W]): HashSMap[K, W] = {\n    var r = HashSMap.emptyInit[K, W](map.size)\n    for (kv <- map.entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def bagToHashBag[T](bag: Bag[T]): HashBag[T] = {\n    return HashBag(mapToHashMap(bag.map))\n  }\n\n}\n
  #633 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.conversions\n\nimport org.sireum._\nimport org.sireum.Z8._\nimport org.sireum.Z16._\nimport org.sireum.Z32._\nimport org.sireum.Z64._\n\n@ext object B {\n\n  @pure def toB(b: B): B = Contract.Only(Ensures(Res == b))\n\n  @pure def toZ(b: B): Z = Contract.Only(Ensures(Res == (if (b) 1 else 0)))\n\n  @pure def toZ8(b: B): Z8 = Contract.Only(Ensures(Res == (if (b) z8\"1\" else z8\"0\")))\n\n  @pure def toZ16(b: B): Z16 = Contract.Only(Ensures(Res == (if (b) z16\"1\" else z16\"0\")))\n\n  @pure def toZ32(b: B): Z32 = Contract.Only(Ensures(Res == (if (b) z32\"1\" else z32\"0\")))\n\n  @pure def toZ64(b: B): Z64 = Contract.Only(Ensures(Res == (if (b) z64\"1\" else z64\"0\")))\n\n  @pure def toN(b: B): N =\n    $ // l\"\"\" ensures result ≡ (if (b) n\"1\" else n\"0\") \"\"\"\n\n  @pure def toN8(b: B): N8 =\n    $ // l\"\"\" ensures result ≡ (if (b) n8\"1\" else n8\"0\") \"\"\"\n\n  @pure def toN16(b: B): N16 =\n    $ // l\"\"\" ensures result ≡ (if (b) n16\"1\" else n16\"0\") \"\"\"\n\n  @pure def toN32(b: B): N32 =\n    $ // l\"\"\" ensures result ≡ (if (b) n32\"1\" else n32\"0\") \"\"\"\n\n  @pure def toN64(b: B): N64 =\n    $ // l\"\"\" ensures result ≡ (if (b) n64\"1\" else n64\"0\") \"\"\"\n\n  @pure def toS8(b: B): S8 =\n    $ // l\"\"\" ensures result ≡ (if (b) s8\"1\" else s8\"0\") \"\"\"\n\n  @pure def toS16(b: B): S16 =\n    $ // l\"\"\" ensures result ≡ (if (b) s16\"1\" else s16\"0\") \"\"\"\n\n  @pure def toS32(b: B): S32 =\n    $ // l\"\"\" ensures result ≡ (if (b) s32\"1\" else s32\"0\") \"\"\"\n\n  @pure def toS64(b: B): S64 =\n    $ // l\"\"\" ensures result ≡ (if (b) s64\"1\" else s64\"0\") \"\"\"\n\n  @pure def toU8(b: B): U8 =\n    $ // l\"\"\" ensures result ≡ (if (b) u8\"1\" else u8\"0\") \"\"\"\n\n  @pure def toU16(b: B): U16 =\n    $ // l\"\"\" ensures result ≡ (if (b) u16\"1\" else u16\"0\") \"\"\"\n\n  @pure def toU32(b: B): U32 =\n    $ // l\"\"\" ensures result ≡ (if (b) u32\"1\" else u32\"0\") \"\"\"\n\n  @pure def toU64(b: B): U64 =\n    $ // l\"\"\" ensures result ≡ (if (b) u64\"1\" else u64\"0\") \"\"\"\n\n  @pure def toF32(b: B): F32 =\n    $ // l\"\"\" ensures result ≡ (if (b) f32\"1.0\" else f32\"0.0\") \"\"\"\n\n  @pure def toF64(b: B): F64 =\n    $ // l\"\"\" ensures result ≡ (if (b) f64\"1.0\" else f64\"0.0\") \"\"\"\n\n  @pure def toR(b: B): R =\n    $ // l\"\"\" ensures result ≡ (if (b) r\"1.0\" else r\"0.0\") \"\"\"\n}\n\n@ext object C {\n  @pure def toU32(c: C): U32 = $\n  @pure def toCodePoints(c: C): ISZ[C] = $\n}\n\n@ext object Z {\n\n  @pure def isInRangeSigned8(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-128 ≤ n ∧ n ≤ 127) \"\"\"\n\n  @pure def isInRangeSigned16(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-32768 ≤ n ∧ n ≤ 32767) \"\"\"\n\n  @pure def isInRangeSigned32(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-2147483648 ≤ n ∧ n ≤ 2147483647) \"\"\"\n\n  @pure def isInRangeSigned64(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\") \"\"\"\n\n  @pure def isInRangeUnsigned8(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ 255) \"\"\"\n\n  @pure def isInRangeUnsigned16(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ 65535) \"\"\"\n\n  @pure def isInRangeUnsigned32(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ z\"4294967295\") \"\"\"\n\n  @pure def isInRangeUnsigned64(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ z\"18446744073709551615\") \"\"\"\n\n  @pure def toB(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ 0) \"\"\"\n\n  @pure def toZ(n: Z): Z =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ8(n: Z): Z8 =\n    $ // l\"\"\" requires -128 ≤ n ∧ n ≤ 127\n      //      ensures  Z8.toZ(result) ≡ n \"\"\"\n\n  @pure def toZ16(n: Z): Z16 =\n    $ // l\"\"\" requires -32768 ≤ n ∧ n ≤ 32767\n      //      ensures  Z16.toZ(result) ≡ n    \"\"\"\n\n  @pure def toZ32(n: Z): Z32 =\n    $ // l\"\"\" requires -2147483648 ≤ n ∧ n ≤ 2147483647\n      //      ensures  Z32.toZ(result) ≡ n              \"\"\"\n\n  @pure def toZ64(n: Z): Z64 =\n    $ // l\"\"\" requires z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\"\n      //      ensures  Z64.toZ(result) ≡ n                                      \"\"\"\n\n  @pure def toN(n: Z): N =\n    $ // l\"\"\" requires n ≥ 0\n      //      ensures  N.toZ(result) ≡ n \"\"\"\n\n  @pure def toN8(n: Z): N8 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 255\n      //      ensures  N8.toZ(result) ≡ n \"\"\"\n\n  @pure def toN16(n: Z): N16 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 65535\n      //      ensures  N16.toZ(result) ≡ n \"\"\"\n\n  @pure def toN32(n: Z): N32 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"4294967295\"\n      //      ensures  N32.toZ(result) ≡ n      \"\"\"\n\n  @pure def toN64(n: Z): N64 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"18446744073709551615\"\n      //      ensures  N64.toZ(result) ≡ n                 \"\"\"\n\n  @pure def toS8(n: Z): S8 =\n    $ // l\"\"\" requires -128 ≤ n ∧ n ≤ 127\n      //      ensures  S8.toZ(result) ≡ n \"\"\"\n\n  @pure def toS16(n: Z): S16 =\n    $ // l\"\"\" requires -32768 ≤ n ∧ n ≤ 32767\n      //      ensures  S16.toZ(result) ≡ n   \"\"\"\n\n  @pure def toS32(n: Z): S32 =\n    $ // l\"\"\" requires -2147483648 ≤ n ∧ n ≤ 2147483647\n      //      ensures  S32.toZ(result) ≡ n              \"\"\"\n\n  @pure def toS64(n: Z): S64 =\n    $ // l\"\"\" requires z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\"\n      //      ensures  S64.toZ(result) ≡ n                                      \"\"\"\n\n  @pure def toU8(n: Z): U8 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 255\n      //      ensures  U8.toZ(result) ≡ n \"\"\"\n\n  @pure def toU16(n: Z): U16 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 65535\n      //      ensures  U16.toZ(result) ≡ n \"\"\"\n\n  @pure def toU32(n: Z): U32 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"4294967295\"\n      //      ensures  U32.toZ(result) ≡ n       \"\"\"\n\n  @pure def toU64(n: Z): U64 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"18446744073709551615\"\n      //      ensures  U64.toZ(result) ≡ n                 \"\"\"\n\n  /* @first */\n  @pure def toR(n: Z): R = $\n\n  @pure def toBinary(n: Z): ISZ[U8] = $\n\n  @pure def fromBinary(bin: ISZ[U8]): Z = $\n}\n\n@ext object Z8 {\n\n  @pure def toB(n: Z8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z8\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z8): Z = $\n\n  @pure def toZ8(n: Z8): Z8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ16(n: Z8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: Z8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: Z8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z8): N =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z8): N8 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN16(n: Z8): N16 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: Z8): N32 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z8): N64 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z8): S8 =\n    $ // l\"\"\" ensures S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: Z8): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: Z8): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z8): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z8): U8 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU16(n: Z8): U16 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU32(n: Z8): U32 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z8): U64 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z8): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z16 {\n\n  @pure def toB(n: Z16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z16\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z16): Z = $\n\n  @pure def toZ8(n: Z16): Z8 =\n    $ // l\"\"\" requires z16\"-128\" ≤ n ∧ n ≤ z16\"127\"\n      //      ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z16): Z16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ32(n: Z16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: Z16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z16): N =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z16): N8 =\n    $ // l\"\"\" requires z16\"0\" ≤ n ∧ n ≤ z16\"255\"\n      //      ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z16): N16 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: Z16): N32 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z16): N64 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z16): S8 =\n    $ // l\"\"\" requires z16\"-128\" ≤ n ∧ n ≤ z16\"127\"\n      //      ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z16): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: Z16): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z16): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z16): U8 =\n    $ // l\"\"\" requires z16\"0\" ≤ n ∧ n ≤ z16\"255\"\n      //      ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z16): U16 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU32(n: Z16): U32 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z16): U64 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U64.toNZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z16): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z32 {\n\n  @pure def toB(n: Z32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z32\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z32): Z = $\n\n  @pure def toZ8(n: Z32): Z8 =\n    $ // l\"\"\" requires z32\"-128\" ≤ n ∧ n ≤ z32\"127\"\n      //      ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z32): Z16 =\n    $ // l\"\"\" requires z32\"-32768\" ≤ n ∧ n ≤ z32\"32767\"\n      //      ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: Z32): Z32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ64(n: Z32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z32): N =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z32): N8 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"255\"\n      //      ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z32): N16 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"65535\"\n      //      ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: Z32): N32 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z32): N64 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z32): S8 =\n    $ // l\"\"\" requires z32\"-128\" ≤ n ∧ n ≤ z32\"127\"\n      //      ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z32): S16 =\n    $ // l\"\"\" requires z32\"-32768\" ≤ n ∧ n ≤ z32\"32767\"\n      //      ensures  S16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toS32(n: Z32): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z32): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z32): U8 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"255\"\n      //      ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z32): U16 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"65535\"\n      //      ensures  U16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toU32(n: Z32): U32 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z32): U64 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n         // ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z32): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z64 {\n\n  @pure def toB(n: Z64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z64\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z64): Z = $\n\n  @pure def toZ8(n: Z64): Z8 =\n    $ // l\"\"\" requires z64\"-128\" ≤ n ∧ n ≤ z64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z64): Z16 =\n    $ // l\"\"\" requires z64\"-32768\" ≤ n ∧ n ≤ z64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: Z64): Z32 =\n    $ // l\"\"\" requires z64\"-2147483648\" ≤ n ∧ n ≤ z64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toZ64(n: Z64): Z64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN(n: Z64): N =\n    $ // l\"\"\" requires n ≥ z64\"0\"\n         // ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z64): N8 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z64): N16 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: Z64): N32 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"4294967295\"\n         // ensures  N32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toN64(n: Z64): N64 =\n    $ // l\"\"\" ensures N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z64): S8 =\n    $ // l\"\"\" requires z64\"-128\" ≤ n ∧ n ≤ z64\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z64): S16 =\n    $ // l\"\"\" requires z64\"-32768\" ≤ n ∧ n ≤ z64\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toS32(n: Z64): S32 =\n    $ // l\"\"\" requires z64\"-2147483648\" ≤ n ∧ n ≤ z64\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toS64(n: Z64): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z64): U8 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"255\"\n         // ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z64): U16 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"65535\"\n         // ensures  U16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toU32(n: Z64): U32 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"4294967295\"\n         // ensures  U32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toU64(n: Z64): U64 =\n    $ // l\"\"\" requires z64\"0\" ≤ n\n         // ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z64): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object N {\n\n  @pure def toB(n: N): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N): Z = $\n\n  @pure def toZ8(n: N): Z8 =\n    $ // l\"\"\" requires n ≤ n\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N): Z16 =\n    $ // l\"\"\" requires n ≤ n\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N): Z32 =\n    $ // l\"\"\" requires n ≤ n\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N): Z64 =\n    $ // l\"\"\" requires n ≤ n\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN(n: N): N =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN8(n: N): N8 =\n    $ // l\"\"\" requires n ≤ n\"255\"\n         // ensures  N8.toN(result) ≡ n \"\"\"\n\n  @pure def toN16(n: N): N16 =\n    $ // l\"\"\" requires n ≤ n\"65535\"\n         // ensures  N16.toN(result) ≡ n \"\"\"\n\n  @pure def toN32(n: N): N32 =\n    $ // l\"\"\" requires n ≤ n\"4294967295\"\n         // ensures  N32.toN(result) ≡ n \"\"\"\n\n  @pure def toN64(n: N): N64 =\n    $ // l\"\"\" requires n ≤ n\"18446744073709551615\"\n         // ensures  N64.toN(result) ≡ n         \"\"\"\n\n  @pure def toS8(n: N): S8 =\n    $ // l\"\"\" requires n ≤ n\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N): S16 =\n    $ // l\"\"\" requires n ≤ n\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N): S32 =\n    $ // l\"\"\" requires n ≤ n\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N): S64 =\n    $ // l\"\"\" requires n ≤ n\"9223372036854775807\"\n         // ensures  S64.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU8(n: N): U8 =\n    $ // l\"\"\" requires n ≤ n\"255\"\n         // ensures  U8.toN(result) ≡ n \"\"\"\n\n  @pure def toU16(n: N): U16 =\n    $ // l\"\"\" requires n ≤ n\"65535\"\n         // ensures  U16.toN(result) ≡ n \"\"\"\n\n  @pure def toU32(n: N): U32 =\n    $ // l\"\"\" requires n ≤ n\"4294967295\"\n         // ensures  U32.toN(result) ≡ n \"\"\"\n\n  @pure def toU64(n: N): U64 =\n    $ // l\"\"\" requires n ≤ n\"18446744073709551615\"\n         // ensures  U64.toN(result) ≡ n         \"\"\"\n\n  /* @first */\n  @pure def toR(n: N): R = $\n}\n\n@ext object N8 {\n\n  @pure def toB(n: N8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n8\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N8): Z = $\n\n  @pure def toZ8(n: N8): Z8 =\n    $ // l\"\"\" requires n ≤ n8\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N8): N = $\n\n  @pure def toN8(n: N8): N8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN16(n: N8): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N8): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N8): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N8): S8 =\n    $ // l\"\"\" requires n ≤ n8\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N8): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N8): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N8): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N8): U8 =\n    $ // l\"\"\" ensures U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N8): U16 =\n    $ // l\"\"\" ensures U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N8): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N8): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N8): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N16 {\n\n  @pure def toB(n: N16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n16\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N16): Z = $\n\n  @pure def toZ8(n: N16): Z8 =\n    $ // l\"\"\" requires n ≤ n16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N16): Z16 =\n    $ // l\"\"\" requires n ≤ n16\"32767\"\n
  #634 = String             #633          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.conversions\n\nimport org.sireum._\nimport org.sireum.Z8._\nimport org.sireum.Z16._\nimport org.sireum.Z32._\nimport org.sireum.Z64._\n\n@ext object B {\n\n  @pure def toB(b: B): B = Contract.Only(Ensures(Res == b))\n\n  @pure def toZ(b: B): Z = Contract.Only(Ensures(Res == (if (b) 1 else 0)))\n\n  @pure def toZ8(b: B): Z8 = Contract.Only(Ensures(Res == (if (b) z8\"1\" else z8\"0\")))\n\n  @pure def toZ16(b: B): Z16 = Contract.Only(Ensures(Res == (if (b) z16\"1\" else z16\"0\")))\n\n  @pure def toZ32(b: B): Z32 = Contract.Only(Ensures(Res == (if (b) z32\"1\" else z32\"0\")))\n\n  @pure def toZ64(b: B): Z64 = Contract.Only(Ensures(Res == (if (b) z64\"1\" else z64\"0\")))\n\n  @pure def toN(b: B): N =\n    $ // l\"\"\" ensures result ≡ (if (b) n\"1\" else n\"0\") \"\"\"\n\n  @pure def toN8(b: B): N8 =\n    $ // l\"\"\" ensures result ≡ (if (b) n8\"1\" else n8\"0\") \"\"\"\n\n  @pure def toN16(b: B): N16 =\n    $ // l\"\"\" ensures result ≡ (if (b) n16\"1\" else n16\"0\") \"\"\"\n\n  @pure def toN32(b: B): N32 =\n    $ // l\"\"\" ensures result ≡ (if (b) n32\"1\" else n32\"0\") \"\"\"\n\n  @pure def toN64(b: B): N64 =\n    $ // l\"\"\" ensures result ≡ (if (b) n64\"1\" else n64\"0\") \"\"\"\n\n  @pure def toS8(b: B): S8 =\n    $ // l\"\"\" ensures result ≡ (if (b) s8\"1\" else s8\"0\") \"\"\"\n\n  @pure def toS16(b: B): S16 =\n    $ // l\"\"\" ensures result ≡ (if (b) s16\"1\" else s16\"0\") \"\"\"\n\n  @pure def toS32(b: B): S32 =\n    $ // l\"\"\" ensures result ≡ (if (b) s32\"1\" else s32\"0\") \"\"\"\n\n  @pure def toS64(b: B): S64 =\n    $ // l\"\"\" ensures result ≡ (if (b) s64\"1\" else s64\"0\") \"\"\"\n\n  @pure def toU8(b: B): U8 =\n    $ // l\"\"\" ensures result ≡ (if (b) u8\"1\" else u8\"0\") \"\"\"\n\n  @pure def toU16(b: B): U16 =\n    $ // l\"\"\" ensures result ≡ (if (b) u16\"1\" else u16\"0\") \"\"\"\n\n  @pure def toU32(b: B): U32 =\n    $ // l\"\"\" ensures result ≡ (if (b) u32\"1\" else u32\"0\") \"\"\"\n\n  @pure def toU64(b: B): U64 =\n    $ // l\"\"\" ensures result ≡ (if (b) u64\"1\" else u64\"0\") \"\"\"\n\n  @pure def toF32(b: B): F32 =\n    $ // l\"\"\" ensures result ≡ (if (b) f32\"1.0\" else f32\"0.0\") \"\"\"\n\n  @pure def toF64(b: B): F64 =\n    $ // l\"\"\" ensures result ≡ (if (b) f64\"1.0\" else f64\"0.0\") \"\"\"\n\n  @pure def toR(b: B): R =\n    $ // l\"\"\" ensures result ≡ (if (b) r\"1.0\" else r\"0.0\") \"\"\"\n}\n\n@ext object C {\n  @pure def toU32(c: C): U32 = $\n  @pure def toCodePoints(c: C): ISZ[C] = $\n}\n\n@ext object Z {\n\n  @pure def isInRangeSigned8(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-128 ≤ n ∧ n ≤ 127) \"\"\"\n\n  @pure def isInRangeSigned16(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-32768 ≤ n ∧ n ≤ 32767) \"\"\"\n\n  @pure def isInRangeSigned32(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-2147483648 ≤ n ∧ n ≤ 2147483647) \"\"\"\n\n  @pure def isInRangeSigned64(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\") \"\"\"\n\n  @pure def isInRangeUnsigned8(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ 255) \"\"\"\n\n  @pure def isInRangeUnsigned16(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ 65535) \"\"\"\n\n  @pure def isInRangeUnsigned32(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ z\"4294967295\") \"\"\"\n\n  @pure def isInRangeUnsigned64(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ z\"18446744073709551615\") \"\"\"\n\n  @pure def toB(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ 0) \"\"\"\n\n  @pure def toZ(n: Z): Z =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ8(n: Z): Z8 =\n    $ // l\"\"\" requires -128 ≤ n ∧ n ≤ 127\n      //      ensures  Z8.toZ(result) ≡ n \"\"\"\n\n  @pure def toZ16(n: Z): Z16 =\n    $ // l\"\"\" requires -32768 ≤ n ∧ n ≤ 32767\n      //      ensures  Z16.toZ(result) ≡ n    \"\"\"\n\n  @pure def toZ32(n: Z): Z32 =\n    $ // l\"\"\" requires -2147483648 ≤ n ∧ n ≤ 2147483647\n      //      ensures  Z32.toZ(result) ≡ n              \"\"\"\n\n  @pure def toZ64(n: Z): Z64 =\n    $ // l\"\"\" requires z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\"\n      //      ensures  Z64.toZ(result) ≡ n                                      \"\"\"\n\n  @pure def toN(n: Z): N =\n    $ // l\"\"\" requires n ≥ 0\n      //      ensures  N.toZ(result) ≡ n \"\"\"\n\n  @pure def toN8(n: Z): N8 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 255\n      //      ensures  N8.toZ(result) ≡ n \"\"\"\n\n  @pure def toN16(n: Z): N16 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 65535\n      //      ensures  N16.toZ(result) ≡ n \"\"\"\n\n  @pure def toN32(n: Z): N32 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"4294967295\"\n      //      ensures  N32.toZ(result) ≡ n      \"\"\"\n\n  @pure def toN64(n: Z): N64 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"18446744073709551615\"\n      //      ensures  N64.toZ(result) ≡ n                 \"\"\"\n\n  @pure def toS8(n: Z): S8 =\n    $ // l\"\"\" requires -128 ≤ n ∧ n ≤ 127\n      //      ensures  S8.toZ(result) ≡ n \"\"\"\n\n  @pure def toS16(n: Z): S16 =\n    $ // l\"\"\" requires -32768 ≤ n ∧ n ≤ 32767\n      //      ensures  S16.toZ(result) ≡ n   \"\"\"\n\n  @pure def toS32(n: Z): S32 =\n    $ // l\"\"\" requires -2147483648 ≤ n ∧ n ≤ 2147483647\n      //      ensures  S32.toZ(result) ≡ n              \"\"\"\n\n  @pure def toS64(n: Z): S64 =\n    $ // l\"\"\" requires z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\"\n      //      ensures  S64.toZ(result) ≡ n                                      \"\"\"\n\n  @pure def toU8(n: Z): U8 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 255\n      //      ensures  U8.toZ(result) ≡ n \"\"\"\n\n  @pure def toU16(n: Z): U16 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 65535\n      //      ensures  U16.toZ(result) ≡ n \"\"\"\n\n  @pure def toU32(n: Z): U32 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"4294967295\"\n      //      ensures  U32.toZ(result) ≡ n       \"\"\"\n\n  @pure def toU64(n: Z): U64 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"18446744073709551615\"\n      //      ensures  U64.toZ(result) ≡ n                 \"\"\"\n\n  /* @first */\n  @pure def toR(n: Z): R = $\n\n  @pure def toBinary(n: Z): ISZ[U8] = $\n\n  @pure def fromBinary(bin: ISZ[U8]): Z = $\n}\n\n@ext object Z8 {\n\n  @pure def toB(n: Z8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z8\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z8): Z = $\n\n  @pure def toZ8(n: Z8): Z8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ16(n: Z8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: Z8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: Z8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z8): N =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z8): N8 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN16(n: Z8): N16 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: Z8): N32 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z8): N64 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z8): S8 =\n    $ // l\"\"\" ensures S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: Z8): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: Z8): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z8): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z8): U8 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU16(n: Z8): U16 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU32(n: Z8): U32 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z8): U64 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z8): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z16 {\n\n  @pure def toB(n: Z16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z16\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z16): Z = $\n\n  @pure def toZ8(n: Z16): Z8 =\n    $ // l\"\"\" requires z16\"-128\" ≤ n ∧ n ≤ z16\"127\"\n      //      ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z16): Z16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ32(n: Z16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: Z16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z16): N =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z16): N8 =\n    $ // l\"\"\" requires z16\"0\" ≤ n ∧ n ≤ z16\"255\"\n      //      ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z16): N16 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: Z16): N32 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z16): N64 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z16): S8 =\n    $ // l\"\"\" requires z16\"-128\" ≤ n ∧ n ≤ z16\"127\"\n      //      ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z16): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: Z16): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z16): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z16): U8 =\n    $ // l\"\"\" requires z16\"0\" ≤ n ∧ n ≤ z16\"255\"\n      //      ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z16): U16 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU32(n: Z16): U32 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z16): U64 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U64.toNZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z16): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z32 {\n\n  @pure def toB(n: Z32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z32\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z32): Z = $\n\n  @pure def toZ8(n: Z32): Z8 =\n    $ // l\"\"\" requires z32\"-128\" ≤ n ∧ n ≤ z32\"127\"\n      //      ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z32): Z16 =\n    $ // l\"\"\" requires z32\"-32768\" ≤ n ∧ n ≤ z32\"32767\"\n      //      ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: Z32): Z32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ64(n: Z32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z32): N =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z32): N8 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"255\"\n      //      ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z32): N16 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"65535\"\n      //      ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: Z32): N32 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z32): N64 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z32): S8 =\n    $ // l\"\"\" requires z32\"-128\" ≤ n ∧ n ≤ z32\"127\"\n      //      ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z32): S16 =\n    $ // l\"\"\" requires z32\"-32768\" ≤ n ∧ n ≤ z32\"32767\"\n      //      ensures  S16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toS32(n: Z32): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z32): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z32): U8 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"255\"\n      //      ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z32): U16 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"65535\"\n      //      ensures  U16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toU32(n: Z32): U32 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z32): U64 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n         // ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z32): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z64 {\n\n  @pure def toB(n: Z64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z64\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z64): Z = $\n\n  @pure def toZ8(n: Z64): Z8 =\n    $ // l\"\"\" requires z64\"-128\" ≤ n ∧ n ≤ z64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z64): Z16 =\n    $ // l\"\"\" requires z64\"-32768\" ≤ n ∧ n ≤ z64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: Z64): Z32 =\n    $ // l\"\"\" requires z64\"-2147483648\" ≤ n ∧ n ≤ z64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toZ64(n: Z64): Z64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN(n: Z64): N =\n    $ // l\"\"\" requires n ≥ z64\"0\"\n         // ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z64): N8 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z64): N16 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: Z64): N32 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"4294967295\"\n         // ensures  N32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toN64(n: Z64): N64 =\n    $ // l\"\"\" ensures N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z64): S8 =\n    $ // l\"\"\" requires z64\"-128\" ≤ n ∧ n ≤ z64\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z64): S16 =\n    $ // l\"\"\" requires z64\"-32768\" ≤ n ∧ n ≤ z64\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toS32(n: Z64): S32 =\n    $ // l\"\"\" requires z64\"-2147483648\" ≤ n ∧ n ≤ z64\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toS64(n: Z64): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z64): U8 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"255\"\n         // ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z64): U16 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"65535\"\n         // ensures  U16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toU32(n: Z64): U32 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"4294967295\"\n         // ensures  U32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toU64(n: Z64): U64 =\n    $ // l\"\"\" requires z64\"0\" ≤ n\n         // ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z64): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object N {\n\n  @pure def toB(n: N): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N): Z = $\n\n  @pure def toZ8(n: N): Z8 =\n    $ // l\"\"\" requires n ≤ n\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N): Z16 =\n    $ // l\"\"\" requires n ≤ n\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N): Z32 =\n    $ // l\"\"\" requires n ≤ n\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N): Z64 =\n    $ // l\"\"\" requires n ≤ n\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN(n: N): N =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN8(n: N): N8 =\n    $ // l\"\"\" requires n ≤ n\"255\"\n         // ensures  N8.toN(result) ≡ n \"\"\"\n\n  @pure def toN16(n: N): N16 =\n    $ // l\"\"\" requires n ≤ n\"65535\"\n         // ensures  N16.toN(result) ≡ n \"\"\"\n\n  @pure def toN32(n: N): N32 =\n    $ // l\"\"\" requires n ≤ n\"4294967295\"\n         // ensures  N32.toN(result) ≡ n \"\"\"\n\n  @pure def toN64(n: N): N64 =\n    $ // l\"\"\" requires n ≤ n\"18446744073709551615\"\n         // ensures  N64.toN(result) ≡ n         \"\"\"\n\n  @pure def toS8(n: N): S8 =\n    $ // l\"\"\" requires n ≤ n\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N): S16 =\n    $ // l\"\"\" requires n ≤ n\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N): S32 =\n    $ // l\"\"\" requires n ≤ n\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N): S64 =\n    $ // l\"\"\" requires n ≤ n\"9223372036854775807\"\n         // ensures  S64.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU8(n: N): U8 =\n    $ // l\"\"\" requires n ≤ n\"255\"\n         // ensures  U8.toN(result) ≡ n \"\"\"\n\n  @pure def toU16(n: N): U16 =\n    $ // l\"\"\" requires n ≤ n\"65535\"\n         // ensures  U16.toN(result) ≡ n \"\"\"\n\n  @pure def toU32(n: N): U32 =\n    $ // l\"\"\" requires n ≤ n\"4294967295\"\n         // ensures  U32.toN(result) ≡ n \"\"\"\n\n  @pure def toU64(n: N): U64 =\n    $ // l\"\"\" requires n ≤ n\"18446744073709551615\"\n         // ensures  U64.toN(result) ≡ n         \"\"\"\n\n  /* @first */\n  @pure def toR(n: N): R = $\n}\n\n@ext object N8 {\n\n  @pure def toB(n: N8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n8\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N8): Z = $\n\n  @pure def toZ8(n: N8): Z8 =\n    $ // l\"\"\" requires n ≤ n8\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N8): N = $\n\n  @pure def toN8(n: N8): N8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN16(n: N8): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N8): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N8): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N8): S8 =\n    $ // l\"\"\" requires n ≤ n8\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N8): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N8): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N8): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N8): U8 =\n    $ // l\"\"\" ensures U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N8): U16 =\n    $ // l\"\"\" ensures U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N8): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N8): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N8): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N16 {\n\n  @pure def toB(n: N16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n16\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N16): Z = $\n\n  @pure def toZ8(n: N16): Z8 =\n    $ // l\"\"\" requires n ≤ n16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N16): Z16 =\n    $ // l\"\"\" requires n ≤ n16\"32767\"\n
  #635 = Utf8                      // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N16): N = $\n\n  @pure def toN8(n: N16): N8 =\n    $ // l\"\"\" requires n ≤ n16\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N16): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N16): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N16): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N16): S8 =\n    $ // l\"\"\" requires n ≤ n16\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N16): S16 =\n    $ // l\"\"\" requires n ≤ n16\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N16): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N16): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N16): U8 =\n    $ // l\"\"\" requires n ≤ n16\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N16): U16 =\n    $ // l\"\"\" ensures U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N16): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N16): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N16): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N32 {\n\n  @pure def toB(n: N32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n32\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N32): Z = $\n\n  @pure def toZ8(n: N32): Z8 =\n    $ // l\"\"\" requires n ≤ n32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N32): Z16 =\n    $ // l\"\"\" requires n ≤ n32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N32): Z32 =\n    $ // l\"\"\" requires n ≤ n32\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N32): N = $\n\n  @pure def toN8(n: N32): N8 =\n    $ // l\"\"\" requires n ≤ n32\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N32): N16 =\n    $ // l\"\"\" requires n ≤ n32\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N32): N32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN64(n: N32): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N32): S8 =\n    $ // l\"\"\" requires n ≤ n32\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N32): S16 =\n    $ // l\"\"\" requires n ≤ n32\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N32): S32 =\n    $ // l\"\"\" requires n ≤ n32\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N32): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N32): U8 =\n    $ // l\"\"\" requires n ≤ n32\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N32): U16 =\n    $ // l\"\"\" requires n ≤ n32\"65535\"\n         // ensures  U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N32): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N32): U64 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N32): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N64 {\n\n  @pure def toB(n: N64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n64\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N64): Z = $\n\n  @pure def toZ8(n: N64): Z8 =\n    $ // l\"\"\" requires n ≤ n64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N64): Z16 =\n    $ // l\"\"\" requires n ≤ n64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N64): Z32 =\n    $ // l\"\"\" requires n ≤ n64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N64): Z64 =\n    $ // l\"\"\" requires n ≤ n64\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n)     \"\"\"\n\n  /* @first */\n  @pure def toN(n: N64): N = $\n\n  @pure def toN8(n: N64): N8 =\n    $ // l\"\"\" requires n ≤ n64\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N64): N16 =\n    $ // l\"\"\" requires n ≤ n64\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N64): N32 =\n    $ // l\"\"\" requires n ≤ n64\"4294967295\"\n         // ensures  N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N64): N64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toS8(n: N64): S8 =\n    $ // l\"\"\" requires n ≤ n64\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N64): S16 =\n    $ // l\"\"\" requires n ≤ n64\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N64): S32 =\n    $ // l\"\"\" requires n ≤ n64\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N64): S64 =\n    $ // l\"\"\" requires n ≤ n64\"9223372036854775807\"\n         // ensures  S64.toZ(result) ≡ toZ(n)     \"\"\"\n\n  @pure def toU8(n: N64): U8 =\n    $ // l\"\"\" requires n ≤ n64\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N64): U16 =\n    $ // l\"\"\" requires n ≤ n64\"65535\"\n         // ensures  U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N64): U32 =\n    $ // l\"\"\" requires n ≤ n64\"4294967295\"\n         // ensures  U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N64): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N64): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object S8 {\n\n  @pure def toB(n: S8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s8\"0\") \"\"\"\n\n  @pure def toZ(n: S8): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s8\"0\")\n//                               (if ((n & s8\"0x01\") ≠ s8\"0x01\") 0 else 0x01) +\n//                               (if ((n & s8\"0x02\") ≠ s8\"0x02\") 0 else 0x02) +\n//                               (if ((n & s8\"0x04\") ≠ s8\"0x04\") 0 else 0x04) +\n//                               (if ((n & s8\"0x08\") ≠ s8\"0x08\") 0 else 0x08) +\n//                               (if ((n & s8\"0x10\") ≠ s8\"0x10\") 0 else 0x10) +\n//                               (if ((n & s8\"0x20\") ≠ s8\"0x20\") 0 else 0x20) +\n//                               (if ((n & s8\"0x40\") ≠ s8\"0x40\") 0 else 0x40)\n//                           else\n//                             -((if ((n & s8\"0x01\") ≡ s8\"0x01\") 0 else 0x01) +\n//                               (if ((n & s8\"0x02\") ≡ s8\"0x02\") 0 else 0x02) +\n//                               (if ((n & s8\"0x04\") ≡ s8\"0x04\") 0 else 0x04) +\n//                               (if ((n & s8\"0x08\") ≡ s8\"0x08\") 0 else 0x08) +\n//                               (if ((n & s8\"0x10\") ≡ s8\"0x10\") 0 else 0x10) +\n//                               (if ((n & s8\"0x20\") ≡ s8\"0x20\") 0 else 0x20) +\n//                               (if ((n & s8\"0x40\") ≡ s8\"0x40\") 0 else 0x40) + 1)) \"\"\"\n\n  @pure def toZ8(n: S8): Z8 =\n    $ // l\"\"\" ensures Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: S8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: S8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S8): N =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  result ≡ (if ((n & s8\"0x01\") ≠ s8\"0x01\") n\"0\" else n\"0x01\") +\n//                           (if ((n & s8\"0x02\") ≠ s8\"0x02\") n\"0\" else n\"0x02\") +\n//                           (if ((n & s8\"0x04\") ≠ s8\"0x04\") n\"0\" else n\"0x04\") +\n//                           (if ((n & s8\"0x08\") ≠ s8\"0x08\") n\"0\" else n\"0x08\") +\n//                           (if ((n & s8\"0x10\") ≠ s8\"0x10\") n\"0\" else n\"0x10\") +\n//                           (if ((n & s8\"0x20\") ≠ s8\"0x20\") n\"0\" else n\"0x20\") +\n//                           (if ((n & s8\"0x40\") ≠ s8\"0x40\") n\"0\" else n\"0x40\")   \"\"\"\n\n  @pure def toN8(n: S8): N8 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN16(n: S8): N16 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: S8): N32 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S8): N64 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: S8): S8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S8): S16 = $\n\n  /* @first */\n  @pure def toS32(n: S8): S32 = $\n\n  /* @first */\n  @pure def toS64(n: S8): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S8): U8 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU8(n: S8): U8 = $\n\n  /* @first */\n  @pure def toU16(n: S8): U16 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S8): U32 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S8): U64 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n}\n\n@ext object S16 {\n\n  @pure def toB(n: S16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s16\"0\") \"\"\"\n\n  @pure def toZ(n: S16): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s16\"0\")\n//                               (if ((n & s16\"0x0001\") ≠ s16\"0x0001\") 0 else 0x0001) +\n//                               (if ((n & s16\"0x0002\") ≠ s16\"0x0002\") 0 else 0x0002) +\n//                               (if ((n & s16\"0x0004\") ≠ s16\"0x0004\") 0 else 0x0004) +\n//                               (if ((n & s16\"0x0008\") ≠ s16\"0x0008\") 0 else 0x0008) +\n//                               (if ((n & s16\"0x0010\") ≠ s16\"0x0010\") 0 else 0x0010) +\n//                               (if ((n & s16\"0x0020\") ≠ s16\"0x0020\") 0 else 0x0020) +\n//                               (if ((n & s16\"0x0040\") ≠ s16\"0x0040\") 0 else 0x0040) +\n//                               (if ((n & s16\"0x0080\") ≠ s16\"0x0080\") 0 else 0x0080) +\n//                               (if ((n & s16\"0x0100\") ≠ s16\"0x0100\") 0 else 0x0100) +\n//                               (if ((n & s16\"0x0200\") ≠ s16\"0x0200\") 0 else 0x0200) +\n//                               (if ((n & s16\"0x0400\") ≠ s16\"0x0400\") 0 else 0x0400) +\n//                               (if ((n & s16\"0x0800\") ≠ s16\"0x0800\") 0 else 0x0800) +\n//                               (if ((n & s16\"0x1000\") ≠ s16\"0x1000\") 0 else 0x1000) +\n//                               (if ((n & s16\"0x2000\") ≠ s16\"0x2000\") 0 else 0x2000) +\n//                               (if ((n & s16\"0x4000\") ≠ s16\"0x4000\") 0 else 0x4000)\n//                           else\n//                             -((if ((n & s16\"0x0001\") ≡ s16\"0x0001\") 0 else 0x0001) +\n//                               (if ((n & s16\"0x0002\") ≡ s16\"0x0002\") 0 else 0x0002) +\n//                               (if ((n & s16\"0x0004\") ≡ s16\"0x0004\") 0 else 0x0004) +\n//                               (if ((n & s16\"0x0008\") ≡ s16\"0x0008\") 0 else 0x0008) +\n//                               (if ((n & s16\"0x0010\") ≡ s16\"0x0010\") 0 else 0x0010) +\n//                               (if ((n & s16\"0x0020\") ≡ s16\"0x0020\") 0 else 0x0020) +\n//                               (if ((n & s16\"0x0040\") ≡ s16\"0x0040\") 0 else 0x0040) +\n//                               (if ((n & s16\"0x0080\") ≡ s16\"0x0080\") 0 else 0x0080) +\n//                               (if ((n & s16\"0x0100\") ≡ s16\"0x0100\") 0 else 0x0100) +\n//                               (if ((n & s16\"0x0200\") ≡ s16\"0x0200\") 0 else 0x0200) +\n//                               (if ((n & s16\"0x0400\") ≡ s16\"0x0400\") 0 else 0x0400) +\n//                               (if ((n & s16\"0x0800\") ≡ s16\"0x0800\") 0 else 0x0800) +\n//                               (if ((n & s16\"0x1000\") ≡ s16\"0x1000\") 0 else 0x1000) +\n//                               (if ((n & s16\"0x2000\") ≡ s16\"0x2000\") 0 else 0x2000) +\n//                               (if ((n & s16\"0x4000\") ≡ s16\"0x4000\") 0 else 0x4000) + 1)) \"\"\"\n\n  @pure def toZ8(n: S16): Z8 =\n    $ // l\"\"\" requires s16\"-128\" ≤ n ∧ n ≤ s16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S16): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: S16): Z32 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S16): Z64 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S16): N =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  result ≡ (if ((n & s16\"0x0001\") ≠ s16\"0x0001\") n\"0\" else n\"0x0001\") +\n//                           (if ((n & s16\"0x0002\") ≠ s16\"0x0002\") n\"0\" else n\"0x0002\") +\n//                           (if ((n & s16\"0x0004\") ≠ s16\"0x0004\") n\"0\" else n\"0x0004\") +\n//                           (if ((n & s16\"0x0008\") ≠ s16\"0x0008\") n\"0\" else n\"0x0008\") +\n//                           (if ((n & s16\"0x0010\") ≠ s16\"0x0010\") n\"0\" else n\"0x0010\") +\n//                           (if ((n & s16\"0x0020\") ≠ s16\"0x0020\") n\"0\" else n\"0x0020\") +\n//                           (if ((n & s16\"0x0040\") ≠ s16\"0x0040\") n\"0\" else n\"0x0040\") +\n//                           (if ((n & s16\"0x0080\") ≠ s16\"0x0080\") n\"0\" else n\"0x0080\") +\n//                           (if ((n & s16\"0x0100\") ≠ s16\"0x0100\") n\"0\" else n\"0x0100\") +\n//                           (if ((n & s16\"0x0200\") ≠ s16\"0x0200\") n\"0\" else n\"0x0200\") +\n//                           (if ((n & s16\"0x0400\") ≠ s16\"0x0400\") n\"0\" else n\"0x0400\") +\n//                           (if ((n & s16\"0x0800\") ≠ s16\"0x0800\") n\"0\" else n\"0x0800\") +\n//                           (if ((n & s16\"0x1000\") ≠ s16\"0x1000\") n\"0\" else n\"0x1000\") +\n//                           (if ((n & s16\"0x2000\") ≠ s16\"0x2000\") n\"0\" else n\"0x2000\") +\n//                           (if ((n & s16\"0x4000\") ≠ s16\"0x4000\") n\"0\" else n\"0x4000\")   \"\"\"\n\n  @pure def toN8(n: S16): N8 =\n    $ // l\"\"\" requires s16\"0\" ≤ n ∧ n ≤ s16\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S16): N16 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: S16): N32 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S16): N64 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S16): S8 =\n    $ // l\"\"\" requires s16\"-128\" ≤ n ∧ n ≤ s16\"127\" \"\"\"\n\n  @pure def toS16(n: S16): S16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS32(n: S16): S32 = $\n\n  /* @first */\n  @pure def toS64(n: S16): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S16): U8 =\n    $ // l\"\"\" requires s16\"0\" ≤ n ∧ n ≤ s16\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S16): U16 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU16(n: S16): U16 = $\n\n  /* @first */\n  @pure def toU32(n: S16): U32 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S16): U64 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n}\n\n@ext object S32 {\n\n  @pure def toB(n: S32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s32\"0\") \"\"\"\n\n  @pure def toZ(n: S32): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s32\"0\")\n//                               (if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                               (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                               (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                               (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                               (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                               (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                               (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                               (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                               (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                               (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                               (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                               (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                               (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                               (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                               (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                               (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                               (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                               (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//                               (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                               (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                               (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                               (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                               (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                               (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                               (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                               (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                               (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                               (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                               (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                               (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                               (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000)\n//                           else\n//                             -((if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                               (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                               (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                               (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                               (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                               (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                               (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                               (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                               (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                               (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                               (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                               (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                               (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                               (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                               (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                               (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                               (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                               (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//
  #636 = String             #635          //        // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N16): N = $\n\n  @pure def toN8(n: N16): N8 =\n    $ // l\"\"\" requires n ≤ n16\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N16): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N16): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N16): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N16): S8 =\n    $ // l\"\"\" requires n ≤ n16\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N16): S16 =\n    $ // l\"\"\" requires n ≤ n16\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N16): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N16): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N16): U8 =\n    $ // l\"\"\" requires n ≤ n16\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N16): U16 =\n    $ // l\"\"\" ensures U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N16): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N16): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N16): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N32 {\n\n  @pure def toB(n: N32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n32\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N32): Z = $\n\n  @pure def toZ8(n: N32): Z8 =\n    $ // l\"\"\" requires n ≤ n32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N32): Z16 =\n    $ // l\"\"\" requires n ≤ n32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N32): Z32 =\n    $ // l\"\"\" requires n ≤ n32\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N32): N = $\n\n  @pure def toN8(n: N32): N8 =\n    $ // l\"\"\" requires n ≤ n32\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N32): N16 =\n    $ // l\"\"\" requires n ≤ n32\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N32): N32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN64(n: N32): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N32): S8 =\n    $ // l\"\"\" requires n ≤ n32\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N32): S16 =\n    $ // l\"\"\" requires n ≤ n32\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N32): S32 =\n    $ // l\"\"\" requires n ≤ n32\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N32): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N32): U8 =\n    $ // l\"\"\" requires n ≤ n32\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N32): U16 =\n    $ // l\"\"\" requires n ≤ n32\"65535\"\n         // ensures  U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N32): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N32): U64 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N32): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N64 {\n\n  @pure def toB(n: N64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n64\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N64): Z = $\n\n  @pure def toZ8(n: N64): Z8 =\n    $ // l\"\"\" requires n ≤ n64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N64): Z16 =\n    $ // l\"\"\" requires n ≤ n64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N64): Z32 =\n    $ // l\"\"\" requires n ≤ n64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N64): Z64 =\n    $ // l\"\"\" requires n ≤ n64\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n)     \"\"\"\n\n  /* @first */\n  @pure def toN(n: N64): N = $\n\n  @pure def toN8(n: N64): N8 =\n    $ // l\"\"\" requires n ≤ n64\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N64): N16 =\n    $ // l\"\"\" requires n ≤ n64\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N64): N32 =\n    $ // l\"\"\" requires n ≤ n64\"4294967295\"\n         // ensures  N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N64): N64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toS8(n: N64): S8 =\n    $ // l\"\"\" requires n ≤ n64\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N64): S16 =\n    $ // l\"\"\" requires n ≤ n64\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N64): S32 =\n    $ // l\"\"\" requires n ≤ n64\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N64): S64 =\n    $ // l\"\"\" requires n ≤ n64\"9223372036854775807\"\n         // ensures  S64.toZ(result) ≡ toZ(n)     \"\"\"\n\n  @pure def toU8(n: N64): U8 =\n    $ // l\"\"\" requires n ≤ n64\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N64): U16 =\n    $ // l\"\"\" requires n ≤ n64\"65535\"\n         // ensures  U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N64): U32 =\n    $ // l\"\"\" requires n ≤ n64\"4294967295\"\n         // ensures  U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N64): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N64): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object S8 {\n\n  @pure def toB(n: S8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s8\"0\") \"\"\"\n\n  @pure def toZ(n: S8): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s8\"0\")\n//                               (if ((n & s8\"0x01\") ≠ s8\"0x01\") 0 else 0x01) +\n//                               (if ((n & s8\"0x02\") ≠ s8\"0x02\") 0 else 0x02) +\n//                               (if ((n & s8\"0x04\") ≠ s8\"0x04\") 0 else 0x04) +\n//                               (if ((n & s8\"0x08\") ≠ s8\"0x08\") 0 else 0x08) +\n//                               (if ((n & s8\"0x10\") ≠ s8\"0x10\") 0 else 0x10) +\n//                               (if ((n & s8\"0x20\") ≠ s8\"0x20\") 0 else 0x20) +\n//                               (if ((n & s8\"0x40\") ≠ s8\"0x40\") 0 else 0x40)\n//                           else\n//                             -((if ((n & s8\"0x01\") ≡ s8\"0x01\") 0 else 0x01) +\n//                               (if ((n & s8\"0x02\") ≡ s8\"0x02\") 0 else 0x02) +\n//                               (if ((n & s8\"0x04\") ≡ s8\"0x04\") 0 else 0x04) +\n//                               (if ((n & s8\"0x08\") ≡ s8\"0x08\") 0 else 0x08) +\n//                               (if ((n & s8\"0x10\") ≡ s8\"0x10\") 0 else 0x10) +\n//                               (if ((n & s8\"0x20\") ≡ s8\"0x20\") 0 else 0x20) +\n//                               (if ((n & s8\"0x40\") ≡ s8\"0x40\") 0 else 0x40) + 1)) \"\"\"\n\n  @pure def toZ8(n: S8): Z8 =\n    $ // l\"\"\" ensures Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: S8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: S8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S8): N =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  result ≡ (if ((n & s8\"0x01\") ≠ s8\"0x01\") n\"0\" else n\"0x01\") +\n//                           (if ((n & s8\"0x02\") ≠ s8\"0x02\") n\"0\" else n\"0x02\") +\n//                           (if ((n & s8\"0x04\") ≠ s8\"0x04\") n\"0\" else n\"0x04\") +\n//                           (if ((n & s8\"0x08\") ≠ s8\"0x08\") n\"0\" else n\"0x08\") +\n//                           (if ((n & s8\"0x10\") ≠ s8\"0x10\") n\"0\" else n\"0x10\") +\n//                           (if ((n & s8\"0x20\") ≠ s8\"0x20\") n\"0\" else n\"0x20\") +\n//                           (if ((n & s8\"0x40\") ≠ s8\"0x40\") n\"0\" else n\"0x40\")   \"\"\"\n\n  @pure def toN8(n: S8): N8 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN16(n: S8): N16 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: S8): N32 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S8): N64 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: S8): S8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S8): S16 = $\n\n  /* @first */\n  @pure def toS32(n: S8): S32 = $\n\n  /* @first */\n  @pure def toS64(n: S8): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S8): U8 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU8(n: S8): U8 = $\n\n  /* @first */\n  @pure def toU16(n: S8): U16 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S8): U32 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S8): U64 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n}\n\n@ext object S16 {\n\n  @pure def toB(n: S16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s16\"0\") \"\"\"\n\n  @pure def toZ(n: S16): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s16\"0\")\n//                               (if ((n & s16\"0x0001\") ≠ s16\"0x0001\") 0 else 0x0001) +\n//                               (if ((n & s16\"0x0002\") ≠ s16\"0x0002\") 0 else 0x0002) +\n//                               (if ((n & s16\"0x0004\") ≠ s16\"0x0004\") 0 else 0x0004) +\n//                               (if ((n & s16\"0x0008\") ≠ s16\"0x0008\") 0 else 0x0008) +\n//                               (if ((n & s16\"0x0010\") ≠ s16\"0x0010\") 0 else 0x0010) +\n//                               (if ((n & s16\"0x0020\") ≠ s16\"0x0020\") 0 else 0x0020) +\n//                               (if ((n & s16\"0x0040\") ≠ s16\"0x0040\") 0 else 0x0040) +\n//                               (if ((n & s16\"0x0080\") ≠ s16\"0x0080\") 0 else 0x0080) +\n//                               (if ((n & s16\"0x0100\") ≠ s16\"0x0100\") 0 else 0x0100) +\n//                               (if ((n & s16\"0x0200\") ≠ s16\"0x0200\") 0 else 0x0200) +\n//                               (if ((n & s16\"0x0400\") ≠ s16\"0x0400\") 0 else 0x0400) +\n//                               (if ((n & s16\"0x0800\") ≠ s16\"0x0800\") 0 else 0x0800) +\n//                               (if ((n & s16\"0x1000\") ≠ s16\"0x1000\") 0 else 0x1000) +\n//                               (if ((n & s16\"0x2000\") ≠ s16\"0x2000\") 0 else 0x2000) +\n//                               (if ((n & s16\"0x4000\") ≠ s16\"0x4000\") 0 else 0x4000)\n//                           else\n//                             -((if ((n & s16\"0x0001\") ≡ s16\"0x0001\") 0 else 0x0001) +\n//                               (if ((n & s16\"0x0002\") ≡ s16\"0x0002\") 0 else 0x0002) +\n//                               (if ((n & s16\"0x0004\") ≡ s16\"0x0004\") 0 else 0x0004) +\n//                               (if ((n & s16\"0x0008\") ≡ s16\"0x0008\") 0 else 0x0008) +\n//                               (if ((n & s16\"0x0010\") ≡ s16\"0x0010\") 0 else 0x0010) +\n//                               (if ((n & s16\"0x0020\") ≡ s16\"0x0020\") 0 else 0x0020) +\n//                               (if ((n & s16\"0x0040\") ≡ s16\"0x0040\") 0 else 0x0040) +\n//                               (if ((n & s16\"0x0080\") ≡ s16\"0x0080\") 0 else 0x0080) +\n//                               (if ((n & s16\"0x0100\") ≡ s16\"0x0100\") 0 else 0x0100) +\n//                               (if ((n & s16\"0x0200\") ≡ s16\"0x0200\") 0 else 0x0200) +\n//                               (if ((n & s16\"0x0400\") ≡ s16\"0x0400\") 0 else 0x0400) +\n//                               (if ((n & s16\"0x0800\") ≡ s16\"0x0800\") 0 else 0x0800) +\n//                               (if ((n & s16\"0x1000\") ≡ s16\"0x1000\") 0 else 0x1000) +\n//                               (if ((n & s16\"0x2000\") ≡ s16\"0x2000\") 0 else 0x2000) +\n//                               (if ((n & s16\"0x4000\") ≡ s16\"0x4000\") 0 else 0x4000) + 1)) \"\"\"\n\n  @pure def toZ8(n: S16): Z8 =\n    $ // l\"\"\" requires s16\"-128\" ≤ n ∧ n ≤ s16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S16): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: S16): Z32 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S16): Z64 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S16): N =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  result ≡ (if ((n & s16\"0x0001\") ≠ s16\"0x0001\") n\"0\" else n\"0x0001\") +\n//                           (if ((n & s16\"0x0002\") ≠ s16\"0x0002\") n\"0\" else n\"0x0002\") +\n//                           (if ((n & s16\"0x0004\") ≠ s16\"0x0004\") n\"0\" else n\"0x0004\") +\n//                           (if ((n & s16\"0x0008\") ≠ s16\"0x0008\") n\"0\" else n\"0x0008\") +\n//                           (if ((n & s16\"0x0010\") ≠ s16\"0x0010\") n\"0\" else n\"0x0010\") +\n//                           (if ((n & s16\"0x0020\") ≠ s16\"0x0020\") n\"0\" else n\"0x0020\") +\n//                           (if ((n & s16\"0x0040\") ≠ s16\"0x0040\") n\"0\" else n\"0x0040\") +\n//                           (if ((n & s16\"0x0080\") ≠ s16\"0x0080\") n\"0\" else n\"0x0080\") +\n//                           (if ((n & s16\"0x0100\") ≠ s16\"0x0100\") n\"0\" else n\"0x0100\") +\n//                           (if ((n & s16\"0x0200\") ≠ s16\"0x0200\") n\"0\" else n\"0x0200\") +\n//                           (if ((n & s16\"0x0400\") ≠ s16\"0x0400\") n\"0\" else n\"0x0400\") +\n//                           (if ((n & s16\"0x0800\") ≠ s16\"0x0800\") n\"0\" else n\"0x0800\") +\n//                           (if ((n & s16\"0x1000\") ≠ s16\"0x1000\") n\"0\" else n\"0x1000\") +\n//                           (if ((n & s16\"0x2000\") ≠ s16\"0x2000\") n\"0\" else n\"0x2000\") +\n//                           (if ((n & s16\"0x4000\") ≠ s16\"0x4000\") n\"0\" else n\"0x4000\")   \"\"\"\n\n  @pure def toN8(n: S16): N8 =\n    $ // l\"\"\" requires s16\"0\" ≤ n ∧ n ≤ s16\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S16): N16 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: S16): N32 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S16): N64 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S16): S8 =\n    $ // l\"\"\" requires s16\"-128\" ≤ n ∧ n ≤ s16\"127\" \"\"\"\n\n  @pure def toS16(n: S16): S16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS32(n: S16): S32 = $\n\n  /* @first */\n  @pure def toS64(n: S16): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S16): U8 =\n    $ // l\"\"\" requires s16\"0\" ≤ n ∧ n ≤ s16\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S16): U16 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU16(n: S16): U16 = $\n\n  /* @first */\n  @pure def toU32(n: S16): U32 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S16): U64 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n}\n\n@ext object S32 {\n\n  @pure def toB(n: S32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s32\"0\") \"\"\"\n\n  @pure def toZ(n: S32): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s32\"0\")\n//                               (if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                               (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                               (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                               (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                               (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                               (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                               (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                               (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                               (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                               (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                               (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                               (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                               (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                               (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                               (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                               (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                               (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                               (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//                               (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                               (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                               (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                               (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                               (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                               (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                               (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                               (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                               (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                               (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                               (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                               (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                               (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000)\n//                           else\n//                             -((if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                               (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                               (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                               (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                               (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                               (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                               (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                               (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                               (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                               (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                               (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                               (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                               (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                               (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                               (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                               (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                               (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                               (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//
  #637 = Utf8                        (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                               (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                               (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                               (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                               (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                               (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                               (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                               (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                               (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                               (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                               (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                               (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                               (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000) + 1)) \"\"\"\n\n  @pure def toZ8(n: S32): Z8 =\n    $ // l\"\"\" requires s32\"-128\" ≤ n ∧ n ≤ s32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S32): Z16 =\n    $ // l\"\"\" requires s32\"-32768\" ≤ n ∧ n ≤ s32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: S32): Z32 =\n    $ // l\"\"\" ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S32): Z64 =\n    $ // l\"\"\" ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S32): N =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  result ≡ (if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                           (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                           (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                           (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                           (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                           (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                           (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                           (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                           (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                           (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                           (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                           (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                           (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                           (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                           (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                           (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                           (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                           (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//                           (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                           (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                           (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                           (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                           (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                           (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                           (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                           (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                           (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                           (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                           (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                           (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                           (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000)   \"\"\"\n\n  @pure def toN8(n: S32): N8 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S32): N16 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: S32): N32 =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S32): N64 =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S32): S8 =\n    $ // l\"\"\" requires s32\"-128\" ≤ n ∧ n ≤ s32\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S32): S16 =\n    $ // l\"\"\" requires s32\"-32768\" ≤ n ∧ n ≤ s32\"32767\" \"\"\"\n\n  @pure def toS32(n: S32): S32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS64(n: S32): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S32): U8 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S32): U16 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S32): U32 =\n    $ // l\"\"\" requires n ≥ s32\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU32(n: S32): U32 = $\n\n  /* @first */\n  @pure def toU64(n: S32): U64 =\n    $ // l\"\"\" requires n ≥ s32\"0\" \"\"\"\n}\n\n@ext object S64 {\n\n  @pure def toB(n: S64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s64\"0\") \"\"\"\n\n  @pure def toZ(n: S64): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s64\"0\")\n//                               (if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                               (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                               (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                               (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                               (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                               (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                               (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                               (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                               (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                               (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                               (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                               (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                               (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                               (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                               (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                               (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                               (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                               (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                               (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                               (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                               (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                               (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                               (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                               (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                               (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                               (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                               (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                               (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                               (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                               (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                               (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                               (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                               (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                               (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                               (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                               (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                               (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                               (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                               (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                               (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                               (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                               (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                               (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                               (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                               (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                               (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                               (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                               (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                               (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                               (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                               (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                               (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                               (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                               (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                               (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                               (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                               (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                               (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                               (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                               (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                               (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                               (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                               (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)\n//                           else\n//                             -((if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                               (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                               (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                               (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                               (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                               (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                               (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                               (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                               (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                               (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                               (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                               (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                               (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                               (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                               (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                               (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                               (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                               (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                               (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                               (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                               (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                               (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                               (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                               (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                               (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                               (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                               (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                               (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                               (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                               (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                               (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                               (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                               (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                               (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                               (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                               (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                               (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                               (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                               (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                               (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                               (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                               (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                               (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                               (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                               (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                               (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                               (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x000
  #638 = String             #637          //          (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                               (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                               (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                               (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                               (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                               (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                               (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                               (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                               (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                               (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                               (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                               (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                               (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000) + 1)) \"\"\"\n\n  @pure def toZ8(n: S32): Z8 =\n    $ // l\"\"\" requires s32\"-128\" ≤ n ∧ n ≤ s32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S32): Z16 =\n    $ // l\"\"\" requires s32\"-32768\" ≤ n ∧ n ≤ s32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: S32): Z32 =\n    $ // l\"\"\" ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S32): Z64 =\n    $ // l\"\"\" ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S32): N =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  result ≡ (if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                           (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                           (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                           (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                           (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                           (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                           (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                           (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                           (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                           (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                           (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                           (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                           (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                           (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                           (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                           (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                           (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                           (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//                           (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                           (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                           (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                           (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                           (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                           (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                           (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                           (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                           (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                           (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                           (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                           (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                           (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000)   \"\"\"\n\n  @pure def toN8(n: S32): N8 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S32): N16 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: S32): N32 =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S32): N64 =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S32): S8 =\n    $ // l\"\"\" requires s32\"-128\" ≤ n ∧ n ≤ s32\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S32): S16 =\n    $ // l\"\"\" requires s32\"-32768\" ≤ n ∧ n ≤ s32\"32767\" \"\"\"\n\n  @pure def toS32(n: S32): S32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS64(n: S32): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S32): U8 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S32): U16 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S32): U32 =\n    $ // l\"\"\" requires n ≥ s32\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU32(n: S32): U32 = $\n\n  /* @first */\n  @pure def toU64(n: S32): U64 =\n    $ // l\"\"\" requires n ≥ s32\"0\" \"\"\"\n}\n\n@ext object S64 {\n\n  @pure def toB(n: S64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s64\"0\") \"\"\"\n\n  @pure def toZ(n: S64): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s64\"0\")\n//                               (if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                               (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                               (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                               (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                               (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                               (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                               (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                               (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                               (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                               (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                               (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                               (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                               (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                               (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                               (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                               (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                               (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                               (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                               (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                               (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                               (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                               (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                               (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                               (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                               (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                               (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                               (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                               (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                               (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                               (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                               (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                               (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                               (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                               (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                               (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                               (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                               (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                               (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                               (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                               (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                               (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                               (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                               (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                               (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                               (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                               (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                               (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                               (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                               (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                               (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                               (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                               (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                               (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                               (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                               (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                               (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                               (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                               (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                               (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                               (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                               (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                               (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                               (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)\n//                           else\n//                             -((if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                               (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                               (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                               (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                               (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                               (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                               (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                               (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                               (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                               (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                               (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                               (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                               (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                               (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                               (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                               (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                               (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                               (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                               (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                               (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                               (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                               (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                               (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                               (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                               (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                               (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                               (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                               (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                               (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                               (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                               (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                               (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                               (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                               (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                               (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                               (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                               (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                               (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                               (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                               (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                               (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                               (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                               (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                               (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                               (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                               (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                               (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x000
  #639 = Utf8               0400000000000l) +\n//                               (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                               (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                               (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                               (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                               (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                               (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                               (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                               (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                               (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                               (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                               (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                               (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                               (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                               (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                               (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                               (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)) + 1) \"\"\"\n\n  @pure def toZ8(n: S64): Z8 =\n    $ // l\"\"\" requires s64\"-128\" ≤ n ∧ n ≤ s64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S64): Z16 =\n    $ // l\"\"\" requires s64\"-32768\" ≤ n ∧ n ≤ s64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: S64): Z32 =\n    $ // l\"\"\" requires s64\"-2147483648\" ≤ n ∧ n ≤ s64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toZ64(n: S64): Z64 =\n    $ // l\"\"\" ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S64): N =\n    $ // l\"\"\" requires n ≥ s64\"0\"\n         // ensures  result ≡ (if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                           (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                           (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                           (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                           (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                           (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                           (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                           (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                           (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                           (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                           (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                           (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                           (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                           (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                           (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                           (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                           (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                           (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                           (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                           (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                           (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                           (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                           (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                           (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                           (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                           (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                           (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                           (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                           (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                           (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                           (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                           (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                           (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                           (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                           (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                           (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                           (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                           (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                           (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                           (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                           (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                           (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                           (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                           (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                           (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                           (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                           (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                           (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                           (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                           (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                           (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                           (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                           (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                           (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                           (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                           (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                           (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                           (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                           (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                           (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                           (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                           (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                           (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)   \"\"\"\n\n  @pure def toN8(n: S64): N8 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S64): N16 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: S64): N32 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"4294967295\"\n         // ensures  N32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toN64(n: S64): N64 =\n    $ // l\"\"\" ensures N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S64): S8 =\n    $ // l\"\"\" requires s64\"-128\" ≤ n ∧ n ≤ s64\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S64): S16 =\n    $ // l\"\"\" requires s64\"-32768\" ≤ n ∧ n ≤ s64\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: S64): S32 =\n    $ // l\"\"\" requires s64\"-2147483648\" ≤ n ∧ n ≤ s64\"2147483647\" \"\"\"\n\n  @pure def toS64(n: S64): S64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU8(n: S64): U8 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S64): U16 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S64): U32 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"4294967295\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S64): U64 =\n    $ // l\"\"\" requires n ≥ s64\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU64(n: S64): U64 = $\n}\n\n@ext object U1 {\n  @pure def toU8(n: U1): U8 = $\n  @pure def toU16(n: U1): U16 = $\n  @pure def toU32(n: U1): U32 = $\n  @pure def toU64(n: U1): U64 = $\n}\n\n@ext object U2 {\n  @pure def toU8(n: U2): U8 = $\n  @pure def toU16(n: U2): U16 = $\n  @pure def toU32(n: U2): U32 = $\n  @pure def toU64(n: U2): U64 = $\n}\n\n@ext object U3 {\n  @pure def toU8(n: U3): U8 = $\n  @pure def toU16(n: U3): U16 = $\n  @pure def toU32(n: U3): U32 = $\n  @pure def toU64(n: U3): U64 = $\n}\n\n@ext object U4 {\n  @pure def toU8(n: U4): U8 = $\n  @pure def toU16(n: U4): U16 = $\n  @pure def toU32(n: U4): U32 = $\n  @pure def toU64(n: U4): U64 = $\n}\n\n@ext object U5 {\n  @pure def toU8(n: U5): U8 = $\n  @pure def toU16(n: U5): U16 = $\n  @pure def toU32(n: U5): U32 = $\n  @pure def toU64(n: U5): U64 = $\n}\n\n@ext object U6 {\n  @pure def toU8(n: U6): U8 = $\n  @pure def toU16(n: U6): U16 = $\n  @pure def toU32(n: U6): U32 = $\n  @pure def toU64(n: U6): U64 = $\n}\n\n@ext object U7 {\n  @pure def toU8(n: U7): U8 = $\n  @pure def toU16(n: U7): U16 = $\n  @pure def toU32(n: U7): U32 = $\n  @pure def toU64(n: U7): U64 = $\n}\n\n@ext object U8 {\n\n  @pure def toB(n: U8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u8\"0\") \"\"\"\n\n  @pure def toZ(n: U8): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u8\"0x01\") ≠ u8\"0x01\") 0 else 0x01) +\n//                          (if ((n & u8\"0x02\") ≠ u8\"0x02\") 0 else 0x02) +\n//                          (if ((n & u8\"0x04\") ≠ u8\"0x04\") 0 else 0x04) +\n//                          (if ((n & u8\"0x08\") ≠ u8\"0x08\") 0 else 0x08) +\n//                          (if ((n & u8\"0x10\") ≠ u8\"0x10\") 0 else 0x10) +\n//                          (if ((n & u8\"0x20\") ≠ u8\"0x20\") 0 else 0x20) +\n//                          (if ((n & u8\"0x40\") ≠ u8\"0x40\") 0 else 0x40) +\n//                          (if ((n & u8\"0x80\") ≠ u8\"0x80\") 0 else 0x80)   \"\"\"\n\n  @pure def toZ8(n: U8): Z8 =\n    $ // l\"\"\" requires n ≤ u8\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U8): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u8\"0x01\") ≠ u8\"0x01\") n\"0\" else n\"0x01\") +\n//                          (if ((n & u8\"0x02\") ≠ u8\"0x02\") n\"0\" else n\"0x02\") +\n//                          (if ((n & u8\"0x04\") ≠ u8\"0x04\") n\"0\" else n\"0x04\") +\n//                          (if ((n & u8\"0x08\") ≠ u8\"0x08\") n\"0\" else n\"0x08\") +\n//                          (if ((n & u8\"0x10\") ≠ u8\"0x10\") n\"0\" else n\"0x10\") +\n//                          (if ((n & u8\"0x20\") ≠ u8\"0x20\") n\"0\" else n\"0x20\") +\n//                          (if ((n & u8\"0x40\") ≠ u8\"0x40\") n\"0\" else n\"0x40\") +\n//                          (if ((n & u8\"0x80\") ≠ u8\"0x80\") n\"0\" else n\"0x80\")   \"\"\"\n\n  @pure def toN8(n: U8): N8 =\n    $ // l\"\"\" requires n ≤ u8\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U8): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U8): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U8): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U8): S8 =\n    $ // l\"\"\" requires n ≤ u8\"127\" \"\"\"\n\n  /* @first */\n  @pure def toRawS8(n: U8): S8 = $\n\n  /* @first */\n  @pure def toS16(n: U8): S16 = $\n\n  /* @first */\n  @pure def toS32(n: U8): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U8): S64 = $\n\n  @pure def toU1(n: U8): U1 = $\n\n  @pure def toU2(n: U8): U2 = $\n\n  @pure def toU3(n: U8): U3 = $\n\n  @pure def toU4(n: U8): U4 = $\n\n  @pure def toU5(n: U8): U5 = $\n\n  @pure def toU6(n: U8): U6 = $\n\n  @pure def toU7(n: U8): U7 = $\n\n  @pure def toU8(n: U8): U8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U8): U16 = $\n\n  /* @first */\n  @pure def toU32(n: U8): U32 = $\n\n  /* @first */\n  @pure def toU64(n: U8): U64 = $\n}\n\n@ext object U9 {\n  @pure def toU16(n: U9): U16 = $\n  @pure def toU32(n: U9): U32 = $\n  @pure def toU64(n: U9): U64 = $\n}\n\n@ext object U10 {\n  @pure def toU16(n: U10): U16 = $\n  @pure def toU32(n: U10): U32 = $\n  @pure def toU64(n: U10): U64 = $\n}\n\n@ext object U11 {\n  @pure def toU16(n: U11): U16 = $\n  @pure def toU32(n: U11): U32 = $\n  @pure def toU64(n: U11): U64 = $\n}\n\n@ext object U12 {\n  @pure def toU16(n: U12): U16 = $\n  @pure def toU32(n: U12): U32 = $\n  @pure def toU64(n: U12): U64 = $\n}\n\n@ext object U13 {\n  @pure def toU16(n: U13): U16 = $\n  @pure def toU32(n: U13): U32 = $\n  @pure def toU64(n: U13): U64 = $\n}\n\n@ext object U14 {\n  @pure def toU16(n: U14): U16 = $\n  @pure def toU32(n: U14): U32 = $\n  @pure def toU64(n: U14): U64 = $\n}\n\n@ext object U15 {\n  @pure def toU16(n: U15): U16 = $\n  @pure def toU32(n: U15): U32 = $\n  @pure def toU64(n: U15): U64 = $\n}\n\n@ext object U16 {\n\n  @pure def toB(n: U16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u16\"0\") \"\"\"\n\n  @pure def toZ(n: U16): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u16\"0x0001\") ≠ u16\"0x0001\") 0 else 0x0001) +\n//                          (if ((n & u16\"0x0002\") ≠ u16\"0x0002\") 0 else 0x0002) +\n//                          (if ((n & u16\"0x0004\") ≠ u16\"0x0004\") 0 else 0x0004) +\n//                          (if ((n & u16\"0x0008\") ≠ u16\"0x0008\") 0 else 0x0008) +\n//                          (if ((n & u16\"0x0010\") ≠ u16\"0x0010\") 0 else 0x0010) +\n//                          (if ((n & u16\"0x0020\") ≠ u16\"0x0020\") 0 else 0x0020) +\n//                          (if ((n & u16\"0x0040\") ≠ u16\"0x0040\") 0 else 0x0040) +\n//                          (if ((n & u16\"0x0080\") ≠ u16\"0x0080\") 0 else 0x0080) +\n//                          (if ((n & u16\"0x0100\") ≠ u16\"0x0100\") 0 else 0x0100) +\n//                          (if ((n & u16\"0x0200\") ≠ u16\"0x0200\") 0 else 0x0200) +\n//                          (if ((n & u16\"0x0400\") ≠ u16\"0x0400\") 0 else 0x0400) +\n//                          (if ((n & u16\"0x0800\") ≠ u16\"0x0800\") 0 else 0x0800) +\n//                          (if ((n & u16\"0x1000\") ≠ u16\"0x1000\") 0 else 0x1000) +\n//                          (if ((n & u16\"0x2000\") ≠ u16\"0x2000\") 0 else 0x2000) +\n//                          (if ((n & u16\"0x4000\") ≠ u16\"0x4000\") 0 else 0x4000) +\n//                          (if ((n & u16\"0x8000\") ≠ u16\"0x8000\") 0 else 0x8000)   \"\"\"\n\n  @pure def toZ8(n: U16): Z8 =\n    $ // l\"\"\" requires n ≤ u16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U16): Z16 =\n    $ // l\"\"\" requires n ≤ u16\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U16): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u16\"0x0001\") ≠ u16\"0x0001\") n\"0\" else n\"0x0001\") +\n//                          (if ((n & u16\"0x0002\") ≠ u16\"0x0002\") n\"0\" else n\"0x0002\") +\n//                          (if ((n & u16\"0x0004\") ≠ u16\"0x0004\") n\"0\" else n\"0x0004\") +\n//                          (if ((n & u16\"0x0008\") ≠ u16\"0x0008\") n\"0\" else n\"0x0008\") +\n//                          (if ((n & u16\"0x0010\") ≠ u16\"0x0010\") n\"0\" else n\"0x0010\") +\n//                          (if ((n & u16\"0x0020\") ≠ u16\"0x0020\") n\"0\" else n\"0x0020\") +\n//                          (if ((n & u16\"0x0040\") ≠ u16\"0x0040\") n\"0\" else n\"0x0040\") +\n//                          (if ((n & u16\"0x0080\") ≠ u16\"0x0080\") n\"0\" else n\"0x0080\") +\n//                          (if ((n & u16\"0x0100\") ≠ u16\"0x0100\") n\"0\" else n\"0x0100\") +\n//                          (if ((n & u16\"0x0200\") ≠ u16\"0x0200\") n\"0\" else n\"0x0200\") +\n//                          (if ((n & u16\"0x0400\") ≠ u16\"0x0400\") n\"0\" else n\"0x0400\") +\n//                          (if ((n & u16\"0x0800\") ≠ u16\"0x0800\") n\"0\" else n\"0x0800\") +\n//                          (if ((n & u16\"0x1000\") ≠ u16\"0x1000\") n\"0\" else n\"0x1000\") +\n//                          (if ((n & u16\"0x2000\") ≠ u16\"0x2000\") n\"0\" else n\"0x2000\") +\n//                          (if ((n & u16\"0x4000\") ≠ u16\"0x4000\") n\"0\" else n\"0x4000\") +\n//                          (if ((n & u16\"0x8000\") ≠ u16\"0x8000\") n\"0\" else n\"0x8000\")   \"\"\"\n\n  @pure def toN8(n: U16): N8 =\n    $ // l\"\"\" requires n ≤ u16\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U16): N16 =\n    $ // l\"\"\" requires n ≤ u16\"65535\"\n         // ensures
  #640 = String             #639          // 0400000000000l) +\n//                               (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                               (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                               (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                               (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                               (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                               (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                               (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                               (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                               (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                               (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                               (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                               (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                               (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                               (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                               (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                               (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)) + 1) \"\"\"\n\n  @pure def toZ8(n: S64): Z8 =\n    $ // l\"\"\" requires s64\"-128\" ≤ n ∧ n ≤ s64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S64): Z16 =\n    $ // l\"\"\" requires s64\"-32768\" ≤ n ∧ n ≤ s64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: S64): Z32 =\n    $ // l\"\"\" requires s64\"-2147483648\" ≤ n ∧ n ≤ s64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toZ64(n: S64): Z64 =\n    $ // l\"\"\" ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S64): N =\n    $ // l\"\"\" requires n ≥ s64\"0\"\n         // ensures  result ≡ (if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                           (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                           (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                           (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                           (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                           (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                           (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                           (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                           (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                           (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                           (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                           (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                           (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                           (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                           (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                           (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                           (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                           (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                           (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                           (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                           (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                           (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                           (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                           (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                           (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                           (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                           (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                           (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                           (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                           (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                           (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                           (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                           (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                           (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                           (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                           (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                           (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                           (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                           (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                           (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                           (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                           (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                           (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                           (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                           (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                           (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                           (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                           (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                           (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                           (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                           (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                           (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                           (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                           (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                           (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                           (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                           (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                           (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                           (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                           (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                           (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                           (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                           (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)   \"\"\"\n\n  @pure def toN8(n: S64): N8 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S64): N16 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: S64): N32 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"4294967295\"\n         // ensures  N32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toN64(n: S64): N64 =\n    $ // l\"\"\" ensures N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S64): S8 =\n    $ // l\"\"\" requires s64\"-128\" ≤ n ∧ n ≤ s64\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S64): S16 =\n    $ // l\"\"\" requires s64\"-32768\" ≤ n ∧ n ≤ s64\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: S64): S32 =\n    $ // l\"\"\" requires s64\"-2147483648\" ≤ n ∧ n ≤ s64\"2147483647\" \"\"\"\n\n  @pure def toS64(n: S64): S64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU8(n: S64): U8 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S64): U16 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S64): U32 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"4294967295\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S64): U64 =\n    $ // l\"\"\" requires n ≥ s64\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU64(n: S64): U64 = $\n}\n\n@ext object U1 {\n  @pure def toU8(n: U1): U8 = $\n  @pure def toU16(n: U1): U16 = $\n  @pure def toU32(n: U1): U32 = $\n  @pure def toU64(n: U1): U64 = $\n}\n\n@ext object U2 {\n  @pure def toU8(n: U2): U8 = $\n  @pure def toU16(n: U2): U16 = $\n  @pure def toU32(n: U2): U32 = $\n  @pure def toU64(n: U2): U64 = $\n}\n\n@ext object U3 {\n  @pure def toU8(n: U3): U8 = $\n  @pure def toU16(n: U3): U16 = $\n  @pure def toU32(n: U3): U32 = $\n  @pure def toU64(n: U3): U64 = $\n}\n\n@ext object U4 {\n  @pure def toU8(n: U4): U8 = $\n  @pure def toU16(n: U4): U16 = $\n  @pure def toU32(n: U4): U32 = $\n  @pure def toU64(n: U4): U64 = $\n}\n\n@ext object U5 {\n  @pure def toU8(n: U5): U8 = $\n  @pure def toU16(n: U5): U16 = $\n  @pure def toU32(n: U5): U32 = $\n  @pure def toU64(n: U5): U64 = $\n}\n\n@ext object U6 {\n  @pure def toU8(n: U6): U8 = $\n  @pure def toU16(n: U6): U16 = $\n  @pure def toU32(n: U6): U32 = $\n  @pure def toU64(n: U6): U64 = $\n}\n\n@ext object U7 {\n  @pure def toU8(n: U7): U8 = $\n  @pure def toU16(n: U7): U16 = $\n  @pure def toU32(n: U7): U32 = $\n  @pure def toU64(n: U7): U64 = $\n}\n\n@ext object U8 {\n\n  @pure def toB(n: U8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u8\"0\") \"\"\"\n\n  @pure def toZ(n: U8): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u8\"0x01\") ≠ u8\"0x01\") 0 else 0x01) +\n//                          (if ((n & u8\"0x02\") ≠ u8\"0x02\") 0 else 0x02) +\n//                          (if ((n & u8\"0x04\") ≠ u8\"0x04\") 0 else 0x04) +\n//                          (if ((n & u8\"0x08\") ≠ u8\"0x08\") 0 else 0x08) +\n//                          (if ((n & u8\"0x10\") ≠ u8\"0x10\") 0 else 0x10) +\n//                          (if ((n & u8\"0x20\") ≠ u8\"0x20\") 0 else 0x20) +\n//                          (if ((n & u8\"0x40\") ≠ u8\"0x40\") 0 else 0x40) +\n//                          (if ((n & u8\"0x80\") ≠ u8\"0x80\") 0 else 0x80)   \"\"\"\n\n  @pure def toZ8(n: U8): Z8 =\n    $ // l\"\"\" requires n ≤ u8\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U8): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u8\"0x01\") ≠ u8\"0x01\") n\"0\" else n\"0x01\") +\n//                          (if ((n & u8\"0x02\") ≠ u8\"0x02\") n\"0\" else n\"0x02\") +\n//                          (if ((n & u8\"0x04\") ≠ u8\"0x04\") n\"0\" else n\"0x04\") +\n//                          (if ((n & u8\"0x08\") ≠ u8\"0x08\") n\"0\" else n\"0x08\") +\n//                          (if ((n & u8\"0x10\") ≠ u8\"0x10\") n\"0\" else n\"0x10\") +\n//                          (if ((n & u8\"0x20\") ≠ u8\"0x20\") n\"0\" else n\"0x20\") +\n//                          (if ((n & u8\"0x40\") ≠ u8\"0x40\") n\"0\" else n\"0x40\") +\n//                          (if ((n & u8\"0x80\") ≠ u8\"0x80\") n\"0\" else n\"0x80\")   \"\"\"\n\n  @pure def toN8(n: U8): N8 =\n    $ // l\"\"\" requires n ≤ u8\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U8): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U8): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U8): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U8): S8 =\n    $ // l\"\"\" requires n ≤ u8\"127\" \"\"\"\n\n  /* @first */\n  @pure def toRawS8(n: U8): S8 = $\n\n  /* @first */\n  @pure def toS16(n: U8): S16 = $\n\n  /* @first */\n  @pure def toS32(n: U8): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U8): S64 = $\n\n  @pure def toU1(n: U8): U1 = $\n\n  @pure def toU2(n: U8): U2 = $\n\n  @pure def toU3(n: U8): U3 = $\n\n  @pure def toU4(n: U8): U4 = $\n\n  @pure def toU5(n: U8): U5 = $\n\n  @pure def toU6(n: U8): U6 = $\n\n  @pure def toU7(n: U8): U7 = $\n\n  @pure def toU8(n: U8): U8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U8): U16 = $\n\n  /* @first */\n  @pure def toU32(n: U8): U32 = $\n\n  /* @first */\n  @pure def toU64(n: U8): U64 = $\n}\n\n@ext object U9 {\n  @pure def toU16(n: U9): U16 = $\n  @pure def toU32(n: U9): U32 = $\n  @pure def toU64(n: U9): U64 = $\n}\n\n@ext object U10 {\n  @pure def toU16(n: U10): U16 = $\n  @pure def toU32(n: U10): U32 = $\n  @pure def toU64(n: U10): U64 = $\n}\n\n@ext object U11 {\n  @pure def toU16(n: U11): U16 = $\n  @pure def toU32(n: U11): U32 = $\n  @pure def toU64(n: U11): U64 = $\n}\n\n@ext object U12 {\n  @pure def toU16(n: U12): U16 = $\n  @pure def toU32(n: U12): U32 = $\n  @pure def toU64(n: U12): U64 = $\n}\n\n@ext object U13 {\n  @pure def toU16(n: U13): U16 = $\n  @pure def toU32(n: U13): U32 = $\n  @pure def toU64(n: U13): U64 = $\n}\n\n@ext object U14 {\n  @pure def toU16(n: U14): U16 = $\n  @pure def toU32(n: U14): U32 = $\n  @pure def toU64(n: U14): U64 = $\n}\n\n@ext object U15 {\n  @pure def toU16(n: U15): U16 = $\n  @pure def toU32(n: U15): U32 = $\n  @pure def toU64(n: U15): U64 = $\n}\n\n@ext object U16 {\n\n  @pure def toB(n: U16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u16\"0\") \"\"\"\n\n  @pure def toZ(n: U16): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u16\"0x0001\") ≠ u16\"0x0001\") 0 else 0x0001) +\n//                          (if ((n & u16\"0x0002\") ≠ u16\"0x0002\") 0 else 0x0002) +\n//                          (if ((n & u16\"0x0004\") ≠ u16\"0x0004\") 0 else 0x0004) +\n//                          (if ((n & u16\"0x0008\") ≠ u16\"0x0008\") 0 else 0x0008) +\n//                          (if ((n & u16\"0x0010\") ≠ u16\"0x0010\") 0 else 0x0010) +\n//                          (if ((n & u16\"0x0020\") ≠ u16\"0x0020\") 0 else 0x0020) +\n//                          (if ((n & u16\"0x0040\") ≠ u16\"0x0040\") 0 else 0x0040) +\n//                          (if ((n & u16\"0x0080\") ≠ u16\"0x0080\") 0 else 0x0080) +\n//                          (if ((n & u16\"0x0100\") ≠ u16\"0x0100\") 0 else 0x0100) +\n//                          (if ((n & u16\"0x0200\") ≠ u16\"0x0200\") 0 else 0x0200) +\n//                          (if ((n & u16\"0x0400\") ≠ u16\"0x0400\") 0 else 0x0400) +\n//                          (if ((n & u16\"0x0800\") ≠ u16\"0x0800\") 0 else 0x0800) +\n//                          (if ((n & u16\"0x1000\") ≠ u16\"0x1000\") 0 else 0x1000) +\n//                          (if ((n & u16\"0x2000\") ≠ u16\"0x2000\") 0 else 0x2000) +\n//                          (if ((n & u16\"0x4000\") ≠ u16\"0x4000\") 0 else 0x4000) +\n//                          (if ((n & u16\"0x8000\") ≠ u16\"0x8000\") 0 else 0x8000)   \"\"\"\n\n  @pure def toZ8(n: U16): Z8 =\n    $ // l\"\"\" requires n ≤ u16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U16): Z16 =\n    $ // l\"\"\" requires n ≤ u16\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U16): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u16\"0x0001\") ≠ u16\"0x0001\") n\"0\" else n\"0x0001\") +\n//                          (if ((n & u16\"0x0002\") ≠ u16\"0x0002\") n\"0\" else n\"0x0002\") +\n//                          (if ((n & u16\"0x0004\") ≠ u16\"0x0004\") n\"0\" else n\"0x0004\") +\n//                          (if ((n & u16\"0x0008\") ≠ u16\"0x0008\") n\"0\" else n\"0x0008\") +\n//                          (if ((n & u16\"0x0010\") ≠ u16\"0x0010\") n\"0\" else n\"0x0010\") +\n//                          (if ((n & u16\"0x0020\") ≠ u16\"0x0020\") n\"0\" else n\"0x0020\") +\n//                          (if ((n & u16\"0x0040\") ≠ u16\"0x0040\") n\"0\" else n\"0x0040\") +\n//                          (if ((n & u16\"0x0080\") ≠ u16\"0x0080\") n\"0\" else n\"0x0080\") +\n//                          (if ((n & u16\"0x0100\") ≠ u16\"0x0100\") n\"0\" else n\"0x0100\") +\n//                          (if ((n & u16\"0x0200\") ≠ u16\"0x0200\") n\"0\" else n\"0x0200\") +\n//                          (if ((n & u16\"0x0400\") ≠ u16\"0x0400\") n\"0\" else n\"0x0400\") +\n//                          (if ((n & u16\"0x0800\") ≠ u16\"0x0800\") n\"0\" else n\"0x0800\") +\n//                          (if ((n & u16\"0x1000\") ≠ u16\"0x1000\") n\"0\" else n\"0x1000\") +\n//                          (if ((n & u16\"0x2000\") ≠ u16\"0x2000\") n\"0\" else n\"0x2000\") +\n//                          (if ((n & u16\"0x4000\") ≠ u16\"0x4000\") n\"0\" else n\"0x4000\") +\n//                          (if ((n & u16\"0x8000\") ≠ u16\"0x8000\") n\"0\" else n\"0x8000\")   \"\"\"\n\n  @pure def toN8(n: U16): N8 =\n    $ // l\"\"\" requires n ≤ u16\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U16): N16 =\n    $ // l\"\"\" requires n ≤ u16\"65535\"\n         // ensures
  #641 = Utf8                 N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U16): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U16): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U16): S8 =\n    $ // l\"\"\" requires n ≤ u16\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U16): S16 =\n    $ // l\"\"\" requires n ≤ u16\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toRawS16(n: U16): S16 = $\n\n  /* @first */\n  @pure def toS32(n: U16): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U16): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U16): U8 = $\n\n  @pure def toU9(n: U16): U9 = $\n\n  @pure def toU10(n: U16): U10 = $\n\n  @pure def toU11(n: U16): U11 = $\n\n  @pure def toU12(n: U16): U12 = $\n\n  @pure def toU13(n: U16): U13 = $\n\n  @pure def toU14(n: U16): U14 = $\n\n  @pure def toU15(n: U16): U15 = $\n\n  @pure def toU16(n: U16): U16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU32(n: U16): U32 = $\n\n  /* @first */\n  @pure def toU64(n: U16): U64 = $\n}\n\n@ext object U17 {\n  @pure def toU32(n: U17): U32 = $\n  @pure def toU64(n: U17): U64 = $\n}\n\n@ext object U18 {\n  @pure def toU32(n: U18): U32 = $\n  @pure def toU64(n: U18): U64 = $\n}\n\n@ext object U19 {\n  @pure def toU32(n: U19): U32 = $\n  @pure def toU64(n: U19): U64 = $\n}\n\n@ext object U20 {\n  @pure def toU32(n: U20): U32 = $\n  @pure def toU64(n: U20): U64 = $\n}\n\n@ext object U21 {\n  @pure def toU32(n: U21): U32 = $\n  @pure def toU64(n: U21): U64 = $\n}\n\n@ext object U22 {\n  @pure def toU32(n: U22): U32 = $\n  @pure def toU64(n: U22): U64 = $\n}\n\n@ext object U23 {\n  @pure def toU32(n: U23): U32 = $\n  @pure def toU64(n: U23): U64 = $\n}\n\n@ext object U24 {\n  @pure def toU32(n: U24): U32 = $\n  @pure def toU64(n: U24): U64 = $\n}\n\n@ext object U25 {\n  @pure def toU32(n: U25): U32 = $\n  @pure def toU64(n: U25): U64 = $\n}\n\n@ext object U26 {\n  @pure def toU32(n: U26): U32 = $\n  @pure def toU64(n: U26): U64 = $\n}\n\n@ext object U27 {\n  @pure def toU32(n: U27): U32 = $\n  @pure def toU64(n: U27): U64 = $\n}\n\n@ext object U28 {\n  @pure def toU32(n: U28): U32 = $\n  @pure def toU64(n: U28): U64 = $\n}\n\n@ext object U29 {\n  @pure def toU32(n: U29): U32 = $\n  @pure def toU64(n: U29): U64 = $\n}\n\n@ext object U30 {\n  @pure def toU32(n: U30): U32 = $\n  @pure def toU64(n: U30): U64 = $\n}\n\n@ext object U31 {\n  @pure def toU32(n: U31): U32 = $\n  @pure def toU64(n: U31): U64 = $\n}\n\n@ext object U32 {\n\n  @pure def toB(n: U32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u32\"0\") \"\"\"\n\n  @pure def toZ(n: U32): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") 0 else 0x00000001) +\n//                          (if ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") 0 else 0x00000002) +\n//                          (if ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") 0 else 0x00000004) +\n//                          (if ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") 0 else 0x00000008) +\n//                          (if ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") 0 else 0x00000010) +\n//                          (if ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") 0 else 0x00000020) +\n//                          (if ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") 0 else 0x00000040) +\n//                          (if ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") 0 else 0x00000080) +\n//                          (if ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") 0 else 0x00000100) +\n//                          (if ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") 0 else 0x00000200) +\n//                          (if ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") 0 else 0x00000400) +\n//                          (if ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") 0 else 0x00000800) +\n//                          (if ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") 0 else 0x00001000) +\n//                          (if ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") 0 else 0x00002000) +\n//                          (if ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") 0 else 0x00004000) +\n//                          (if ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") 0 else 0x00008000) +\n//                          (if ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") 0 else 0x00010000) +\n//                          (if ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") 0 else 0x00020000) +\n//                          (if ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") 0 else 0x00040000) +\n//                          (if ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") 0 else 0x00080000) +\n//                          (if ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") 0 else 0x00100000) +\n//                          (if ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") 0 else 0x00200000) +\n//                          (if ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") 0 else 0x00400000) +\n//                          (if ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") 0 else 0x00800000) +\n//                          (if ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") 0 else 0x01000000) +\n//                          (if ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") 0 else 0x02000000) +\n//                          (if ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") 0 else 0x04000000) +\n//                          (if ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") 0 else 0x08000000) +\n//                          (if ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") 0 else 0x10000000) +\n//                          (if ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") 0 else 0x20000000) +\n//                          (if ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") 0 else 0x40000000) +\n//                          (if ((n & u32\"0x80000000\") ≠ u32\"0x80000000\") 0 else 0x80000000)   \"\"\"\n\n  @pure def toZ8(n: U32): Z8 =\n    $ // l\"\"\" requires n ≤ u32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U32): Z16 =\n    $ // l\"\"\" requires n ≤ u32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U32): Z32 =\n    $ // l\"\"\" requires n ≤ u32\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U32): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") n\"0\" else n\"0x00000001\") +\n//                          (if ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") n\"0\" else n\"0x00000002\") +\n//                          (if ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") n\"0\" else n\"0x00000004\") +\n//                          (if ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") n\"0\" else n\"0x00000008\") +\n//                          (if ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") n\"0\" else n\"0x00000010\") +\n//                          (if ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") n\"0\" else n\"0x00000020\") +\n//                          (if ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") n\"0\" else n\"0x00000040\") +\n//                          (if ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") n\"0\" else n\"0x00000080\") +\n//                          (if ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") n\"0\" else n\"0x00000100\") +\n//                          (if ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") n\"0\" else n\"0x00000200\") +\n//                          (if ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") n\"0\" else n\"0x00000400\") +\n//                          (if ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") n\"0\" else n\"0x00000800\") +\n//                          (if ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") n\"0\" else n\"0x00001000\") +\n//                          (if ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") n\"0\" else n\"0x00002000\") +\n//                          (if ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") n\"0\" else n\"0x00004000\") +\n//                          (if ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") n\"0\" else n\"0x00008000\") +\n//                          (if ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") n\"0\" else n\"0x00010000\") +\n//                          (if ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") n\"0\" else n\"0x00020000\") +\n//                          (if ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") n\"0\" else n\"0x00040000\") +\n//                          (if ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") n\"0\" else n\"0x00080000\") +\n//                          (if ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") n\"0\" else n\"0x00100000\") +\n//                          (if ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") n\"0\" else n\"0x00200000\") +\n//                          (if ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") n\"0\" else n\"0x00400000\") +\n//                          (if ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") n\"0\" else n\"0x00800000\") +\n//                          (if ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") n\"0\" else n\"0x01000000\") +\n//                          (if ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") n\"0\" else n\"0x02000000\") +\n//                          (if ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") n\"0\" else n\"0x04000000\") +\n//                          (if ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") n\"0\" else n\"0x08000000\") +\n//                          (if ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") n\"0\" else n\"0x10000000\") +\n//                          (if ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") n\"0\" else n\"0x20000000\") +\n//                          (if ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") n\"0\" else n\"0x40000000\") +\n//                          (if ((n & u32\"0x80000000\") ≠ u32\"0x80000000\") n\"0\" else n\"0x80000000\")   \"\"\"\n\n  @pure def toN8(n: U32): N8 =\n    $ // l\"\"\" requires n ≤ u32\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U32): N16 =\n    $ // l\"\"\" requires n ≤ u32\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U32): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U32): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U32): S8 =\n    $ // l\"\"\" requires n ≤ u32\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U32): S16 =\n    $ // l\"\"\" requires n ≤ u32\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: U32): S32 =\n    $ // l\"\"\" requires n ≤ u32\"2147483647\" \"\"\"\n\n  /* @first */\n  @pure def toRawS32(n: U32): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U32): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U32): U8 =\n    $ // l\"\"\" requires n ≤ u32\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U32): U16 =\n    $ // l\"\"\" requires n ≤ u32\"65535\" \"\"\"\n\n  @pure def toU17(n: U32): U17 = $\n\n  @pure def toU18(n: U32): U18 = $\n\n  @pure def toU19(n: U32): U19 = $\n\n  @pure def toU20(n: U32): U20 = $\n\n  @pure def toU21(n: U32): U21 = $\n\n  @pure def toU22(n: U32): U22 = $\n\n  @pure def toU23(n: U32): U23 = $\n\n  @pure def toU24(n: U32): U24 = $\n\n  @pure def toU25(n: U32): U25 = $\n\n  @pure def toU26(n: U32): U26 = $\n\n  @pure def toU27(n: U32): U27 = $\n\n  @pure def toU28(n: U32): U28 = $\n\n  @pure def toU29(n: U32): U29 = $\n\n  @pure def toU30(n: U32): U30 = $\n\n  @pure def toU31(n: U32): U31 = $\n\n  @pure def toU32(n: U32): U32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU64(n: U32): U64 = $\n\n  /* @first */\n  @pure def toRawF32(n: U32): F32 = $\n\n  @pure def toC(n: U32): C = $\n}\n\n@ext object U33 {\n  @pure def toU64(n: U33): U64 = $\n}\n\n@ext object U34 {\n  @pure def toU64(n: U34): U64 = $\n}\n\n@ext object U35 {\n  @pure def toU64(n: U35): U64 = $\n}\n\n@ext object U36 {\n  @pure def toU64(n: U36): U64 = $\n}\n\n@ext object U37 {\n  @pure def toU64(n: U37): U64 = $\n}\n\n@ext object U38 {\n  @pure def toU64(n: U38): U64 = $\n}\n\n@ext object U39 {\n  @pure def toU64(n: U39): U64 = $\n}\n\n@ext object U40 {\n  @pure def toU64(n: U40): U64 = $\n}\n\n@ext object U41 {\n  @pure def toU64(n: U41): U64 = $\n}\n\n@ext object U42 {\n  @pure def toU64(n: U42): U64 = $\n}\n\n@ext object U43 {\n  @pure def toU64(n: U43): U64 = $\n}\n\n@ext object U44 {\n  @pure def toU64(n: U44): U64 = $\n}\n\n@ext object U45 {\n  @pure def toU64(n: U45): U64 = $\n}\n\n@ext object U46 {\n  @pure def toU64(n: U46): U64 = $\n}\n\n@ext object U47 {\n  @pure def toU64(n: U47): U64 = $\n}\n\n@ext object U48 {\n  @pure def toU64(n: U48): U64 = $\n}\n\n@ext object U49 {\n  @pure def toU64(n: U49): U64 = $\n}\n\n@ext object U50 {\n  @pure def toU64(n: U50): U64 = $\n}\n\n@ext object U51 {\n  @pure def toU64(n: U51): U64 = $\n}\n\n@ext object U52 {\n  @pure def toU64(n: U52): U64 = $\n}\n\n@ext object U53 {\n  @pure def toU64(n: U53): U64 = $\n}\n\n@ext object U54 {\n  @pure def toU64(n: U54): U64 = $\n}\n\n@ext object U55 {\n  @pure def toU64(n: U55): U64 = $\n}\n\n@ext object U56 {\n  @pure def toU64(n: U56): U64 = $\n}\n\n@ext object U57 {\n  @pure def toU64(n: U57): U64 = $\n}\n\n@ext object U58 {\n  @pure def toU64(n: U58): U64 = $\n}\n\n@ext object U59 {\n  @pure def toU64(n: U59): U64 = $\n}\n\n@ext object U60 {\n  @pure def toU64(n: U60): U64 = $\n}\n\n@ext object U61 {\n  @pure def toU64(n: U61): U64 = $\n}\n\n@ext object U62 {\n  @pure def toU64(n: U62): U64 = $\n}\n\n@ext object U63 {\n  @pure def toU64(n: U63): U64 = $\n}\n\n@ext object U64 {\n\n  @pure def toB(n: U64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u64\"0\") \"\"\"\n\n  @pure def toZ(n: U64): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                          (if ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                          (if ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                          (if ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                          (if ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                          (if ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                          (if ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                          (if ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                          (if ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                          (if ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                          (if ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                          (if ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                          (if ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                          (if ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                          (if ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                          (if ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                          (if ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                          (if ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                          (if ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                          (if ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                          (if ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                          (if ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                          (if ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                          (if ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                          (if ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                          (if ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                          (if ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                          (if ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                          (if ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                          (if ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                          (if ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                          (if ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                          (if ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                          (if ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                          (if ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                          (if ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                          (if ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                          (if ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                          (if ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                          (if ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                          (if ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                          (if ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                          (if ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                          (if ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                          (if ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                          (if ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                          (if ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                          (if ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                          (if ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                          (if ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                          (if ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                          (if ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                          (if ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                          (if ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                          (if ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                          (if ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                          (if ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                          (if ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                          (if ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                          (if ((n & u64\"0x0800000000000000\") ≠ u64\"0
  #642 = String             #641          //   N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U16): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U16): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U16): S8 =\n    $ // l\"\"\" requires n ≤ u16\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U16): S16 =\n    $ // l\"\"\" requires n ≤ u16\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toRawS16(n: U16): S16 = $\n\n  /* @first */\n  @pure def toS32(n: U16): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U16): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U16): U8 = $\n\n  @pure def toU9(n: U16): U9 = $\n\n  @pure def toU10(n: U16): U10 = $\n\n  @pure def toU11(n: U16): U11 = $\n\n  @pure def toU12(n: U16): U12 = $\n\n  @pure def toU13(n: U16): U13 = $\n\n  @pure def toU14(n: U16): U14 = $\n\n  @pure def toU15(n: U16): U15 = $\n\n  @pure def toU16(n: U16): U16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU32(n: U16): U32 = $\n\n  /* @first */\n  @pure def toU64(n: U16): U64 = $\n}\n\n@ext object U17 {\n  @pure def toU32(n: U17): U32 = $\n  @pure def toU64(n: U17): U64 = $\n}\n\n@ext object U18 {\n  @pure def toU32(n: U18): U32 = $\n  @pure def toU64(n: U18): U64 = $\n}\n\n@ext object U19 {\n  @pure def toU32(n: U19): U32 = $\n  @pure def toU64(n: U19): U64 = $\n}\n\n@ext object U20 {\n  @pure def toU32(n: U20): U32 = $\n  @pure def toU64(n: U20): U64 = $\n}\n\n@ext object U21 {\n  @pure def toU32(n: U21): U32 = $\n  @pure def toU64(n: U21): U64 = $\n}\n\n@ext object U22 {\n  @pure def toU32(n: U22): U32 = $\n  @pure def toU64(n: U22): U64 = $\n}\n\n@ext object U23 {\n  @pure def toU32(n: U23): U32 = $\n  @pure def toU64(n: U23): U64 = $\n}\n\n@ext object U24 {\n  @pure def toU32(n: U24): U32 = $\n  @pure def toU64(n: U24): U64 = $\n}\n\n@ext object U25 {\n  @pure def toU32(n: U25): U32 = $\n  @pure def toU64(n: U25): U64 = $\n}\n\n@ext object U26 {\n  @pure def toU32(n: U26): U32 = $\n  @pure def toU64(n: U26): U64 = $\n}\n\n@ext object U27 {\n  @pure def toU32(n: U27): U32 = $\n  @pure def toU64(n: U27): U64 = $\n}\n\n@ext object U28 {\n  @pure def toU32(n: U28): U32 = $\n  @pure def toU64(n: U28): U64 = $\n}\n\n@ext object U29 {\n  @pure def toU32(n: U29): U32 = $\n  @pure def toU64(n: U29): U64 = $\n}\n\n@ext object U30 {\n  @pure def toU32(n: U30): U32 = $\n  @pure def toU64(n: U30): U64 = $\n}\n\n@ext object U31 {\n  @pure def toU32(n: U31): U32 = $\n  @pure def toU64(n: U31): U64 = $\n}\n\n@ext object U32 {\n\n  @pure def toB(n: U32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u32\"0\") \"\"\"\n\n  @pure def toZ(n: U32): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") 0 else 0x00000001) +\n//                          (if ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") 0 else 0x00000002) +\n//                          (if ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") 0 else 0x00000004) +\n//                          (if ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") 0 else 0x00000008) +\n//                          (if ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") 0 else 0x00000010) +\n//                          (if ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") 0 else 0x00000020) +\n//                          (if ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") 0 else 0x00000040) +\n//                          (if ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") 0 else 0x00000080) +\n//                          (if ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") 0 else 0x00000100) +\n//                          (if ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") 0 else 0x00000200) +\n//                          (if ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") 0 else 0x00000400) +\n//                          (if ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") 0 else 0x00000800) +\n//                          (if ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") 0 else 0x00001000) +\n//                          (if ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") 0 else 0x00002000) +\n//                          (if ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") 0 else 0x00004000) +\n//                          (if ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") 0 else 0x00008000) +\n//                          (if ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") 0 else 0x00010000) +\n//                          (if ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") 0 else 0x00020000) +\n//                          (if ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") 0 else 0x00040000) +\n//                          (if ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") 0 else 0x00080000) +\n//                          (if ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") 0 else 0x00100000) +\n//                          (if ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") 0 else 0x00200000) +\n//                          (if ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") 0 else 0x00400000) +\n//                          (if ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") 0 else 0x00800000) +\n//                          (if ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") 0 else 0x01000000) +\n//                          (if ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") 0 else 0x02000000) +\n//                          (if ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") 0 else 0x04000000) +\n//                          (if ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") 0 else 0x08000000) +\n//                          (if ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") 0 else 0x10000000) +\n//                          (if ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") 0 else 0x20000000) +\n//                          (if ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") 0 else 0x40000000) +\n//                          (if ((n & u32\"0x80000000\") ≠ u32\"0x80000000\") 0 else 0x80000000)   \"\"\"\n\n  @pure def toZ8(n: U32): Z8 =\n    $ // l\"\"\" requires n ≤ u32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U32): Z16 =\n    $ // l\"\"\" requires n ≤ u32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U32): Z32 =\n    $ // l\"\"\" requires n ≤ u32\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U32): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") n\"0\" else n\"0x00000001\") +\n//                          (if ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") n\"0\" else n\"0x00000002\") +\n//                          (if ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") n\"0\" else n\"0x00000004\") +\n//                          (if ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") n\"0\" else n\"0x00000008\") +\n//                          (if ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") n\"0\" else n\"0x00000010\") +\n//                          (if ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") n\"0\" else n\"0x00000020\") +\n//                          (if ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") n\"0\" else n\"0x00000040\") +\n//                          (if ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") n\"0\" else n\"0x00000080\") +\n//                          (if ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") n\"0\" else n\"0x00000100\") +\n//                          (if ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") n\"0\" else n\"0x00000200\") +\n//                          (if ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") n\"0\" else n\"0x00000400\") +\n//                          (if ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") n\"0\" else n\"0x00000800\") +\n//                          (if ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") n\"0\" else n\"0x00001000\") +\n//                          (if ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") n\"0\" else n\"0x00002000\") +\n//                          (if ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") n\"0\" else n\"0x00004000\") +\n//                          (if ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") n\"0\" else n\"0x00008000\") +\n//                          (if ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") n\"0\" else n\"0x00010000\") +\n//                          (if ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") n\"0\" else n\"0x00020000\") +\n//                          (if ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") n\"0\" else n\"0x00040000\") +\n//                          (if ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") n\"0\" else n\"0x00080000\") +\n//                          (if ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") n\"0\" else n\"0x00100000\") +\n//                          (if ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") n\"0\" else n\"0x00200000\") +\n//                          (if ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") n\"0\" else n\"0x00400000\") +\n//                          (if ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") n\"0\" else n\"0x00800000\") +\n//                          (if ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") n\"0\" else n\"0x01000000\") +\n//                          (if ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") n\"0\" else n\"0x02000000\") +\n//                          (if ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") n\"0\" else n\"0x04000000\") +\n//                          (if ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") n\"0\" else n\"0x08000000\") +\n//                          (if ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") n\"0\" else n\"0x10000000\") +\n//                          (if ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") n\"0\" else n\"0x20000000\") +\n//                          (if ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") n\"0\" else n\"0x40000000\") +\n//                          (if ((n & u32\"0x80000000\") ≠ u32\"0x80000000\") n\"0\" else n\"0x80000000\")   \"\"\"\n\n  @pure def toN8(n: U32): N8 =\n    $ // l\"\"\" requires n ≤ u32\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U32): N16 =\n    $ // l\"\"\" requires n ≤ u32\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U32): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U32): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U32): S8 =\n    $ // l\"\"\" requires n ≤ u32\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U32): S16 =\n    $ // l\"\"\" requires n ≤ u32\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: U32): S32 =\n    $ // l\"\"\" requires n ≤ u32\"2147483647\" \"\"\"\n\n  /* @first */\n  @pure def toRawS32(n: U32): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U32): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U32): U8 =\n    $ // l\"\"\" requires n ≤ u32\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U32): U16 =\n    $ // l\"\"\" requires n ≤ u32\"65535\" \"\"\"\n\n  @pure def toU17(n: U32): U17 = $\n\n  @pure def toU18(n: U32): U18 = $\n\n  @pure def toU19(n: U32): U19 = $\n\n  @pure def toU20(n: U32): U20 = $\n\n  @pure def toU21(n: U32): U21 = $\n\n  @pure def toU22(n: U32): U22 = $\n\n  @pure def toU23(n: U32): U23 = $\n\n  @pure def toU24(n: U32): U24 = $\n\n  @pure def toU25(n: U32): U25 = $\n\n  @pure def toU26(n: U32): U26 = $\n\n  @pure def toU27(n: U32): U27 = $\n\n  @pure def toU28(n: U32): U28 = $\n\n  @pure def toU29(n: U32): U29 = $\n\n  @pure def toU30(n: U32): U30 = $\n\n  @pure def toU31(n: U32): U31 = $\n\n  @pure def toU32(n: U32): U32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU64(n: U32): U64 = $\n\n  /* @first */\n  @pure def toRawF32(n: U32): F32 = $\n\n  @pure def toC(n: U32): C = $\n}\n\n@ext object U33 {\n  @pure def toU64(n: U33): U64 = $\n}\n\n@ext object U34 {\n  @pure def toU64(n: U34): U64 = $\n}\n\n@ext object U35 {\n  @pure def toU64(n: U35): U64 = $\n}\n\n@ext object U36 {\n  @pure def toU64(n: U36): U64 = $\n}\n\n@ext object U37 {\n  @pure def toU64(n: U37): U64 = $\n}\n\n@ext object U38 {\n  @pure def toU64(n: U38): U64 = $\n}\n\n@ext object U39 {\n  @pure def toU64(n: U39): U64 = $\n}\n\n@ext object U40 {\n  @pure def toU64(n: U40): U64 = $\n}\n\n@ext object U41 {\n  @pure def toU64(n: U41): U64 = $\n}\n\n@ext object U42 {\n  @pure def toU64(n: U42): U64 = $\n}\n\n@ext object U43 {\n  @pure def toU64(n: U43): U64 = $\n}\n\n@ext object U44 {\n  @pure def toU64(n: U44): U64 = $\n}\n\n@ext object U45 {\n  @pure def toU64(n: U45): U64 = $\n}\n\n@ext object U46 {\n  @pure def toU64(n: U46): U64 = $\n}\n\n@ext object U47 {\n  @pure def toU64(n: U47): U64 = $\n}\n\n@ext object U48 {\n  @pure def toU64(n: U48): U64 = $\n}\n\n@ext object U49 {\n  @pure def toU64(n: U49): U64 = $\n}\n\n@ext object U50 {\n  @pure def toU64(n: U50): U64 = $\n}\n\n@ext object U51 {\n  @pure def toU64(n: U51): U64 = $\n}\n\n@ext object U52 {\n  @pure def toU64(n: U52): U64 = $\n}\n\n@ext object U53 {\n  @pure def toU64(n: U53): U64 = $\n}\n\n@ext object U54 {\n  @pure def toU64(n: U54): U64 = $\n}\n\n@ext object U55 {\n  @pure def toU64(n: U55): U64 = $\n}\n\n@ext object U56 {\n  @pure def toU64(n: U56): U64 = $\n}\n\n@ext object U57 {\n  @pure def toU64(n: U57): U64 = $\n}\n\n@ext object U58 {\n  @pure def toU64(n: U58): U64 = $\n}\n\n@ext object U59 {\n  @pure def toU64(n: U59): U64 = $\n}\n\n@ext object U60 {\n  @pure def toU64(n: U60): U64 = $\n}\n\n@ext object U61 {\n  @pure def toU64(n: U61): U64 = $\n}\n\n@ext object U62 {\n  @pure def toU64(n: U62): U64 = $\n}\n\n@ext object U63 {\n  @pure def toU64(n: U63): U64 = $\n}\n\n@ext object U64 {\n\n  @pure def toB(n: U64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u64\"0\") \"\"\"\n\n  @pure def toZ(n: U64): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                          (if ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                          (if ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                          (if ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                          (if ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                          (if ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                          (if ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                          (if ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                          (if ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                          (if ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                          (if ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                          (if ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                          (if ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                          (if ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                          (if ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                          (if ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                          (if ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                          (if ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                          (if ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                          (if ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                          (if ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                          (if ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                          (if ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                          (if ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                          (if ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                          (if ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                          (if ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                          (if ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                          (if ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                          (if ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                          (if ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                          (if ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                          (if ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                          (if ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                          (if ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                          (if ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                          (if ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                          (if ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                          (if ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                          (if ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                          (if ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                          (if ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                          (if ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                          (if ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                          (if ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                          (if ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                          (if ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                          (if ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                          (if ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                          (if ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                          (if ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                          (if ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                          (if ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                          (if ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                          (if ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                          (if ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                          (if ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                          (if ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                          (if ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                          (if ((n & u64\"0x0800000000000000\") ≠ u64\"0
  #643 = Utf8               x0800000000000000\") 0 else 0x0800000000000000l) +\n//                          (if ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                          (if ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                          (if ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") 0 else 0x4000000000000000l) +\n//                          (if ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\") 0 else 0x8000000000000000l)   \"\"\"\n\n  @pure def toZ8(n: U64): Z8 =\n    $ // l\"\"\" requires n ≤ u64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U64): Z16 =\n    $ // l\"\"\" requires n ≤ u64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U64): Z32 =\n    $ // l\"\"\" requires n ≤ u64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U64): Z64 =\n    $ // l\"\"\" requires n ≤ u64\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U64): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") n\"0\" else n\"0x0000000000000001\") +\n//                          (if ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") n\"0\" else n\"0x0000000000000002\") +\n//                          (if ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") n\"0\" else n\"0x0000000000000004\") +\n//                          (if ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") n\"0\" else n\"0x0000000000000008\") +\n//                          (if ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") n\"0\" else n\"0x0000000000000010\") +\n//                          (if ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") n\"0\" else n\"0x0000000000000020\") +\n//                          (if ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") n\"0\" else n\"0x0000000000000040\") +\n//                          (if ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") n\"0\" else n\"0x0000000000000080\") +\n//                          (if ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") n\"0\" else n\"0x0000000000000100\") +\n//                          (if ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") n\"0\" else n\"0x0000000000000200\") +\n//                          (if ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") n\"0\" else n\"0x0000000000000400\") +\n//                          (if ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") n\"0\" else n\"0x0000000000000800\") +\n//                          (if ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") n\"0\" else n\"0x0000000000001000\") +\n//                          (if ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") n\"0\" else n\"0x0000000000002000\") +\n//                          (if ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") n\"0\" else n\"0x0000000000004000\") +\n//                          (if ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") n\"0\" else n\"0x0000000000008000\") +\n//                          (if ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") n\"0\" else n\"0x0000000000010000\") +\n//                          (if ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") n\"0\" else n\"0x0000000000020000\") +\n//                          (if ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") n\"0\" else n\"0x0000000000040000\") +\n//                          (if ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") n\"0\" else n\"0x0000000000080000\") +\n//                          (if ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") n\"0\" else n\"0x0000000000100000\") +\n//                          (if ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") n\"0\" else n\"0x0000000000200000\") +\n//                          (if ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") n\"0\" else n\"0x0000000000400000\") +\n//                          (if ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") n\"0\" else n\"0x0000000000800000\") +\n//                          (if ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") n\"0\" else n\"0x0000000001000000\") +\n//                          (if ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") n\"0\" else n\"0x0000000002000000\") +\n//                          (if ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") n\"0\" else n\"0x0000000004000000\") +\n//                          (if ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") n\"0\" else n\"0x0000000008000000\") +\n//                          (if ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") n\"0\" else n\"0x0000000010000000\") +\n//                          (if ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") n\"0\" else n\"0x0000000020000000\") +\n//                          (if ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") n\"0\" else n\"0x0000000040000000\") +\n//                          (if ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") n\"0\" else n\"0x0000000080000000\") +\n//                          (if ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") n\"0\" else n\"0x0000000100000000\") +\n//                          (if ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") n\"0\" else n\"0x0000000200000000\") +\n//                          (if ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") n\"0\" else n\"0x0000000400000000\") +\n//                          (if ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") n\"0\" else n\"0x0000000800000000\") +\n//                          (if ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") n\"0\" else n\"0x0000001000000000\") +\n//                          (if ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") n\"0\" else n\"0x0000002000000000\") +\n//                          (if ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") n\"0\" else n\"0x0000004000000000\") +\n//                          (if ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") n\"0\" else n\"0x0000008000000000\") +\n//                          (if ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") n\"0\" else n\"0x0000010000000000\") +\n//                          (if ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") n\"0\" else n\"0x0000020000000000\") +\n//                          (if ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") n\"0\" else n\"0x0000040000000000\") +\n//                          (if ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") n\"0\" else n\"0x0000080000000000\") +\n//                          (if ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") n\"0\" else n\"0x0000100000000000\") +\n//                          (if ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") n\"0\" else n\"0x0000200000000000\") +\n//                          (if ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") n\"0\" else n\"0x0000400000000000\") +\n//                          (if ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") n\"0\" else n\"0x0000800000000000\") +\n//                          (if ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") n\"0\" else n\"0x0001000000000000\") +\n//                          (if ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") n\"0\" else n\"0x0002000000000000\") +\n//                          (if ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") n\"0\" else n\"0x0004000000000000\") +\n//                          (if ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") n\"0\" else n\"0x0008000000000000\") +\n//                          (if ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") n\"0\" else n\"0x0010000000000000\") +\n//                          (if ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") n\"0\" else n\"0x0020000000000000\") +\n//                          (if ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") n\"0\" else n\"0x0040000000000000\") +\n//                          (if ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") n\"0\" else n\"0x0080000000000000\") +\n//                          (if ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") n\"0\" else n\"0x0100000000000000\") +\n//                          (if ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") n\"0\" else n\"0x0200000000000000\") +\n//                          (if ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") n\"0\" else n\"0x0400000000000000\") +\n//                          (if ((n & u64\"0x0800000000000000\") ≠ u64\"0x0800000000000000\") n\"0\" else n\"0x0800000000000000\") +\n//                          (if ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") n\"0\" else n\"0x1000000000000000\") +\n//                          (if ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") n\"0\" else n\"0x2000000000000000\") +\n//                          (if ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") n\"0\" else n\"0x4000000000000000\") +\n//                          (if ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\") n\"0\" else n\"0x8000000000000000\")   \"\"\"\n\n  @pure def toN8(n: U64): N8 =\n    $ // l\"\"\" requires n ≤ u64\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U64): N16 =\n    $ // l\"\"\" requires n ≤ u64\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U64): N32 =\n    $ // l\"\"\" requires n ≤ u64\"4294967295\"\n         // ensures  N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U64): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U64): S8 =\n    $ // l\"\"\" requires n ≤ u64\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U64): S16 =\n    $ // l\"\"\" requires n ≤ u64\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: U64): S32 =\n    $ // l\"\"\" requires n ≤ u64\"2147483647\" \"\"\"\n\n  /* @first */\n  @pure def toS64(n: U64): S64 =\n    $ // l\"\"\" requires n ≤ u64\"9223372036854775807\" \"\"\"\n\n  /* @first */\n  @pure def toRawS64(n: U64): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U64): U8 =\n    $ // l\"\"\" requires n ≤ u64\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U64): U16 =\n    $ // l\"\"\" requires n ≤ u64\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: U64): U32 =\n    $ // l\"\"\" requires n ≤ u64\"4294967295\" \"\"\"\n\n  @pure def toU33(n: U64): U33 = $\n\n  @pure def toU34(n: U64): U34 = $\n\n  @pure def toU35(n: U64): U35 = $\n\n  @pure def toU36(n: U64): U36 = $\n\n  @pure def toU37(n: U64): U37 = $\n\n  @pure def toU38(n: U64): U38 = $\n\n  @pure def toU39(n: U64): U39 = $\n\n  @pure def toU40(n: U64): U40 = $\n\n  @pure def toU41(n: U64): U41 = $\n\n  @pure def toU42(n: U64): U42 = $\n\n  @pure def toU43(n: U64): U43 = $\n\n  @pure def toU44(n: U64): U44 = $\n\n  @pure def toU45(n: U64): U45 = $\n\n  @pure def toU46(n: U64): U46 = $\n\n  @pure def toU47(n: U64): U47 = $\n\n  @pure def toU48(n: U64): U48 = $\n\n  @pure def toU49(n: U64): U49 = $\n\n  @pure def toU50(n: U64): U50 = $\n\n  @pure def toU51(n: U64): U51 = $\n\n  @pure def toU52(n: U64): U52 = $\n\n  @pure def toU53(n: U64): U53 = $\n\n  @pure def toU54(n: U64): U54 = $\n\n  @pure def toU55(n: U64): U55 = $\n\n  @pure def toU56(n: U64): U56 = $\n\n  @pure def toU57(n: U64): U57 = $\n\n  @pure def toU58(n: U64): U58 = $\n\n  @pure def toU59(n: U64): U59 = $\n\n  @pure def toU60(n: U64): U60 = $\n\n  @pure def toU61(n: U64): U61 = $\n\n  @pure def toU62(n: U64): U62 = $\n\n  @pure def toU63(n: U64): U63 = $\n\n  /* @first */\n  @pure def toU64(n: U64): U64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toRawF64(n: U64): F64 = $\n}\n\n@ext object F32 {\n\n  @pure def toB(n: F32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ f32\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toRawU32(n: F32): U32 = $\n\n  @pure def toF32(n: F32): F32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toR(n: F32): R = $\n}\n\n@ext object F64 {\n\n  @pure def toB(n: F64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ f64\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toRawU64(n: F64): U64 = $\n\n  @pure def toF64(n: F64): F64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toR(n: F64): R = $\n}\n\n@ext object R {\n\n  @pure def toB(n: R): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ r\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: R): Z = $\n\n  /* @first */\n  @pure def toN(n: R): N =\n    $ // l\"\"\" requires n ≥ r\"0.0\" \"\"\"\n\n  @pure def toR(n: R): R =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n}\n\n@ext object String {\n\n  @pure def fromBase64(s: String): Either[IS[Z, U8], String] = $\n\n  @pure def toBase64(data: IS[Z, U8]): String = $\n\n  @pure def fromCis[I](cs: IS[I, C]): String = $\n\n  @pure def fromCms[I](cs: MS[I, C]): String = $\n\n  @pure def fromU8is(u8s: IS[Z, U8]): String = $\n\n  @pure def fromU8ms(u8s: MS[Z, U8]): String = $\n\n  @pure def toCis(s: String): IS[Z, C] = $\n\n  @pure def toCStream(s: String): Jen[C] = $\n\n  @pure def toCms(s: String): MS[Z, C] = $\n\n  @pure def toU8is(s: String): IS[Z, U8] = $\n\n  @pure def toU8ms(s: String): MS[Z, U8] = $\n}\n\n@ext object ISB {\n  @pure def fromISU8[I](s: IS[I, U8]): IS[I, B] = $\n  @pure def toISU8[I](s: IS[I, B]): IS[I, U8] = $\n  @pure def toMSU8[I](s: IS[I, B]): MS[I, U8] = $\n}\n\n@ext object MSB {\n  @pure def fromMSU8[I](s: MS[I, U8]): MS[I, B] = $\n  @pure def toISU8[I](s: MS[I, B]): IS[I, U8] = $\n  @pure def toMSU8[I](s: MS[I, B]): MS[I, U8] = $\n}\n
  #644 = String             #643          // x0800000000000000\") 0 else 0x0800000000000000l) +\n//                          (if ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                          (if ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                          (if ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") 0 else 0x4000000000000000l) +\n//                          (if ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\") 0 else 0x8000000000000000l)   \"\"\"\n\n  @pure def toZ8(n: U64): Z8 =\n    $ // l\"\"\" requires n ≤ u64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U64): Z16 =\n    $ // l\"\"\" requires n ≤ u64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U64): Z32 =\n    $ // l\"\"\" requires n ≤ u64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U64): Z64 =\n    $ // l\"\"\" requires n ≤ u64\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U64): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") n\"0\" else n\"0x0000000000000001\") +\n//                          (if ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") n\"0\" else n\"0x0000000000000002\") +\n//                          (if ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") n\"0\" else n\"0x0000000000000004\") +\n//                          (if ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") n\"0\" else n\"0x0000000000000008\") +\n//                          (if ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") n\"0\" else n\"0x0000000000000010\") +\n//                          (if ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") n\"0\" else n\"0x0000000000000020\") +\n//                          (if ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") n\"0\" else n\"0x0000000000000040\") +\n//                          (if ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") n\"0\" else n\"0x0000000000000080\") +\n//                          (if ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") n\"0\" else n\"0x0000000000000100\") +\n//                          (if ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") n\"0\" else n\"0x0000000000000200\") +\n//                          (if ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") n\"0\" else n\"0x0000000000000400\") +\n//                          (if ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") n\"0\" else n\"0x0000000000000800\") +\n//                          (if ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") n\"0\" else n\"0x0000000000001000\") +\n//                          (if ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") n\"0\" else n\"0x0000000000002000\") +\n//                          (if ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") n\"0\" else n\"0x0000000000004000\") +\n//                          (if ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") n\"0\" else n\"0x0000000000008000\") +\n//                          (if ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") n\"0\" else n\"0x0000000000010000\") +\n//                          (if ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") n\"0\" else n\"0x0000000000020000\") +\n//                          (if ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") n\"0\" else n\"0x0000000000040000\") +\n//                          (if ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") n\"0\" else n\"0x0000000000080000\") +\n//                          (if ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") n\"0\" else n\"0x0000000000100000\") +\n//                          (if ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") n\"0\" else n\"0x0000000000200000\") +\n//                          (if ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") n\"0\" else n\"0x0000000000400000\") +\n//                          (if ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") n\"0\" else n\"0x0000000000800000\") +\n//                          (if ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") n\"0\" else n\"0x0000000001000000\") +\n//                          (if ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") n\"0\" else n\"0x0000000002000000\") +\n//                          (if ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") n\"0\" else n\"0x0000000004000000\") +\n//                          (if ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") n\"0\" else n\"0x0000000008000000\") +\n//                          (if ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") n\"0\" else n\"0x0000000010000000\") +\n//                          (if ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") n\"0\" else n\"0x0000000020000000\") +\n//                          (if ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") n\"0\" else n\"0x0000000040000000\") +\n//                          (if ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") n\"0\" else n\"0x0000000080000000\") +\n//                          (if ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") n\"0\" else n\"0x0000000100000000\") +\n//                          (if ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") n\"0\" else n\"0x0000000200000000\") +\n//                          (if ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") n\"0\" else n\"0x0000000400000000\") +\n//                          (if ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") n\"0\" else n\"0x0000000800000000\") +\n//                          (if ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") n\"0\" else n\"0x0000001000000000\") +\n//                          (if ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") n\"0\" else n\"0x0000002000000000\") +\n//                          (if ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") n\"0\" else n\"0x0000004000000000\") +\n//                          (if ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") n\"0\" else n\"0x0000008000000000\") +\n//                          (if ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") n\"0\" else n\"0x0000010000000000\") +\n//                          (if ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") n\"0\" else n\"0x0000020000000000\") +\n//                          (if ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") n\"0\" else n\"0x0000040000000000\") +\n//                          (if ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") n\"0\" else n\"0x0000080000000000\") +\n//                          (if ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") n\"0\" else n\"0x0000100000000000\") +\n//                          (if ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") n\"0\" else n\"0x0000200000000000\") +\n//                          (if ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") n\"0\" else n\"0x0000400000000000\") +\n//                          (if ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") n\"0\" else n\"0x0000800000000000\") +\n//                          (if ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") n\"0\" else n\"0x0001000000000000\") +\n//                          (if ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") n\"0\" else n\"0x0002000000000000\") +\n//                          (if ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") n\"0\" else n\"0x0004000000000000\") +\n//                          (if ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") n\"0\" else n\"0x0008000000000000\") +\n//                          (if ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") n\"0\" else n\"0x0010000000000000\") +\n//                          (if ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") n\"0\" else n\"0x0020000000000000\") +\n//                          (if ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") n\"0\" else n\"0x0040000000000000\") +\n//                          (if ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") n\"0\" else n\"0x0080000000000000\") +\n//                          (if ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") n\"0\" else n\"0x0100000000000000\") +\n//                          (if ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") n\"0\" else n\"0x0200000000000000\") +\n//                          (if ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") n\"0\" else n\"0x0400000000000000\") +\n//                          (if ((n & u64\"0x0800000000000000\") ≠ u64\"0x0800000000000000\") n\"0\" else n\"0x0800000000000000\") +\n//                          (if ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") n\"0\" else n\"0x1000000000000000\") +\n//                          (if ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") n\"0\" else n\"0x2000000000000000\") +\n//                          (if ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") n\"0\" else n\"0x4000000000000000\") +\n//                          (if ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\") n\"0\" else n\"0x8000000000000000\")   \"\"\"\n\n  @pure def toN8(n: U64): N8 =\n    $ // l\"\"\" requires n ≤ u64\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U64): N16 =\n    $ // l\"\"\" requires n ≤ u64\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U64): N32 =\n    $ // l\"\"\" requires n ≤ u64\"4294967295\"\n         // ensures  N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U64): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U64): S8 =\n    $ // l\"\"\" requires n ≤ u64\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U64): S16 =\n    $ // l\"\"\" requires n ≤ u64\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: U64): S32 =\n    $ // l\"\"\" requires n ≤ u64\"2147483647\" \"\"\"\n\n  /* @first */\n  @pure def toS64(n: U64): S64 =\n    $ // l\"\"\" requires n ≤ u64\"9223372036854775807\" \"\"\"\n\n  /* @first */\n  @pure def toRawS64(n: U64): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U64): U8 =\n    $ // l\"\"\" requires n ≤ u64\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U64): U16 =\n    $ // l\"\"\" requires n ≤ u64\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: U64): U32 =\n    $ // l\"\"\" requires n ≤ u64\"4294967295\" \"\"\"\n\n  @pure def toU33(n: U64): U33 = $\n\n  @pure def toU34(n: U64): U34 = $\n\n  @pure def toU35(n: U64): U35 = $\n\n  @pure def toU36(n: U64): U36 = $\n\n  @pure def toU37(n: U64): U37 = $\n\n  @pure def toU38(n: U64): U38 = $\n\n  @pure def toU39(n: U64): U39 = $\n\n  @pure def toU40(n: U64): U40 = $\n\n  @pure def toU41(n: U64): U41 = $\n\n  @pure def toU42(n: U64): U42 = $\n\n  @pure def toU43(n: U64): U43 = $\n\n  @pure def toU44(n: U64): U44 = $\n\n  @pure def toU45(n: U64): U45 = $\n\n  @pure def toU46(n: U64): U46 = $\n\n  @pure def toU47(n: U64): U47 = $\n\n  @pure def toU48(n: U64): U48 = $\n\n  @pure def toU49(n: U64): U49 = $\n\n  @pure def toU50(n: U64): U50 = $\n\n  @pure def toU51(n: U64): U51 = $\n\n  @pure def toU52(n: U64): U52 = $\n\n  @pure def toU53(n: U64): U53 = $\n\n  @pure def toU54(n: U64): U54 = $\n\n  @pure def toU55(n: U64): U55 = $\n\n  @pure def toU56(n: U64): U56 = $\n\n  @pure def toU57(n: U64): U57 = $\n\n  @pure def toU58(n: U64): U58 = $\n\n  @pure def toU59(n: U64): U59 = $\n\n  @pure def toU60(n: U64): U60 = $\n\n  @pure def toU61(n: U64): U61 = $\n\n  @pure def toU62(n: U64): U62 = $\n\n  @pure def toU63(n: U64): U63 = $\n\n  /* @first */\n  @pure def toU64(n: U64): U64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toRawF64(n: U64): F64 = $\n}\n\n@ext object F32 {\n\n  @pure def toB(n: F32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ f32\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toRawU32(n: F32): U32 = $\n\n  @pure def toF32(n: F32): F32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toR(n: F32): R = $\n}\n\n@ext object F64 {\n\n  @pure def toB(n: F64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ f64\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toRawU64(n: F64): U64 = $\n\n  @pure def toF64(n: F64): F64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toR(n: F64): R = $\n}\n\n@ext object R {\n\n  @pure def toB(n: R): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ r\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: R): Z = $\n\n  /* @first */\n  @pure def toN(n: R): N =\n    $ // l\"\"\" requires n ≥ r\"0.0\" \"\"\"\n\n  @pure def toR(n: R): R =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n}\n\n@ext object String {\n\n  @pure def fromBase64(s: String): Either[IS[Z, U8], String] = $\n\n  @pure def toBase64(data: IS[Z, U8]): String = $\n\n  @pure def fromCis[I](cs: IS[I, C]): String = $\n\n  @pure def fromCms[I](cs: MS[I, C]): String = $\n\n  @pure def fromU8is(u8s: IS[Z, U8]): String = $\n\n  @pure def fromU8ms(u8s: MS[Z, U8]): String = $\n\n  @pure def toCis(s: String): IS[Z, C] = $\n\n  @pure def toCStream(s: String): Jen[C] = $\n\n  @pure def toCms(s: String): MS[Z, C] = $\n\n  @pure def toU8is(s: String): IS[Z, U8] = $\n\n  @pure def toU8ms(s: String): MS[Z, U8] = $\n}\n\n@ext object ISB {\n  @pure def fromISU8[I](s: IS[I, U8]): IS[I, B] = $\n  @pure def toISU8[I](s: IS[I, B]): IS[I, U8] = $\n  @pure def toMSU8[I](s: IS[I, B]): MS[I, U8] = $\n}\n\n@ext object MSB {\n  @pure def fromMSU8[I](s: MS[I, U8]): MS[I, B] = $\n  @pure def toISU8[I](s: MS[I, B]): IS[I, U8] = $\n  @pure def toMSU8[I](s: MS[I, B]): MS[I, U8] = $\n}\n
  #645 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashMap {\n\n  @pure def empty[K, T]: HashMap[K, T] = {\n    return emptyInit[K, T](12)\n  }\n\n  @pure def emptyInit[K, T](initialCapacity: Z): HashMap[K, T] = {\n    val sz: Z = if (initialCapacity <= 0) 4 else initialCapacity * 4 / 3 + 1\n    return HashMap[K, T](ISZ.create(sz, Map.empty), 0)\n  }\n\n  @pure def ++[I, K, T](s: IS[I, (K, T)]): HashMap[K, T] = {\n    return HashMap.emptyInit[K, T](s.size) ++ s\n  }\n\n}\n\n@datatype class HashMap[K, T](val mapEntries: ISZ[Map[K, T]], val size: Z) {\n\n  @pure def entries: ISZ[(K, T)] = {\n    var r = ISZ[(K, T)]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.entries\n      }\n    }\n    return r\n  }\n\n  @pure def keys: ISZ[K] = {\n    var r = ISZ[K]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.keys\n      }\n    }\n    return r\n  }\n\n  @pure def values: ISZ[T] = {\n    var r = ISZ[T]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.values\n      }\n    }\n    return r\n  }\n\n  @pure def keySet: Set[K] = {\n    return Set.empty[K] ++ keys\n  }\n\n  @pure def valueSet: Set[T] = {\n    return Set.empty[T] ++ values\n  }\n\n  @pure def +(p: (K, T)): HashMap[K, T] = {\n    val (key, value) = p\n    val r = ensureCapacity(size + 1)\n    val i = r.hashIndex(key)\n    val m = r.mapEntries(i)\n    val newSize: Z = if (m.contains(key)) size else size + 1\n    return r(mapEntries = r.mapEntries(i ~> (m + key ~> value)), size = newSize)\n  }\n\n  @pure def ++[I](entries: IS[I, (K, T)]): HashMap[K, T] = {\n    if (entries.isEmpty) {\n      return this\n    }\n    var r = ensureCapacity(size + entries.size)\n    for (kv <- entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def ensureCapacity(sz: Z): HashMap[K, T] = {\n    if (mapEntries.size * 3 / 4 >= sz) {\n      return this\n    }\n    val init = sz * 2\n    var r = HashMap.emptyInit[K, T](init)\n    for (ms <- mapEntries) {\n      for (kv <- ms.entries) {\n        r = r + kv._1 ~> kv._2\n      }\n    }\n    return r\n  }\n\n  @pure def hashIndex(key: K): Z = {\n    val sz = mapEntries.size\n    val i = key.hash % sz\n    return if (i < 0) i + sz else i\n  }\n\n  @pure def get(key: K): Option[T] = {\n    val m = mapEntries(hashIndex(key))\n    return m.get(key)\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    val m = mapEntries(hashIndex(key))\n    return m.entry(key)\n  }\n\n  @pure def --[I](keys: IS[I, K]): HashMap[K, T] = {\n    var r = this\n    for (k <- keys) {\n      r.get(k) match {\n        case Some(v) => r = r - k ~> v\n        case _ =>\n      }\n    }\n    return r\n  }\n\n  @pure def -(p: (K, T)): HashMap[K, T] = {\n    val (key, value) = p\n    val i = hashIndex(key)\n    return this(mapEntries(i ~> (mapEntries(i) - key ~> value)), size - 1)\n  }\n\n  @pure def contains(key: K): B = {\n    return get(key).nonEmpty\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: HashMap[K, T]): B = {\n    if (size != other.size) {\n      return F\n    }\n\n    var comparedKeys = ISZ[K]()\n    for (ms <- mapEntries) {\n      for (kv <- ms.entries) {\n        val k = kv._1\n        comparedKeys = comparedKeys :+ k\n        other.get(k) match {\n          case Some(v) =>\n            if (kv._2 != v) {\n              return F\n            }\n          case _ => return F\n        }\n      }\n    }\n    for (ms <- (other -- comparedKeys).mapEntries) {\n      for (kv <- ms.entries) {\n        val k = kv._1\n        get(k) match {\n          case Some(v) =>\n            if (kv._2 != v) {\n              return F\n            }\n          case _ => return F\n        }\n      }\n    }\n\n    return T\n  }\n}\n
  #646 = String             #645          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashMap {\n\n  @pure def empty[K, T]: HashMap[K, T] = {\n    return emptyInit[K, T](12)\n  }\n\n  @pure def emptyInit[K, T](initialCapacity: Z): HashMap[K, T] = {\n    val sz: Z = if (initialCapacity <= 0) 4 else initialCapacity * 4 / 3 + 1\n    return HashMap[K, T](ISZ.create(sz, Map.empty), 0)\n  }\n\n  @pure def ++[I, K, T](s: IS[I, (K, T)]): HashMap[K, T] = {\n    return HashMap.emptyInit[K, T](s.size) ++ s\n  }\n\n}\n\n@datatype class HashMap[K, T](val mapEntries: ISZ[Map[K, T]], val size: Z) {\n\n  @pure def entries: ISZ[(K, T)] = {\n    var r = ISZ[(K, T)]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.entries\n      }\n    }\n    return r\n  }\n\n  @pure def keys: ISZ[K] = {\n    var r = ISZ[K]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.keys\n      }\n    }\n    return r\n  }\n\n  @pure def values: ISZ[T] = {\n    var r = ISZ[T]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.values\n      }\n    }\n    return r\n  }\n\n  @pure def keySet: Set[K] = {\n    return Set.empty[K] ++ keys\n  }\n\n  @pure def valueSet: Set[T] = {\n    return Set.empty[T] ++ values\n  }\n\n  @pure def +(p: (K, T)): HashMap[K, T] = {\n    val (key, value) = p\n    val r = ensureCapacity(size + 1)\n    val i = r.hashIndex(key)\n    val m = r.mapEntries(i)\n    val newSize: Z = if (m.contains(key)) size else size + 1\n    return r(mapEntries = r.mapEntries(i ~> (m + key ~> value)), size = newSize)\n  }\n\n  @pure def ++[I](entries: IS[I, (K, T)]): HashMap[K, T] = {\n    if (entries.isEmpty) {\n      return this\n    }\n    var r = ensureCapacity(size + entries.size)\n    for (kv <- entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def ensureCapacity(sz: Z): HashMap[K, T] = {\n    if (mapEntries.size * 3 / 4 >= sz) {\n      return this\n    }\n    val init = sz * 2\n    var r = HashMap.emptyInit[K, T](init)\n    for (ms <- mapEntries) {\n      for (kv <- ms.entries) {\n        r = r + kv._1 ~> kv._2\n      }\n    }\n    return r\n  }\n\n  @pure def hashIndex(key: K): Z = {\n    val sz = mapEntries.size\n    val i = key.hash % sz\n    return if (i < 0) i + sz else i\n  }\n\n  @pure def get(key: K): Option[T] = {\n    val m = mapEntries(hashIndex(key))\n    return m.get(key)\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    val m = mapEntries(hashIndex(key))\n    return m.entry(key)\n  }\n\n  @pure def --[I](keys: IS[I, K]): HashMap[K, T] = {\n    var r = this\n    for (k <- keys) {\n      r.get(k) match {\n        case Some(v) => r = r - k ~> v\n        case _ =>\n      }\n    }\n    return r\n  }\n\n  @pure def -(p: (K, T)): HashMap[K, T] = {\n    val (key, value) = p\n    val i = hashIndex(key)\n    return this(mapEntries(i ~> (mapEntries(i) - key ~> value)), size - 1)\n  }\n\n  @pure def contains(key: K): B = {\n    return get(key).nonEmpty\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: HashMap[K, T]): B = {\n    if (size != other.size) {\n      return F\n    }\n\n    var comparedKeys = ISZ[K]()\n    for (ms <- mapEntries) {\n      for (kv <- ms.entries) {\n        val k = kv._1\n        comparedKeys = comparedKeys :+ k\n        other.get(k) match {\n          case Some(v) =>\n            if (kv._2 != v) {\n              return F\n            }\n          case _ => return F\n        }\n      }\n    }\n    for (ms <- (other -- comparedKeys).mapEntries) {\n      for (kv <- ms.entries) {\n        val k = kv._1\n        get(k) match {\n          case Some(v) =>\n            if (kv._2 != v) {\n              return F\n            }\n          case _ => return F\n        }\n      }\n    }\n\n    return T\n  }\n}\n
  #647 = Utf8               // #Sireum\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Li Haoyi (haoyi.sg@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n */\n\npackage org.sireum\n\n// Adapted from https://github.com/lihaoyi/geny\n\n@sig trait Jen[T] {\n\n  def generate(f: T => Jen.Action): Jen.Action\n\n  def foreach[V](f: T => V): Unit = {\n    def ap(o: T): Jen.Action = {\n      f(o)\n      return Jen.Continue\n    }\n\n    generate(ap _)\n  }\n\n  def find(f: T => B): Option[T] = {\n    var result: Option[T] = None()\n\n    def ap(o: T): Jen.Action = {\n      val r = f(o)\n      if (!r) {\n        return Jen.Continue\n      } else {\n        result = Some(o)\n        return Jen.End\n      }\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  def exists(f: T => B): B = {\n    val r = find(f)\n    return r.nonEmpty\n  }\n\n  @pure def contains(o: T): B = {\n    return exists(e => e == o)\n  }\n\n  def forall(f: T => B): B = {\n    def ap(o: T): B = {\n      val r = f(o)\n      return !r\n    }\n    val r = exists(ap _)\n    return !r\n  }\n\n  @pure def count(): Z = {\n    return countIf(_ => T)\n  }\n\n  def countIf(p: T => B): Z = {\n    var result = 0\n\n    def ap(o: T): Jen.Action = {\n      val r = p(o)\n      if (r) {\n        result = result + 1\n      }\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  @pure def fold[U](initial: U, f: (U, T) => U@pure): U = {\n    return foldLeft(initial, f)\n  }\n\n  @pure def foldLeft[U](initial: U, f: (U, T) => U@pure): U = {\n    var r = initial\n\n    def ap(o: T): Jen.Action = {\n      r = f(r, o)\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def reduce(f: (T, T) => T@pure): Option[T] = {\n    return reduceLeft(f)\n  }\n\n  @pure def reduceLeft(f: (T, T) => T@pure): Option[T] = {\n    var r: Option[T] = None()\n\n    def ap(o: T): Jen.Action = {\n      r = r match {\n        case Some(prev) => Some(f(prev, o))\n        case _ => Some(o)\n      }\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def filter(p: T => B@pure): Jen[T] = {\n    return Jen.Internal.Filtered(this, p)\n  }\n\n  def withFilter(p: T => B): Jen[T] = {\n    return Jen.Internal.Filtered(this, p)\n  }\n\n  @pure def map[U](f: T => U@pure): Jen[U] = {\n    return Jen.Internal.Mapped(this, f)\n  }\n\n  @pure def flatMap[U](f: T => Jen[U]@pure): Jen[U] = {\n    return Jen.Internal.FlatMapped(this, f)\n  }\n\n  @pure def flatten[U](f: T => Jen[U]@pure): Jen[U] = {\n    return this.flatMap(o => f(o))\n  }\n\n  @pure def slice(start: Z, end: Z): Jen[T] = {\n    return Jen.Internal.Sliced(this, start, end)\n  }\n\n  @pure def take(n: Z): Jen[T] = {\n    return slice(0, n)\n  }\n\n  @pure def drop(n: Z): Jen[T] = {\n    return slice(n, -1)\n  }\n\n  @pure def takeWhile(p: T => B): Jen[T] = {\n    return Jen.Internal.TakeWhile(this, p)\n  }\n\n  @pure def dropWhile(p: T => B): Jen[T] = {\n    return Jen.Internal.DropWhile(this, p)\n  }\n\n  @pure def zipWithIndex: Jen[(T, Z)] = {\n    return Jen.Internal.ZipWithIndexed(this)\n  }\n\n  @pure def zip[U](other: Jen[U]): Jen[(T, U)] = {\n    return Jen.Internal.Zipped(this, other)\n  }\n\n  @pure def product[U](other: Jen[U]): Jen[(T, U)] = {\n    return Jen.Internal.Product(this, other)\n  }\n\n  @pure def ++(other: Jen[T]): Jen[T] = {\n    return Jen.Internal.Concat(this, other)\n  }\n\n  @pure def head: T = {\n    return take(1).toISZ(0)\n  }\n\n  @pure def headOption: Option[T] = {\n    val s = take(1).toISZ\n    return if (s.isEmpty) None() else Some(s(0))\n  }\n\n  @pure def toISZ: ISZ[T] = {\n    val r = toIS(ISZ[T]())\n    return r\n  }\n\n  @pure def toIS[I](init: IS[I, T]): IS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def toMSZ: MSZ[T] = {\n    val r = toMS(MSZ[T]())\n    return r\n  }\n\n  @pure def toMS[I](init: MS[I, T]): MS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def mkStringWrap(start: String, sep: String, end: String): String = {\n    return st\"$start${(toISZ, sep)}$end\".render\n  }\n\n  @pure def mkString(sep: String): String = {\n    return mkStringWrap(\"\", sep, \"\")\n  }\n\n}\n\nobject Jen {\n\n  type Action = B\n  val Continue: Action = T\n  val End: Action = F\n\n  object Internal {\n\n    @datatype class ISImpl[I, T](val s: IS[I, T]) extends Jen[T] {\n      override def generate(f: T => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return Jen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($s)\"\n      }\n    }\n\n    @datatype class MapImpl[K, T](val m: Map[K, T]) extends Jen[(K, T)] {\n      override def generate(f: ((K, T)) => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (e <- m.entries) {\n          last = f(e)\n          if (!last) {\n            return Jen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($m)\"\n      }\n    }\n\n    @datatype class HashMapImpl[K, T](val m: HashMap[K, T]) extends Jen[(K, T)] {\n      override def generate(f: ((K, T)) => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (ms <- m.mapEntries) {\n          if (ms.nonEmpty) {\n            for (e <- ms.entries) {\n              last = f(e)\n              if (!last) {\n                return Jen.End\n              }\n            }\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($m)\"\n      }\n    }\n\n    @datatype class Filtered[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      override def generate(f: T => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return Jen.Continue\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.filter($p)\"\n      }\n    }\n\n    @datatype class Mapped[U, T](val gen: Jen[T], val f: T => U@pure) extends Jen[U] {\n      override def generate(g: U => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          val r = g(f(o))\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.map($f)\"\n      }\n    }\n\n    @datatype class FlatMapped[U, T](val gen: Jen[T], val f: T => Jen[U]@pure) extends Jen[U] {\n      override def generate(g: U => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          def ap2(o2: U): Jen.Action = {\n            val r = g(o2)\n            return r\n          }\n\n          val r = f(o).generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.flatMap($f)\"\n      }\n    }\n\n    @datatype class Sliced[T](val gen: Jen[T], val start: Z, val end: Z) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var count = 0\n\n        def ap(o: T): Jen.Action = {\n          if (count < start) {\n            count = count + 1\n            return Jen.Continue\n          } else if (count < end || end < 0) {\n            count = count + 1\n            if (count != end) {\n              return f(o)\n            } else {\n              f(o)\n              return Jen.End\n            }\n          } else {\n            return Jen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return if (end < 0) s\"$gen.slice($start, ~)\" else s\"$gen.slice($start, $end)\"\n      }\n    }\n\n    @datatype class TakeWhile[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return Jen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.takeWhile($p)\"\n      }\n    }\n\n    @datatype class DropWhile[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var started = F\n\n        def ap(o: T): Jen.Action = {\n          if (!started) {\n            var r = p(o)\n            if (r) {\n              return Jen.Continue\n            } else {\n              started = T\n              r = f(o)\n              return r\n            }\n          } else {\n            val r = f(o)\n            return r\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.dropWhile($p)\"\n      }\n    }\n\n    @datatype class ZipWithIndexed[T](val gen: Jen[T]) extends Jen[(T, Z)] {\n      def generate(f: ((T, Z)) => Jen.Action): Jen.Action = {\n        var i = 0\n\n        def ap(o: T): Jen.Action = {\n          val r = f((o, i))\n          i = i + 1\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zipWithIndex\"\n      }\n    }\n\n    @datatype class Zipped[T, U](val gen: Jen[T], val gen2: Jen[U]) extends Jen[(T, U)] {\n      def generate(f: ((T, U)) => Jen.Action): Jen.Action = {\n        var g = gen\n        var g2 = gen2\n        var i = 1\n        while (true) {\n          (g.headOption, g2.headOption) match {\n            case (Some(h), Some(h2)) =>\n              val r = f((h, h2))\n              if (r) {\n                g = gen.drop(i)\n                g2 = gen2.drop(i)\n              } else {\n                return Jen.End\n              }\n            case _ => return Jen.End\n          }\n          i = i + 1\n        }\n        return Jen.End\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n    @datatype class Concat[T](val gen: Jen[T], val gen2: Jen[T]) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var r = gen.generate(f)\n        if (!r) {\n          return Jen.End\n        }\n        r = gen2.generate(f)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen ++ $gen2\"\n      }\n    }\n\n    @datatype class Product[T, U](val gen: Jen[T], val gen2: Jen[U]) extends Jen[(T, U)] {\n      def generate(f: ((T, U)) => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          def ap2(o2: U): Jen.Action = {\n            val r = f((o, o2))\n            return r\n          }\n\n          val r = gen2.generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n  }\n\n  @pure def IS[I, T](s: IS[I, T]): Jen[T] = {\n    return Internal.ISImpl(s)\n  }\n\n  @pure def Map[K, T](m: Map[K, T]): Jen[(K, T)] = {\n    return Internal.MapImpl(m)\n  }\n\n  @pure def Set[T](s: Set[T]): Jen[T] = {\n    return Internal.ISImpl(s.elements)\n  }\n\n  @pure def HashMap[K, T](m: HashMap[K, T]): Jen[(K, T)] = {\n    return Internal.HashMapImpl(m)\n  }\n\n  @pure def HashSet[T](s: HashSet[T]): Jen[T] = {\n    return Internal.HashMapImpl(s.map).map(p => p._1)\n  }\n\n  @pure def HashSMap[K, T](m: HashSMap[K, T]): Jen[(K, T)] = {\n    return IS(m.keys).map(k => (k, m.get(k).get))\n  }\n\n  @pure def HashSSet[T](s: HashSSet[T]): Jen[T] = {\n    return HashSMap(s.map).map(p => p._1)\n  }\n}\n
  #648 = String             #647          // // #Sireum\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Li Haoyi (haoyi.sg@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n */\n\npackage org.sireum\n\n// Adapted from https://github.com/lihaoyi/geny\n\n@sig trait Jen[T] {\n\n  def generate(f: T => Jen.Action): Jen.Action\n\n  def foreach[V](f: T => V): Unit = {\n    def ap(o: T): Jen.Action = {\n      f(o)\n      return Jen.Continue\n    }\n\n    generate(ap _)\n  }\n\n  def find(f: T => B): Option[T] = {\n    var result: Option[T] = None()\n\n    def ap(o: T): Jen.Action = {\n      val r = f(o)\n      if (!r) {\n        return Jen.Continue\n      } else {\n        result = Some(o)\n        return Jen.End\n      }\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  def exists(f: T => B): B = {\n    val r = find(f)\n    return r.nonEmpty\n  }\n\n  @pure def contains(o: T): B = {\n    return exists(e => e == o)\n  }\n\n  def forall(f: T => B): B = {\n    def ap(o: T): B = {\n      val r = f(o)\n      return !r\n    }\n    val r = exists(ap _)\n    return !r\n  }\n\n  @pure def count(): Z = {\n    return countIf(_ => T)\n  }\n\n  def countIf(p: T => B): Z = {\n    var result = 0\n\n    def ap(o: T): Jen.Action = {\n      val r = p(o)\n      if (r) {\n        result = result + 1\n      }\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  @pure def fold[U](initial: U, f: (U, T) => U@pure): U = {\n    return foldLeft(initial, f)\n  }\n\n  @pure def foldLeft[U](initial: U, f: (U, T) => U@pure): U = {\n    var r = initial\n\n    def ap(o: T): Jen.Action = {\n      r = f(r, o)\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def reduce(f: (T, T) => T@pure): Option[T] = {\n    return reduceLeft(f)\n  }\n\n  @pure def reduceLeft(f: (T, T) => T@pure): Option[T] = {\n    var r: Option[T] = None()\n\n    def ap(o: T): Jen.Action = {\n      r = r match {\n        case Some(prev) => Some(f(prev, o))\n        case _ => Some(o)\n      }\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def filter(p: T => B@pure): Jen[T] = {\n    return Jen.Internal.Filtered(this, p)\n  }\n\n  def withFilter(p: T => B): Jen[T] = {\n    return Jen.Internal.Filtered(this, p)\n  }\n\n  @pure def map[U](f: T => U@pure): Jen[U] = {\n    return Jen.Internal.Mapped(this, f)\n  }\n\n  @pure def flatMap[U](f: T => Jen[U]@pure): Jen[U] = {\n    return Jen.Internal.FlatMapped(this, f)\n  }\n\n  @pure def flatten[U](f: T => Jen[U]@pure): Jen[U] = {\n    return this.flatMap(o => f(o))\n  }\n\n  @pure def slice(start: Z, end: Z): Jen[T] = {\n    return Jen.Internal.Sliced(this, start, end)\n  }\n\n  @pure def take(n: Z): Jen[T] = {\n    return slice(0, n)\n  }\n\n  @pure def drop(n: Z): Jen[T] = {\n    return slice(n, -1)\n  }\n\n  @pure def takeWhile(p: T => B): Jen[T] = {\n    return Jen.Internal.TakeWhile(this, p)\n  }\n\n  @pure def dropWhile(p: T => B): Jen[T] = {\n    return Jen.Internal.DropWhile(this, p)\n  }\n\n  @pure def zipWithIndex: Jen[(T, Z)] = {\n    return Jen.Internal.ZipWithIndexed(this)\n  }\n\n  @pure def zip[U](other: Jen[U]): Jen[(T, U)] = {\n    return Jen.Internal.Zipped(this, other)\n  }\n\n  @pure def product[U](other: Jen[U]): Jen[(T, U)] = {\n    return Jen.Internal.Product(this, other)\n  }\n\n  @pure def ++(other: Jen[T]): Jen[T] = {\n    return Jen.Internal.Concat(this, other)\n  }\n\n  @pure def head: T = {\n    return take(1).toISZ(0)\n  }\n\n  @pure def headOption: Option[T] = {\n    val s = take(1).toISZ\n    return if (s.isEmpty) None() else Some(s(0))\n  }\n\n  @pure def toISZ: ISZ[T] = {\n    val r = toIS(ISZ[T]())\n    return r\n  }\n\n  @pure def toIS[I](init: IS[I, T]): IS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def toMSZ: MSZ[T] = {\n    val r = toMS(MSZ[T]())\n    return r\n  }\n\n  @pure def toMS[I](init: MS[I, T]): MS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def mkStringWrap(start: String, sep: String, end: String): String = {\n    return st\"$start${(toISZ, sep)}$end\".render\n  }\n\n  @pure def mkString(sep: String): String = {\n    return mkStringWrap(\"\", sep, \"\")\n  }\n\n}\n\nobject Jen {\n\n  type Action = B\n  val Continue: Action = T\n  val End: Action = F\n\n  object Internal {\n\n    @datatype class ISImpl[I, T](val s: IS[I, T]) extends Jen[T] {\n      override def generate(f: T => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return Jen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($s)\"\n      }\n    }\n\n    @datatype class MapImpl[K, T](val m: Map[K, T]) extends Jen[(K, T)] {\n      override def generate(f: ((K, T)) => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (e <- m.entries) {\n          last = f(e)\n          if (!last) {\n            return Jen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($m)\"\n      }\n    }\n\n    @datatype class HashMapImpl[K, T](val m: HashMap[K, T]) extends Jen[(K, T)] {\n      override def generate(f: ((K, T)) => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (ms <- m.mapEntries) {\n          if (ms.nonEmpty) {\n            for (e <- ms.entries) {\n              last = f(e)\n              if (!last) {\n                return Jen.End\n              }\n            }\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($m)\"\n      }\n    }\n\n    @datatype class Filtered[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      override def generate(f: T => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return Jen.Continue\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.filter($p)\"\n      }\n    }\n\n    @datatype class Mapped[U, T](val gen: Jen[T], val f: T => U@pure) extends Jen[U] {\n      override def generate(g: U => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          val r = g(f(o))\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.map($f)\"\n      }\n    }\n\n    @datatype class FlatMapped[U, T](val gen: Jen[T], val f: T => Jen[U]@pure) extends Jen[U] {\n      override def generate(g: U => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          def ap2(o2: U): Jen.Action = {\n            val r = g(o2)\n            return r\n          }\n\n          val r = f(o).generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.flatMap($f)\"\n      }\n    }\n\n    @datatype class Sliced[T](val gen: Jen[T], val start: Z, val end: Z) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var count = 0\n\n        def ap(o: T): Jen.Action = {\n          if (count < start) {\n            count = count + 1\n            return Jen.Continue\n          } else if (count < end || end < 0) {\n            count = count + 1\n            if (count != end) {\n              return f(o)\n            } else {\n              f(o)\n              return Jen.End\n            }\n          } else {\n            return Jen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return if (end < 0) s\"$gen.slice($start, ~)\" else s\"$gen.slice($start, $end)\"\n      }\n    }\n\n    @datatype class TakeWhile[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return Jen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.takeWhile($p)\"\n      }\n    }\n\n    @datatype class DropWhile[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var started = F\n\n        def ap(o: T): Jen.Action = {\n          if (!started) {\n            var r = p(o)\n            if (r) {\n              return Jen.Continue\n            } else {\n              started = T\n              r = f(o)\n              return r\n            }\n          } else {\n            val r = f(o)\n            return r\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.dropWhile($p)\"\n      }\n    }\n\n    @datatype class ZipWithIndexed[T](val gen: Jen[T]) extends Jen[(T, Z)] {\n      def generate(f: ((T, Z)) => Jen.Action): Jen.Action = {\n        var i = 0\n\n        def ap(o: T): Jen.Action = {\n          val r = f((o, i))\n          i = i + 1\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zipWithIndex\"\n      }\n    }\n\n    @datatype class Zipped[T, U](val gen: Jen[T], val gen2: Jen[U]) extends Jen[(T, U)] {\n      def generate(f: ((T, U)) => Jen.Action): Jen.Action = {\n        var g = gen\n        var g2 = gen2\n        var i = 1\n        while (true) {\n          (g.headOption, g2.headOption) match {\n            case (Some(h), Some(h2)) =>\n              val r = f((h, h2))\n              if (r) {\n                g = gen.drop(i)\n                g2 = gen2.drop(i)\n              } else {\n                return Jen.End\n              }\n            case _ => return Jen.End\n          }\n          i = i + 1\n        }\n        return Jen.End\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n    @datatype class Concat[T](val gen: Jen[T], val gen2: Jen[T]) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var r = gen.generate(f)\n        if (!r) {\n          return Jen.End\n        }\n        r = gen2.generate(f)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen ++ $gen2\"\n      }\n    }\n\n    @datatype class Product[T, U](val gen: Jen[T], val gen2: Jen[U]) extends Jen[(T, U)] {\n      def generate(f: ((T, U)) => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          def ap2(o2: U): Jen.Action = {\n            val r = f((o, o2))\n            return r\n          }\n\n          val r = gen2.generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n  }\n\n  @pure def IS[I, T](s: IS[I, T]): Jen[T] = {\n    return Internal.ISImpl(s)\n  }\n\n  @pure def Map[K, T](m: Map[K, T]): Jen[(K, T)] = {\n    return Internal.MapImpl(m)\n  }\n\n  @pure def Set[T](s: Set[T]): Jen[T] = {\n    return Internal.ISImpl(s.elements)\n  }\n\n  @pure def HashMap[K, T](m: HashMap[K, T]): Jen[(K, T)] = {\n    return Internal.HashMapImpl(m)\n  }\n\n  @pure def HashSet[T](s: HashSet[T]): Jen[T] = {\n    return Internal.HashMapImpl(s.map).map(p => p._1)\n  }\n\n  @pure def HashSMap[K, T](m: HashSMap[K, T]): Jen[(K, T)] = {\n    return IS(m.keys).map(k => (k, m.get(k).get))\n  }\n\n  @pure def HashSSet[T](s: HashSSet[T]): Jen[T] = {\n    return HashSMap(s.map).map(p => p._1)\n  }\n}\n
  #649 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject MOption {\n\n  @strictpure def some[T](value: T): MOption[T] = MSome(value)\n\n  @strictpure def none[T](): MOption[T] = MNone()\n\n}\n\n@record trait MOption[T] {\n\n  @pure def isEmpty: B = Contract.Only(\n    Ensures(Res == (this == MNone[T]()))\n  )\n\n  @pure def nonEmpty: B = Contract.Only(\n    Ensures(Res == !isEmpty)\n  )\n\n  @pure def map[T2](f: T => T2 @pure): MOption[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MNone[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == MSome(f(get)))\n    )\n  )\n\n  @pure def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MNone[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def forall(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == T)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def exists(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == F)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def get: T = Contract.Only(\n    Requires(nonEmpty),\n    Ensures(MSome(Res) == this)\n  )\n\n  @pure def getOrElse(default: => T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(MSome(Res) == this)\n    )\n  )\n\n  @pure def getOrElseEager(default: T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(MSome(Res) == this)\n    )\n  )\n\n  @pure def toMS: MSZ[T] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MSZ[T]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == MSZ[T](get))\n    )\n  )\n\n  def foreach[V](f: T => V): Unit\n}\n\n@record class MNone[T] extends MOption[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): MOption[T2] = {\n    Contract(Ensures(Res == MNone[T2]()))\n    return MNone[T2]()\n  }\n\n  @pure override def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = {\n    Contract(Ensures(Res == MNone[T2]()))\n    return MNone[T2]()\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def get: T = {\n    Contract(Requires(F))\n    halt(\"Invalid \'MNone\' operation \'get\'.\")\n  }\n\n  @pure override def toMS: MS[Z, T] = {\n    Contract(Ensures(Res[MSZ[T]].size == 0))\n    return MS[Z, T]()\n  }\n\n  def foreach[V](f: T => V): Unit = {}\n}\n\n@record class MSome[T](val value: T) extends MOption[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): MOption[T2] = {\n    Contract(Ensures(Res == MSome(f(value))))\n    return MSome(f(value))\n  }\n\n  @pure override def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def get: T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def toMS: MS[Z, T] = {\n    Contract(Ensures(Res == MSZ(value)))\n    return MSZ(value)\n  }\n\n  override def foreach[V](f: T => V): Unit = {\n    f(value)\n  }\n}\n
  #650 = String             #649          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject MOption {\n\n  @strictpure def some[T](value: T): MOption[T] = MSome(value)\n\n  @strictpure def none[T](): MOption[T] = MNone()\n\n}\n\n@record trait MOption[T] {\n\n  @pure def isEmpty: B = Contract.Only(\n    Ensures(Res == (this == MNone[T]()))\n  )\n\n  @pure def nonEmpty: B = Contract.Only(\n    Ensures(Res == !isEmpty)\n  )\n\n  @pure def map[T2](f: T => T2 @pure): MOption[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MNone[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == MSome(f(get)))\n    )\n  )\n\n  @pure def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MNone[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def forall(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == T)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def exists(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == F)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def get: T = Contract.Only(\n    Requires(nonEmpty),\n    Ensures(MSome(Res) == this)\n  )\n\n  @pure def getOrElse(default: => T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(MSome(Res) == this)\n    )\n  )\n\n  @pure def getOrElseEager(default: T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(MSome(Res) == this)\n    )\n  )\n\n  @pure def toMS: MSZ[T] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MSZ[T]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == MSZ[T](get))\n    )\n  )\n\n  def foreach[V](f: T => V): Unit\n}\n\n@record class MNone[T] extends MOption[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): MOption[T2] = {\n    Contract(Ensures(Res == MNone[T2]()))\n    return MNone[T2]()\n  }\n\n  @pure override def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = {\n    Contract(Ensures(Res == MNone[T2]()))\n    return MNone[T2]()\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def get: T = {\n    Contract(Requires(F))\n    halt(\"Invalid \'MNone\' operation \'get\'.\")\n  }\n\n  @pure override def toMS: MS[Z, T] = {\n    Contract(Ensures(Res[MSZ[T]].size == 0))\n    return MS[Z, T]()\n  }\n\n  def foreach[V](f: T => V): Unit = {}\n}\n\n@record class MSome[T](val value: T) extends MOption[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): MOption[T2] = {\n    Contract(Ensures(Res == MSome(f(value))))\n    return MSome(f(value))\n  }\n\n  @pure override def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def get: T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def toMS: MS[Z, T] = {\n    Contract(Ensures(Res == MSZ(value)))\n    return MSZ(value)\n  }\n\n  override def foreach[V](f: T => V): Unit = {\n    f(value)\n  }\n}\n
  #651 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSet {\n\n  @pure def empty[T]: HashSet[T] = {\n    return HashSet(HashMap.empty[T, B])\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSet[T] = {\n    return HashSet(HashMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSet[T] = {\n    return HashSet.emptyInit[T](s.size) ++ s\n  }\n}\n\n@datatype class HashSet[T](val map: HashMap[T, B]) {\n\n  @pure def +(e: T): HashSet[T] = {\n    return HashSet(map + e ~> T)\n  }\n\n  @pure def ++[I](is: IS[I, T]): HashSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSet[T] = {\n    return HashSet(map - e ~> T)\n  }\n\n  @pure def --[I](is: IS[I, T]): HashSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    return map.contains(e)\n  }\n\n  @pure def union(other: HashSet[T]): HashSet[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSet[T]): HashSet[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSet[T]): HashSet[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSet[T]): HashSet[T] = {\n    var r = HashSet.emptyInit[T](size)\n    for (e <- other.map.keys) {\n      if (contains(e)) {\n        r = r + e\n      }\n    }\n    return r\n  }\n\n  @pure def \\(other: HashSet[T]): HashSet[T] = {\n    return this -- other.elements\n  }\n\n  @pure def isEqual(other: HashSet[T]): B = {\n    return map.isEqual(other.map)\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    return map.size\n  }\n\n  @pure def elements: ISZ[T] = {\n    return map.keys\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
  #652 = String             #651          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSet {\n\n  @pure def empty[T]: HashSet[T] = {\n    return HashSet(HashMap.empty[T, B])\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSet[T] = {\n    return HashSet(HashMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSet[T] = {\n    return HashSet.emptyInit[T](s.size) ++ s\n  }\n}\n\n@datatype class HashSet[T](val map: HashMap[T, B]) {\n\n  @pure def +(e: T): HashSet[T] = {\n    return HashSet(map + e ~> T)\n  }\n\n  @pure def ++[I](is: IS[I, T]): HashSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSet[T] = {\n    return HashSet(map - e ~> T)\n  }\n\n  @pure def --[I](is: IS[I, T]): HashSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    return map.contains(e)\n  }\n\n  @pure def union(other: HashSet[T]): HashSet[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSet[T]): HashSet[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSet[T]): HashSet[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSet[T]): HashSet[T] = {\n    var r = HashSet.emptyInit[T](size)\n    for (e <- other.map.keys) {\n      if (contains(e)) {\n        r = r + e\n      }\n    }\n    return r\n  }\n\n  @pure def \\(other: HashSet[T]): HashSet[T] = {\n    return this -- other.elements\n  }\n\n  @pure def isEqual(other: HashSet[T]): B = {\n    return map.isEqual(other.map)\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    return map.size\n  }\n\n  @pure def elements: ISZ[T] = {\n    return map.keys\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
  #653 = Utf8               /*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n\n@ext object B {\n\n  def random: B = $\n\n}\n\n@ext trait B {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def &(other: B): B\n\n  @pure def |(other: B): B\n\n  @pure def |^(other: B): B\n\n  @pure def imply_:(other: B): B\n\n  @pure def ->:(other: B): B\n\n  @pure def =!=(other: B): B\n\n  @pure def ===(other: B): B\n\n  @pure def &&(other: => B): B\n\n  @pure def ||(other: => B): B\n\n  @pure def simply_:(other: => B): B\n\n  @pure def -->:(other: => B): B\n\n  @pure def unary_! : B\n\n  @pure def unary_~ : B\n\n}\n\n\n@ext object C {\n\n  def random: C = $\n\n}\n\n@ext trait C {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: C): B\n\n  @pure def <=(other: C): B\n\n  @pure def >(other: C): B\n\n  @pure def >=(other: C): B\n\n  @pure def ===(other: C): B\n\n  @pure def =!=(other: C): B\n\n  @pure def >>>(other: C): C\n\n  @pure def <<(other: C): C\n\n  @pure def &(other: C): C\n\n  @pure def |(other: C): C\n\n  @pure def |^(other: C): C\n\n  @pure def isWhitespace: B\n}\n\n\n@ext object Z {\n\n  def random: Z = $\n\n}\n\n@ext trait Z {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: Z): B\n\n  @pure def <=(other: Z): B\n\n  @pure def >(other: Z): B\n\n  @pure def >=(other: Z): B\n\n  @pure def ===(other: Z): B\n\n  @pure def =!=(other: Z): B\n\n  @pure def +(other: Z): Z\n\n  @pure def -(other: Z): Z\n\n  @pure def *(other: Z): Z\n\n  @pure def /(other: Z): Z\n\n  @pure def %(other: Z): Z\n\n  @pure def unary_- : Z\n\n  @pure def increase: Z\n\n  @pure def decrease: Z\n\n}\n\n\n@ext object F32 {\n\n  def random: F32 = $\n\n}\n\n@ext trait F32 {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: F32): B\n\n  @pure def <=(other: F32): B\n\n  @pure def >(other: F32): B\n\n  @pure def >=(other: F32): B\n\n  @pure def +(other: F32): F32\n\n  @pure def -(other: F32): F32\n\n  @pure def *(other: F32): F32\n\n  @pure def /(other: F32): F32\n\n  @pure def %(other: F32): F32\n\n  @pure def unary_- : F32\n\n}\n\n\n@ext object F64 {\n\n  def random: F64 = $\n\n}\n\n@ext trait F64 {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: F64): B\n\n  @pure def <=(other: F64): B\n\n  @pure def >(other: F64): B\n\n  @pure def >=(other: F64): B\n\n  @pure def +(other: F64): F64\n\n  @pure def -(other: F64): F64\n\n  @pure def *(other: F64): F64\n\n  @pure def /(other: F64): F64\n\n  @pure def %(other: F64): F64\n\n  @pure def unary_- : F64\n\n}\n\n\n@ext object R {\n\n  def random: R = $\n\n}\n\n@ext trait R {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: R): B\n\n  @pure def <=(other: R): B\n\n  @pure def >(other: R): B\n\n  @pure def >=(other: R): B\n\n  @pure def ===(other: R): B\n\n  @pure def =!=(other: R): B\n\n  @pure def +(other: R): R\n\n  @pure def -(other: R): R\n\n  @pure def *(other: R): R\n\n  @pure def /(other: R): R\n\n  @pure def unary_- : R\n\n}\n\n@ext object String {\n\n  def random: String = $\n\n}\n\n@ext trait String {\n\n  @pure def ===(other: String): B\n\n  @pure def =!=(other: String): B\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def size: Z\n\n}\n\n\n@ext trait ST {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def render: String\n\n  @pure def renderCompact: String\n\n}\n\n\n@ext object IS {\n\n  @pure def create[I, E](size: Z, default: E): IS[I, E] =\n    Contract.Only(\n      Requires(seqIndexValidSize[I](size)),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext trait IS[I, E] {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def isEmpty: B\n\n  @pure def nonEmpty: B\n\n  @pure def isInBound(i: I): B\n\n  @pure def :+(e: E): IS[I, E]\n\n  @pure def +:(e: E): IS[I, E]\n\n  @pure def ++[I2](other: IS[I2, E]): IS[I, E]\n\n  @pure def --[I2](other: IS[I2, E]): IS[I, E]\n\n  @pure def -(e: E): IS[I, E]\n\n  @pure def map[E2](f: E => E2 @pure): IS[I, E2]\n\n  @pure def flatMap[E2](f: E => IS[I, E2] @pure): IS[I, E2]\n\n  @pure def filter(p: E => B @pure): IS[I, E]\n\n  def foreach[V](p: E => V): Unit\n\n  @pure def size: Z\n\n  @pure def firstIndex: I\n\n  @pure def lastIndex: I\n\n  @pure def indices: ISZ[I]\n\n  @pure def atZ(index: Z): E\n\n  @pure def toMS: MS[I, E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(Res.indices)(i => Res(i) == this(i))\n      )\n    )\n\n  @pure def toISZ: ISZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n\n  @pure def toMSZ: MSZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n}\n\n@ext object ISZ {\n\n  @pure def create[E](size: Z, default: E): ISZ[E] =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext object MS {\n\n  @pure def create[I, E](size: Z, default: E): MS[I, E] =\n    Contract.Only(\n      Requires(seqIndexValidSize[I](size)),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext trait MS[I, E] {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def isEmpty: B\n\n  @pure def nonEmpty: B\n\n  @pure def isInBound(i: I): B\n\n  @pure def :+(e: E): MS[I, E]\n\n  @pure def +:(e: E): MS[I, E]\n\n  @pure def ++[I2](other: MS[I2, E]): MS[I, E]\n\n  @pure def --[I2](other: MS[I2, E]): MS[I, E]\n\n  @pure def -(e: E): MS[I, E]\n\n  @pure def map[E2](f: E => E2 @pure): MS[I, E2]\n\n  @pure def flatMap[E2](f: E => MS[I, E2] @pure): MS[I, E2]\n\n  @pure def filter(p: E => B @pure): MS[I, E]\n\n  def foreach[V](p: E => V): Unit\n\n  @pure def size: Z\n\n  @pure def firstIndex: I\n\n  @pure def lastIndex: I\n\n  @pure def indices: ISZ[I]\n\n  @pure def atZ(index: Z): E\n\n  @pure def toIS: IS[I, E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(Res.indices)(i => Res(i) == this(i))\n      )\n    )\n\n  @pure def toISZ: ISZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n\n  @pure def toMSZ: MSZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n}\n\n@ext object MSZ {\n\n  @pure def create[E](size: Z, default: E): MSZ[E] =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext object ZS {\n\n  def random: ZS = $\n\n  @pure def create(size: Z, default: Z): ZS =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n}\n\n@ext object Sireum {\n\n  def run(args: ISZ[String]): Z = $\n\n  def initRuntimeLibrary(): Unit = $\n\n}
  #654 = String             #653          // /*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n\n@ext object B {\n\n  def random: B = $\n\n}\n\n@ext trait B {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def &(other: B): B\n\n  @pure def |(other: B): B\n\n  @pure def |^(other: B): B\n\n  @pure def imply_:(other: B): B\n\n  @pure def ->:(other: B): B\n\n  @pure def =!=(other: B): B\n\n  @pure def ===(other: B): B\n\n  @pure def &&(other: => B): B\n\n  @pure def ||(other: => B): B\n\n  @pure def simply_:(other: => B): B\n\n  @pure def -->:(other: => B): B\n\n  @pure def unary_! : B\n\n  @pure def unary_~ : B\n\n}\n\n\n@ext object C {\n\n  def random: C = $\n\n}\n\n@ext trait C {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: C): B\n\n  @pure def <=(other: C): B\n\n  @pure def >(other: C): B\n\n  @pure def >=(other: C): B\n\n  @pure def ===(other: C): B\n\n  @pure def =!=(other: C): B\n\n  @pure def >>>(other: C): C\n\n  @pure def <<(other: C): C\n\n  @pure def &(other: C): C\n\n  @pure def |(other: C): C\n\n  @pure def |^(other: C): C\n\n  @pure def isWhitespace: B\n}\n\n\n@ext object Z {\n\n  def random: Z = $\n\n}\n\n@ext trait Z {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: Z): B\n\n  @pure def <=(other: Z): B\n\n  @pure def >(other: Z): B\n\n  @pure def >=(other: Z): B\n\n  @pure def ===(other: Z): B\n\n  @pure def =!=(other: Z): B\n\n  @pure def +(other: Z): Z\n\n  @pure def -(other: Z): Z\n\n  @pure def *(other: Z): Z\n\n  @pure def /(other: Z): Z\n\n  @pure def %(other: Z): Z\n\n  @pure def unary_- : Z\n\n  @pure def increase: Z\n\n  @pure def decrease: Z\n\n}\n\n\n@ext object F32 {\n\n  def random: F32 = $\n\n}\n\n@ext trait F32 {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: F32): B\n\n  @pure def <=(other: F32): B\n\n  @pure def >(other: F32): B\n\n  @pure def >=(other: F32): B\n\n  @pure def +(other: F32): F32\n\n  @pure def -(other: F32): F32\n\n  @pure def *(other: F32): F32\n\n  @pure def /(other: F32): F32\n\n  @pure def %(other: F32): F32\n\n  @pure def unary_- : F32\n\n}\n\n\n@ext object F64 {\n\n  def random: F64 = $\n\n}\n\n@ext trait F64 {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: F64): B\n\n  @pure def <=(other: F64): B\n\n  @pure def >(other: F64): B\n\n  @pure def >=(other: F64): B\n\n  @pure def +(other: F64): F64\n\n  @pure def -(other: F64): F64\n\n  @pure def *(other: F64): F64\n\n  @pure def /(other: F64): F64\n\n  @pure def %(other: F64): F64\n\n  @pure def unary_- : F64\n\n}\n\n\n@ext object R {\n\n  def random: R = $\n\n}\n\n@ext trait R {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: R): B\n\n  @pure def <=(other: R): B\n\n  @pure def >(other: R): B\n\n  @pure def >=(other: R): B\n\n  @pure def ===(other: R): B\n\n  @pure def =!=(other: R): B\n\n  @pure def +(other: R): R\n\n  @pure def -(other: R): R\n\n  @pure def *(other: R): R\n\n  @pure def /(other: R): R\n\n  @pure def unary_- : R\n\n}\n\n@ext object String {\n\n  def random: String = $\n\n}\n\n@ext trait String {\n\n  @pure def ===(other: String): B\n\n  @pure def =!=(other: String): B\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def size: Z\n\n}\n\n\n@ext trait ST {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def render: String\n\n  @pure def renderCompact: String\n\n}\n\n\n@ext object IS {\n\n  @pure def create[I, E](size: Z, default: E): IS[I, E] =\n    Contract.Only(\n      Requires(seqIndexValidSize[I](size)),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext trait IS[I, E] {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def isEmpty: B\n\n  @pure def nonEmpty: B\n\n  @pure def isInBound(i: I): B\n\n  @pure def :+(e: E): IS[I, E]\n\n  @pure def +:(e: E): IS[I, E]\n\n  @pure def ++[I2](other: IS[I2, E]): IS[I, E]\n\n  @pure def --[I2](other: IS[I2, E]): IS[I, E]\n\n  @pure def -(e: E): IS[I, E]\n\n  @pure def map[E2](f: E => E2 @pure): IS[I, E2]\n\n  @pure def flatMap[E2](f: E => IS[I, E2] @pure): IS[I, E2]\n\n  @pure def filter(p: E => B @pure): IS[I, E]\n\n  def foreach[V](p: E => V): Unit\n\n  @pure def size: Z\n\n  @pure def firstIndex: I\n\n  @pure def lastIndex: I\n\n  @pure def indices: ISZ[I]\n\n  @pure def atZ(index: Z): E\n\n  @pure def toMS: MS[I, E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(Res.indices)(i => Res(i) == this(i))\n      )\n    )\n\n  @pure def toISZ: ISZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n\n  @pure def toMSZ: MSZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n}\n\n@ext object ISZ {\n\n  @pure def create[E](size: Z, default: E): ISZ[E] =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext object MS {\n\n  @pure def create[I, E](size: Z, default: E): MS[I, E] =\n    Contract.Only(\n      Requires(seqIndexValidSize[I](size)),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext trait MS[I, E] {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def isEmpty: B\n\n  @pure def nonEmpty: B\n\n  @pure def isInBound(i: I): B\n\n  @pure def :+(e: E): MS[I, E]\n\n  @pure def +:(e: E): MS[I, E]\n\n  @pure def ++[I2](other: MS[I2, E]): MS[I, E]\n\n  @pure def --[I2](other: MS[I2, E]): MS[I, E]\n\n  @pure def -(e: E): MS[I, E]\n\n  @pure def map[E2](f: E => E2 @pure): MS[I, E2]\n\n  @pure def flatMap[E2](f: E => MS[I, E2] @pure): MS[I, E2]\n\n  @pure def filter(p: E => B @pure): MS[I, E]\n\n  def foreach[V](p: E => V): Unit\n\n  @pure def size: Z\n\n  @pure def firstIndex: I\n\n  @pure def lastIndex: I\n\n  @pure def indices: ISZ[I]\n\n  @pure def atZ(index: Z): E\n\n  @pure def toIS: IS[I, E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(Res.indices)(i => Res(i) == this(i))\n      )\n    )\n\n  @pure def toISZ: ISZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n\n  @pure def toMSZ: MSZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n}\n\n@ext object MSZ {\n\n  @pure def create[E](size: Z, default: E): MSZ[E] =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext object ZS {\n\n  def random: ZS = $\n\n  @pure def create(size: Z, default: Z): ZS =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n}\n\n@ext object Sireum {\n\n  def run(args: ISZ[String]): Z = $\n\n  def initRuntimeLibrary(): Unit = $\n\n}
  #655 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.message\n\nimport org.sireum._\nimport org.sireum.U64._\n\n@enum object Level {\n  \"InternalError\"\n  \"Error\"\n  \"Warning\"\n  \"Info\"\n}\n\n@datatype class Message(val level: Level.Type, val posOpt: Option[Position], val kind: String, val text: String) {\n\n  def isInternalError: B = {\n    return level == Level.InternalError\n  }\n\n  def isError: B = {\n    return level == Level.Error\n  }\n\n  def isWarning: B = {\n    return level == Level.Warning\n  }\n\n  def isInfo: B = {\n    return level == Level.Info\n  }\n\n  def fileUriOpt: Option[String] = {\n    posOpt match {\n      case Some(pos) => return pos.uriOpt\n      case _ => return None()\n    }\n  }\n}\n\nimport org.sireum.U32._\n\nobject Position {\n  val none: Position = FlatPos(None(), u32\"1\", u32\"1\", u32\"1\", u32\"1\", u32\"0\", u32\"0\")\n}\n\n@datatype trait Position {\n\n//  l\"\"\" invariant LinePos:            beginLine ≥ 1\n//                 ColumnPos:          beginColumn ≥ 1\n//                 EndLinePos:         endLine ≥ 1\n//                 EncColumnPos:       endColumn ≥ 1\n//                 OffsetNonNegative:  offset ≥ 0\n//                 LengthNonNegative:  length ≥ 0 \"\"\"\n\n  @pure def uriOpt: Option[String]\n\n  @pure def beginLine: Z\n\n  @pure def beginColumn: Z\n\n  @pure def endLine: Z\n\n  @pure def endColumn: Z\n\n  @pure def offset: Z\n\n  @pure def length: Z\n\n  @pure override def hash: Z = {\n    return (uriOpt, beginLine, endLine, endColumn, offset, length).hash\n  }\n\n  @pure def isEqual(other: Position): B = {\n    return uriOpt == other.uriOpt && beginLine == other.beginLine && beginColumn == other.beginColumn &&\n      endLine == other.endLine && endColumn == other.endColumn && offset == other.offset && length == other.length\n  }\n\n  @pure override def string: String = {\n    uriOpt match {\n      case Some(fileUri) =>\n        var i = ops.StringOps(fileUri).lastIndexOf(\'/\')\n        if (i < 0) {\n          i = 0\n        }\n        return s\"[${ops.StringOps(fileUri).substring(i, fileUri.size)}, $beginLine, $beginColumn]\"\n      case _ => return s\"[$beginLine, $beginColumn]\"\n    }\n\n  }\n\n  @pure def to(other: Position): Position = {\n    val pos1 = this\n    val pos2 = other\n    var docInfoOpt: Option[message.DocInfo] = None()\n    pos1 match {\n      case pos1: PosInfo => docInfoOpt = Some(pos1.info)\n      case _ =>\n        pos2 match {\n          case pos2: PosInfo => docInfoOpt = Some(pos2.info)\n          case _ =>\n        }\n    }\n    docInfoOpt match {\n      case Some(info) =>\n        return PosInfo(info, (conversions.Z.toU64(pos1.offset) << u64\"32\") |\n          conversions.Z.toU64(pos2.offset + pos2.length - pos1.offset))\n      case _ =>\n        return FlatPos(\n          uriOpt = pos1.uriOpt,\n          beginLine32 = conversions.Z.toU32(pos1.beginLine),\n          beginColumn32 = conversions.Z.toU32(pos1.beginColumn),\n          endLine32 = conversions.Z.toU32(pos2.endLine),\n          endColumn32 = conversions.Z.toU32(pos2.endColumn),\n          offset32 = conversions.Z.toU32(pos1.offset),\n          length32 = conversions.Z.toU32(pos2.offset + pos2.length - pos1.offset)\n        )\n    }\n  }\n\n}\n\n@datatype class FlatPos(\n  val uriOpt: Option[String],\n  val beginLine32: U32,\n  val beginColumn32: U32,\n  val endLine32: U32,\n  val endColumn32: U32,\n  val offset32: U32,\n  val length32: U32\n) extends Position {\n\n  @pure override def beginLine: Z = {\n    return conversions.U32.toZ(beginLine32)\n  }\n\n  @pure override def beginColumn: Z = {\n    return conversions.U32.toZ(beginColumn32)\n  }\n\n  @pure override def endLine: Z = {\n    return conversions.U32.toZ(endLine32)\n  }\n\n  @pure override def endColumn: Z = {\n    return conversions.U32.toZ(endColumn32)\n  }\n\n  @pure override def offset: Z = {\n    return conversions.U32.toZ(offset32)\n  }\n\n  @pure override def length: Z = {\n    return conversions.U32.toZ(length32)\n  }\n}\n\n@datatype class PosInfo(val info: DocInfo, val offsetLength: U64) extends Position {\n\n  @pure override def uriOpt: Option[String] = {\n    return info.uriOpt\n  }\n\n  @pure override def beginLine: Z = {\n    return conversions.U64.toZ(info.lineColumn(offsetLength) >>> u64\"32\")\n  }\n\n  @pure override def beginColumn: Z = {\n    return conversions.U64.toZ(info.lineColumn(offsetLength) & u64\"0xFFFFFFFF\")\n  }\n\n  @pure override def endLine: Z = {\n    val endOffset = offsetLength + ((offsetLength - u64\"1\") << u64\"32\")\n    return conversions.U64.toZ(info.lineColumn(endOffset) >>> u64\"32\")\n  }\n\n  @pure override def endColumn: Z = {\n    val endOffset = offsetLength + ((offsetLength - u64\"1\") << u64\"32\")\n    return conversions.U64.toZ(info.lineColumn(endOffset) & u64\"0xFFFFFFFF\")\n  }\n\n  @pure override def offset: Z = {\n    return conversions.U64.toZ(offsetLength >>> u64\"32\")\n  }\n\n  @pure override def length: Z = {\n    return conversions.U64.toZ(offsetLength & u64\"0xFFFFFFFF\")\n  }\n}\n\n@datatype class DocInfo(val uriOpt: Option[String], val lineOffsets: ISZ[U32]) {\n\n  @pure def lineColumn(offsetLength: U64): U64 = {\n    val offsetLine = conversions.U64.toU32(offsetLength >>> u64\"32\")\n    @pure def computeLC(i: Z): U64 = {\n      val line = conversions.Z.toU64(i + 1) << u64\"32\"\n      val column = conversions.U32.toU64(offsetLine - lineOffsets(i)) + u64\"1\"\n      return line | column\n    }\n    val size = lineOffsets.size\n    var i = size / 2\n    var max = size - 1\n    var min = z\"0\"\n    while (min < i && i <= max) {\n      val lineOffsetsI = lineOffsets(i)\n      if (offsetLine < lineOffsetsI) {\n        if (lineOffsets(i - 1) <= offsetLine) {\n          return computeLC(i - 1)\n        }\n        max = i\n        i = i - ((i - min) / 2)\n      } else if (offsetLine == lineOffsetsI) {\n        return computeLC(i)\n      } else {\n        min = i\n        i = i + (max - i) / 2\n      }\n    }\n    return if (i <= min) computeLC(min) else computeLC(max)\n  }\n}\n\nobject DocInfo {\n\n  @pure def create(uriOpt: Option[String], input: String): DocInfo = {\n    val inputOps = ops.StringOps(input)\n    var i = inputOps.indexOf(\'\\n\')\n    var lineOffsets = ISZ[U32](u32\"0\")\n    while (0 <= i && i < input.size) {\n      lineOffsets = lineOffsets :+ conversions.Z.toU32(i + 1)\n      i = inputOps.indexOfFrom(\'\\n\', i + 1)\n    }\n    return DocInfo(uriOpt, lineOffsets)\n  }\n\n}\n
  #656 = String             #655          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.message\n\nimport org.sireum._\nimport org.sireum.U64._\n\n@enum object Level {\n  \"InternalError\"\n  \"Error\"\n  \"Warning\"\n  \"Info\"\n}\n\n@datatype class Message(val level: Level.Type, val posOpt: Option[Position], val kind: String, val text: String) {\n\n  def isInternalError: B = {\n    return level == Level.InternalError\n  }\n\n  def isError: B = {\n    return level == Level.Error\n  }\n\n  def isWarning: B = {\n    return level == Level.Warning\n  }\n\n  def isInfo: B = {\n    return level == Level.Info\n  }\n\n  def fileUriOpt: Option[String] = {\n    posOpt match {\n      case Some(pos) => return pos.uriOpt\n      case _ => return None()\n    }\n  }\n}\n\nimport org.sireum.U32._\n\nobject Position {\n  val none: Position = FlatPos(None(), u32\"1\", u32\"1\", u32\"1\", u32\"1\", u32\"0\", u32\"0\")\n}\n\n@datatype trait Position {\n\n//  l\"\"\" invariant LinePos:            beginLine ≥ 1\n//                 ColumnPos:          beginColumn ≥ 1\n//                 EndLinePos:         endLine ≥ 1\n//                 EncColumnPos:       endColumn ≥ 1\n//                 OffsetNonNegative:  offset ≥ 0\n//                 LengthNonNegative:  length ≥ 0 \"\"\"\n\n  @pure def uriOpt: Option[String]\n\n  @pure def beginLine: Z\n\n  @pure def beginColumn: Z\n\n  @pure def endLine: Z\n\n  @pure def endColumn: Z\n\n  @pure def offset: Z\n\n  @pure def length: Z\n\n  @pure override def hash: Z = {\n    return (uriOpt, beginLine, endLine, endColumn, offset, length).hash\n  }\n\n  @pure def isEqual(other: Position): B = {\n    return uriOpt == other.uriOpt && beginLine == other.beginLine && beginColumn == other.beginColumn &&\n      endLine == other.endLine && endColumn == other.endColumn && offset == other.offset && length == other.length\n  }\n\n  @pure override def string: String = {\n    uriOpt match {\n      case Some(fileUri) =>\n        var i = ops.StringOps(fileUri).lastIndexOf(\'/\')\n        if (i < 0) {\n          i = 0\n        }\n        return s\"[${ops.StringOps(fileUri).substring(i, fileUri.size)}, $beginLine, $beginColumn]\"\n      case _ => return s\"[$beginLine, $beginColumn]\"\n    }\n\n  }\n\n  @pure def to(other: Position): Position = {\n    val pos1 = this\n    val pos2 = other\n    var docInfoOpt: Option[message.DocInfo] = None()\n    pos1 match {\n      case pos1: PosInfo => docInfoOpt = Some(pos1.info)\n      case _ =>\n        pos2 match {\n          case pos2: PosInfo => docInfoOpt = Some(pos2.info)\n          case _ =>\n        }\n    }\n    docInfoOpt match {\n      case Some(info) =>\n        return PosInfo(info, (conversions.Z.toU64(pos1.offset) << u64\"32\") |\n          conversions.Z.toU64(pos2.offset + pos2.length - pos1.offset))\n      case _ =>\n        return FlatPos(\n          uriOpt = pos1.uriOpt,\n          beginLine32 = conversions.Z.toU32(pos1.beginLine),\n          beginColumn32 = conversions.Z.toU32(pos1.beginColumn),\n          endLine32 = conversions.Z.toU32(pos2.endLine),\n          endColumn32 = conversions.Z.toU32(pos2.endColumn),\n          offset32 = conversions.Z.toU32(pos1.offset),\n          length32 = conversions.Z.toU32(pos2.offset + pos2.length - pos1.offset)\n        )\n    }\n  }\n\n}\n\n@datatype class FlatPos(\n  val uriOpt: Option[String],\n  val beginLine32: U32,\n  val beginColumn32: U32,\n  val endLine32: U32,\n  val endColumn32: U32,\n  val offset32: U32,\n  val length32: U32\n) extends Position {\n\n  @pure override def beginLine: Z = {\n    return conversions.U32.toZ(beginLine32)\n  }\n\n  @pure override def beginColumn: Z = {\n    return conversions.U32.toZ(beginColumn32)\n  }\n\n  @pure override def endLine: Z = {\n    return conversions.U32.toZ(endLine32)\n  }\n\n  @pure override def endColumn: Z = {\n    return conversions.U32.toZ(endColumn32)\n  }\n\n  @pure override def offset: Z = {\n    return conversions.U32.toZ(offset32)\n  }\n\n  @pure override def length: Z = {\n    return conversions.U32.toZ(length32)\n  }\n}\n\n@datatype class PosInfo(val info: DocInfo, val offsetLength: U64) extends Position {\n\n  @pure override def uriOpt: Option[String] = {\n    return info.uriOpt\n  }\n\n  @pure override def beginLine: Z = {\n    return conversions.U64.toZ(info.lineColumn(offsetLength) >>> u64\"32\")\n  }\n\n  @pure override def beginColumn: Z = {\n    return conversions.U64.toZ(info.lineColumn(offsetLength) & u64\"0xFFFFFFFF\")\n  }\n\n  @pure override def endLine: Z = {\n    val endOffset = offsetLength + ((offsetLength - u64\"1\") << u64\"32\")\n    return conversions.U64.toZ(info.lineColumn(endOffset) >>> u64\"32\")\n  }\n\n  @pure override def endColumn: Z = {\n    val endOffset = offsetLength + ((offsetLength - u64\"1\") << u64\"32\")\n    return conversions.U64.toZ(info.lineColumn(endOffset) & u64\"0xFFFFFFFF\")\n  }\n\n  @pure override def offset: Z = {\n    return conversions.U64.toZ(offsetLength >>> u64\"32\")\n  }\n\n  @pure override def length: Z = {\n    return conversions.U64.toZ(offsetLength & u64\"0xFFFFFFFF\")\n  }\n}\n\n@datatype class DocInfo(val uriOpt: Option[String], val lineOffsets: ISZ[U32]) {\n\n  @pure def lineColumn(offsetLength: U64): U64 = {\n    val offsetLine = conversions.U64.toU32(offsetLength >>> u64\"32\")\n    @pure def computeLC(i: Z): U64 = {\n      val line = conversions.Z.toU64(i + 1) << u64\"32\"\n      val column = conversions.U32.toU64(offsetLine - lineOffsets(i)) + u64\"1\"\n      return line | column\n    }\n    val size = lineOffsets.size\n    var i = size / 2\n    var max = size - 1\n    var min = z\"0\"\n    while (min < i && i <= max) {\n      val lineOffsetsI = lineOffsets(i)\n      if (offsetLine < lineOffsetsI) {\n        if (lineOffsets(i - 1) <= offsetLine) {\n          return computeLC(i - 1)\n        }\n        max = i\n        i = i - ((i - min) / 2)\n      } else if (offsetLine == lineOffsetsI) {\n        return computeLC(i)\n      } else {\n        min = i\n        i = i + (max - i) / 2\n      }\n    }\n    return if (i <= min) computeLC(min) else computeLC(max)\n  }\n}\n\nobject DocInfo {\n\n  @pure def create(uriOpt: Option[String], input: String): DocInfo = {\n    val inputOps = ops.StringOps(input)\n    var i = inputOps.indexOf(\'\\n\')\n    var lineOffsets = ISZ[U32](u32\"0\")\n    while (0 <= i && i < input.size) {\n      lineOffsets = lineOffsets :+ conversions.Z.toU32(i + 1)\n      i = inputOps.indexOfFrom(\'\\n\', i + 1)\n    }\n    return DocInfo(uriOpt, lineOffsets)\n  }\n\n}\n
  #657 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.message\n\nimport org.sireum._\n\nobject Reporter {\n\n  @pure def create: Reporter = {\n    return ReporterImpl(ISZ())\n  }\n\n  @pure def combine(r1: Reporter, r2: Reporter): Reporter = {\n    return ReporterImpl(r1.messages ++ r2.messages)\n  }\n}\n\n@msig trait Reporter {\n  def messages: ISZ[Message]\n  def ignore: B\n  def setIgnore(newIgnore: B): Unit\n  def setMessages(newMessages: ISZ[Message]): Unit\n  def timing(desc: String, timeInMs: Z): Unit\n\n  def hasInternalError: B = {\n    for (m <- messages) {\n      m.level match {\n        case Level.InternalError => return T\n        case _ =>\n      }\n    }\n    return F\n  }\n\n  def hasError: B = {\n    for (m <- messages if m.isError || m.isInternalError) {\n      return T\n    }\n    return F\n  }\n\n  def hasWarning: B = {\n    for (m <- messages if m.isWarning) {\n      return T\n    }\n    return F\n  }\n\n  def hasIssue: B = {\n    for (m <- messages if m.isError || m.isWarning || m.isInternalError) {\n      return T\n    }\n    return F\n  }\n\n  def hasInfo: B = {\n    for (m <- messages if m.isInfo) {\n      return T\n    }\n    return F\n  }\n\n  def hasMessage: B = {\n    return messages.nonEmpty\n  }\n\n  def internalErrors: ISZ[Message] = {\n    return for (m <- messages if m.isInternalError) yield m\n  }\n\n  def errors: ISZ[Message] = {\n    return for (m <- messages if m.isError) yield m\n  }\n\n  def warnings: ISZ[Message] = {\n    return for (m <- messages if m.isWarning) yield m\n  }\n\n  def issues: ISZ[Message] = {\n    return for (m <- messages if m.isError || m.isWarning || m.isInternalError) yield m\n  }\n\n  def infos: ISZ[Message] = {\n    return for (m <- messages if m.isInfo) yield m\n  }\n\n  def report(m: Message): Unit = {\n    //assert(m.fileUriOpt.isEmpty || !ops.ISZOps(messages).contains(m))\n    if (!ignore) {\n      setMessages(messages :+ m)\n    }\n  }\n\n  def messagesByFileUri: HashSMap[Option[String], ISZ[Message]] = {\n    var r = HashSMap.empty[Option[String], ISZ[Message]]\n    for (m <- messages) {\n      val key: Option[String] = m.fileUriOpt\n      r.get(key) match {\n        case Some(ms) => r = r + key ~> (ms :+ m)\n        case _ => r = r + key ~> ISZ(m)\n      }\n    }\n    return r\n  }\n\n  def printMessages(): Unit = {\n    @pure def sortMessages(ms: ISZ[Message]): ISZ[Message] = {\n      return ops\n        .ISZOps(ms)\n        .sortWith((m1, m2) => {\n          (m1.posOpt, m2.posOpt) match {\n            case (Some(m1pos), Some(m2pos)) =>\n              if (m1pos.beginLine < m2pos.beginLine) T\n              else if (m1pos.beginLine > m2pos.beginLine) F\n              else if (m1pos.beginColumn < m2pos.beginColumn) T\n              else if (m1pos.beginColumn > m2pos.beginColumn) F\n              else false\n            case _ => false\n          }\n        })\n    }\n    val map = messagesByFileUri\n    val err = hasError\n    var first = T\n    for (kv <- map.entries) {\n      if (!first) {\n        cprintln(err, \"\")\n      }\n      first = F\n      val fileUriOpt = kv._1\n      val ms = kv._2\n      fileUriOpt match {\n        case Some(fileUri) =>\n          cprintln(err, s\"* $fileUri\")\n          for (m <- sortMessages(ms)) {\n            cprint(err, \"  \")\n            val int: String = if (m.level == Level.InternalError) \"INTERNAL ERROR -- \" else \"\"\n            val mText: String = m.posOpt match {\n              case Some(pos) => s\"- [${pos.beginLine}, ${pos.beginColumn}] $int${m.text}\"\n              case _ => s\"- ${m.text}\"\n            }\n            cprintln(err, mText)\n          }\n        case _ =>\n          for (m <- sortMessages(ms)) {\n            val int: String = if (m.level == Level.InternalError) \"INTERNAL ERROR -- \" else \"\"\n            val mText: String = m.posOpt match {\n              case Some(pos) => s\"- [${pos.beginLine}, ${pos.beginColumn}] $int${m.text}\"\n              case _ => s\"- ${m.text}\"\n            }\n            cprintln(err, mText)\n          }\n      }\n    }\n  }\n\n  def internalError(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.InternalError, posOpt, kind, message))\n    }\n  }\n\n  def error(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Error, posOpt, kind, message))\n    }\n  }\n\n  def warn(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Warning, posOpt, kind, message))\n    }\n  }\n\n  def info(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Info, posOpt, kind, message))\n    }\n  }\n\n  def reports(ms: ISZ[Message]): Unit = {\n    for (m <- ms) {\n      report(m)\n    }\n  }\n}\n\n@record class ReporterImpl(var _messages: ISZ[Message]) extends Reporter {\n\n  var ignore: B = F\n\n  def setIgnore(newIgnore: B): Unit = {\n    ignore = newIgnore\n  }\n\n  def messages: ISZ[Message] = {\n    return _messages\n  }\n\n  def setMessages(newMessages: ISZ[Message]): Unit = {\n    _messages = newMessages\n  }\n\n  def timing(desc: String, timeInMs: Z): Unit = {}\n\n}\n
  #658 = String             #657          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.message\n\nimport org.sireum._\n\nobject Reporter {\n\n  @pure def create: Reporter = {\n    return ReporterImpl(ISZ())\n  }\n\n  @pure def combine(r1: Reporter, r2: Reporter): Reporter = {\n    return ReporterImpl(r1.messages ++ r2.messages)\n  }\n}\n\n@msig trait Reporter {\n  def messages: ISZ[Message]\n  def ignore: B\n  def setIgnore(newIgnore: B): Unit\n  def setMessages(newMessages: ISZ[Message]): Unit\n  def timing(desc: String, timeInMs: Z): Unit\n\n  def hasInternalError: B = {\n    for (m <- messages) {\n      m.level match {\n        case Level.InternalError => return T\n        case _ =>\n      }\n    }\n    return F\n  }\n\n  def hasError: B = {\n    for (m <- messages if m.isError || m.isInternalError) {\n      return T\n    }\n    return F\n  }\n\n  def hasWarning: B = {\n    for (m <- messages if m.isWarning) {\n      return T\n    }\n    return F\n  }\n\n  def hasIssue: B = {\n    for (m <- messages if m.isError || m.isWarning || m.isInternalError) {\n      return T\n    }\n    return F\n  }\n\n  def hasInfo: B = {\n    for (m <- messages if m.isInfo) {\n      return T\n    }\n    return F\n  }\n\n  def hasMessage: B = {\n    return messages.nonEmpty\n  }\n\n  def internalErrors: ISZ[Message] = {\n    return for (m <- messages if m.isInternalError) yield m\n  }\n\n  def errors: ISZ[Message] = {\n    return for (m <- messages if m.isError) yield m\n  }\n\n  def warnings: ISZ[Message] = {\n    return for (m <- messages if m.isWarning) yield m\n  }\n\n  def issues: ISZ[Message] = {\n    return for (m <- messages if m.isError || m.isWarning || m.isInternalError) yield m\n  }\n\n  def infos: ISZ[Message] = {\n    return for (m <- messages if m.isInfo) yield m\n  }\n\n  def report(m: Message): Unit = {\n    //assert(m.fileUriOpt.isEmpty || !ops.ISZOps(messages).contains(m))\n    if (!ignore) {\n      setMessages(messages :+ m)\n    }\n  }\n\n  def messagesByFileUri: HashSMap[Option[String], ISZ[Message]] = {\n    var r = HashSMap.empty[Option[String], ISZ[Message]]\n    for (m <- messages) {\n      val key: Option[String] = m.fileUriOpt\n      r.get(key) match {\n        case Some(ms) => r = r + key ~> (ms :+ m)\n        case _ => r = r + key ~> ISZ(m)\n      }\n    }\n    return r\n  }\n\n  def printMessages(): Unit = {\n    @pure def sortMessages(ms: ISZ[Message]): ISZ[Message] = {\n      return ops\n        .ISZOps(ms)\n        .sortWith((m1, m2) => {\n          (m1.posOpt, m2.posOpt) match {\n            case (Some(m1pos), Some(m2pos)) =>\n              if (m1pos.beginLine < m2pos.beginLine) T\n              else if (m1pos.beginLine > m2pos.beginLine) F\n              else if (m1pos.beginColumn < m2pos.beginColumn) T\n              else if (m1pos.beginColumn > m2pos.beginColumn) F\n              else false\n            case _ => false\n          }\n        })\n    }\n    val map = messagesByFileUri\n    val err = hasError\n    var first = T\n    for (kv <- map.entries) {\n      if (!first) {\n        cprintln(err, \"\")\n      }\n      first = F\n      val fileUriOpt = kv._1\n      val ms = kv._2\n      fileUriOpt match {\n        case Some(fileUri) =>\n          cprintln(err, s\"* $fileUri\")\n          for (m <- sortMessages(ms)) {\n            cprint(err, \"  \")\n            val int: String = if (m.level == Level.InternalError) \"INTERNAL ERROR -- \" else \"\"\n            val mText: String = m.posOpt match {\n              case Some(pos) => s\"- [${pos.beginLine}, ${pos.beginColumn}] $int${m.text}\"\n              case _ => s\"- ${m.text}\"\n            }\n            cprintln(err, mText)\n          }\n        case _ =>\n          for (m <- sortMessages(ms)) {\n            val int: String = if (m.level == Level.InternalError) \"INTERNAL ERROR -- \" else \"\"\n            val mText: String = m.posOpt match {\n              case Some(pos) => s\"- [${pos.beginLine}, ${pos.beginColumn}] $int${m.text}\"\n              case _ => s\"- ${m.text}\"\n            }\n            cprintln(err, mText)\n          }\n      }\n    }\n  }\n\n  def internalError(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.InternalError, posOpt, kind, message))\n    }\n  }\n\n  def error(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Error, posOpt, kind, message))\n    }\n  }\n\n  def warn(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Warning, posOpt, kind, message))\n    }\n  }\n\n  def info(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Info, posOpt, kind, message))\n    }\n  }\n\n  def reports(ms: ISZ[Message]): Unit = {\n    for (m <- ms) {\n      report(m)\n    }\n  }\n}\n\n@record class ReporterImpl(var _messages: ISZ[Message]) extends Reporter {\n\n  var ignore: B = F\n\n  def setIgnore(newIgnore: B): Unit = {\n    ignore = newIgnore\n  }\n\n  def messages: ISZ[Message] = {\n    return _messages\n  }\n\n  def setMessages(newMessages: ISZ[Message]): Unit = {\n    _messages = newMessages\n  }\n\n  def timing(desc: String, timeInMs: Z): Unit = {}\n\n}\n
  #659 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject ObjPrinter {\n  val stTrue: ST = st\"true\"\n  val stFalse: ST = st\"false\"\n  val stZ: ST = st\"Z\"\n  val stZ8: ST = st\"Z8\"\n  val stZ16: ST = st\"Z16\"\n  val stZ32: ST = st\"Z32\"\n  val stZ64: ST = st\"Z64\"\n  val stN: ST = st\"N\"\n  val stN8: ST = st\"N8\"\n  val stN16: ST = st\"N16\"\n  val stN32: ST = st\"N32\"\n  val stN64: ST = st\"N64\"\n  val stS8: ST = st\"S8\"\n  val stS16: ST = st\"S16\"\n  val stS32: ST = st\"S32\"\n  val stS64: ST = st\"S64\"\n  val stU8: ST = st\"U8\"\n  val stU16: ST = st\"U16\"\n  val stU32: ST = st\"U32\"\n  val stU64: ST = st\"U64\"\n  val stString: ST = st\"String\"\n  val stDocInfo: ST = st\"message.DocInfo\"\n  val stPosition: ST = st\"message.Position\"\n  val stMessage: ST = st\"message.Message\"\n\n  val sGroupMax: Z = 10\n\n  @strictpure def printB(b: B): ST = if (b) stTrue else stFalse\n\n  @strictpure def printC(c: C): ST = st\"\'${ops.COps(c).escapeString}\'\"\n\n  @strictpure def printZ(n: Z): ST = printNumber(\"z\", n.string)\n\n  @strictpure def printZ8(n: Z8): ST = printNumber(\"z8\", n.string)\n\n  @strictpure def printZ16(n: Z16): ST = printNumber(\"z16\", n.string)\n\n  @strictpure def printZ32(n: Z32): ST = printNumber(\"z32\", n.string)\n\n  @strictpure def printZ64(n: Z64): ST = printNumber(\"z64\", n.string)\n\n  @strictpure def printN(n: N): ST = printNumber(\"n\", n.string)\n\n  @strictpure def printN8(n: N8): ST = printNumber(\"n8\", n.string)\n\n  @strictpure def printN16(n: N16): ST = printNumber(\"n16\", n.string)\n\n  @strictpure def printN32(n: N32): ST = printNumber(\"n32\", n.string)\n\n  @strictpure def printN64(n: N64): ST = printNumber(\"n64\", n.string)\n\n  @strictpure def printS8(n: S8): ST = printNumber(\"s8\", n.string)\n\n  @strictpure def printS16(n: S16): ST = printNumber(\"s16\", n.string)\n\n  @strictpure def printS32(n: S32): ST = printNumber(\"s32\", n.string)\n\n  @strictpure def printS64(n: S64): ST = printNumber(\"s64\", n.string)\n\n  @strictpure def printU8(n: U8): ST = printNumber(\"u8\", conversions.U8.toZ(n).string)\n\n  @strictpure def printU16(n: U16): ST = printNumber(\"u16\", conversions.U16.toZ(n).string)\n\n  @strictpure def printU32(n: U32): ST = printNumber(\"u32\", conversions.U32.toZ(n).string)\n\n  @strictpure def printU64(n: U64): ST = printNumber(\"u64\", conversions.U64.toZ(n).string)\n\n  @strictpure def printF32(n: F32): ST = printNumber(\"f32\", n.string)\n\n  @strictpure def printF64(n: F64): ST = printNumber(\"f64\", n.string)\n\n  @strictpure def printR(n: R): ST = printNumber(\"r\", n.string)\n\n  @strictpure def printNumber(prefix: String, s: String): ST = st\"\"\"$prefix\"$s\"\"\"\"\n\n  @strictpure def printString(s: String): ST = st\"\"\"\"${ops.StringOps(s).escapeST}\"\"\"\"\n\n  @pure def printOption[T](eType: ST, o: Option[T], f: T => ST): ST = {\n    o match {\n      case Some(v) => return st\"Option.some(${f(v)})\"\n      case _ => return st\"Option.none()\"\n    }\n  }\n\n  @pure def printMOption[T](eType: ST, o: MOption[T], f: T => ST): ST = {\n    o match {\n      case MSome(v) => return st\"MOption.some(${f(v)})\"\n      case _ => return st\"MOption.none()\"\n    }\n  }\n\n  @pure def printEither[L, R](lType: ST, rType: ST, o: Either[L, R], f0: L => ST, f1: R => ST): ST = {\n    o match {\n      case Either.Left(v) => return st\"Either.left(${f0(v)})\"\n      case Either.Right(v) => return st\"Either.right(${f1(v)})\"\n    }\n  }\n\n  @pure def printMEither[L, R](lType: ST, rType: ST, o: MEither[L, R], f0: L => ST, f1: R => ST): ST = {\n    o match {\n      case MEither.Left(v) => return st\"MEither.left(${f0(v)})\"\n      case MEither.Right(v) => return st\"MEither.right(${f1(v)})\"\n    }\n  }\n\n}\n\nimport ObjPrinter._\n\n@msig trait ObjPrinter {\n\n  def freshNum(): Z\n\n  def write(content: ST): Unit\n\n  def cache[T](o: T, f: () => ST): ST\n\n  def addMethod(tipe: ST, isStrictPure: B, body: ST): ST = {\n    val num = freshNum()\n    val ann: String = if (isStrictPure) \"@strictpure\" else \"@pure\"\n    val name = st\"object$num\"\n    write(\n      st\"\"\"  $ann def $name: $tipe =\n          |    $body\"\"\")\n    return name\n  }\n\n  def printISZ[E](elementType: ST, s: ISZ[E], e: E => ST): ST = {\n    return printIS(stZ, elementType, s, printZ _, e)\n  }\n\n  def printIS[I, E](indexType: ST, elementType: ST, s: IS[I, E], i: I => ST, e: E => ST): ST = {\n    val f: () => ST = { () =>\n      val t = st\"IS[$indexType, $elementType]\"\n      val elements = s.map(e)\n      if (elements.isEmpty) {\n        return st\"$t()\"\n      }\n      var ll = ISZ[ST]()\n      var l = ISZ[ST]()\n      for (e <- elements) {\n        l = l :+ e\n        if (l.size == sGroupMax) {\n          ll = ll :+ st\"${(l, \", \")}\"\n          l = ISZ()\n        }\n      }\n      if (l.size > 0) {\n        ll = ll :+ st\"${(l, \", \")}\"\n      }\n      addMethod(t, T,\n        if (ll.isEmpty) st\"$t()\"\n        else if (ll.size === 1) st\"$t(${(ll(0), \", \")})\"\n        else\n          st\"\"\"$t(\n              |  ${(ll, \",\\n\")})\"\"\")\n    }\n    return cache(s, f)\n  }\n\n  def printMS[I, E](indexType: ST, elementType: ST, s: MS[I, E], i: I => ST, e: E => ST): ST = {\n    val f: () => ST = { () =>\n      val t = st\"MS[$indexType, $elementType]\"\n      val elements = s.map(e)\n      if (elements.isEmpty) {\n        return st\"$t()\"\n      }\n      var ll = ISZ[ST]()\n      var l = ISZ[ST]()\n      for (e <- elements) {\n        l = l :+ e\n        if (l.size == sGroupMax) {\n          ll = ll :+ st\"${(l, \", \")}\"\n          l = ISZ()\n        }\n      }\n      if (l.size > 0) {\n        ll = ll :+ st\"${(l, \", \")}\"\n      }\n      addMethod(t, T,\n        if (ll.isEmpty) st\"$t()\"\n        else if (ll.size === 1) st\"$t(${(ll(0), \", \")})\"\n        else\n          st\"\"\"$t(\n              |  ${(ll, \",\\n\")}\"\"\")\n    }\n    return cache(s, f)\n  }\n\n  def printMap[K, V](keyType: ST, valueType: ST, o: Map[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"Map.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(Map ++ $entries)\"\n  }\n\n  def printSet[T](elementType: ST, o: Set[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"Set.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(Set ++ $elements)\"\n  }\n\n  def printHashMap[K, V](keyType: ST, valueType: ST, o: HashMap[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashMap.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(HashMap ++ $entries)\"\n  }\n\n  def printHashSet[T](elementType: ST, o: HashSet[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSet.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(HashSet ++ $elements)\"\n  }\n\n  def printHashSMap[K, V](keyType: ST, valueType: ST, o: HashSMap[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSMap.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(HashSMap ++ $entries)\"\n  }\n\n  def printHashSSet[T](elementType: ST, o: HashSSet[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSSet.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(HashSSet ++ $elements)\"\n  }\n\n  def printStack[T](elementType: ST, o: Stack[T], f: T => ST): ST = {\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"Stack($elements)\"\n  }\n\n  def printBag[T](elementType: ST, o: Bag[T], f: T => ST): ST = {\n    val map = printMap(elementType, stZ, o.map, f, printZ _)\n    return st\"Bag($map)\"\n  }\n\n  def printHashBag[T](elementType: ST, o: HashBag[T], f: T => ST): ST = {\n    val map = printHashMap(elementType, stZ, o.map, f, printZ _)\n    return st\"HashBag($map)\"\n  }\n\n  def printHashSBag[T](elementType: ST, o: HashSBag[T], f: T => ST): ST = {\n    val map = printHashSMap(elementType, stZ, o.map, f, printZ _)\n    return st\"HashSBag($map)\"\n  }\n\n  def printPoset[T](elementType: ST, o: Poset[T], e: T => ST): ST = {\n    if (o.nodesInverse.isEmpty) {\n      return st\"Poset.empty[$elementType]\"\n    }\n    val f = () => addMethod(st\"Poset[$elementType]\", F,\n      st\"\"\"{\n          |  var r = Poset.empty[$elementType]\n          |  for (n <- o.nodesInverse) {\n          |    r = r.addNode(n)\n          |  }\n          |  for (i <- 0 until o.nodesInverse.size) {\n          |    o.parents.get(i) match {\n          |      case Some(v) => r = Poset.Internal.addParents(r, i, v.elements)\n          |      case _ =>\n          |    }\n          |  }\n          |  return r\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printGraph[V, E](vType: ST, eType: ST, o: Graph[V, E], v: V => ST, e: E => ST): ST = {\n    if (o.nodesInverse.isEmpty) {\n      return st\"Graph.empty${if (o.multi) \"Multi\" else \"\"}[$vType, $eType]\"\n    }\n\n    def printEdge(edge: Graph.Internal.Edge[E]): ST = {\n      edge match {\n        case Graph.Internal.Edge.Plain(source, dest) => return st\"Graph.Internal.Edge.Plain($source, $dest)\"\n        case Graph.Internal.Edge.Data(source, dest, data) => return st\"Graph.Internal.Edge.Data($source, $dest, ${e(data)})\"\n      }\n    }\n\n    val f = () => addMethod(st\"Graph[$vType, $eType]\", F,\n      st\"\"\"{\n          |  var r = Graph.empty${if (o.multi) \"Multi\" else \"\"}[$vType, $eType]\n          |  ${(for (n <- o.nodesInverse) yield st\"r = r * ${v(n)}\", \"\\n\")}\n          |  ${(for (es <- o.outgoingEdges.values; e <- es.elements) yield st\"r = Graph.Internal.addEdge(r, ${printEdge(e)})\", \"\\n\")}\n          |  return r\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printUnionFind[E](eType: ST, o: UnionFind[E], e: E => ST): ST = {\n    if (o.size === 0) {\n      return st\"UnionFind.create[$eType](ISZ())\"\n    }\n    val f = () => addMethod(st\"UnionFind[$eType]\", F,\n      st\"\"\"{\n          |  val elementsInverse = ${printISZ(eType, o.elementsInverse, e)}\n          |  var elements = HashSMap.empty[T, UnionFind.Index]\n          |  for (i <- z\"0\" until elementsInverse.size) {\n          |    elements = elements + elementsInverse(i) ~> i\n          |  }\n          |  val parentsOf = ${printISZ(stZ, o.parentOf, printZ _)}\n          |  val sizeOf = ${printISZ(stZ, o.sizeOf, printZ _)}\n          |  return UnionFind[$eType](elements, elementsInverse, parentsOf, sizeOf)\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printMessage(o: message.Message): ST = {\n    val f = () => addMethod(stMessage, T,\n      st\"\"\"message.Message(\n          |  message.Level.${o.level},\n          |  ${printOption(stPosition, o.posOpt, printPosition _)},\n          |  ${printString(o.kind)},\n          |  ${printString(o.text)})\"\"\")\n    return cache(o, f)\n  }\n\n  def printPosition(o: message.Position): ST = {\n    o match {\n      case o: message.FlatPos =>\n        val f = () => addMethod(stPosition, T,\n          st\"\"\"message.FlatPos(\n              |  uriOpt = ${printOption(stString, o.uriOpt, printString _)},\n              |  beginLine32 = ${printU32(o.beginLine32)},\n              |  beginColumn32 = ${printU32(o.beginColumn32)},\n              |  endLine32 = ${printU32(o.endLine32)},\n              |  endColumn32 = ${printU32(o.endColumn32)},\n              |  offset32 = ${printU32(o.offset32)},\n              |  length32 = ${printU32(o.length32)})\"\"\")\n        return cache(o, f)\n      case o: message.PosInfo =>\n        val f = () => st\"message.PosInfo(${printDocInfo(o.info)}, ${printU64(o.offsetLength)})\"\n        return cache(o, f)\n    }\n  }\n\n  def printDocInfo(o: message.DocInfo): ST = {\n    val f = () => addMethod(stDocInfo, T,\n      st\"\"\"message.DocInfo(\n          |  ${printOption[String](stString, o.uriOpt, printString _)},\n          |  ${printISZ(stU32, o.lineOffsets, printU32 _)})\"\"\")\n    return cache(o, f)\n  }\n\n}\n
  #660 = String             #659          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject ObjPrinter {\n  val stTrue: ST = st\"true\"\n  val stFalse: ST = st\"false\"\n  val stZ: ST = st\"Z\"\n  val stZ8: ST = st\"Z8\"\n  val stZ16: ST = st\"Z16\"\n  val stZ32: ST = st\"Z32\"\n  val stZ64: ST = st\"Z64\"\n  val stN: ST = st\"N\"\n  val stN8: ST = st\"N8\"\n  val stN16: ST = st\"N16\"\n  val stN32: ST = st\"N32\"\n  val stN64: ST = st\"N64\"\n  val stS8: ST = st\"S8\"\n  val stS16: ST = st\"S16\"\n  val stS32: ST = st\"S32\"\n  val stS64: ST = st\"S64\"\n  val stU8: ST = st\"U8\"\n  val stU16: ST = st\"U16\"\n  val stU32: ST = st\"U32\"\n  val stU64: ST = st\"U64\"\n  val stString: ST = st\"String\"\n  val stDocInfo: ST = st\"message.DocInfo\"\n  val stPosition: ST = st\"message.Position\"\n  val stMessage: ST = st\"message.Message\"\n\n  val sGroupMax: Z = 10\n\n  @strictpure def printB(b: B): ST = if (b) stTrue else stFalse\n\n  @strictpure def printC(c: C): ST = st\"\'${ops.COps(c).escapeString}\'\"\n\n  @strictpure def printZ(n: Z): ST = printNumber(\"z\", n.string)\n\n  @strictpure def printZ8(n: Z8): ST = printNumber(\"z8\", n.string)\n\n  @strictpure def printZ16(n: Z16): ST = printNumber(\"z16\", n.string)\n\n  @strictpure def printZ32(n: Z32): ST = printNumber(\"z32\", n.string)\n\n  @strictpure def printZ64(n: Z64): ST = printNumber(\"z64\", n.string)\n\n  @strictpure def printN(n: N): ST = printNumber(\"n\", n.string)\n\n  @strictpure def printN8(n: N8): ST = printNumber(\"n8\", n.string)\n\n  @strictpure def printN16(n: N16): ST = printNumber(\"n16\", n.string)\n\n  @strictpure def printN32(n: N32): ST = printNumber(\"n32\", n.string)\n\n  @strictpure def printN64(n: N64): ST = printNumber(\"n64\", n.string)\n\n  @strictpure def printS8(n: S8): ST = printNumber(\"s8\", n.string)\n\n  @strictpure def printS16(n: S16): ST = printNumber(\"s16\", n.string)\n\n  @strictpure def printS32(n: S32): ST = printNumber(\"s32\", n.string)\n\n  @strictpure def printS64(n: S64): ST = printNumber(\"s64\", n.string)\n\n  @strictpure def printU8(n: U8): ST = printNumber(\"u8\", conversions.U8.toZ(n).string)\n\n  @strictpure def printU16(n: U16): ST = printNumber(\"u16\", conversions.U16.toZ(n).string)\n\n  @strictpure def printU32(n: U32): ST = printNumber(\"u32\", conversions.U32.toZ(n).string)\n\n  @strictpure def printU64(n: U64): ST = printNumber(\"u64\", conversions.U64.toZ(n).string)\n\n  @strictpure def printF32(n: F32): ST = printNumber(\"f32\", n.string)\n\n  @strictpure def printF64(n: F64): ST = printNumber(\"f64\", n.string)\n\n  @strictpure def printR(n: R): ST = printNumber(\"r\", n.string)\n\n  @strictpure def printNumber(prefix: String, s: String): ST = st\"\"\"$prefix\"$s\"\"\"\"\n\n  @strictpure def printString(s: String): ST = st\"\"\"\"${ops.StringOps(s).escapeST}\"\"\"\"\n\n  @pure def printOption[T](eType: ST, o: Option[T], f: T => ST): ST = {\n    o match {\n      case Some(v) => return st\"Option.some(${f(v)})\"\n      case _ => return st\"Option.none()\"\n    }\n  }\n\n  @pure def printMOption[T](eType: ST, o: MOption[T], f: T => ST): ST = {\n    o match {\n      case MSome(v) => return st\"MOption.some(${f(v)})\"\n      case _ => return st\"MOption.none()\"\n    }\n  }\n\n  @pure def printEither[L, R](lType: ST, rType: ST, o: Either[L, R], f0: L => ST, f1: R => ST): ST = {\n    o match {\n      case Either.Left(v) => return st\"Either.left(${f0(v)})\"\n      case Either.Right(v) => return st\"Either.right(${f1(v)})\"\n    }\n  }\n\n  @pure def printMEither[L, R](lType: ST, rType: ST, o: MEither[L, R], f0: L => ST, f1: R => ST): ST = {\n    o match {\n      case MEither.Left(v) => return st\"MEither.left(${f0(v)})\"\n      case MEither.Right(v) => return st\"MEither.right(${f1(v)})\"\n    }\n  }\n\n}\n\nimport ObjPrinter._\n\n@msig trait ObjPrinter {\n\n  def freshNum(): Z\n\n  def write(content: ST): Unit\n\n  def cache[T](o: T, f: () => ST): ST\n\n  def addMethod(tipe: ST, isStrictPure: B, body: ST): ST = {\n    val num = freshNum()\n    val ann: String = if (isStrictPure) \"@strictpure\" else \"@pure\"\n    val name = st\"object$num\"\n    write(\n      st\"\"\"  $ann def $name: $tipe =\n          |    $body\"\"\")\n    return name\n  }\n\n  def printISZ[E](elementType: ST, s: ISZ[E], e: E => ST): ST = {\n    return printIS(stZ, elementType, s, printZ _, e)\n  }\n\n  def printIS[I, E](indexType: ST, elementType: ST, s: IS[I, E], i: I => ST, e: E => ST): ST = {\n    val f: () => ST = { () =>\n      val t = st\"IS[$indexType, $elementType]\"\n      val elements = s.map(e)\n      if (elements.isEmpty) {\n        return st\"$t()\"\n      }\n      var ll = ISZ[ST]()\n      var l = ISZ[ST]()\n      for (e <- elements) {\n        l = l :+ e\n        if (l.size == sGroupMax) {\n          ll = ll :+ st\"${(l, \", \")}\"\n          l = ISZ()\n        }\n      }\n      if (l.size > 0) {\n        ll = ll :+ st\"${(l, \", \")}\"\n      }\n      addMethod(t, T,\n        if (ll.isEmpty) st\"$t()\"\n        else if (ll.size === 1) st\"$t(${(ll(0), \", \")})\"\n        else\n          st\"\"\"$t(\n              |  ${(ll, \",\\n\")})\"\"\")\n    }\n    return cache(s, f)\n  }\n\n  def printMS[I, E](indexType: ST, elementType: ST, s: MS[I, E], i: I => ST, e: E => ST): ST = {\n    val f: () => ST = { () =>\n      val t = st\"MS[$indexType, $elementType]\"\n      val elements = s.map(e)\n      if (elements.isEmpty) {\n        return st\"$t()\"\n      }\n      var ll = ISZ[ST]()\n      var l = ISZ[ST]()\n      for (e <- elements) {\n        l = l :+ e\n        if (l.size == sGroupMax) {\n          ll = ll :+ st\"${(l, \", \")}\"\n          l = ISZ()\n        }\n      }\n      if (l.size > 0) {\n        ll = ll :+ st\"${(l, \", \")}\"\n      }\n      addMethod(t, T,\n        if (ll.isEmpty) st\"$t()\"\n        else if (ll.size === 1) st\"$t(${(ll(0), \", \")})\"\n        else\n          st\"\"\"$t(\n              |  ${(ll, \",\\n\")}\"\"\")\n    }\n    return cache(s, f)\n  }\n\n  def printMap[K, V](keyType: ST, valueType: ST, o: Map[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"Map.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(Map ++ $entries)\"\n  }\n\n  def printSet[T](elementType: ST, o: Set[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"Set.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(Set ++ $elements)\"\n  }\n\n  def printHashMap[K, V](keyType: ST, valueType: ST, o: HashMap[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashMap.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(HashMap ++ $entries)\"\n  }\n\n  def printHashSet[T](elementType: ST, o: HashSet[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSet.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(HashSet ++ $elements)\"\n  }\n\n  def printHashSMap[K, V](keyType: ST, valueType: ST, o: HashSMap[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSMap.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(HashSMap ++ $entries)\"\n  }\n\n  def printHashSSet[T](elementType: ST, o: HashSSet[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSSet.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(HashSSet ++ $elements)\"\n  }\n\n  def printStack[T](elementType: ST, o: Stack[T], f: T => ST): ST = {\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"Stack($elements)\"\n  }\n\n  def printBag[T](elementType: ST, o: Bag[T], f: T => ST): ST = {\n    val map = printMap(elementType, stZ, o.map, f, printZ _)\n    return st\"Bag($map)\"\n  }\n\n  def printHashBag[T](elementType: ST, o: HashBag[T], f: T => ST): ST = {\n    val map = printHashMap(elementType, stZ, o.map, f, printZ _)\n    return st\"HashBag($map)\"\n  }\n\n  def printHashSBag[T](elementType: ST, o: HashSBag[T], f: T => ST): ST = {\n    val map = printHashSMap(elementType, stZ, o.map, f, printZ _)\n    return st\"HashSBag($map)\"\n  }\n\n  def printPoset[T](elementType: ST, o: Poset[T], e: T => ST): ST = {\n    if (o.nodesInverse.isEmpty) {\n      return st\"Poset.empty[$elementType]\"\n    }\n    val f = () => addMethod(st\"Poset[$elementType]\", F,\n      st\"\"\"{\n          |  var r = Poset.empty[$elementType]\n          |  for (n <- o.nodesInverse) {\n          |    r = r.addNode(n)\n          |  }\n          |  for (i <- 0 until o.nodesInverse.size) {\n          |    o.parents.get(i) match {\n          |      case Some(v) => r = Poset.Internal.addParents(r, i, v.elements)\n          |      case _ =>\n          |    }\n          |  }\n          |  return r\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printGraph[V, E](vType: ST, eType: ST, o: Graph[V, E], v: V => ST, e: E => ST): ST = {\n    if (o.nodesInverse.isEmpty) {\n      return st\"Graph.empty${if (o.multi) \"Multi\" else \"\"}[$vType, $eType]\"\n    }\n\n    def printEdge(edge: Graph.Internal.Edge[E]): ST = {\n      edge match {\n        case Graph.Internal.Edge.Plain(source, dest) => return st\"Graph.Internal.Edge.Plain($source, $dest)\"\n        case Graph.Internal.Edge.Data(source, dest, data) => return st\"Graph.Internal.Edge.Data($source, $dest, ${e(data)})\"\n      }\n    }\n\n    val f = () => addMethod(st\"Graph[$vType, $eType]\", F,\n      st\"\"\"{\n          |  var r = Graph.empty${if (o.multi) \"Multi\" else \"\"}[$vType, $eType]\n          |  ${(for (n <- o.nodesInverse) yield st\"r = r * ${v(n)}\", \"\\n\")}\n          |  ${(for (es <- o.outgoingEdges.values; e <- es.elements) yield st\"r = Graph.Internal.addEdge(r, ${printEdge(e)})\", \"\\n\")}\n          |  return r\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printUnionFind[E](eType: ST, o: UnionFind[E], e: E => ST): ST = {\n    if (o.size === 0) {\n      return st\"UnionFind.create[$eType](ISZ())\"\n    }\n    val f = () => addMethod(st\"UnionFind[$eType]\", F,\n      st\"\"\"{\n          |  val elementsInverse = ${printISZ(eType, o.elementsInverse, e)}\n          |  var elements = HashSMap.empty[T, UnionFind.Index]\n          |  for (i <- z\"0\" until elementsInverse.size) {\n          |    elements = elements + elementsInverse(i) ~> i\n          |  }\n          |  val parentsOf = ${printISZ(stZ, o.parentOf, printZ _)}\n          |  val sizeOf = ${printISZ(stZ, o.sizeOf, printZ _)}\n          |  return UnionFind[$eType](elements, elementsInverse, parentsOf, sizeOf)\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printMessage(o: message.Message): ST = {\n    val f = () => addMethod(stMessage, T,\n      st\"\"\"message.Message(\n          |  message.Level.${o.level},\n          |  ${printOption(stPosition, o.posOpt, printPosition _)},\n          |  ${printString(o.kind)},\n          |  ${printString(o.text)})\"\"\")\n    return cache(o, f)\n  }\n\n  def printPosition(o: message.Position): ST = {\n    o match {\n      case o: message.FlatPos =>\n        val f = () => addMethod(stPosition, T,\n          st\"\"\"message.FlatPos(\n              |  uriOpt = ${printOption(stString, o.uriOpt, printString _)},\n              |  beginLine32 = ${printU32(o.beginLine32)},\n              |  beginColumn32 = ${printU32(o.beginColumn32)},\n              |  endLine32 = ${printU32(o.endLine32)},\n              |  endColumn32 = ${printU32(o.endColumn32)},\n              |  offset32 = ${printU32(o.offset32)},\n              |  length32 = ${printU32(o.length32)})\"\"\")\n        return cache(o, f)\n      case o: message.PosInfo =>\n        val f = () => st\"message.PosInfo(${printDocInfo(o.info)}, ${printU64(o.offsetLength)})\"\n        return cache(o, f)\n    }\n  }\n\n  def printDocInfo(o: message.DocInfo): ST = {\n    val f = () => addMethod(stDocInfo, T,\n      st\"\"\"message.DocInfo(\n          |  ${printOption[String](stString, o.uriOpt, printString _)},\n          |  ${printISZ(stU32, o.lineOffsets, printU32 _)})\"\"\")\n    return cache(o, f)\n  }\n\n}\n
  #661 = Utf8               // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from CliOpt.scala\n\npackage org.sireum.cli\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printCliOpt(o: CliOpt): ST = {\n      o match {\n        case o: CliOpt.Group => return printCliOptGroup(o)\n        case o: CliOpt.Tool => return printCliOptTool(o)\n      }\n    }\n\n    @pure def printCliOptGroup(o: CliOpt.Group): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Group\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"description\", printString(o.description)),\n        (\"header\", printString(o.header)),\n        (\"unlisted\", printB(o.unlisted)),\n        (\"subs\", printISZ(F, o.subs, printCliOpt _))\n      ))\n    }\n\n    @pure def printCliOptTool(o: CliOpt.Tool): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Tool\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"command\", printString(o.command)),\n        (\"description\", printString(o.description)),\n        (\"header\", printString(o.header)),\n        (\"usage\", printString(o.usage)),\n        (\"usageDescOpt\", printOption(T, o.usageDescOpt, printString _)),\n        (\"opts\", printISZ(F, o.opts, printCliOptOpt _)),\n        (\"groups\", printISZ(F, o.groups, printCliOptOptGroup _))\n      ))\n    }\n\n    @pure def printCliOptOptGroup(o: CliOpt.OptGroup): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.OptGroup\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"opts\", printISZ(F, o.opts, printCliOptOpt _))\n      ))\n    }\n\n    @pure def printCliOptOpt(o: CliOpt.Opt): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Opt\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"longKey\", printString(o.longKey)),\n        (\"shortKey\", printOption(T, o.shortKey, printC _)),\n        (\"tpe\", printCliOptType(o.tpe)),\n        (\"description\", printString(o.description))\n      ))\n    }\n\n    @pure def printCliOptType(o: CliOpt.Type): ST = {\n      o match {\n        case o: CliOpt.Type.Flag => return printCliOptTypeFlag(o)\n        case o: CliOpt.Type.Num => return printCliOptTypeNum(o)\n        case o: CliOpt.Type.NumFlag => return printCliOptTypeNumFlag(o)\n        case o: CliOpt.Type.NumChoice => return printCliOptTypeNumChoice(o)\n        case o: CliOpt.Type.Str => return printCliOptTypeStr(o)\n        case o: CliOpt.Type.Choice => return printCliOptTypeChoice(o)\n        case o: CliOpt.Type.Path => return printCliOptTypePath(o)\n      }\n    }\n\n    @pure def printCliOptTypeFlag(o: CliOpt.Type.Flag): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Flag\"\"\"\"),\n        (\"default\", printB(o.default))\n      ))\n    }\n\n    @pure def printCliOptTypeNum(o: CliOpt.Type.Num): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Num\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"default\", printZ(o.default)),\n        (\"min\", printOption(T, o.min, printZ _)),\n        (\"max\", printOption(T, o.max, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeNumFlag(o: CliOpt.Type.NumFlag): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.NumFlag\"\"\"\"),\n        (\"default\", printZ(o.default)),\n        (\"min\", printOption(T, o.min, printZ _)),\n        (\"max\", printOption(T, o.max, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeNumChoice(o: CliOpt.Type.NumChoice): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.NumChoice\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"choices\", printISZ(T, o.choices, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeStr(o: CliOpt.Type.Str): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Str\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"default\", printOption(T, o.default, printString _))\n      ))\n    }\n\n    @pure def printCliOptTypeChoice(o: CliOpt.Type.Choice): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Choice\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"elements\", printISZ(T, o.elements, printString _))\n      ))\n    }\n\n    @pure def printCliOptTypePath(o: CliOpt.Type.Path): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Path\"\"\"\"),\n        (\"multiple\", printB(o.multiple)),\n        (\"default\", printOption(T, o.default, printString _))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parseCliOpt(): CliOpt = {\n      val t = parser.parseObjectTypes(ISZ(\"CliOpt.Group\", \"CliOpt.Tool\"))\n      t.native match {\n        case \"CliOpt.Group\" => val r = parseCliOptGroupT(T); return r\n        case \"CliOpt.Tool\" => val r = parseCliOptToolT(T); return r\n        case _ => val r = parseCliOptToolT(T); return r\n      }\n    }\n\n    def parseCliOptGroup(): CliOpt.Group = {\n      val r = parseCliOptGroupT(F)\n      return r\n    }\n\n    def parseCliOptGroupT(typeParsed: B): CliOpt.Group = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Group\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"header\")\n      val header = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"unlisted\")\n      val unlisted = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"subs\")\n      val subs = parser.parseISZ(parseCliOpt _)\n      parser.parseObjectNext()\n      return CliOpt.Group(name, description, header, unlisted, subs)\n    }\n\n    def parseCliOptTool(): CliOpt.Tool = {\n      val r = parseCliOptToolT(F)\n      return r\n    }\n\n    def parseCliOptToolT(typeParsed: B): CliOpt.Tool = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Tool\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"command\")\n      val command = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"header\")\n      val header = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"usage\")\n      val usage = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"usageDescOpt\")\n      val usageDescOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"opts\")\n      val opts = parser.parseISZ(parseCliOptOpt _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"groups\")\n      val groups = parser.parseISZ(parseCliOptOptGroup _)\n      parser.parseObjectNext()\n      return CliOpt.Tool(name, command, description, header, usage, usageDescOpt, opts, groups)\n    }\n\n    def parseCliOptOptGroup(): CliOpt.OptGroup = {\n      val r = parseCliOptOptGroupT(F)\n      return r\n    }\n\n    def parseCliOptOptGroupT(typeParsed: B): CliOpt.OptGroup = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.OptGroup\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"opts\")\n      val opts = parser.parseISZ(parseCliOptOpt _)\n      parser.parseObjectNext()\n      return CliOpt.OptGroup(name, opts)\n    }\n\n    def parseCliOptOpt(): CliOpt.Opt = {\n      val r = parseCliOptOptT(F)\n      return r\n    }\n\n    def parseCliOptOptT(typeParsed: B): CliOpt.Opt = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Opt\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"longKey\")\n      val longKey = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"shortKey\")\n      val shortKey = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"tpe\")\n      val tpe = parseCliOptType()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      return CliOpt.Opt(name, longKey, shortKey, tpe, description)\n    }\n\n    def parseCliOptType(): CliOpt.Type = {\n      val t = parser.parseObjectTypes(ISZ(\"CliOpt.Type.Flag\", \"CliOpt.Type.Num\", \"CliOpt.Type.NumFlag\", \"CliOpt.Type.NumChoice\", \"CliOpt.Type.Str\", \"CliOpt.Type.Choice\", \"CliOpt.Type.Path\"))\n      t.native match {\n        case \"CliOpt.Type.Flag\" => val r = parseCliOptTypeFlagT(T); return r\n        case \"CliOpt.Type.Num\" => val r = parseCliOptTypeNumT(T); return r\n        case \"CliOpt.Type.NumFlag\" => val r = parseCliOptTypeNumFlagT(T); return r\n        case \"CliOpt.Type.NumChoice\" => val r = parseCliOptTypeNumChoiceT(T); return r\n        case \"CliOpt.Type.Str\" => val r = parseCliOptTypeStrT(T); return r\n        case \"CliOpt.Type.Choice\" => val r = parseCliOptTypeChoiceT(T); return r\n        case \"CliOpt.Type.Path\" => val r = parseCliOptTypePathT(T); return r\n        case _ => val r = parseCliOptTypePathT(T); return r\n      }\n    }\n\n    def parseCliOptTypeFlag(): CliOpt.Type.Flag = {\n      val r = parseCliOptTypeFlagT(F)\n      return r\n    }\n\n    def parseCliOptTypeFlagT(typeParsed: B): CliOpt.Type.Flag = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Flag\")\n      }\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseB()\n      parser.parseObjectNext()\n      return CliOpt.Type.Flag(default)\n    }\n\n    def parseCliOptTypeNum(): CliOpt.Type.Num = {\n      val r = parseCliOptTypeNumT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumT(typeParsed: B): CliOpt.Type.Num = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Num\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"min\")\n      val min = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"max\")\n      val max = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Num(sep, default, min, max)\n    }\n\n    def parseCliOptTypeNumFlag(): CliOpt.Type.NumFlag = {\n      val r = parseCliOptTypeNumFlagT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumFlagT(typeParsed: B): CliOpt.Type.NumFlag = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.NumFlag\")\n      }\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"min\")\n      val min = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"max\")\n      val max = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.NumFlag(default, min, max)\n    }\n\n    def parseCliOptTypeNumChoice(): CliOpt.Type.NumChoice = {\n      val r = parseCliOptTypeNumChoiceT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumChoiceT(typeParsed: B): CliOpt.Type.NumChoice = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.NumChoice\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"choices\")\n      val choices = parser.parseISZ(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.NumChoice(sep, choices)\n    }\n\n    def parseCliOptTypeStr(): CliOpt.Type.Str = {\n      val r = parseCliOptTypeStrT(F)\n      return r\n    }\n\n    def parseCliOptTypeStrT(typeParsed: B): CliOpt.Type.Str = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Str\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Str(sep, default)\n    }\n\n    def parseCliOptTypeChoice(): CliOpt.Type.Choice = {\n      val r = parseCliOptTypeChoiceT(F)\n      return r\n    }\n\n    def parseCliOptTypeChoiceT(typeParsed: B): CliOpt.Type.Choice = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Choice\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"elements\")\n      val elements = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Choice(name, sep, elements)\n    }\n\n    def parseCliOptTypePath(): CliOpt.Type.Path = {\n      val r = parseCliOptTypePathT(F)\n      return r\n    }\n\n    def parseCliOptTypePathT(typeParsed: B): CliOpt.Type.Path = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Path\")\n      }\n      parser.parseObjectKey(\"multiple\")\n      val multiple = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Path(multiple, default)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromCliOpt(o: CliOpt, isCompact: B): String = {\n    val st = Printer.printCliOpt(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOpt(s: String): Either[CliOpt, Json.ErrorMsg] = {\n    def fCliOpt(parser: Parser): CliOpt = {\n      val r = parser.parseCliOpt()\n      return r\n    }\n    val r = to(s, fCliOpt _)\n    return r\n  }\n\n  def fromCliOptGroup(o: CliOpt.Group, isCompact: B): String = {\n    val st = Printer.printCliOptGroup(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptGroup(s: String): Either[CliOpt.Group, Json.ErrorMsg] = {\n    def fCliOptGroup(parser: Parser): CliOpt.Group = {\n      val r = parser.parseCliOptGroup()\n      return r\n    }\n    val r = to(s, fCliOptGroup _)\n    return r\n  }\n\n  def fromCliOptTool(o: CliOpt.Tool, isCompact: B): String = {\n    val st = Printer.printCliOptTool(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTool(s: String): Either[CliOpt.Tool, Json.ErrorMsg] = {\n    def fCliOptTool(parser: Parser): CliOpt.Tool = {\n      val r = parser.parseCliOptTool()\n      return r\n    }\n    val r = to(s, fCliOptTool _)\n    return r\n  }\n\n  def fromCliOptOptGroup(o: CliOpt.OptGroup, isCompact: B): String = {\n    val st = Printer.printCliOptOptGroup(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptOptGroup(s: String): Either[CliOpt.OptGroup, Json.ErrorMsg] = {\n    def fCliOptOptGroup(parser: Parser): CliOpt.OptGroup = {\n      val r = parser.parseCliOptOptGroup()\n      return r\n    }\n    val r = to(s, fCliOptOptGroup _)\n    return r\n  }\n\n  def fromCliOptOpt(o: CliOpt.Opt, isCompact: B): String = {\n    val st = Printer.printCliOptOpt(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptOpt(s: String): Either[CliOpt.Opt, Json.ErrorMsg] = {\n    def fCliOptOpt(parser: Parser): CliOpt.Opt = {\n      val r = parser.parseCliOptOpt()\n      return r\n    }\n    val r = to(s, fCliOptOpt _)\n    return r\n  }\n\n  def fromCliOptType(o: CliOpt.Type, isCompact: B): String = {\n    val st = Printer.printCliOptType(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptType(s: String): Either[CliOpt.Type, Json.ErrorMsg] = {\n    def fCliOptType(parser: Parser): CliOpt.Type = {\n      val r = parser.parseCliOptType()\n      return r\n    }\n    val r = to(s, fCliOptType _)\n    return r\n  }\n\n  def fromCliOptTypeFlag(o: CliOpt.Type.Flag, isCompact: B): String = {\n    val st = Printer.printCliOptTypeFlag(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeFlag(s: String): Either[CliOpt.Type.Flag, Json.ErrorMsg] = {\n    def fCliOptTypeFlag(parser: Parser): CliOpt.Type.Flag = {\n      val r = parser.parseCliOptTypeFlag()\n      return r\n    }\n    val r = to(s, fCliOptTypeFlag _)\n    return r\n  }\n\n  def fromCliOptTypeNum(o: CliOpt.Type.Num, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNum(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNum(s: String): Either[CliOpt.Type.Num, Json.ErrorMsg] = {\n    def fCliOptTypeNum(parser: Parser): CliOpt.Type.Num = {\n      val r = parser.parseCliOptTypeNum()\n      return r\n    }\n    val r = to(s, fCliOptTypeNum _)\n    return r\n  }\n\n  def fromCliOptTypeNumFlag(o: CliOpt.Type.NumFlag, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNumFlag(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNumFlag(s: String): Either[CliOpt.Type.NumFlag, Json.ErrorMsg] = {\n    def fCliOptTypeNumFlag(parser: Parser): CliOpt.Type.NumFlag = {\n      val r = parser.parseCliOptTypeNumFlag()\n      return r\n    }\n    val r = to(s, fCliOptTypeNumFlag _)\n    return r\n  }\n\n  def fromCliOptTypeNumChoice(o: CliOpt.Type.NumChoice, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNumChoice(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNumChoice(s: String): Either[CliOpt.Type.NumChoice, Json.ErrorMsg] = {\n    def fCliOptTypeNumChoice(parser: Parser): CliOpt.Type.NumChoice = {\n      val r = parser.parseCliOptTypeNumChoice()\n      return r\n    }\n    val r = to(s, fCliOptTypeNumChoice _)\n    return r\n  }\n\n  def fromCliOptTypeStr(o: CliOpt.Type.Str, isCompact: B): String = {\n    val st = Printer
  #662 = String             #661          // // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from CliOpt.scala\n\npackage org.sireum.cli\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printCliOpt(o: CliOpt): ST = {\n      o match {\n        case o: CliOpt.Group => return printCliOptGroup(o)\n        case o: CliOpt.Tool => return printCliOptTool(o)\n      }\n    }\n\n    @pure def printCliOptGroup(o: CliOpt.Group): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Group\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"description\", printString(o.description)),\n        (\"header\", printString(o.header)),\n        (\"unlisted\", printB(o.unlisted)),\n        (\"subs\", printISZ(F, o.subs, printCliOpt _))\n      ))\n    }\n\n    @pure def printCliOptTool(o: CliOpt.Tool): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Tool\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"command\", printString(o.command)),\n        (\"description\", printString(o.description)),\n        (\"header\", printString(o.header)),\n        (\"usage\", printString(o.usage)),\n        (\"usageDescOpt\", printOption(T, o.usageDescOpt, printString _)),\n        (\"opts\", printISZ(F, o.opts, printCliOptOpt _)),\n        (\"groups\", printISZ(F, o.groups, printCliOptOptGroup _))\n      ))\n    }\n\n    @pure def printCliOptOptGroup(o: CliOpt.OptGroup): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.OptGroup\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"opts\", printISZ(F, o.opts, printCliOptOpt _))\n      ))\n    }\n\n    @pure def printCliOptOpt(o: CliOpt.Opt): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Opt\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"longKey\", printString(o.longKey)),\n        (\"shortKey\", printOption(T, o.shortKey, printC _)),\n        (\"tpe\", printCliOptType(o.tpe)),\n        (\"description\", printString(o.description))\n      ))\n    }\n\n    @pure def printCliOptType(o: CliOpt.Type): ST = {\n      o match {\n        case o: CliOpt.Type.Flag => return printCliOptTypeFlag(o)\n        case o: CliOpt.Type.Num => return printCliOptTypeNum(o)\n        case o: CliOpt.Type.NumFlag => return printCliOptTypeNumFlag(o)\n        case o: CliOpt.Type.NumChoice => return printCliOptTypeNumChoice(o)\n        case o: CliOpt.Type.Str => return printCliOptTypeStr(o)\n        case o: CliOpt.Type.Choice => return printCliOptTypeChoice(o)\n        case o: CliOpt.Type.Path => return printCliOptTypePath(o)\n      }\n    }\n\n    @pure def printCliOptTypeFlag(o: CliOpt.Type.Flag): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Flag\"\"\"\"),\n        (\"default\", printB(o.default))\n      ))\n    }\n\n    @pure def printCliOptTypeNum(o: CliOpt.Type.Num): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Num\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"default\", printZ(o.default)),\n        (\"min\", printOption(T, o.min, printZ _)),\n        (\"max\", printOption(T, o.max, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeNumFlag(o: CliOpt.Type.NumFlag): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.NumFlag\"\"\"\"),\n        (\"default\", printZ(o.default)),\n        (\"min\", printOption(T, o.min, printZ _)),\n        (\"max\", printOption(T, o.max, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeNumChoice(o: CliOpt.Type.NumChoice): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.NumChoice\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"choices\", printISZ(T, o.choices, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeStr(o: CliOpt.Type.Str): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Str\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"default\", printOption(T, o.default, printString _))\n      ))\n    }\n\n    @pure def printCliOptTypeChoice(o: CliOpt.Type.Choice): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Choice\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"elements\", printISZ(T, o.elements, printString _))\n      ))\n    }\n\n    @pure def printCliOptTypePath(o: CliOpt.Type.Path): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Path\"\"\"\"),\n        (\"multiple\", printB(o.multiple)),\n        (\"default\", printOption(T, o.default, printString _))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parseCliOpt(): CliOpt = {\n      val t = parser.parseObjectTypes(ISZ(\"CliOpt.Group\", \"CliOpt.Tool\"))\n      t.native match {\n        case \"CliOpt.Group\" => val r = parseCliOptGroupT(T); return r\n        case \"CliOpt.Tool\" => val r = parseCliOptToolT(T); return r\n        case _ => val r = parseCliOptToolT(T); return r\n      }\n    }\n\n    def parseCliOptGroup(): CliOpt.Group = {\n      val r = parseCliOptGroupT(F)\n      return r\n    }\n\n    def parseCliOptGroupT(typeParsed: B): CliOpt.Group = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Group\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"header\")\n      val header = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"unlisted\")\n      val unlisted = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"subs\")\n      val subs = parser.parseISZ(parseCliOpt _)\n      parser.parseObjectNext()\n      return CliOpt.Group(name, description, header, unlisted, subs)\n    }\n\n    def parseCliOptTool(): CliOpt.Tool = {\n      val r = parseCliOptToolT(F)\n      return r\n    }\n\n    def parseCliOptToolT(typeParsed: B): CliOpt.Tool = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Tool\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"command\")\n      val command = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"header\")\n      val header = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"usage\")\n      val usage = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"usageDescOpt\")\n      val usageDescOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"opts\")\n      val opts = parser.parseISZ(parseCliOptOpt _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"groups\")\n      val groups = parser.parseISZ(parseCliOptOptGroup _)\n      parser.parseObjectNext()\n      return CliOpt.Tool(name, command, description, header, usage, usageDescOpt, opts, groups)\n    }\n\n    def parseCliOptOptGroup(): CliOpt.OptGroup = {\n      val r = parseCliOptOptGroupT(F)\n      return r\n    }\n\n    def parseCliOptOptGroupT(typeParsed: B): CliOpt.OptGroup = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.OptGroup\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"opts\")\n      val opts = parser.parseISZ(parseCliOptOpt _)\n      parser.parseObjectNext()\n      return CliOpt.OptGroup(name, opts)\n    }\n\n    def parseCliOptOpt(): CliOpt.Opt = {\n      val r = parseCliOptOptT(F)\n      return r\n    }\n\n    def parseCliOptOptT(typeParsed: B): CliOpt.Opt = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Opt\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"longKey\")\n      val longKey = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"shortKey\")\n      val shortKey = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"tpe\")\n      val tpe = parseCliOptType()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      return CliOpt.Opt(name, longKey, shortKey, tpe, description)\n    }\n\n    def parseCliOptType(): CliOpt.Type = {\n      val t = parser.parseObjectTypes(ISZ(\"CliOpt.Type.Flag\", \"CliOpt.Type.Num\", \"CliOpt.Type.NumFlag\", \"CliOpt.Type.NumChoice\", \"CliOpt.Type.Str\", \"CliOpt.Type.Choice\", \"CliOpt.Type.Path\"))\n      t.native match {\n        case \"CliOpt.Type.Flag\" => val r = parseCliOptTypeFlagT(T); return r\n        case \"CliOpt.Type.Num\" => val r = parseCliOptTypeNumT(T); return r\n        case \"CliOpt.Type.NumFlag\" => val r = parseCliOptTypeNumFlagT(T); return r\n        case \"CliOpt.Type.NumChoice\" => val r = parseCliOptTypeNumChoiceT(T); return r\n        case \"CliOpt.Type.Str\" => val r = parseCliOptTypeStrT(T); return r\n        case \"CliOpt.Type.Choice\" => val r = parseCliOptTypeChoiceT(T); return r\n        case \"CliOpt.Type.Path\" => val r = parseCliOptTypePathT(T); return r\n        case _ => val r = parseCliOptTypePathT(T); return r\n      }\n    }\n\n    def parseCliOptTypeFlag(): CliOpt.Type.Flag = {\n      val r = parseCliOptTypeFlagT(F)\n      return r\n    }\n\n    def parseCliOptTypeFlagT(typeParsed: B): CliOpt.Type.Flag = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Flag\")\n      }\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseB()\n      parser.parseObjectNext()\n      return CliOpt.Type.Flag(default)\n    }\n\n    def parseCliOptTypeNum(): CliOpt.Type.Num = {\n      val r = parseCliOptTypeNumT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumT(typeParsed: B): CliOpt.Type.Num = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Num\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"min\")\n      val min = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"max\")\n      val max = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Num(sep, default, min, max)\n    }\n\n    def parseCliOptTypeNumFlag(): CliOpt.Type.NumFlag = {\n      val r = parseCliOptTypeNumFlagT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumFlagT(typeParsed: B): CliOpt.Type.NumFlag = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.NumFlag\")\n      }\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"min\")\n      val min = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"max\")\n      val max = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.NumFlag(default, min, max)\n    }\n\n    def parseCliOptTypeNumChoice(): CliOpt.Type.NumChoice = {\n      val r = parseCliOptTypeNumChoiceT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumChoiceT(typeParsed: B): CliOpt.Type.NumChoice = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.NumChoice\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"choices\")\n      val choices = parser.parseISZ(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.NumChoice(sep, choices)\n    }\n\n    def parseCliOptTypeStr(): CliOpt.Type.Str = {\n      val r = parseCliOptTypeStrT(F)\n      return r\n    }\n\n    def parseCliOptTypeStrT(typeParsed: B): CliOpt.Type.Str = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Str\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Str(sep, default)\n    }\n\n    def parseCliOptTypeChoice(): CliOpt.Type.Choice = {\n      val r = parseCliOptTypeChoiceT(F)\n      return r\n    }\n\n    def parseCliOptTypeChoiceT(typeParsed: B): CliOpt.Type.Choice = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Choice\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"elements\")\n      val elements = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Choice(name, sep, elements)\n    }\n\n    def parseCliOptTypePath(): CliOpt.Type.Path = {\n      val r = parseCliOptTypePathT(F)\n      return r\n    }\n\n    def parseCliOptTypePathT(typeParsed: B): CliOpt.Type.Path = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Path\")\n      }\n      parser.parseObjectKey(\"multiple\")\n      val multiple = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Path(multiple, default)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromCliOpt(o: CliOpt, isCompact: B): String = {\n    val st = Printer.printCliOpt(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOpt(s: String): Either[CliOpt, Json.ErrorMsg] = {\n    def fCliOpt(parser: Parser): CliOpt = {\n      val r = parser.parseCliOpt()\n      return r\n    }\n    val r = to(s, fCliOpt _)\n    return r\n  }\n\n  def fromCliOptGroup(o: CliOpt.Group, isCompact: B): String = {\n    val st = Printer.printCliOptGroup(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptGroup(s: String): Either[CliOpt.Group, Json.ErrorMsg] = {\n    def fCliOptGroup(parser: Parser): CliOpt.Group = {\n      val r = parser.parseCliOptGroup()\n      return r\n    }\n    val r = to(s, fCliOptGroup _)\n    return r\n  }\n\n  def fromCliOptTool(o: CliOpt.Tool, isCompact: B): String = {\n    val st = Printer.printCliOptTool(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTool(s: String): Either[CliOpt.Tool, Json.ErrorMsg] = {\n    def fCliOptTool(parser: Parser): CliOpt.Tool = {\n      val r = parser.parseCliOptTool()\n      return r\n    }\n    val r = to(s, fCliOptTool _)\n    return r\n  }\n\n  def fromCliOptOptGroup(o: CliOpt.OptGroup, isCompact: B): String = {\n    val st = Printer.printCliOptOptGroup(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptOptGroup(s: String): Either[CliOpt.OptGroup, Json.ErrorMsg] = {\n    def fCliOptOptGroup(parser: Parser): CliOpt.OptGroup = {\n      val r = parser.parseCliOptOptGroup()\n      return r\n    }\n    val r = to(s, fCliOptOptGroup _)\n    return r\n  }\n\n  def fromCliOptOpt(o: CliOpt.Opt, isCompact: B): String = {\n    val st = Printer.printCliOptOpt(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptOpt(s: String): Either[CliOpt.Opt, Json.ErrorMsg] = {\n    def fCliOptOpt(parser: Parser): CliOpt.Opt = {\n      val r = parser.parseCliOptOpt()\n      return r\n    }\n    val r = to(s, fCliOptOpt _)\n    return r\n  }\n\n  def fromCliOptType(o: CliOpt.Type, isCompact: B): String = {\n    val st = Printer.printCliOptType(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptType(s: String): Either[CliOpt.Type, Json.ErrorMsg] = {\n    def fCliOptType(parser: Parser): CliOpt.Type = {\n      val r = parser.parseCliOptType()\n      return r\n    }\n    val r = to(s, fCliOptType _)\n    return r\n  }\n\n  def fromCliOptTypeFlag(o: CliOpt.Type.Flag, isCompact: B): String = {\n    val st = Printer.printCliOptTypeFlag(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeFlag(s: String): Either[CliOpt.Type.Flag, Json.ErrorMsg] = {\n    def fCliOptTypeFlag(parser: Parser): CliOpt.Type.Flag = {\n      val r = parser.parseCliOptTypeFlag()\n      return r\n    }\n    val r = to(s, fCliOptTypeFlag _)\n    return r\n  }\n\n  def fromCliOptTypeNum(o: CliOpt.Type.Num, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNum(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNum(s: String): Either[CliOpt.Type.Num, Json.ErrorMsg] = {\n    def fCliOptTypeNum(parser: Parser): CliOpt.Type.Num = {\n      val r = parser.parseCliOptTypeNum()\n      return r\n    }\n    val r = to(s, fCliOptTypeNum _)\n    return r\n  }\n\n  def fromCliOptTypeNumFlag(o: CliOpt.Type.NumFlag, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNumFlag(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNumFlag(s: String): Either[CliOpt.Type.NumFlag, Json.ErrorMsg] = {\n    def fCliOptTypeNumFlag(parser: Parser): CliOpt.Type.NumFlag = {\n      val r = parser.parseCliOptTypeNumFlag()\n      return r\n    }\n    val r = to(s, fCliOptTypeNumFlag _)\n    return r\n  }\n\n  def fromCliOptTypeNumChoice(o: CliOpt.Type.NumChoice, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNumChoice(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNumChoice(s: String): Either[CliOpt.Type.NumChoice, Json.ErrorMsg] = {\n    def fCliOptTypeNumChoice(parser: Parser): CliOpt.Type.NumChoice = {\n      val r = parser.parseCliOptTypeNumChoice()\n      return r\n    }\n    val r = to(s, fCliOptTypeNumChoice _)\n    return r\n  }\n\n  def fromCliOptTypeStr(o: CliOpt.Type.Str, isCompact: B): String = {\n    val st = Printer
  #663 = Utf8               .printCliOptTypeStr(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeStr(s: String): Either[CliOpt.Type.Str, Json.ErrorMsg] = {\n    def fCliOptTypeStr(parser: Parser): CliOpt.Type.Str = {\n      val r = parser.parseCliOptTypeStr()\n      return r\n    }\n    val r = to(s, fCliOptTypeStr _)\n    return r\n  }\n\n  def fromCliOptTypeChoice(o: CliOpt.Type.Choice, isCompact: B): String = {\n    val st = Printer.printCliOptTypeChoice(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeChoice(s: String): Either[CliOpt.Type.Choice, Json.ErrorMsg] = {\n    def fCliOptTypeChoice(parser: Parser): CliOpt.Type.Choice = {\n      val r = parser.parseCliOptTypeChoice()\n      return r\n    }\n    val r = to(s, fCliOptTypeChoice _)\n    return r\n  }\n\n  def fromCliOptTypePath(o: CliOpt.Type.Path, isCompact: B): String = {\n    val st = Printer.printCliOptTypePath(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypePath(s: String): Either[CliOpt.Type.Path, Json.ErrorMsg] = {\n    def fCliOptTypePath(parser: Parser): CliOpt.Type.Path = {\n      val r = parser.parseCliOptTypePath()\n      return r\n    }\n    val r = to(s, fCliOptTypePath _)\n    return r\n  }\n\n}
  #664 = String             #663          // .printCliOptTypeStr(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeStr(s: String): Either[CliOpt.Type.Str, Json.ErrorMsg] = {\n    def fCliOptTypeStr(parser: Parser): CliOpt.Type.Str = {\n      val r = parser.parseCliOptTypeStr()\n      return r\n    }\n    val r = to(s, fCliOptTypeStr _)\n    return r\n  }\n\n  def fromCliOptTypeChoice(o: CliOpt.Type.Choice, isCompact: B): String = {\n    val st = Printer.printCliOptTypeChoice(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeChoice(s: String): Either[CliOpt.Type.Choice, Json.ErrorMsg] = {\n    def fCliOptTypeChoice(parser: Parser): CliOpt.Type.Choice = {\n      val r = parser.parseCliOptTypeChoice()\n      return r\n    }\n    val r = to(s, fCliOptTypeChoice _)\n    return r\n  }\n\n  def fromCliOptTypePath(o: CliOpt.Type.Path, isCompact: B): String = {\n    val st = Printer.printCliOptTypePath(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypePath(s: String): Either[CliOpt.Type.Path, Json.ErrorMsg] = {\n    def fCliOptTypePath(parser: Parser): CliOpt.Type.Path = {\n      val r = parser.parseCliOptTypePath()\n      return r\n    }\n    val r = to(s, fCliOptTypePath _)\n    return r\n  }\n\n}
  #665 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.cli\n\nimport org.sireum._\n\n@datatype trait CliOpt {\n  @pure def name: String\n\n  @pure def command: String\n\n  @pure def description: String\n\n  @pure def header: String\n\n  @pure def unlisted: B\n}\n\nobject CliOpt {\n\n  val tqs: String = \"\\\"\\\"\\\"\"\n\n  @datatype class Group(\n    val name: String,\n    val description: String,\n    val header: String,\n    val unlisted: B,\n    val subs: ISZ[CliOpt]\n  ) extends CliOpt {\n\n    @pure def command: String = {\n      return name\n    }\n  }\n\n  @datatype class Tool(\n    val name: String,\n    val command: String,\n    val description: String,\n    val header: String,\n    val usage: String,\n    val usageDescOpt: Option[String],\n    val opts: ISZ[Opt],\n    val groups: ISZ[OptGroup]\n  ) extends CliOpt {\n    override def unlisted: B = {\n      return F\n    }\n  }\n\n  @datatype class OptGroup(val name: String, val opts: ISZ[Opt])\n\n  @datatype class Opt(val name: String, val longKey: String, val shortKey: Option[C], val tpe: Type, val description: String)\n\n  @datatype trait Type\n\n  object Type {\n\n    @datatype class Flag(val default: B) extends Type\n\n    @datatype class Num(val sep: Option[C], val default: Z, val min: Option[Z], val max: Option[Z]) extends Type\n\n    @datatype class NumFlag(val default: Z, val min: Option[Z], val max: Option[Z]) extends Type\n\n    @datatype class NumChoice(val sep: Option[C], val choices: ISZ[Z]) extends Type\n\n    @datatype class Str(val sep: Option[C], val default: Option[String]) extends Type\n\n    @datatype class Choice(val name: String, val sep: Option[C], val elements: ISZ[String]) extends Type\n\n    @datatype class Path(val multiple: B, val default: Option[String]) extends Type\n\n  }\n\n}\n
  #666 = String             #665          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.cli\n\nimport org.sireum._\n\n@datatype trait CliOpt {\n  @pure def name: String\n\n  @pure def command: String\n\n  @pure def description: String\n\n  @pure def header: String\n\n  @pure def unlisted: B\n}\n\nobject CliOpt {\n\n  val tqs: String = \"\\\"\\\"\\\"\"\n\n  @datatype class Group(\n    val name: String,\n    val description: String,\n    val header: String,\n    val unlisted: B,\n    val subs: ISZ[CliOpt]\n  ) extends CliOpt {\n\n    @pure def command: String = {\n      return name\n    }\n  }\n\n  @datatype class Tool(\n    val name: String,\n    val command: String,\n    val description: String,\n    val header: String,\n    val usage: String,\n    val usageDescOpt: Option[String],\n    val opts: ISZ[Opt],\n    val groups: ISZ[OptGroup]\n  ) extends CliOpt {\n    override def unlisted: B = {\n      return F\n    }\n  }\n\n  @datatype class OptGroup(val name: String, val opts: ISZ[Opt])\n\n  @datatype class Opt(val name: String, val longKey: String, val shortKey: Option[C], val tpe: Type, val description: String)\n\n  @datatype trait Type\n\n  object Type {\n\n    @datatype class Flag(val default: B) extends Type\n\n    @datatype class Num(val sep: Option[C], val default: Z, val min: Option[Z], val max: Option[Z]) extends Type\n\n    @datatype class NumFlag(val default: Z, val min: Option[Z], val max: Option[Z]) extends Type\n\n    @datatype class NumChoice(val sep: Option[C], val choices: ISZ[Z]) extends Type\n\n    @datatype class Str(val sep: Option[C], val default: Option[String]) extends Type\n\n    @datatype class Choice(val name: String, val sep: Option[C], val elements: ISZ[String]) extends Type\n\n    @datatype class Path(val multiple: B, val default: Option[String]) extends Type\n\n  }\n\n}\n
  #667 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@record trait MEither[L, R] {\n\n  @pure def isLeft: B = Contract.Only(Ensures(Res == ∃{e: L => MEither.Left[L, R](e) == this}))\n\n  @pure def isRight: B = Contract.Only(Ensures(!isLeft))\n\n  @pure def leftOpt: MOption[L] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(MEither.Left[L, R](Res[MOption[L]].get) == this)\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Res == MNone[L]())\n    ),\n  )\n\n  @pure def left: L = Contract.Only(\n    Requires(isLeft),\n    Ensures(MEither.Left[L, R](Res) == this)\n  )\n\n  @pure def rightOpt: MOption[R] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Res == MNone[R]())\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(MEither.Right[L, R](Res[MOption[R]].get) == this)\n    )\n  )\n\n  @pure def right: R\n}\n\nobject MEither {\n\n  @record class Left[L, R](val value: L) extends MEither[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def leftOpt: MOption[L] = {\n      Contract(Ensures(Res == MSome(value)))\n      return MSome(value)\n    }\n\n    @pure override def left: L = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n    @pure override def rightOpt: MOption[R] = {\n      Contract(Ensures(Res == MNone[R]()))\n      return MNone()\n    }\n\n    @pure override def right: R = {\n      Contract(Requires(F))\n      halt(\"Invalid \'MEither.Left\' operation \'right\'.\")\n    }\n\n  }\n\n  @record class Right[L, R](val value: R) extends MEither[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def leftOpt: MOption[L] = {\n      Contract(Ensures(Res == MNone[L]()))\n      return MNone()\n    }\n\n    @pure override def left: L = {\n      Contract(Requires(F))\n      halt(\"Invalid \'MEither.Right\' operation \'left\'.\")\n    }\n\n    @pure override def rightOpt: MOption[R] = {\n      Contract(Ensures(Res == MSome(value)))\n      return MSome(value)\n    }\n\n    @pure override def right: R = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n  }\n\n  @strictpure def left[L, R](value: L): MEither[L, R] = Left(value)\n\n  @strictpure def right[L, R](value: R): MEither[L, R] = Right(value)\n\n}\n
  #668 = String             #667          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@record trait MEither[L, R] {\n\n  @pure def isLeft: B = Contract.Only(Ensures(Res == ∃{e: L => MEither.Left[L, R](e) == this}))\n\n  @pure def isRight: B = Contract.Only(Ensures(!isLeft))\n\n  @pure def leftOpt: MOption[L] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(MEither.Left[L, R](Res[MOption[L]].get) == this)\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Res == MNone[L]())\n    ),\n  )\n\n  @pure def left: L = Contract.Only(\n    Requires(isLeft),\n    Ensures(MEither.Left[L, R](Res) == this)\n  )\n\n  @pure def rightOpt: MOption[R] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Res == MNone[R]())\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(MEither.Right[L, R](Res[MOption[R]].get) == this)\n    )\n  )\n\n  @pure def right: R\n}\n\nobject MEither {\n\n  @record class Left[L, R](val value: L) extends MEither[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def leftOpt: MOption[L] = {\n      Contract(Ensures(Res == MSome(value)))\n      return MSome(value)\n    }\n\n    @pure override def left: L = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n    @pure override def rightOpt: MOption[R] = {\n      Contract(Ensures(Res == MNone[R]()))\n      return MNone()\n    }\n\n    @pure override def right: R = {\n      Contract(Requires(F))\n      halt(\"Invalid \'MEither.Left\' operation \'right\'.\")\n    }\n\n  }\n\n  @record class Right[L, R](val value: R) extends MEither[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def leftOpt: MOption[L] = {\n      Contract(Ensures(Res == MNone[L]()))\n      return MNone()\n    }\n\n    @pure override def left: L = {\n      Contract(Requires(F))\n      halt(\"Invalid \'MEither.Right\' operation \'left\'.\")\n    }\n\n    @pure override def rightOpt: MOption[R] = {\n      Contract(Ensures(Res == MSome(value)))\n      return MSome(value)\n    }\n\n    @pure override def right: R = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n  }\n\n  @strictpure def left[L, R](value: L): MEither[L, R] = Left(value)\n\n  @strictpure def right[L, R](value: R): MEither[L, R] = Right(value)\n\n}\n
  #669 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Use (patched) AntlrWorks at https://github.com/sireum/antlrworks to generate the parser/lexer\n\npackage org.sireum.parser\n\nimport org.sireum._\nimport org.sireum.U32._\nimport org.sireum.message.Position\n\n@datatype trait ParseTree {\n  @pure def ruleName: String\n  @pure def toST: ST\n  @pure def tipe: U32\n\n  override def string: String = {\n    return toST.render\n  }\n}\n\nobject ParseTree {\n\n  @datatype class Leaf(val text: String,\n                       @hidden val ruleName: String,\n                       @hidden val tipe: U32,\n                       @hidden val isHidden: B,\n                       @hidden val posOpt: Option[Position]) extends ParseTree {\n    @pure override def toST: ST = {\n      return if (ops.StringOps(ruleName).startsWith(\"\'\")) st\"\"\"\"${ops.StringOps(text).escapeST}\"\"\"\"\n      else st\"\"\"$ruleName[\"${ops.StringOps(text).escapeST}\"]\"\"\"\n    }\n  }\n\n  @datatype class Node(val children: ISZ[ParseTree],\n                       @hidden val ruleName: String,\n                       @hidden val tipe: U32) extends ParseTree {\n    @strictpure override def toST: ST = st\"\"\"$ruleName(${(for (child <- children) yield child.toST, \", \")})\"\"\"\n  }\n\n  @record class DotGenerator {\n    var fresh: Z = -1\n    var nodes: ISZ[ST] = ISZ()\n    var edges: ISZ[ST] = ISZ()\n\n    def toDot(root: ParseTree): ST = {\n      def rec(tree: ParseTree): ST = {\n        fresh = fresh + 1\n        val name = st\"n$fresh\"\n        tree match {\n          case tree: Node =>\n            nodes = nodes :+ st\"\"\"$name [label = \"${tree.ruleName}\"]\"\"\"\n            for (child <- tree.children) {\n              val childName = rec(child)\n              edges = edges :+ st\"\"\"$name -> $childName\"\"\"\n            }\n          case tree: Leaf =>\n            nodes = nodes :+ st\"\"\"$name [label = ${tree.toST}]\"\"\"\n        }\n        return name\n      }\n\n      rec(root)\n      val r =\n        st\"\"\"digraph G {\n            |  node [shape = \"rect\"]\n            |\n            |  ${(nodes, \"\\n\")}\n            |\n            |  ${(edges, \"\\n\")}\n            |}\"\"\"\n      return r\n    }\n  }\n\n  object Node {\n    @strictpure def empty: Node = Node(ISZ(), \"Tree\", u32\"-1\")\n  }\n\n  @sig trait BinaryPrecedenceOps[Builder, T1, T2] {\n    @pure def messageKind: String\n\n    @pure def isBinary(t: T2): B\n\n    @pure def isRightAssoc(t: T2): B\n\n    @pure def isHigherPrecedence(n1: Z, n2: Z): B\n\n    @pure def lowestPrecedence: Z\n\n    @pure def shouldParenthesizeOperands(t: T2): B\n\n    @pure def precedence(t: T2): Option[Z]\n\n    @pure def posOpt(t: T2): Option[message.Position]\n\n    @pure def parenthesize(builder: Builder, t: T2): T2\n\n    @pure def binary(builder: Builder, left: T2, op: T2, right: T2): T2\n\n    @pure def transform(builder: Builder, tree: T1): T2\n\n    @pure def toString(t: T2): String\n  }\n\n\n  // T1[exp] ( T1[op] T1[exp] )* => T2[exp]\n  def rewriteBinary[Builder, T1, T2](builder: Builder,\n                                     bp: BinaryPrecedenceOps[Builder, T1, T2],\n                                     trees: ISZ[T1],\n                                     reporter: message.Reporter): T2 = {\n    def construct(ts: ISZ[T2], rightAssoc: B, start: Z, stop: Z): T2 = {\n      if (rightAssoc) {\n        var r = ts(stop)\n        for (i <- stop - 2 to start by -2) {\n          val op = ts(i + 1)\n          var l = ts(i)\n          if (bp.shouldParenthesizeOperands(op)) {\n            if (bp.isBinary(l)) {\n              l = bp.parenthesize(builder, l)\n            }\n            if (bp.shouldParenthesizeOperands(op)) {\n              r = bp.parenthesize(builder, r)\n            }\n          }\n          r = bp.binary(builder, l, op, r)\n        }\n        return r\n      } else {\n        var l = ts(start)\n        for (i <- start + 2 to stop by 2) {\n          val op = ts(i - 1)\n          var r = ts(i)\n          if (bp.shouldParenthesizeOperands(op)) {\n            if (bp.isBinary(l)) {\n              l = bp.parenthesize(builder, l)\n            }\n            if (bp.shouldParenthesizeOperands(op)) {\n              r = bp.parenthesize(builder, r)\n            }\n          }\n          l = bp.binary(builder, l, op, r)\n        }\n        return l\n      }\n    }\n\n    def maxPrecedence(ts: ISZ[T2]): Z = {\n      var max = bp.lowestPrecedence\n      for (e <- ts) {\n        bp.precedence(e) match {\n          case Some(n) if bp.isHigherPrecedence(n, max) => max = n\n          case _ =>\n        }\n      }\n      return max\n    }\n\n    def reduceHighestPrecedence(acs: ISZ[T2]): ISZ[T2] = {\n      val max = maxPrecedence(acs)\n      val maxOpt: Option[Z] = Some(max)\n\n      def findMaxPrecedenceIndex(from: Z): Z = {\n        for (i <- from until acs.size if bp.precedence(acs(i)) == maxOpt) {\n          return i\n        }\n        return acs.size\n      }\n\n      var newAcs = ISZ[T2]()\n      var start = findMaxPrecedenceIndex(1)\n      for (j <- 0 to start - 2) {\n        newAcs = newAcs :+ acs(j)\n      }\n      while (start < acs.size) {\n        val startOp = acs(start)\n        var i = start + 2\n        var found = false\n        while (!found && i < acs.size) {\n          val op = acs(i)\n          if (bp.precedence(op) == bp.precedence(startOp)) {\n            if (bp.isRightAssoc(op) != bp.isRightAssoc(op)) {\n              reporter.error(bp.posOpt(op), bp.messageKind,\n                s\"Could not mix right/left associative operators with the same precedence: ${bp.toString(op)}, ${bp.toString(startOp)}\")\n            }\n            i = i + 2\n          } else {\n            found = true\n          }\n        }\n        if (i - start >= 2) {\n          newAcs = newAcs :+ construct(acs, bp.isRightAssoc(startOp), start - 1, i - 1)\n        } else {\n          for (j <- start - 1 until i) {\n            newAcs = newAcs :+ acs(j)\n          }\n        }\n\n        start = findMaxPrecedenceIndex(i + 2)\n        if (start < acs.size) {\n          for (j <- i to start - 2) {\n            newAcs = newAcs :+ acs(j)\n          }\n        } else {\n          for (j <- i until acs.size) {\n            newAcs = newAcs :+ acs(j)\n          }\n        }\n      }\n      return newAcs\n    }\n\n    var acs: ISZ[T2] = for (t <- trees) yield bp.transform(builder, t)\n    while (acs.size != 1) {\n      acs = reduceHighestPrecedence(acs)\n    }\n    return acs(0)\n  }\n\n}\n
  #670 = String             #669          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Use (patched) AntlrWorks at https://github.com/sireum/antlrworks to generate the parser/lexer\n\npackage org.sireum.parser\n\nimport org.sireum._\nimport org.sireum.U32._\nimport org.sireum.message.Position\n\n@datatype trait ParseTree {\n  @pure def ruleName: String\n  @pure def toST: ST\n  @pure def tipe: U32\n\n  override def string: String = {\n    return toST.render\n  }\n}\n\nobject ParseTree {\n\n  @datatype class Leaf(val text: String,\n                       @hidden val ruleName: String,\n                       @hidden val tipe: U32,\n                       @hidden val isHidden: B,\n                       @hidden val posOpt: Option[Position]) extends ParseTree {\n    @pure override def toST: ST = {\n      return if (ops.StringOps(ruleName).startsWith(\"\'\")) st\"\"\"\"${ops.StringOps(text).escapeST}\"\"\"\"\n      else st\"\"\"$ruleName[\"${ops.StringOps(text).escapeST}\"]\"\"\"\n    }\n  }\n\n  @datatype class Node(val children: ISZ[ParseTree],\n                       @hidden val ruleName: String,\n                       @hidden val tipe: U32) extends ParseTree {\n    @strictpure override def toST: ST = st\"\"\"$ruleName(${(for (child <- children) yield child.toST, \", \")})\"\"\"\n  }\n\n  @record class DotGenerator {\n    var fresh: Z = -1\n    var nodes: ISZ[ST] = ISZ()\n    var edges: ISZ[ST] = ISZ()\n\n    def toDot(root: ParseTree): ST = {\n      def rec(tree: ParseTree): ST = {\n        fresh = fresh + 1\n        val name = st\"n$fresh\"\n        tree match {\n          case tree: Node =>\n            nodes = nodes :+ st\"\"\"$name [label = \"${tree.ruleName}\"]\"\"\"\n            for (child <- tree.children) {\n              val childName = rec(child)\n              edges = edges :+ st\"\"\"$name -> $childName\"\"\"\n            }\n          case tree: Leaf =>\n            nodes = nodes :+ st\"\"\"$name [label = ${tree.toST}]\"\"\"\n        }\n        return name\n      }\n\n      rec(root)\n      val r =\n        st\"\"\"digraph G {\n            |  node [shape = \"rect\"]\n            |\n            |  ${(nodes, \"\\n\")}\n            |\n            |  ${(edges, \"\\n\")}\n            |}\"\"\"\n      return r\n    }\n  }\n\n  object Node {\n    @strictpure def empty: Node = Node(ISZ(), \"Tree\", u32\"-1\")\n  }\n\n  @sig trait BinaryPrecedenceOps[Builder, T1, T2] {\n    @pure def messageKind: String\n\n    @pure def isBinary(t: T2): B\n\n    @pure def isRightAssoc(t: T2): B\n\n    @pure def isHigherPrecedence(n1: Z, n2: Z): B\n\n    @pure def lowestPrecedence: Z\n\n    @pure def shouldParenthesizeOperands(t: T2): B\n\n    @pure def precedence(t: T2): Option[Z]\n\n    @pure def posOpt(t: T2): Option[message.Position]\n\n    @pure def parenthesize(builder: Builder, t: T2): T2\n\n    @pure def binary(builder: Builder, left: T2, op: T2, right: T2): T2\n\n    @pure def transform(builder: Builder, tree: T1): T2\n\n    @pure def toString(t: T2): String\n  }\n\n\n  // T1[exp] ( T1[op] T1[exp] )* => T2[exp]\n  def rewriteBinary[Builder, T1, T2](builder: Builder,\n                                     bp: BinaryPrecedenceOps[Builder, T1, T2],\n                                     trees: ISZ[T1],\n                                     reporter: message.Reporter): T2 = {\n    def construct(ts: ISZ[T2], rightAssoc: B, start: Z, stop: Z): T2 = {\n      if (rightAssoc) {\n        var r = ts(stop)\n        for (i <- stop - 2 to start by -2) {\n          val op = ts(i + 1)\n          var l = ts(i)\n          if (bp.shouldParenthesizeOperands(op)) {\n            if (bp.isBinary(l)) {\n              l = bp.parenthesize(builder, l)\n            }\n            if (bp.shouldParenthesizeOperands(op)) {\n              r = bp.parenthesize(builder, r)\n            }\n          }\n          r = bp.binary(builder, l, op, r)\n        }\n        return r\n      } else {\n        var l = ts(start)\n        for (i <- start + 2 to stop by 2) {\n          val op = ts(i - 1)\n          var r = ts(i)\n          if (bp.shouldParenthesizeOperands(op)) {\n            if (bp.isBinary(l)) {\n              l = bp.parenthesize(builder, l)\n            }\n            if (bp.shouldParenthesizeOperands(op)) {\n              r = bp.parenthesize(builder, r)\n            }\n          }\n          l = bp.binary(builder, l, op, r)\n        }\n        return l\n      }\n    }\n\n    def maxPrecedence(ts: ISZ[T2]): Z = {\n      var max = bp.lowestPrecedence\n      for (e <- ts) {\n        bp.precedence(e) match {\n          case Some(n) if bp.isHigherPrecedence(n, max) => max = n\n          case _ =>\n        }\n      }\n      return max\n    }\n\n    def reduceHighestPrecedence(acs: ISZ[T2]): ISZ[T2] = {\n      val max = maxPrecedence(acs)\n      val maxOpt: Option[Z] = Some(max)\n\n      def findMaxPrecedenceIndex(from: Z): Z = {\n        for (i <- from until acs.size if bp.precedence(acs(i)) == maxOpt) {\n          return i\n        }\n        return acs.size\n      }\n\n      var newAcs = ISZ[T2]()\n      var start = findMaxPrecedenceIndex(1)\n      for (j <- 0 to start - 2) {\n        newAcs = newAcs :+ acs(j)\n      }\n      while (start < acs.size) {\n        val startOp = acs(start)\n        var i = start + 2\n        var found = false\n        while (!found && i < acs.size) {\n          val op = acs(i)\n          if (bp.precedence(op) == bp.precedence(startOp)) {\n            if (bp.isRightAssoc(op) != bp.isRightAssoc(op)) {\n              reporter.error(bp.posOpt(op), bp.messageKind,\n                s\"Could not mix right/left associative operators with the same precedence: ${bp.toString(op)}, ${bp.toString(startOp)}\")\n            }\n            i = i + 2\n          } else {\n            found = true\n          }\n        }\n        if (i - start >= 2) {\n          newAcs = newAcs :+ construct(acs, bp.isRightAssoc(startOp), start - 1, i - 1)\n        } else {\n          for (j <- start - 1 until i) {\n            newAcs = newAcs :+ acs(j)\n          }\n        }\n\n        start = findMaxPrecedenceIndex(i + 2)\n        if (start < acs.size) {\n          for (j <- i to start - 2) {\n            newAcs = newAcs :+ acs(j)\n          }\n        } else {\n          for (j <- i until acs.size) {\n            newAcs = newAcs :+ acs(j)\n          }\n        }\n      }\n      return newAcs\n    }\n\n    var acs: ISZ[T2] = for (t <- trees) yield bp.transform(builder, t)\n    while (acs.size != 1) {\n      acs = reduceHighestPrecedence(acs)\n    }\n    return acs(0)\n  }\n\n}\n
  #671 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from JSON.g\n\npackage org.sireum.parser\n\n\nimport org.sireum._\nimport org.sireum.U32._\nimport org.sireum.U64._\nimport org.sireum.conversions.U32.toC\n\nobject Json {\n  @range(min = 0, max = 9) class State\n}\n\nimport Json.State\nimport Json.State._\n\nobject JsonParser {\n\n  @datatype class Result(val kind: Result.Kind.Type, val tree: ParseTree, val newIndex: Z) {\n    def leaf: ParseTree.Leaf = {\n      return tree.asInstanceOf[ParseTree.Leaf]\n    }\n  }\n\n  object Result {\n\n    @enum object Kind {\n      \'Normal\n      \'LexicalError\n      \'GrammaticalError\n    }\n\n    @strictpure def create(tree: ParseTree, newIndex: Z): Result =\n      Result(Result.Kind.Normal, tree, newIndex)\n\n    @strictpure def error(isLexical: B, index: Z): Result =\n      Result(if (isLexical) Result.Kind.LexicalError else Result.Kind.GrammaticalError, errorLeaf, index)\n\n  }\n\n  @record class Context(val ruleName: String,\n                        val ruleType: U32,\n                        val accepting: IS[State, B],\n                        var state: State,\n                        var resOpt: Option[Result],\n                        var j: Z,\n                        var max: Z,\n                        var initial: B,\n                        var trees: ISZ[ParseTree],\n                        var found: B,\n                        var failIndex: Z,\n                        var isLexical: B) {\n\n    def updateTerminal(token: ParseTree.Leaf, newState: State): Unit = {\n      found = T\n      j = j + 1\n      initial = F\n      state = newState\n      trees = trees :+ token\n      if (accepting(state)) {\n        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))\n      }\n    }\n\n    def updateNonTerminal(r: Result, newState: State): Unit = {\n      found = T\n      initial = F\n      j = r.newIndex\n      state = newState\n      trees = trees :+ r.tree\n      if (accepting(state)) {\n        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))\n      }\n    }\n  }\n\n  object Context {\n    @pure def create(ruleName: String, ruleType: U32, accepts: ISZ[State], i: Z): Context = {\n      val accepting = MS.create[State, B](10, F)\n      for (accept <- accepts) {\n        accepting(accept) = T\n      }\n      return Context(\n        ruleName = ruleName,\n        ruleType = ruleType,\n        accepting = accepting.toIS,\n        state = state\"0\",\n        resOpt = None(),\n        trees = ISZ[ParseTree](),\n        j = i,\n        max = i,\n        initial = T,\n        found = F,\n        failIndex = 0,\n        isLexical = F\n      )\n    }\n  }\n\n  @record class LContext(val accepting: IS[State, B], var state: State, var j: Z, var afterAcceptIndex: Z, var found: B) {\n    def update(newState: State): Unit = {\n      state = newState\n      found = T\n      if (accepting(state)) {\n        afterAcceptIndex = j + 1\n      }\n    }\n  }\n\n  object LContext {\n    @pure def create(accepts: ISZ[State], i: Z): LContext = {\n      val accepting = MS.create[State, B](10, F)\n      for (accept <- accepts) {\n        accepting(accept) = T\n      }\n      return LContext(accepting = accepting.toIS, state = state\"0\", j = i, afterAcceptIndex = -1, found = F)\n    }\n  }\n\n  @datatype class IndexableToken(val input: Indexable.Pos[C], val skipHidden: B) extends Indexable[Result] {\n    val lexer: JsonLexer = JsonLexer(input)\n\n    override def at(i: Z): Result = {\n      return _at(i)\n    }\n\n    override def has(i: Z): B = {\n      return _has(i)\n    }\n\n    @memoize def _has(i: Z): B = {\n      assert(i >= 0)\n      if (i == 0) {\n        return T\n      }\n      if (!_has(i - 1)) {\n        return F\n      }\n      val prev = _at(i - 1)\n      return prev.kind == Result.Kind.Normal && prev.newIndex != -1\n    }\n\n    @memoize def _at(i: Z): Result = {\n      if (i == 0) {\n        if (input.has(0)) {\n          lexer.tokenize(0, skipHidden) match {\n            case Some(result) => return result\n            case _ =>\n          }\n        }\n      } else {\n        val prev = _at(i - 1)\n        if (input.has(prev.newIndex)) {\n          lexer.tokenize(prev.newIndex, skipHidden) match {\n            case Some(result) => return result\n            case _ =>\n          }\n        }\n      }\n      return Result(Result.Kind.Normal, eofLeaf, -1)\n    }\n\n  }\n\n  val kind: String = \"JsonParser\"\n\n  val minChar: C = \'\\u0000\'\n  val maxChar: C = toC(u32\"0x0010FFFF\")\n\n  val T_AFEF039D: U32 = u32\"0xAFEF039D\" /* \"true\" */\n  val T_D8AFD1B9: U32 = u32\"0xD8AFD1B9\" /* \"false\" */\n  val T_3EA44541: U32 = u32\"0x3EA44541\" /* \"null\" */\n  val T_FDCE65E5: U32 = u32\"0xFDCE65E5\" /* \"{\" */\n  val T_763C38BE: U32 = u32\"0x763C38BE\" /* \":\" */\n  val T_45445E21: U32 = u32\"0x45445E21\" /* \",\" */\n  val T_5BF60471: U32 = u32\"0x5BF60471\" /* \"}\" */\n  val T_A44269E9: U32 = u32\"0xA44269E9\" /* \"[\" */\n  val T_9977908D: U32 = u32\"0x9977908D\" /* \"]\" */\n  val T_STRING: U32 = u32\"0xA7CF0FE0\"\n  val T_NUMBER: U32 = u32\"0x28C20CF1\"\n  val T_WS: U32 = u32\"0x0E3F5D1E\"\n  val T_valueFile: U32 = u32\"0x94F3E412\"\n  val T_value: U32 = u32\"0x82EEA07A\"\n  val T_object: U32 = u32\"0x5ED5358F\"\n  val T_array: U32 = u32\"0xB11A9723\"\n\n  val errorLeaf: ParseTree.Leaf = ParseTree.Leaf(\"<ERROR>\", \"<ERROR>\", u32\"0xE3CDEDDA\", F, None())\n  val eofLeaf: ParseTree.Leaf = ParseTree.Leaf(\"<EOF>\", \"EOF\", u32\"0xFC5CB374\", F, None())\n\n  def parse(uriOpt: Option[String], input: String, reporter: message.Reporter): Option[ParseTree] = {\n    val docInfo = message.DocInfo.create(uriOpt, input)\n    val tokens = lex(input, docInfo, T, T, reporter)\n    if (reporter.hasError) {\n      return None()\n    }\n    val r = JsonParser(Indexable.fromIsz(tokens)).parseValueFile(0)\n    r.kind match {\n      case Result.Kind.Normal => return Some(r.tree)\n      case Result.Kind.LexicalError =>\n        reporter.error(Some(message.PosInfo(docInfo, offsetLength(r.newIndex, 1))), kind, s\"Could not recognize token\")\n        return None()\n      case Result.Kind.GrammaticalError =>\n        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex\n        if (idx < tokens.size) {\n          val token = tokens(idx).leaf\n          reporter.error(token.posOpt, kind, s\"Could not parse token: \\\"${ops.StringOps(token.text).escapeST.render}\\\"\")\n        } else {\n          val token = tokens(idx - 1).leaf\n          reporter.error(token.posOpt, kind, \"Expecting more input but reached the end\")\n        }\n        return None()\n    }\n  }\n\n  def parseIndexable(input: Indexable.Pos[C], reporter: message.Reporter): Option[ParseTree] = {\n    val it = IndexableToken(input, T)\n    val r = JsonParser(it).parseValueFile(0)\n    r.kind match {\n      case Result.Kind.Normal => return Some(r.tree)\n      case Result.Kind.LexicalError =>\n        reporter.error(input.posOpt(r.newIndex, 1), kind, s\"Could not recognize token\")\n        return None()\n      case Result.Kind.GrammaticalError =>\n        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex\n        if (it.has(idx)) {\n          val token = it.at(idx).leaf\n          reporter.error(token.posOpt, kind, s\"Could not parse token: \\\"${ops.StringOps(token.text).escapeST.render}\\\"\")\n        } else {\n          val token = it.at(idx - 1).leaf\n          reporter.error(token.posOpt, kind, \"Expecting more input but reached the end\")\n        }\n        return None()\n    }\n  }\n\n  def lex(input: String, docInfo: message.DocInfo, skipHidden: B, stopAtError: B,\n          reporter: message.Reporter): ISZ[Result] = {\n    return JsonLexer(Indexable.fromIszDocInfo(conversions.String.toCis(input), docInfo)).tokenizeAll(skipHidden, stopAtError, reporter)\n  }\n\n  @strictpure def offsetLength(offset: Z, length: Z): U64 =\n    (conversions.Z.toU64(offset) << u64\"32\") | (conversions.Z.toU64(length) & u64\"0xFFFFFFFF\")\n\n}\n\nimport JsonParser._\n\n@datatype class JsonParser(tokens: Indexable[Result]) {\n\n  @pure def parseValueFile(i: Z): Result = {\n    val ctx = Context.create(\"valueFile\", u32\"0x94F3E412\", ISZ(state\"2\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"1\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xFC5CB374\" /* EOF */ => ctx.updateTerminal(token, state\"2\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseValue(i: Z): Result = {\n    val ctx = Context.create(\"value\", u32\"0x82EEA07A\", ISZ(state\"1\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          val n_object = predictObject(ctx.j)\n          val n_array = predictArray(ctx.j)\n          for (n <- 1 to 1 by -1 if !ctx.found) {\n            if (n_object == n && parseObjectH(ctx, state\"1\")) {\n              return Result.error(ctx.isLexical, ctx.failIndex)\n            } else if (n_array == n && parseArrayH(ctx, state\"1\")) {\n              return Result.error(ctx.isLexical, ctx.failIndex)\n            }\n          }\n          if (!ctx.found) {\n            token.tipe match {\n              case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0x28C20CF1\" /* NUMBER */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0xAFEF039D\" /* \"true\" */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0xD8AFD1B9\" /* \"false\" */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0x3EA44541\" /* \"null\" */ => ctx.updateTerminal(token, state\"1\")\n              case _ =>\n            }\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseObject(i: Z): Result = {\n    val ctx = Context.create(\"object\", u32\"0x5ED5358F\", ISZ(state\"8\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xFDCE65E5\" /* \"{\" */ => ctx.updateTerminal(token, state\"1\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"2\")\n            case u32\"0x5BF60471\" /* \"}\" */ => ctx.updateTerminal(token, state\"8\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x763C38BE\" /* \":\" */ => ctx.updateTerminal(token, state\"3\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"3\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"4\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"4\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x45445E21\" /* \",\" */ => ctx.updateTerminal(token, state\"5\")\n            case u32\"0x5BF60471\" /* \"}\" */ => ctx.updateTerminal(token, state\"8\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"5\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"6\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"6\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x763C38BE\" /* \":\" */ => ctx.updateTerminal(token, state\"7\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"7\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"4\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"8\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseArray(i: Z): Result = {\n    val ctx = Context.create(\"array\", u32\"0xB11A9723\", ISZ(state\"4\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA44269E9\" /* \"[\" */ => ctx.updateTerminal(token, state\"1\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"2\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            token.tipe match {\n              case u32\"0x9977908D\" /* \"]\" */ => ctx.updateTerminal(token, state\"4\")\n              case _ =>\n            }\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x45445E21\" /* \",\" */ => ctx.updateTerminal(token, state\"3\")\n            case u32\"0x9977908D\" /* \"]\" */ => ctx.updateTerminal(token, state\"4\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"3\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"2\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"4\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  def parseValueH(ctx: Context, nextState: State): B = {\n    val r = parseValue(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  def parseObjectH(ctx: Context, nextState: State): B = {\n    val r = parseObject(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  def parseArrayH(ctx: Context, nextState: State): B = {\n    val r = parseArray(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  @pure def predictValueFile(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xA7CF0FE0\" /* STRING */ => return 1\n        case u32\"0x28C20CF1\" /* NUMBER */ => return 1\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case u32\"0xAFEF039D\" /* \"true\" */ => return 1\n        case u32\"0xD8AFD1B9\" /* \"false\" */ => return 1\n        case u32\"0x3EA44541\" /* \"null\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictArray(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictValue(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tip
  #672 = String             #671          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from JSON.g\n\npackage org.sireum.parser\n\n\nimport org.sireum._\nimport org.sireum.U32._\nimport org.sireum.U64._\nimport org.sireum.conversions.U32.toC\n\nobject Json {\n  @range(min = 0, max = 9) class State\n}\n\nimport Json.State\nimport Json.State._\n\nobject JsonParser {\n\n  @datatype class Result(val kind: Result.Kind.Type, val tree: ParseTree, val newIndex: Z) {\n    def leaf: ParseTree.Leaf = {\n      return tree.asInstanceOf[ParseTree.Leaf]\n    }\n  }\n\n  object Result {\n\n    @enum object Kind {\n      \'Normal\n      \'LexicalError\n      \'GrammaticalError\n    }\n\n    @strictpure def create(tree: ParseTree, newIndex: Z): Result =\n      Result(Result.Kind.Normal, tree, newIndex)\n\n    @strictpure def error(isLexical: B, index: Z): Result =\n      Result(if (isLexical) Result.Kind.LexicalError else Result.Kind.GrammaticalError, errorLeaf, index)\n\n  }\n\n  @record class Context(val ruleName: String,\n                        val ruleType: U32,\n                        val accepting: IS[State, B],\n                        var state: State,\n                        var resOpt: Option[Result],\n                        var j: Z,\n                        var max: Z,\n                        var initial: B,\n                        var trees: ISZ[ParseTree],\n                        var found: B,\n                        var failIndex: Z,\n                        var isLexical: B) {\n\n    def updateTerminal(token: ParseTree.Leaf, newState: State): Unit = {\n      found = T\n      j = j + 1\n      initial = F\n      state = newState\n      trees = trees :+ token\n      if (accepting(state)) {\n        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))\n      }\n    }\n\n    def updateNonTerminal(r: Result, newState: State): Unit = {\n      found = T\n      initial = F\n      j = r.newIndex\n      state = newState\n      trees = trees :+ r.tree\n      if (accepting(state)) {\n        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))\n      }\n    }\n  }\n\n  object Context {\n    @pure def create(ruleName: String, ruleType: U32, accepts: ISZ[State], i: Z): Context = {\n      val accepting = MS.create[State, B](10, F)\n      for (accept <- accepts) {\n        accepting(accept) = T\n      }\n      return Context(\n        ruleName = ruleName,\n        ruleType = ruleType,\n        accepting = accepting.toIS,\n        state = state\"0\",\n        resOpt = None(),\n        trees = ISZ[ParseTree](),\n        j = i,\n        max = i,\n        initial = T,\n        found = F,\n        failIndex = 0,\n        isLexical = F\n      )\n    }\n  }\n\n  @record class LContext(val accepting: IS[State, B], var state: State, var j: Z, var afterAcceptIndex: Z, var found: B) {\n    def update(newState: State): Unit = {\n      state = newState\n      found = T\n      if (accepting(state)) {\n        afterAcceptIndex = j + 1\n      }\n    }\n  }\n\n  object LContext {\n    @pure def create(accepts: ISZ[State], i: Z): LContext = {\n      val accepting = MS.create[State, B](10, F)\n      for (accept <- accepts) {\n        accepting(accept) = T\n      }\n      return LContext(accepting = accepting.toIS, state = state\"0\", j = i, afterAcceptIndex = -1, found = F)\n    }\n  }\n\n  @datatype class IndexableToken(val input: Indexable.Pos[C], val skipHidden: B) extends Indexable[Result] {\n    val lexer: JsonLexer = JsonLexer(input)\n\n    override def at(i: Z): Result = {\n      return _at(i)\n    }\n\n    override def has(i: Z): B = {\n      return _has(i)\n    }\n\n    @memoize def _has(i: Z): B = {\n      assert(i >= 0)\n      if (i == 0) {\n        return T\n      }\n      if (!_has(i - 1)) {\n        return F\n      }\n      val prev = _at(i - 1)\n      return prev.kind == Result.Kind.Normal && prev.newIndex != -1\n    }\n\n    @memoize def _at(i: Z): Result = {\n      if (i == 0) {\n        if (input.has(0)) {\n          lexer.tokenize(0, skipHidden) match {\n            case Some(result) => return result\n            case _ =>\n          }\n        }\n      } else {\n        val prev = _at(i - 1)\n        if (input.has(prev.newIndex)) {\n          lexer.tokenize(prev.newIndex, skipHidden) match {\n            case Some(result) => return result\n            case _ =>\n          }\n        }\n      }\n      return Result(Result.Kind.Normal, eofLeaf, -1)\n    }\n\n  }\n\n  val kind: String = \"JsonParser\"\n\n  val minChar: C = \'\\u0000\'\n  val maxChar: C = toC(u32\"0x0010FFFF\")\n\n  val T_AFEF039D: U32 = u32\"0xAFEF039D\" /* \"true\" */\n  val T_D8AFD1B9: U32 = u32\"0xD8AFD1B9\" /* \"false\" */\n  val T_3EA44541: U32 = u32\"0x3EA44541\" /* \"null\" */\n  val T_FDCE65E5: U32 = u32\"0xFDCE65E5\" /* \"{\" */\n  val T_763C38BE: U32 = u32\"0x763C38BE\" /* \":\" */\n  val T_45445E21: U32 = u32\"0x45445E21\" /* \",\" */\n  val T_5BF60471: U32 = u32\"0x5BF60471\" /* \"}\" */\n  val T_A44269E9: U32 = u32\"0xA44269E9\" /* \"[\" */\n  val T_9977908D: U32 = u32\"0x9977908D\" /* \"]\" */\n  val T_STRING: U32 = u32\"0xA7CF0FE0\"\n  val T_NUMBER: U32 = u32\"0x28C20CF1\"\n  val T_WS: U32 = u32\"0x0E3F5D1E\"\n  val T_valueFile: U32 = u32\"0x94F3E412\"\n  val T_value: U32 = u32\"0x82EEA07A\"\n  val T_object: U32 = u32\"0x5ED5358F\"\n  val T_array: U32 = u32\"0xB11A9723\"\n\n  val errorLeaf: ParseTree.Leaf = ParseTree.Leaf(\"<ERROR>\", \"<ERROR>\", u32\"0xE3CDEDDA\", F, None())\n  val eofLeaf: ParseTree.Leaf = ParseTree.Leaf(\"<EOF>\", \"EOF\", u32\"0xFC5CB374\", F, None())\n\n  def parse(uriOpt: Option[String], input: String, reporter: message.Reporter): Option[ParseTree] = {\n    val docInfo = message.DocInfo.create(uriOpt, input)\n    val tokens = lex(input, docInfo, T, T, reporter)\n    if (reporter.hasError) {\n      return None()\n    }\n    val r = JsonParser(Indexable.fromIsz(tokens)).parseValueFile(0)\n    r.kind match {\n      case Result.Kind.Normal => return Some(r.tree)\n      case Result.Kind.LexicalError =>\n        reporter.error(Some(message.PosInfo(docInfo, offsetLength(r.newIndex, 1))), kind, s\"Could not recognize token\")\n        return None()\n      case Result.Kind.GrammaticalError =>\n        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex\n        if (idx < tokens.size) {\n          val token = tokens(idx).leaf\n          reporter.error(token.posOpt, kind, s\"Could not parse token: \\\"${ops.StringOps(token.text).escapeST.render}\\\"\")\n        } else {\n          val token = tokens(idx - 1).leaf\n          reporter.error(token.posOpt, kind, \"Expecting more input but reached the end\")\n        }\n        return None()\n    }\n  }\n\n  def parseIndexable(input: Indexable.Pos[C], reporter: message.Reporter): Option[ParseTree] = {\n    val it = IndexableToken(input, T)\n    val r = JsonParser(it).parseValueFile(0)\n    r.kind match {\n      case Result.Kind.Normal => return Some(r.tree)\n      case Result.Kind.LexicalError =>\n        reporter.error(input.posOpt(r.newIndex, 1), kind, s\"Could not recognize token\")\n        return None()\n      case Result.Kind.GrammaticalError =>\n        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex\n        if (it.has(idx)) {\n          val token = it.at(idx).leaf\n          reporter.error(token.posOpt, kind, s\"Could not parse token: \\\"${ops.StringOps(token.text).escapeST.render}\\\"\")\n        } else {\n          val token = it.at(idx - 1).leaf\n          reporter.error(token.posOpt, kind, \"Expecting more input but reached the end\")\n        }\n        return None()\n    }\n  }\n\n  def lex(input: String, docInfo: message.DocInfo, skipHidden: B, stopAtError: B,\n          reporter: message.Reporter): ISZ[Result] = {\n    return JsonLexer(Indexable.fromIszDocInfo(conversions.String.toCis(input), docInfo)).tokenizeAll(skipHidden, stopAtError, reporter)\n  }\n\n  @strictpure def offsetLength(offset: Z, length: Z): U64 =\n    (conversions.Z.toU64(offset) << u64\"32\") | (conversions.Z.toU64(length) & u64\"0xFFFFFFFF\")\n\n}\n\nimport JsonParser._\n\n@datatype class JsonParser(tokens: Indexable[Result]) {\n\n  @pure def parseValueFile(i: Z): Result = {\n    val ctx = Context.create(\"valueFile\", u32\"0x94F3E412\", ISZ(state\"2\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"1\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xFC5CB374\" /* EOF */ => ctx.updateTerminal(token, state\"2\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseValue(i: Z): Result = {\n    val ctx = Context.create(\"value\", u32\"0x82EEA07A\", ISZ(state\"1\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          val n_object = predictObject(ctx.j)\n          val n_array = predictArray(ctx.j)\n          for (n <- 1 to 1 by -1 if !ctx.found) {\n            if (n_object == n && parseObjectH(ctx, state\"1\")) {\n              return Result.error(ctx.isLexical, ctx.failIndex)\n            } else if (n_array == n && parseArrayH(ctx, state\"1\")) {\n              return Result.error(ctx.isLexical, ctx.failIndex)\n            }\n          }\n          if (!ctx.found) {\n            token.tipe match {\n              case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0x28C20CF1\" /* NUMBER */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0xAFEF039D\" /* \"true\" */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0xD8AFD1B9\" /* \"false\" */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0x3EA44541\" /* \"null\" */ => ctx.updateTerminal(token, state\"1\")\n              case _ =>\n            }\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseObject(i: Z): Result = {\n    val ctx = Context.create(\"object\", u32\"0x5ED5358F\", ISZ(state\"8\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xFDCE65E5\" /* \"{\" */ => ctx.updateTerminal(token, state\"1\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"2\")\n            case u32\"0x5BF60471\" /* \"}\" */ => ctx.updateTerminal(token, state\"8\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x763C38BE\" /* \":\" */ => ctx.updateTerminal(token, state\"3\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"3\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"4\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"4\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x45445E21\" /* \",\" */ => ctx.updateTerminal(token, state\"5\")\n            case u32\"0x5BF60471\" /* \"}\" */ => ctx.updateTerminal(token, state\"8\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"5\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"6\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"6\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x763C38BE\" /* \":\" */ => ctx.updateTerminal(token, state\"7\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"7\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"4\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"8\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseArray(i: Z): Result = {\n    val ctx = Context.create(\"array\", u32\"0xB11A9723\", ISZ(state\"4\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA44269E9\" /* \"[\" */ => ctx.updateTerminal(token, state\"1\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"2\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            token.tipe match {\n              case u32\"0x9977908D\" /* \"]\" */ => ctx.updateTerminal(token, state\"4\")\n              case _ =>\n            }\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x45445E21\" /* \",\" */ => ctx.updateTerminal(token, state\"3\")\n            case u32\"0x9977908D\" /* \"]\" */ => ctx.updateTerminal(token, state\"4\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"3\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"2\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"4\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  def parseValueH(ctx: Context, nextState: State): B = {\n    val r = parseValue(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  def parseObjectH(ctx: Context, nextState: State): B = {\n    val r = parseObject(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  def parseArrayH(ctx: Context, nextState: State): B = {\n    val r = parseArray(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  @pure def predictValueFile(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xA7CF0FE0\" /* STRING */ => return 1\n        case u32\"0x28C20CF1\" /* NUMBER */ => return 1\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case u32\"0xAFEF039D\" /* \"true\" */ => return 1\n        case u32\"0xD8AFD1B9\" /* \"false\" */ => return 1\n        case u32\"0x3EA44541\" /* \"null\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictArray(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictValue(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tip
  #673 = Utf8               e match {\n        case u32\"0xA7CF0FE0\" /* STRING */ => return 1\n        case u32\"0x28C20CF1\" /* NUMBER */ => return 1\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case u32\"0xAFEF039D\" /* \"true\" */ => return 1\n        case u32\"0xD8AFD1B9\" /* \"false\" */ => return 1\n        case u32\"0x3EA44541\" /* \"null\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictObject(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  def retVal(n: Z, resOpt: Option[Result], initial: B, noBacktrack: B): Result = {\n    resOpt match {\n      case Some(res) => return res\n      case _ => return Result.error(F, if (noBacktrack && !initial) -n else n)\n    }\n  }\n\n  @pure def posOpts(docInfo: message.DocInfo,\n                    posOpt1: Option[message.Position],\n                    posOpt2: Option[message.Position]): Option[message.Position] = {\n    val pos1 = posOpt1.get\n    val pos2 = posOpt2.get\n    return Some(message.PosInfo(docInfo, offsetLength(pos1.offset,\n      pos2.offset + pos2.length - pos1.offset)))\n  }\n\n}\n\n@datatype class JsonLexer(cis: Indexable.Pos[C]) {\n\n  def tokenizeAll(skipHidden: B, stopAtError: B, reporter: message.Reporter): ISZ[Result] = {\n    var i: Z = 0\n    var r = ISZ[Result]()\n    var done = F\n    while (!done && cis.has(i)) {\n      tokenize(i, skipHidden) match {\n        case Some(result) =>\n          if (result.kind == Result.Kind.Normal) {\n            i = result.newIndex\n            r = r :+ result\n          } else {\n            val posOpt = cis.posOpt(i, 1)\n            reporter.error(posOpt, kind, s\"Could not recognize token\")\n            if (stopAtError) {\n              return r\n            }\n            r = r :+ result(tree = errorLeaf(text = conversions.String.fromCis(ISZ(cis.at(i))), posOpt = posOpt))\n            i = i + 1\n          }\n        case _ => done = T\n      }\n    }\n    r = r :+ Result.create(eofLeaf, -1)\n    return r\n  }\n\n  @pure def tokenize(i: Z, skipHidden: B): Option[Result] = {\n    val r = MBox(Result.error(T, i))\n    tokenizeH(r, i)\n    while (skipHidden && r.value.leaf.isHidden && cis.has(r.value.newIndex)) {\n      tokenizeH(r, r.value.newIndex)\n    }\n    return if (skipHidden && r.value.leaf.isHidden) None() else Some(r.value)\n  }\n\n  def tokenizeH(r: MBox[Result], i: Z): Unit = {\n    updateToken(r, lex_true(i))\n    updateToken(r, lex_false(i))\n    updateToken(r, lex_null(i))\n    updateToken(r, lex_u007B(i))\n    updateToken(r, lex_u003A(i))\n    updateToken(r, lex_u002C(i))\n    updateToken(r, lex_u007D(i))\n    updateToken(r, lex_u005B(i))\n    updateToken(r, lex_u005D(i))\n    updateToken(r, lex_STRING(i))\n    updateToken(r, lex_NUMBER(i))\n    updateToken(r, lex_WS(i))\n  }\n\n  def updateToken(r: MBox[Result], rOpt: Option[Result]): Unit = {\n    rOpt match {\n      case Some(newR) if newR.newIndex > r.value.newIndex => r.value = newR\n      case _ =>\n    }\n  }\n\n  @pure def lit_true(i: Z): Z = {\n    if (!cis.has(i + 4)) {\n      return -1\n    }\n    if (cis.at(i) === \'t\' && cis.at(i + 1) === \'r\' && cis.at(i + 2) === \'u\' && cis.at(i + 3) === \'e\') {\n      return i + 4\n    }\n    return -1\n  }\n\n  @strictpure def lex_true(index: Z): Option[Result] = lexH(index, lit_true(index), \"\"\"\'true\'\"\"\", u32\"0xAFEF039D\" /* \"true\" */, F)\n\n  @pure def lit_false(i: Z): Z = {\n    if (!cis.has(i + 5)) {\n      return -1\n    }\n    if (cis.at(i) === \'f\' && cis.at(i + 1) === \'a\' && cis.at(i + 2) === \'l\' && cis.at(i + 3) === \'s\' && cis.at(i + 4) === \'e\') {\n      return i + 5\n    }\n    return -1\n  }\n\n  @strictpure def lex_false(index: Z): Option[Result] = lexH(index, lit_false(index), \"\"\"\'false\'\"\"\", u32\"0xD8AFD1B9\" /* \"false\" */, F)\n\n  @pure def lit_null(i: Z): Z = {\n    if (!cis.has(i + 4)) {\n      return -1\n    }\n    if (cis.at(i) === \'n\' && cis.at(i + 1) === \'u\' && cis.at(i + 2) === \'l\' && cis.at(i + 3) === \'l\') {\n      return i + 4\n    }\n    return -1\n  }\n\n  @strictpure def lex_null(index: Z): Option[Result] = lexH(index, lit_null(index), \"\"\"\'null\'\"\"\", u32\"0x3EA44541\" /* \"null\" */, F)\n\n  @pure def lit_u007B(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'{\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u007B(index: Z): Option[Result] = lexH(index, lit_u007B(index), \"\"\"\'{\'\"\"\", u32\"0xFDCE65E5\" /* \"{\" */, F)\n\n  @pure def lit_u003A(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \':\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u003A(index: Z): Option[Result] = lexH(index, lit_u003A(index), \"\"\"\':\'\"\"\", u32\"0x763C38BE\" /* \":\" */, F)\n\n  @pure def lit_u002C(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \',\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u002C(index: Z): Option[Result] = lexH(index, lit_u002C(index), \"\"\"\',\'\"\"\", u32\"0x45445E21\" /* \",\" */, F)\n\n  @pure def lit_u007D(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'}\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u007D(index: Z): Option[Result] = lexH(index, lit_u007D(index), \"\"\"\'}\'\"\"\", u32\"0x5BF60471\" /* \"}\" */, F)\n\n  @pure def lit_u005B(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'[\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u005B(index: Z): Option[Result] = lexH(index, lit_u005B(index), \"\"\"\'[\'\"\"\", u32\"0xA44269E9\" /* \"[\" */, F)\n\n  @pure def lit_u005D(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \']\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u005D(index: Z): Option[Result] = lexH(index, lit_u005D(index), \"\"\"\']\'\"\"\", u32\"0x9977908D\" /* \"]\" */, F)\n\n  @pure def dfa_STRING(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"2\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'\"\') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\' \' <= c && c <= \'!\' || \'#\' <= c && c <= \'[\' || \']\' <= c && c <= maxChar) {\n            ctx.update(state\"1\")\n          } else if (c === \'\"\') {\n            ctx.update(state\"2\")\n          } else if (c === \'\\\\\') {\n            ctx.update(state\"3\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"2\" => return ctx.afterAcceptIndex\n        case state\"3\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'\"\' || c === \'/\' || c === \'\\\\\' || c === \'b\' || c === \'f\' || c === \'n\' || c === \'r\' || c === \'t\') {\n            ctx.update(state\"1\")\n          } else if (c === \'u\') {\n            ctx.update(state\"4\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"4\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"5\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"6\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"6\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"7\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"7\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_STRING(index: Z): Option[Result] = lexH(index, dfa_STRING(index), \"\"\"STRING\"\"\", u32\"0xA7CF0FE0\", F)\n\n  @pure def dfa_NUMBER(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"2\", state\"4\", state\"7\", state\"8\", state\"9\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'-\') {\n            ctx.update(state\"1\")\n          } else if (c === \'0\') {\n            ctx.update(state\"2\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'0\') {\n            ctx.update(state\"2\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"2\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'.\') {\n            ctx.update(state\"3\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"3\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"4\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"4\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"4\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"5\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'+\' || c === \'-\') {\n            ctx.update(state\"6\")\n          } else if (c === \'0\') {\n            ctx.update(state\"7\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"6\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'0\') {\n            ctx.update(state\"7\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"7\" => return ctx.afterAcceptIndex\n        case state\"8\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"9\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'.\') {\n            ctx.update(state\"3\")\n          } else if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_NUMBER(index: Z): Option[Result] = lexH(index, dfa_NUMBER(index), \"\"\"NUMBER\"\"\", u32\"0x28C20CF1\", F)\n\n  @pure def dfa_WS(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"1\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'\\u0009\' <= c && c <= \'\\u000A\' || c === \'\\u000D\' || c === \' \') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'\\u0009\' <= c && c <= \'\\u000A\' || c === \'\\u000D\' || c === \' \') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_WS(index: Z): Option[Result] = lexH(index, dfa_WS(index), \"\"\"WS\"\"\", u32\"0x0E3F5D1E\", T)\n\n  @pure def hidden(i: Z): Z = {\n     var j: Z = -1\n     j = dfa_WS(i)\n     if (j > 0) {\n       return j\n     }\n     return -1\n  }\n\n  @pure def lexH(index: Z, newIndex: Z, name: String, tipe: U32, isHidden: B): Option[Result] = {\n    if (newIndex > 0) {\n      return Some(Result.create(ParseTree.Leaf(conversions.String.fromCis(for (i <- index until newIndex) yield cis.at(i)),\n        name, tipe, isHidden, cis.posOpt(index, newIndex - index)), newIndex))\n    } else {\n      return None()\n    }\n  }\n\n}
  #674 = String             #673          // e match {\n        case u32\"0xA7CF0FE0\" /* STRING */ => return 1\n        case u32\"0x28C20CF1\" /* NUMBER */ => return 1\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case u32\"0xAFEF039D\" /* \"true\" */ => return 1\n        case u32\"0xD8AFD1B9\" /* \"false\" */ => return 1\n        case u32\"0x3EA44541\" /* \"null\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictObject(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  def retVal(n: Z, resOpt: Option[Result], initial: B, noBacktrack: B): Result = {\n    resOpt match {\n      case Some(res) => return res\n      case _ => return Result.error(F, if (noBacktrack && !initial) -n else n)\n    }\n  }\n\n  @pure def posOpts(docInfo: message.DocInfo,\n                    posOpt1: Option[message.Position],\n                    posOpt2: Option[message.Position]): Option[message.Position] = {\n    val pos1 = posOpt1.get\n    val pos2 = posOpt2.get\n    return Some(message.PosInfo(docInfo, offsetLength(pos1.offset,\n      pos2.offset + pos2.length - pos1.offset)))\n  }\n\n}\n\n@datatype class JsonLexer(cis: Indexable.Pos[C]) {\n\n  def tokenizeAll(skipHidden: B, stopAtError: B, reporter: message.Reporter): ISZ[Result] = {\n    var i: Z = 0\n    var r = ISZ[Result]()\n    var done = F\n    while (!done && cis.has(i)) {\n      tokenize(i, skipHidden) match {\n        case Some(result) =>\n          if (result.kind == Result.Kind.Normal) {\n            i = result.newIndex\n            r = r :+ result\n          } else {\n            val posOpt = cis.posOpt(i, 1)\n            reporter.error(posOpt, kind, s\"Could not recognize token\")\n            if (stopAtError) {\n              return r\n            }\n            r = r :+ result(tree = errorLeaf(text = conversions.String.fromCis(ISZ(cis.at(i))), posOpt = posOpt))\n            i = i + 1\n          }\n        case _ => done = T\n      }\n    }\n    r = r :+ Result.create(eofLeaf, -1)\n    return r\n  }\n\n  @pure def tokenize(i: Z, skipHidden: B): Option[Result] = {\n    val r = MBox(Result.error(T, i))\n    tokenizeH(r, i)\n    while (skipHidden && r.value.leaf.isHidden && cis.has(r.value.newIndex)) {\n      tokenizeH(r, r.value.newIndex)\n    }\n    return if (skipHidden && r.value.leaf.isHidden) None() else Some(r.value)\n  }\n\n  def tokenizeH(r: MBox[Result], i: Z): Unit = {\n    updateToken(r, lex_true(i))\n    updateToken(r, lex_false(i))\n    updateToken(r, lex_null(i))\n    updateToken(r, lex_u007B(i))\n    updateToken(r, lex_u003A(i))\n    updateToken(r, lex_u002C(i))\n    updateToken(r, lex_u007D(i))\n    updateToken(r, lex_u005B(i))\n    updateToken(r, lex_u005D(i))\n    updateToken(r, lex_STRING(i))\n    updateToken(r, lex_NUMBER(i))\n    updateToken(r, lex_WS(i))\n  }\n\n  def updateToken(r: MBox[Result], rOpt: Option[Result]): Unit = {\n    rOpt match {\n      case Some(newR) if newR.newIndex > r.value.newIndex => r.value = newR\n      case _ =>\n    }\n  }\n\n  @pure def lit_true(i: Z): Z = {\n    if (!cis.has(i + 4)) {\n      return -1\n    }\n    if (cis.at(i) === \'t\' && cis.at(i + 1) === \'r\' && cis.at(i + 2) === \'u\' && cis.at(i + 3) === \'e\') {\n      return i + 4\n    }\n    return -1\n  }\n\n  @strictpure def lex_true(index: Z): Option[Result] = lexH(index, lit_true(index), \"\"\"\'true\'\"\"\", u32\"0xAFEF039D\" /* \"true\" */, F)\n\n  @pure def lit_false(i: Z): Z = {\n    if (!cis.has(i + 5)) {\n      return -1\n    }\n    if (cis.at(i) === \'f\' && cis.at(i + 1) === \'a\' && cis.at(i + 2) === \'l\' && cis.at(i + 3) === \'s\' && cis.at(i + 4) === \'e\') {\n      return i + 5\n    }\n    return -1\n  }\n\n  @strictpure def lex_false(index: Z): Option[Result] = lexH(index, lit_false(index), \"\"\"\'false\'\"\"\", u32\"0xD8AFD1B9\" /* \"false\" */, F)\n\n  @pure def lit_null(i: Z): Z = {\n    if (!cis.has(i + 4)) {\n      return -1\n    }\n    if (cis.at(i) === \'n\' && cis.at(i + 1) === \'u\' && cis.at(i + 2) === \'l\' && cis.at(i + 3) === \'l\') {\n      return i + 4\n    }\n    return -1\n  }\n\n  @strictpure def lex_null(index: Z): Option[Result] = lexH(index, lit_null(index), \"\"\"\'null\'\"\"\", u32\"0x3EA44541\" /* \"null\" */, F)\n\n  @pure def lit_u007B(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'{\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u007B(index: Z): Option[Result] = lexH(index, lit_u007B(index), \"\"\"\'{\'\"\"\", u32\"0xFDCE65E5\" /* \"{\" */, F)\n\n  @pure def lit_u003A(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \':\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u003A(index: Z): Option[Result] = lexH(index, lit_u003A(index), \"\"\"\':\'\"\"\", u32\"0x763C38BE\" /* \":\" */, F)\n\n  @pure def lit_u002C(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \',\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u002C(index: Z): Option[Result] = lexH(index, lit_u002C(index), \"\"\"\',\'\"\"\", u32\"0x45445E21\" /* \",\" */, F)\n\n  @pure def lit_u007D(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'}\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u007D(index: Z): Option[Result] = lexH(index, lit_u007D(index), \"\"\"\'}\'\"\"\", u32\"0x5BF60471\" /* \"}\" */, F)\n\n  @pure def lit_u005B(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'[\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u005B(index: Z): Option[Result] = lexH(index, lit_u005B(index), \"\"\"\'[\'\"\"\", u32\"0xA44269E9\" /* \"[\" */, F)\n\n  @pure def lit_u005D(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \']\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u005D(index: Z): Option[Result] = lexH(index, lit_u005D(index), \"\"\"\']\'\"\"\", u32\"0x9977908D\" /* \"]\" */, F)\n\n  @pure def dfa_STRING(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"2\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'\"\') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\' \' <= c && c <= \'!\' || \'#\' <= c && c <= \'[\' || \']\' <= c && c <= maxChar) {\n            ctx.update(state\"1\")\n          } else if (c === \'\"\') {\n            ctx.update(state\"2\")\n          } else if (c === \'\\\\\') {\n            ctx.update(state\"3\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"2\" => return ctx.afterAcceptIndex\n        case state\"3\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'\"\' || c === \'/\' || c === \'\\\\\' || c === \'b\' || c === \'f\' || c === \'n\' || c === \'r\' || c === \'t\') {\n            ctx.update(state\"1\")\n          } else if (c === \'u\') {\n            ctx.update(state\"4\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"4\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"5\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"6\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"6\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"7\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"7\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_STRING(index: Z): Option[Result] = lexH(index, dfa_STRING(index), \"\"\"STRING\"\"\", u32\"0xA7CF0FE0\", F)\n\n  @pure def dfa_NUMBER(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"2\", state\"4\", state\"7\", state\"8\", state\"9\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'-\') {\n            ctx.update(state\"1\")\n          } else if (c === \'0\') {\n            ctx.update(state\"2\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'0\') {\n            ctx.update(state\"2\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"2\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'.\') {\n            ctx.update(state\"3\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"3\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"4\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"4\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"4\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"5\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'+\' || c === \'-\') {\n            ctx.update(state\"6\")\n          } else if (c === \'0\') {\n            ctx.update(state\"7\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"6\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'0\') {\n            ctx.update(state\"7\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"7\" => return ctx.afterAcceptIndex\n        case state\"8\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"9\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'.\') {\n            ctx.update(state\"3\")\n          } else if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_NUMBER(index: Z): Option[Result] = lexH(index, dfa_NUMBER(index), \"\"\"NUMBER\"\"\", u32\"0x28C20CF1\", F)\n\n  @pure def dfa_WS(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"1\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'\\u0009\' <= c && c <= \'\\u000A\' || c === \'\\u000D\' || c === \' \') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'\\u0009\' <= c && c <= \'\\u000A\' || c === \'\\u000D\' || c === \' \') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_WS(index: Z): Option[Result] = lexH(index, dfa_WS(index), \"\"\"WS\"\"\", u32\"0x0E3F5D1E\", T)\n\n  @pure def hidden(i: Z): Z = {\n     var j: Z = -1\n     j = dfa_WS(i)\n     if (j > 0) {\n       return j\n     }\n     return -1\n  }\n\n  @pure def lexH(index: Z, newIndex: Z, name: String, tipe: U32, isHidden: B): Option[Result] = {\n    if (newIndex > 0) {\n      return Some(Result.create(ParseTree.Leaf(conversions.String.fromCis(for (i <- index until newIndex) yield cis.at(i)),\n        name, tipe, isHidden, cis.posOpt(index, newIndex - index)), newIndex))\n    } else {\n      return None()\n    }\n  }\n\n}
  #675 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.ops._\nimport Z8._\nimport Z16._\nimport Z32._\nimport Z64._\nimport N._\nimport N8._\nimport N16._\nimport N32._\nimport N64._\nimport S8._\nimport S16._\nimport S32._\nimport S64._\nimport U8._\nimport U16._\nimport U32._\nimport U64._\n\nobject Json {\n\n  @sig trait JsonAstBinding[T] {\n    @pure def toObject(fields: ISZ[(String, T)]): T\n\n    @pure def toArray(elements: ISZ[T]): T\n\n    @pure def toNumber(s: String): T\n\n    @pure def toString(s: String): T\n\n    @pure def toNull: T\n\n    @pure def toBoolean(b: B): T\n\n    @pure def kind(o: T): ValueKind.Type\n\n    @pure def fromObject(o: T): ISZ[(String, T)]\n\n    @pure def fromArray(o: T): ISZ[T]\n\n    @pure def fromNumber(o: T): String\n\n    @pure def fromString(o: T): String\n\n    @pure def fromBoolean(o: T): B\n  }\n\n  @datatype class ErrorMsg(val line: Z, val column: Z, val message: String)\n\n  @enum object ValueKind {\n    \"String\"\n    \"Number\"\n    \"Object\"\n    \"Array\"\n    \"True\"\n    \"False\"\n    \"Null\"\n  }\n\n  object Printer {\n    val trueSt: ST = st\"true\"\n    val falseSt: ST = st\"false\"\n    val nullSt: ST = st\"null\"\n\n    @pure def printB(b: B): ST = {\n      if (b) {\n        return trueSt\n      } else {\n        return falseSt\n      }\n    }\n\n    @pure def printC(c: C): ST = {\n      return printString(c.string)\n    }\n\n    @pure def printZ(n: Z): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ8(n: Z8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ16(n: Z16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ32(n: Z32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ64(n: Z64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN(n: N): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN8(n: N8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN16(n: N16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN32(n: N32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN64(n: N64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS8(n: S8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS16(n: S16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS32(n: S32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS64(n: S64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printU8(n: U8): ST = {\n      return printNumber(conversions.U8.toZ(n).string)\n    }\n\n    @pure def printU16(n: U16): ST = {\n      return printNumber(conversions.U16.toZ(n).string)\n    }\n\n    @pure def printU32(n: U32): ST = {\n      return printNumber(conversions.U32.toZ(n).string)\n    }\n\n    @pure def printU64(n: U64): ST = {\n      return printNumber(conversions.U64.toZ(n).string)\n    }\n\n    @pure def printF32(n: F32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printF64(n: F64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printR(n: R): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printISZ[T](isSimple: B, s: IS[Z, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ8[T](isSimple: B, s: IS[Z8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ16[T](isSimple: B, s: IS[Z16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ32[T](isSimple: B, s: IS[Z32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ64[T](isSimple: B, s: IS[Z64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN[T](isSimple: B, s: IS[N, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN8[T](isSimple: B, s: IS[N8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN16[T](isSimple: B, s: IS[N16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN32[T](isSimple: B, s: IS[N32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN64[T](isSimple: B, s: IS[N64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS8[T](isSimple: B, s: IS[S8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS16[T](isSimple: B, s: IS[S16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS32[T](isSimple: B, s: IS[S32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS64[T](isSimple: B, s: IS[S64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU8[T](isSimple: B, s: IS[U8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU16[T](isSimple: B, s: IS[U16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU32[T](isSimple: B, s: IS[U32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU64[T](isSimple: B, s: IS[U64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ[T](isSimple: B, s: MS[Z, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ8[T](isSimple: B, s: MS[Z8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ16[T](isSimple: B, s: MS[Z16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ32[T](isSimple: B, s: MS[Z32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ64[T](isSimple: B, s: MS[Z64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN[T](isSimple: B, s: MS[N, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN8[T](isSimple: B, s: MS[N8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN16[T](isSimple: B, s: MS[N16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN32[T](isSimple: B, s: MS[N32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN64[T](isSimple: B, s: MS[N64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS8[T](isSimple: B, s: MS[S8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS16[T](isSimple: B, s: MS[S16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS32[T](isSimple: B, s: MS[S32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS64[T](isSimple: B, s: MS[S64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU8[T](isSimple: B, s: MS[U8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU16[T](isSimple: B, s: MS[U16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU32[T](isSimple: B, s: MS[U32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU64[T](isSimple: B, s: MS[U64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printZS(isSimple: B, s: ZS): ST = {\n      return printMS(isSimple, s.map(printZ _))\n    }\n\n    @pure def printOption[T](isSimple: B, o: Option[T], f: T => ST): ST = {\n      o match {\n        case Some(t) =>\n          return printObject(ISZ((\"type\", printString(\"Some\")), (\"value\", f(t))))\n        case _ => return printObject(ISZ((\"type\", printString(\"None\"))))\n      }\n    }\n\n    @pure def printMOption[T](isSimple: B, o: MOption[T], f: T => ST): ST = {\n      o match {\n        case MSome(t) =>\n          return printObject(ISZ((\"type\", printString(\"Some\")), (\"value\", f(t))))\n        case _ => return printObject(ISZ((\"type\", printString(\"None\"))))\n      }\n    }\n\n    @pure def printEither[L, R](isSimple: B, o: Either[L, R], f0: L => ST, f1: R => ST): ST = {\n      o match {\n        case Either.Left(l) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(0)), (\"value\", f0(l))))\n        case Either.Right(r) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(1)), (\"value\", f1(r))))\n        case _ => assume(F); return nullSt\n      }\n    }\n\n    @pure def printMEither[L, R](isSimple: B, o: MEither[L, R], f0: L => ST, f1: R => ST): ST = {\n      o match {\n        case MEither.Left(l) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(0)), (\"value\", f0(l))))\n        case MEither.Right(r) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(1)), (\"value\", f1(r))))\n        case _ => assume(F); return nullSt\n      }\n    }\n\n    @pure def printMap[K, T](isSimple: B, o: Map[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"Map\")), (\"entries\", entries)))\n    }\n\n    @pure def printSet[T](isSimple: B, o: Set[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Set\")),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printHashMap[K, T](isSimple: B, o: HashMap[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"HashMap\")), (\"size\", printZ(o.size)), (\"entries\", entries)))\n    }\n\n    @pure def printHashSet[T](isSimple: B, o: HashSet[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"HashSet\")),\n          (\"size\", printZ(o.size)),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printHashSMap[K, T](isSimple: B, o: HashSMap[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"HashSMap\")), (\"size\", printZ(o.size)), (\"entries\", entries)))\n    }\n\n    @pure def printHashSSet[T](isSimple: B, o: HashSSet[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"HashSSet\")),\n          (\"size\", printZ(o.size)),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printStack[T](isSimple: B, o: Stack[T], f: T => ST): ST = {\n      return printISZ(isSimple, o.elements, f)\n    }\n\n    @pure def printBag[T](isSimple: B, o: Bag[T], f: T => ST): ST = {\n      return printMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printHashBag[T](isSimple: B, o: HashBag[T], f: T => ST): ST = {\n      return printHashMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printHashSBag[T](isSimple: B, o: HashSBag[T], f: T => ST): ST = {\n      return printHashSMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printPoset[T](isSimple: B, o: Poset[T], f: T => ST): ST = {\n      val g: HashSSet[Poset.Index] => ST = s => printHashSSet(isSimple, s, printZ _)\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Poset\")),\n          (\"nodes\", printISZ(isSimple, o.nodesInverse, f)),\n          (\"parents\", printHashSMap(isSimple, o.parents, printZ _, g))\n        )\n      )\n    }\n\n    @pure def printGraph[W, E](isSimple: B, o: Graph[W, E], f: W => ST, g: E => ST): ST = {\n      @pure def printEdge(edge: Graph.Internal.Edge[E]): ST = {\n        edge match {\n          case Graph.Internal.Edge.Plain(src, dest) =>\n            return printObject(ISZ((\"src\", printZ(src)), (\"dest\", printZ(dest))))\n          case Graph.Internal.Edge.Data(src, dest, data) =>\n            return printObject(ISZ((\"src\", printZ(src)), (\"dest\", printZ(dest)), (\"data\", g(data))))\n        }\n      }\n      val edges: ISZ[Graph.Internal.Edge[E]] =\n        for (es <- o.outgoingEdges.values; e <- es.elements) yield e\n      return printObject(\n        ISZ(\n          (\"type\", printString(if (o.multi) \"MultiGraph\" else \"Graph\")),\n          (\"nodes\", printISZ(isSimple, o.nodesInverse, f)),\n          (\"edges\", printISZ(isSimple, edges, printEdge _))\n        )\n      )\n    }\n\n    @pure def printUnionFind[T](isSimple: B, o: UnionFind[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"UnionFind\")),\n          (\"elements\", printISZ(isSimple, o.elementsInverse, f)),\n          (\"parentOf\", printISZ(T, o.parentOf, printZ _)),\n          (\"sizeOf\", printISZ(T, o.sizeOf, printZ _))\n        )\n      )\n    }\n\n    @pure def printMessage(o: message.Message): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Message\")),\n          (\"level\", printZ(o.level.ordinal)),\n          (\"message\", printString(o.text)),\n          (\"posOpt\", printOption(F, o.posOpt, printPosition _)),\n          (\"kind\", printString(o.kind))\n        )\n      )\n    }\n\n    @pure def printPosition(o: message.Position): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Position\")),\n          (\"uriOpt\", printOption(T, o.uriOpt, printString _)),\n          (\"beginLine\", printZ(o.beginLine)),\n          (\"beginColumn\", printZ(o.beginColumn)),\n          (\"endLine\", printZ(o.endLine)),\n          (\"endColumn\", printZ(o.endColumn)),\n          (\"offset\", printZ(o.offset)),\n          (\"length\", printZ(o.length))\n        )\n      )\n    }\n\n    @pure def printDocInfo(o: message.DocInfo): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Position\")),\n          (\"uriOpt\", printOption(T, o.uriOpt, printString _)),\n          (\"lineOffsets\", printISZ(T, o.lineOffsets, printU32 _))\n        )\n      )\n    }\n\n    @pure def printString(s: String): ST = {\n      var r = ISZ[C]()\n      for (c <- conversions.String.toCis(s)) {\n        c.native match {\n          case \'\"\' => r = r :+ \'\\\\\' :+ \'\\\"\'\n          case \'\\\\\' => r = r :+ \'\\\\\' :+ \'\\\\\'\n          case \'/\' => r = r :+ \'\\\\\' :+ \'/\'\n          case \'\\b\' => r = r :+ \'\\\\\' :+ \'b\'\n          case \'\\f\' => r = r :+ \'\\\\\' :+ \'f\'\n          case \'\\n\' => r = r :+ \'\\\\\' :+ \'n\'\n          case \'\\r\' => r = r :+ \'\\\\\' :+ \'r\'\n          case \'\\t\' => r = r :+ \'\\\\\' :+ \'t\'\n          case _ if \'\\u0020\' <= c && c < \'\\u00FF\' && c != \'\\u007f\' => r = r :+ c\n          case _ =>\n            val q = COps(c).toUnicodeHex\n            r = r :+ \'\\\\\' :+ \'u\' :+ q._1 :+ q._2 :+ q._3 :+ q._4\n        }\n      }\n      return st\"\"\"\"${conversions.String.fromCis(r)}\"\"\"\"\n    }\n\n    @pure def printConstant(s: String): ST = {\n      s.native match {\n        case \"true\" => return trueSt\n        case \"false\" => return falseSt\n        case \"null\" => return nullSt\n      }\n    }\n\n    @pure def printNumber(s: String): ST = {\n      return st\"$s\"\n    }\n\n    @pure def printObject(fields: ISZ[(String, ST)]): ST = {\n      val fs: ISZ[ST] = for (p <- fields) yield st\"\"\"\"${p._1}\" : ${p._2}\"\"\"\n      return st\"\"\"{\n      |  ${(fs, \",\\n\")}\n      |}\"\"\"\n    }\n\n    @pure def printIS[I](isSimple: B, elements: IS[I, ST]): ST = {\n      return if (isSimple) st\"[${(elements, \", \")}]\"\n      else st\"\"\"[\n      |  ${(elements, \",\\n\")}\n      |]\"\"\"\n    }\n\n    @pure def printMS[I](isSimple: B, elements: MS[I, ST]): ST = {\n      return if (isSimple) st\"[${(elements, \", \")}]\"\n      else st\"\"\"[\n      |  ${(elements, \",\\n\")}\n      |]\"\"\"\n    }\n  }\n\n  object Parser {\n\n    @pure def create(input: String): Parser = {\n      return Parser(conversions.String.toCis(input), 0, None())\n    }\n  }\n\n  @record class Parser(val input: ISZ[C], var offset: Z, var errorOpt: Option[ErrorMsg]) {\n\n    val typesOption: ISZ[String] = ISZ(\"Some\", \"None\")\n\n    def errorMessage: String = {\n      errorOpt match {\n        case Some(e) => return s\"[${e.line}, ${e.column}] ${e.message}\"\n        case _ => return \"\"\n      }\n    }\n\n    def eof(): B = {\n      if (input.size != offset) {\n        if (errorOpt.nonEmpty) {\n          return F\n        }\n        val p = computeLineColumn(offset)\n        errorOpt = Some(ErrorMsg(p._1, p._2, s\"Expected end-of-file, but \'${input(offset)}\' found.\"))\n        return F\n      } else {\n        return T\n      }\n    }\n\n    def parseB(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'t\' => parseConstant(\"true\"); return T\n        case \'f\' => parseConstant(\"false\"); return F\n        case c => parseException(offset, s\"Expected \'true\' or \'false\', but \'$c...\' found.\"); return F\n      }\n    }\n\n    def parseC(): C = {\n      val i = offset\n      val s = conversions.String.toCis(parseString(
  #676 = String             #675          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.ops._\nimport Z8._\nimport Z16._\nimport Z32._\nimport Z64._\nimport N._\nimport N8._\nimport N16._\nimport N32._\nimport N64._\nimport S8._\nimport S16._\nimport S32._\nimport S64._\nimport U8._\nimport U16._\nimport U32._\nimport U64._\n\nobject Json {\n\n  @sig trait JsonAstBinding[T] {\n    @pure def toObject(fields: ISZ[(String, T)]): T\n\n    @pure def toArray(elements: ISZ[T]): T\n\n    @pure def toNumber(s: String): T\n\n    @pure def toString(s: String): T\n\n    @pure def toNull: T\n\n    @pure def toBoolean(b: B): T\n\n    @pure def kind(o: T): ValueKind.Type\n\n    @pure def fromObject(o: T): ISZ[(String, T)]\n\n    @pure def fromArray(o: T): ISZ[T]\n\n    @pure def fromNumber(o: T): String\n\n    @pure def fromString(o: T): String\n\n    @pure def fromBoolean(o: T): B\n  }\n\n  @datatype class ErrorMsg(val line: Z, val column: Z, val message: String)\n\n  @enum object ValueKind {\n    \"String\"\n    \"Number\"\n    \"Object\"\n    \"Array\"\n    \"True\"\n    \"False\"\n    \"Null\"\n  }\n\n  object Printer {\n    val trueSt: ST = st\"true\"\n    val falseSt: ST = st\"false\"\n    val nullSt: ST = st\"null\"\n\n    @pure def printB(b: B): ST = {\n      if (b) {\n        return trueSt\n      } else {\n        return falseSt\n      }\n    }\n\n    @pure def printC(c: C): ST = {\n      return printString(c.string)\n    }\n\n    @pure def printZ(n: Z): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ8(n: Z8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ16(n: Z16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ32(n: Z32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ64(n: Z64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN(n: N): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN8(n: N8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN16(n: N16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN32(n: N32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN64(n: N64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS8(n: S8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS16(n: S16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS32(n: S32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS64(n: S64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printU8(n: U8): ST = {\n      return printNumber(conversions.U8.toZ(n).string)\n    }\n\n    @pure def printU16(n: U16): ST = {\n      return printNumber(conversions.U16.toZ(n).string)\n    }\n\n    @pure def printU32(n: U32): ST = {\n      return printNumber(conversions.U32.toZ(n).string)\n    }\n\n    @pure def printU64(n: U64): ST = {\n      return printNumber(conversions.U64.toZ(n).string)\n    }\n\n    @pure def printF32(n: F32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printF64(n: F64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printR(n: R): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printISZ[T](isSimple: B, s: IS[Z, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ8[T](isSimple: B, s: IS[Z8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ16[T](isSimple: B, s: IS[Z16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ32[T](isSimple: B, s: IS[Z32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ64[T](isSimple: B, s: IS[Z64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN[T](isSimple: B, s: IS[N, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN8[T](isSimple: B, s: IS[N8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN16[T](isSimple: B, s: IS[N16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN32[T](isSimple: B, s: IS[N32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN64[T](isSimple: B, s: IS[N64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS8[T](isSimple: B, s: IS[S8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS16[T](isSimple: B, s: IS[S16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS32[T](isSimple: B, s: IS[S32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS64[T](isSimple: B, s: IS[S64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU8[T](isSimple: B, s: IS[U8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU16[T](isSimple: B, s: IS[U16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU32[T](isSimple: B, s: IS[U32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU64[T](isSimple: B, s: IS[U64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ[T](isSimple: B, s: MS[Z, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ8[T](isSimple: B, s: MS[Z8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ16[T](isSimple: B, s: MS[Z16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ32[T](isSimple: B, s: MS[Z32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ64[T](isSimple: B, s: MS[Z64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN[T](isSimple: B, s: MS[N, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN8[T](isSimple: B, s: MS[N8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN16[T](isSimple: B, s: MS[N16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN32[T](isSimple: B, s: MS[N32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN64[T](isSimple: B, s: MS[N64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS8[T](isSimple: B, s: MS[S8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS16[T](isSimple: B, s: MS[S16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS32[T](isSimple: B, s: MS[S32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS64[T](isSimple: B, s: MS[S64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU8[T](isSimple: B, s: MS[U8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU16[T](isSimple: B, s: MS[U16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU32[T](isSimple: B, s: MS[U32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU64[T](isSimple: B, s: MS[U64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printZS(isSimple: B, s: ZS): ST = {\n      return printMS(isSimple, s.map(printZ _))\n    }\n\n    @pure def printOption[T](isSimple: B, o: Option[T], f: T => ST): ST = {\n      o match {\n        case Some(t) =>\n          return printObject(ISZ((\"type\", printString(\"Some\")), (\"value\", f(t))))\n        case _ => return printObject(ISZ((\"type\", printString(\"None\"))))\n      }\n    }\n\n    @pure def printMOption[T](isSimple: B, o: MOption[T], f: T => ST): ST = {\n      o match {\n        case MSome(t) =>\n          return printObject(ISZ((\"type\", printString(\"Some\")), (\"value\", f(t))))\n        case _ => return printObject(ISZ((\"type\", printString(\"None\"))))\n      }\n    }\n\n    @pure def printEither[L, R](isSimple: B, o: Either[L, R], f0: L => ST, f1: R => ST): ST = {\n      o match {\n        case Either.Left(l) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(0)), (\"value\", f0(l))))\n        case Either.Right(r) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(1)), (\"value\", f1(r))))\n        case _ => assume(F); return nullSt\n      }\n    }\n\n    @pure def printMEither[L, R](isSimple: B, o: MEither[L, R], f0: L => ST, f1: R => ST): ST = {\n      o match {\n        case MEither.Left(l) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(0)), (\"value\", f0(l))))\n        case MEither.Right(r) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(1)), (\"value\", f1(r))))\n        case _ => assume(F); return nullSt\n      }\n    }\n\n    @pure def printMap[K, T](isSimple: B, o: Map[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"Map\")), (\"entries\", entries)))\n    }\n\n    @pure def printSet[T](isSimple: B, o: Set[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Set\")),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printHashMap[K, T](isSimple: B, o: HashMap[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"HashMap\")), (\"size\", printZ(o.size)), (\"entries\", entries)))\n    }\n\n    @pure def printHashSet[T](isSimple: B, o: HashSet[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"HashSet\")),\n          (\"size\", printZ(o.size)),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printHashSMap[K, T](isSimple: B, o: HashSMap[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"HashSMap\")), (\"size\", printZ(o.size)), (\"entries\", entries)))\n    }\n\n    @pure def printHashSSet[T](isSimple: B, o: HashSSet[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"HashSSet\")),\n          (\"size\", printZ(o.size)),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printStack[T](isSimple: B, o: Stack[T], f: T => ST): ST = {\n      return printISZ(isSimple, o.elements, f)\n    }\n\n    @pure def printBag[T](isSimple: B, o: Bag[T], f: T => ST): ST = {\n      return printMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printHashBag[T](isSimple: B, o: HashBag[T], f: T => ST): ST = {\n      return printHashMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printHashSBag[T](isSimple: B, o: HashSBag[T], f: T => ST): ST = {\n      return printHashSMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printPoset[T](isSimple: B, o: Poset[T], f: T => ST): ST = {\n      val g: HashSSet[Poset.Index] => ST = s => printHashSSet(isSimple, s, printZ _)\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Poset\")),\n          (\"nodes\", printISZ(isSimple, o.nodesInverse, f)),\n          (\"parents\", printHashSMap(isSimple, o.parents, printZ _, g))\n        )\n      )\n    }\n\n    @pure def printGraph[W, E](isSimple: B, o: Graph[W, E], f: W => ST, g: E => ST): ST = {\n      @pure def printEdge(edge: Graph.Internal.Edge[E]): ST = {\n        edge match {\n          case Graph.Internal.Edge.Plain(src, dest) =>\n            return printObject(ISZ((\"src\", printZ(src)), (\"dest\", printZ(dest))))\n          case Graph.Internal.Edge.Data(src, dest, data) =>\n            return printObject(ISZ((\"src\", printZ(src)), (\"dest\", printZ(dest)), (\"data\", g(data))))\n        }\n      }\n      val edges: ISZ[Graph.Internal.Edge[E]] =\n        for (es <- o.outgoingEdges.values; e <- es.elements) yield e\n      return printObject(\n        ISZ(\n          (\"type\", printString(if (o.multi) \"MultiGraph\" else \"Graph\")),\n          (\"nodes\", printISZ(isSimple, o.nodesInverse, f)),\n          (\"edges\", printISZ(isSimple, edges, printEdge _))\n        )\n      )\n    }\n\n    @pure def printUnionFind[T](isSimple: B, o: UnionFind[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"UnionFind\")),\n          (\"elements\", printISZ(isSimple, o.elementsInverse, f)),\n          (\"parentOf\", printISZ(T, o.parentOf, printZ _)),\n          (\"sizeOf\", printISZ(T, o.sizeOf, printZ _))\n        )\n      )\n    }\n\n    @pure def printMessage(o: message.Message): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Message\")),\n          (\"level\", printZ(o.level.ordinal)),\n          (\"message\", printString(o.text)),\n          (\"posOpt\", printOption(F, o.posOpt, printPosition _)),\n          (\"kind\", printString(o.kind))\n        )\n      )\n    }\n\n    @pure def printPosition(o: message.Position): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Position\")),\n          (\"uriOpt\", printOption(T, o.uriOpt, printString _)),\n          (\"beginLine\", printZ(o.beginLine)),\n          (\"beginColumn\", printZ(o.beginColumn)),\n          (\"endLine\", printZ(o.endLine)),\n          (\"endColumn\", printZ(o.endColumn)),\n          (\"offset\", printZ(o.offset)),\n          (\"length\", printZ(o.length))\n        )\n      )\n    }\n\n    @pure def printDocInfo(o: message.DocInfo): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Position\")),\n          (\"uriOpt\", printOption(T, o.uriOpt, printString _)),\n          (\"lineOffsets\", printISZ(T, o.lineOffsets, printU32 _))\n        )\n      )\n    }\n\n    @pure def printString(s: String): ST = {\n      var r = ISZ[C]()\n      for (c <- conversions.String.toCis(s)) {\n        c.native match {\n          case \'\"\' => r = r :+ \'\\\\\' :+ \'\\\"\'\n          case \'\\\\\' => r = r :+ \'\\\\\' :+ \'\\\\\'\n          case \'/\' => r = r :+ \'\\\\\' :+ \'/\'\n          case \'\\b\' => r = r :+ \'\\\\\' :+ \'b\'\n          case \'\\f\' => r = r :+ \'\\\\\' :+ \'f\'\n          case \'\\n\' => r = r :+ \'\\\\\' :+ \'n\'\n          case \'\\r\' => r = r :+ \'\\\\\' :+ \'r\'\n          case \'\\t\' => r = r :+ \'\\\\\' :+ \'t\'\n          case _ if \'\\u0020\' <= c && c < \'\\u00FF\' && c != \'\\u007f\' => r = r :+ c\n          case _ =>\n            val q = COps(c).toUnicodeHex\n            r = r :+ \'\\\\\' :+ \'u\' :+ q._1 :+ q._2 :+ q._3 :+ q._4\n        }\n      }\n      return st\"\"\"\"${conversions.String.fromCis(r)}\"\"\"\"\n    }\n\n    @pure def printConstant(s: String): ST = {\n      s.native match {\n        case \"true\" => return trueSt\n        case \"false\" => return falseSt\n        case \"null\" => return nullSt\n      }\n    }\n\n    @pure def printNumber(s: String): ST = {\n      return st\"$s\"\n    }\n\n    @pure def printObject(fields: ISZ[(String, ST)]): ST = {\n      val fs: ISZ[ST] = for (p <- fields) yield st\"\"\"\"${p._1}\" : ${p._2}\"\"\"\n      return st\"\"\"{\n      |  ${(fs, \",\\n\")}\n      |}\"\"\"\n    }\n\n    @pure def printIS[I](isSimple: B, elements: IS[I, ST]): ST = {\n      return if (isSimple) st\"[${(elements, \", \")}]\"\n      else st\"\"\"[\n      |  ${(elements, \",\\n\")}\n      |]\"\"\"\n    }\n\n    @pure def printMS[I](isSimple: B, elements: MS[I, ST]): ST = {\n      return if (isSimple) st\"[${(elements, \", \")}]\"\n      else st\"\"\"[\n      |  ${(elements, \",\\n\")}\n      |]\"\"\"\n    }\n  }\n\n  object Parser {\n\n    @pure def create(input: String): Parser = {\n      return Parser(conversions.String.toCis(input), 0, None())\n    }\n  }\n\n  @record class Parser(val input: ISZ[C], var offset: Z, var errorOpt: Option[ErrorMsg]) {\n\n    val typesOption: ISZ[String] = ISZ(\"Some\", \"None\")\n\n    def errorMessage: String = {\n      errorOpt match {\n        case Some(e) => return s\"[${e.line}, ${e.column}] ${e.message}\"\n        case _ => return \"\"\n      }\n    }\n\n    def eof(): B = {\n      if (input.size != offset) {\n        if (errorOpt.nonEmpty) {\n          return F\n        }\n        val p = computeLineColumn(offset)\n        errorOpt = Some(ErrorMsg(p._1, p._2, s\"Expected end-of-file, but \'${input(offset)}\' found.\"))\n        return F\n      } else {\n        return T\n      }\n    }\n\n    def parseB(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'t\' => parseConstant(\"true\"); return T\n        case \'f\' => parseConstant(\"false\"); return F\n        case c => parseException(offset, s\"Expected \'true\' or \'false\', but \'$c...\' found.\"); return F\n      }\n    }\n\n    def parseC(): C = {\n      val i = offset\n      val s = conversions.String.toCis(parseString(
  #677 = Utf8               ))\n      if (s.size != 1) {\n        parseException(i, s\"Expected a C, but \'$s\' found.\")\n        return \' \'\n      } else {\n        return s(0)\n      }\n    }\n\n    def parseZ(): Z = {\n      val i = offset\n      val s = parseNumber()\n      Z(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z, but \'$s\' found.\")\n          return 0\n      }\n    }\n\n    def parseZ8(): Z8 = {\n      val i = offset\n      val s = parseNumber()\n      Z8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z8, but \'$s\' found.\")\n          return z8\"0\"\n      }\n    }\n\n    def parseZ16(): Z16 = {\n      val i = offset\n      val s = parseNumber()\n      Z16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z16, but \'$s\' found.\")\n          return z16\"0\"\n      }\n    }\n\n    def parseZ32(): Z32 = {\n      val i = offset\n      val s = parseNumber()\n      Z32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z32, but \'$s\' found.\")\n          return z32\"0\"\n      }\n    }\n\n    def parseZ64(): Z64 = {\n      val i = offset\n      val s = parseNumber()\n      Z64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z64, but \'$s\' found.\")\n          return z64\"0\"\n      }\n    }\n\n    def parseN(): N = {\n      val i = offset\n      val s = parseNumber()\n      N(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N, but \'$s\' found.\")\n          return n\"0\"\n      }\n    }\n\n    def parseN8(): N8 = {\n      val i = offset\n      val s = parseNumber()\n      N8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N8, but \'$s\' found.\")\n          return n8\"0\"\n      }\n    }\n\n    def parseN16(): N16 = {\n      val i = offset\n      val s = parseNumber()\n      N16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N16, but \'$s\' found.\")\n          return n16\"0\"\n      }\n    }\n\n    def parseN32(): N32 = {\n      val i = offset\n      val s = parseNumber()\n      N32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N32, but \'$s\' found.\")\n          return n32\"0\"\n      }\n    }\n\n    def parseN64(): N64 = {\n      val i = offset\n      val s = parseNumber()\n      N64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N64, but \'$s\' found.\")\n          return n64\"0\"\n      }\n    }\n\n    def parseS8(): S8 = {\n      val i = offset\n      val s = parseNumber()\n      S8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S8, but \'$s\' found.\")\n          return s8\"0\"\n      }\n    }\n\n    def parseS16(): S16 = {\n      val i = offset\n      val s = parseNumber()\n      S16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S16, but \'$s\' found.\")\n          return s16\"0\"\n      }\n    }\n\n    def parseS32(): S32 = {\n      val i = offset\n      val s = parseNumber()\n      S32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S32, but \'$s\' found.\")\n          return s32\"0\"\n      }\n    }\n\n    def parseS64(): S64 = {\n      val i = offset\n      val s = parseNumber()\n      S64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S64, but \'$s\' found.\")\n          return s64\"0\"\n      }\n    }\n\n    def parseU8(): U8 = {\n      val i = offset\n      val s = parseNumber()\n      U8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U8, but \'$s\' found.\")\n          return u8\"0\"\n      }\n    }\n\n    def parseU16(): U16 = {\n      val i = offset\n      val s = parseNumber()\n      U16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U16, but \'$s\' found.\")\n          return u16\"0\"\n      }\n    }\n\n    def parseU32(): U32 = {\n      val i = offset\n      val s = parseNumber()\n      U32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U32, but \'$s\' found.\")\n          return u32\"0\"\n      }\n    }\n\n    def parseU64(): U64 = {\n      val i = offset\n      val s = parseNumber()\n      U64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U64, but \'$s\' found.\")\n          return u64\"0\"\n      }\n    }\n\n    def parseF32(): F32 = {\n      val i = offset\n      val s = parseNumber()\n      F32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a F32, but \'$s\' found.\")\n          return 0f\n      }\n    }\n\n    def parseF64(): F64 = {\n      val i = offset\n      val s = parseNumber()\n      F64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a F64, but \'$s\' found.\")\n          return 0.0\n      }\n    }\n\n    def parseR(): R = {\n      val i = offset\n      val s = parseNumber()\n      R(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a R, but \'$s\' found.\")\n          return r\"0\"\n      }\n    }\n\n    def parseISZ[T](f: () => T): IS[Z, T] = {\n      if (!parseArrayBegin()) {\n        return IS()\n      }\n      var e = f()\n      var r = IS[Z, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ8[T](f: () => T): IS[Z8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z8, T]()\n      }\n      var e = f()\n      var r = IS[Z8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ16[T](f: () => T): IS[Z16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z16, T]()\n      }\n      var e = f()\n      var r = IS[Z16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ32[T](f: () => T): IS[Z32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z32, T]()\n      }\n      var e = f()\n      var r = IS[Z32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ64[T](f: () => T): IS[Z64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z64, T]()\n      }\n      var e = f()\n      var r = IS[Z64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN[T](f: () => T): IS[N, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N, T]()\n      }\n      var e = f()\n      var r = IS[N, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN8[T](f: () => T): IS[N8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N8, T]()\n      }\n      var e = f()\n      var r = IS[N8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN16[T](f: () => T): IS[N16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N16, T]()\n      }\n      var e = f()\n      var r = IS[N16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN32[T](f: () => T): IS[N32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N32, T]()\n      }\n      var e = f()\n      var r = IS[N32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN64[T](f: () => T): IS[N64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N64, T]()\n      }\n      var e = f()\n      var r = IS[N64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS8[T](f: () => T): IS[S8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S8, T]()\n      }\n      var e = f()\n      var r = IS[S8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS16[T](f: () => T): IS[S16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S16, T]()\n      }\n      var e = f()\n      var r = IS[S16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS32[T](f: () => T): IS[S32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S32, T]()\n      }\n      var e = f()\n      var r = IS[S32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS64[T](f: () => T): IS[S64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S64, T]()\n      }\n      var e = f()\n      var r = IS[S64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU8[T](f: () => T): IS[U8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U8, T]()\n      }\n      var e = f()\n      var r = IS[U8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU16[T](f: () => T): IS[U16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U16, T]()\n      }\n      var e = f()\n      var r = IS[U16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU32[T](f: () => T): IS[U32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U32, T]()\n      }\n      var e = f()\n      var r = IS[U32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU64[T](f: () => T): IS[U64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U64, T]()\n      }\n      var e = f()\n      var r = IS[U64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ[T](f: () => T): MS[Z, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z, T]()\n      }\n      var e = f()\n      var r = MS[Z, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ8[T](f: () => T): MS[Z8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z8, T]()\n      }\n      var e = f()\n      var r = MS[Z8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ16[T](f: () => T): MS[Z16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z16, T]()\n      }\n      var e = f()\n      var r = MS[Z16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ32[T](f: () => T): MS[Z32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z32, T]()\n      }\n      var e = f()\n      var r = MS[Z32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ64[T](f: () => T): MS[Z64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z64, T]()\n      }\n      var e = f()\n      var r = MS[Z64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN[T](f: () => T): MS[N, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N, T]()\n      }\n      var e = f()\n      var r = MS[N, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN8[T](f: () => T): MS[N8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N8, T]()\n      }\n      var e = f()\n      var r = MS[N8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN16[T](f: () => T): MS[N16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N16, T]()\n      }\n      var e = f()\n      var r = MS[N16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN32[T](f: () => T): MS[N32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N32, T]()\n      }\n      var e = f()\n      var r = MS[N32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN64[T](f: () => T): MS[N64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N64, T]()\n      }\n      var e = f()\n      var r = MS[N64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS8[T](f: () => T): MS[S8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S8, T]()\n      }\n      var e = f()\n      var r = MS[S8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS16[T](f: () => T): MS[S16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S16, T]()\n      }\n      var e = f()\n      var r = MS[S16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS32[T](f: () => T): MS[S32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S32, T]()\n      }\n      var e = f()\n      var r = MS[S32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS64[T](f: () => T): MS[S64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S64, T]()\n      }\n      var e = f()\n      var r = MS[S64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU8[T](f: () => T): MS[U8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U8, T]()\n      }\n      var e = f()\n      var r = MS[U8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU16[T](f: () => T): MS[U16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U16, T]()\n      }\n      var e = f()\n      var r = MS[U16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU32[T](f: () => T): MS[U32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U32, T]()\n      }\n      var e = f()\n      var r = MS[U32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU64[T](f: () => T): MS[U64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U64, T]()\n      }\n      var e = f()\n      var r = MS[U64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseZS(): ZS = {\n      val r = parseMSZ(parseZ _)\n      return r\n    }\n\n    def parseOption[T](f: () => T): Option[T] = {\n      val tpe = parseObjectTypes(typesOption)\n      tpe.native match {\n        case \"Some\" =>\n          parseObjectKey(\"value\")\n          val v = f()\n          parseObjectNext()\n          return Some(v)\n        case _ =>\n          return None()\n      }\n    }\n\n    def parseMOption[T](f: () => T): MOption[T] = {\n      val tpe = parseObjectTypes(typesOption)\n      tpe.native match {\n        case \"Some\" =>\n          parseObjectKey(\"value\")\n          val v = f()\n          parseObjectNext()\n          return MSome(v)\n        case _ =>\n          return MNone()\n      }\n    }\n\n    def parseEither[L, R](f0: () => L, f1: () => R): Either[L, R] = {\n      parseObjectType(\"Or\")\n      parseObjectKey(\"i\")\n      val o = offset\n      val i = parseZ()\n      parseObjectNext()\n      parseObjectKey(\"value\")\n      if (i == 1) {\n        val r = f1()\n        parseObjectNext()\n        return Either.Right(r)\n      } else {\n        if (i != 0) {\n          parseException(o, s\"Expecting 0 or 1, but found $i\")\n        }\n        val l = f0()\n        parseObjectNext()\n        return Either.Left(l)\n      }\n    }\n\n    def parseMEither[L, R](f0: () => L, f1: () => R): MEither[L, R] = {\n      parseObjectType(\"Or\")\n      parseObjectKey(\"i\")\n      val o = offset\n      val i = parseZ()\n      parseObjectNext()\n      parseObjectKey(\"value\")\n      if (i == 1) {\n        val r = f1()\n        parseObjectNext()\n        return MEither.Right(r)\n      } else {\n        if (i != 0) {\n          parseException(o, s\"Expecting 0 or 1, but found $i\")\n        }\n        val l = f0()\n        parseObjectNext()\n        return MEither.Left(l)\n      }\n    }\n\n    def parseMap[K, T](k: () => K, v: () => T): Map[K, T] = {\n      parseObjectType(\"Map\")\n\n      var r = Map.empty[K, T]\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseSet[T](f: () => T): Set[T] = {\n      parseObjectType(\"Set\")\n\n      var r = Set.empty[T]\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashMap[K, T](k: () => K, v: () => T): HashM
  #678 = String             #677          // ))\n      if (s.size != 1) {\n        parseException(i, s\"Expected a C, but \'$s\' found.\")\n        return \' \'\n      } else {\n        return s(0)\n      }\n    }\n\n    def parseZ(): Z = {\n      val i = offset\n      val s = parseNumber()\n      Z(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z, but \'$s\' found.\")\n          return 0\n      }\n    }\n\n    def parseZ8(): Z8 = {\n      val i = offset\n      val s = parseNumber()\n      Z8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z8, but \'$s\' found.\")\n          return z8\"0\"\n      }\n    }\n\n    def parseZ16(): Z16 = {\n      val i = offset\n      val s = parseNumber()\n      Z16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z16, but \'$s\' found.\")\n          return z16\"0\"\n      }\n    }\n\n    def parseZ32(): Z32 = {\n      val i = offset\n      val s = parseNumber()\n      Z32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z32, but \'$s\' found.\")\n          return z32\"0\"\n      }\n    }\n\n    def parseZ64(): Z64 = {\n      val i = offset\n      val s = parseNumber()\n      Z64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z64, but \'$s\' found.\")\n          return z64\"0\"\n      }\n    }\n\n    def parseN(): N = {\n      val i = offset\n      val s = parseNumber()\n      N(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N, but \'$s\' found.\")\n          return n\"0\"\n      }\n    }\n\n    def parseN8(): N8 = {\n      val i = offset\n      val s = parseNumber()\n      N8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N8, but \'$s\' found.\")\n          return n8\"0\"\n      }\n    }\n\n    def parseN16(): N16 = {\n      val i = offset\n      val s = parseNumber()\n      N16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N16, but \'$s\' found.\")\n          return n16\"0\"\n      }\n    }\n\n    def parseN32(): N32 = {\n      val i = offset\n      val s = parseNumber()\n      N32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N32, but \'$s\' found.\")\n          return n32\"0\"\n      }\n    }\n\n    def parseN64(): N64 = {\n      val i = offset\n      val s = parseNumber()\n      N64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N64, but \'$s\' found.\")\n          return n64\"0\"\n      }\n    }\n\n    def parseS8(): S8 = {\n      val i = offset\n      val s = parseNumber()\n      S8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S8, but \'$s\' found.\")\n          return s8\"0\"\n      }\n    }\n\n    def parseS16(): S16 = {\n      val i = offset\n      val s = parseNumber()\n      S16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S16, but \'$s\' found.\")\n          return s16\"0\"\n      }\n    }\n\n    def parseS32(): S32 = {\n      val i = offset\n      val s = parseNumber()\n      S32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S32, but \'$s\' found.\")\n          return s32\"0\"\n      }\n    }\n\n    def parseS64(): S64 = {\n      val i = offset\n      val s = parseNumber()\n      S64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S64, but \'$s\' found.\")\n          return s64\"0\"\n      }\n    }\n\n    def parseU8(): U8 = {\n      val i = offset\n      val s = parseNumber()\n      U8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U8, but \'$s\' found.\")\n          return u8\"0\"\n      }\n    }\n\n    def parseU16(): U16 = {\n      val i = offset\n      val s = parseNumber()\n      U16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U16, but \'$s\' found.\")\n          return u16\"0\"\n      }\n    }\n\n    def parseU32(): U32 = {\n      val i = offset\n      val s = parseNumber()\n      U32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U32, but \'$s\' found.\")\n          return u32\"0\"\n      }\n    }\n\n    def parseU64(): U64 = {\n      val i = offset\n      val s = parseNumber()\n      U64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U64, but \'$s\' found.\")\n          return u64\"0\"\n      }\n    }\n\n    def parseF32(): F32 = {\n      val i = offset\n      val s = parseNumber()\n      F32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a F32, but \'$s\' found.\")\n          return 0f\n      }\n    }\n\n    def parseF64(): F64 = {\n      val i = offset\n      val s = parseNumber()\n      F64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a F64, but \'$s\' found.\")\n          return 0.0\n      }\n    }\n\n    def parseR(): R = {\n      val i = offset\n      val s = parseNumber()\n      R(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a R, but \'$s\' found.\")\n          return r\"0\"\n      }\n    }\n\n    def parseISZ[T](f: () => T): IS[Z, T] = {\n      if (!parseArrayBegin()) {\n        return IS()\n      }\n      var e = f()\n      var r = IS[Z, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ8[T](f: () => T): IS[Z8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z8, T]()\n      }\n      var e = f()\n      var r = IS[Z8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ16[T](f: () => T): IS[Z16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z16, T]()\n      }\n      var e = f()\n      var r = IS[Z16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ32[T](f: () => T): IS[Z32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z32, T]()\n      }\n      var e = f()\n      var r = IS[Z32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ64[T](f: () => T): IS[Z64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z64, T]()\n      }\n      var e = f()\n      var r = IS[Z64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN[T](f: () => T): IS[N, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N, T]()\n      }\n      var e = f()\n      var r = IS[N, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN8[T](f: () => T): IS[N8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N8, T]()\n      }\n      var e = f()\n      var r = IS[N8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN16[T](f: () => T): IS[N16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N16, T]()\n      }\n      var e = f()\n      var r = IS[N16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN32[T](f: () => T): IS[N32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N32, T]()\n      }\n      var e = f()\n      var r = IS[N32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN64[T](f: () => T): IS[N64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N64, T]()\n      }\n      var e = f()\n      var r = IS[N64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS8[T](f: () => T): IS[S8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S8, T]()\n      }\n      var e = f()\n      var r = IS[S8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS16[T](f: () => T): IS[S16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S16, T]()\n      }\n      var e = f()\n      var r = IS[S16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS32[T](f: () => T): IS[S32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S32, T]()\n      }\n      var e = f()\n      var r = IS[S32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS64[T](f: () => T): IS[S64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S64, T]()\n      }\n      var e = f()\n      var r = IS[S64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU8[T](f: () => T): IS[U8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U8, T]()\n      }\n      var e = f()\n      var r = IS[U8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU16[T](f: () => T): IS[U16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U16, T]()\n      }\n      var e = f()\n      var r = IS[U16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU32[T](f: () => T): IS[U32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U32, T]()\n      }\n      var e = f()\n      var r = IS[U32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU64[T](f: () => T): IS[U64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U64, T]()\n      }\n      var e = f()\n      var r = IS[U64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ[T](f: () => T): MS[Z, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z, T]()\n      }\n      var e = f()\n      var r = MS[Z, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ8[T](f: () => T): MS[Z8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z8, T]()\n      }\n      var e = f()\n      var r = MS[Z8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ16[T](f: () => T): MS[Z16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z16, T]()\n      }\n      var e = f()\n      var r = MS[Z16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ32[T](f: () => T): MS[Z32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z32, T]()\n      }\n      var e = f()\n      var r = MS[Z32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ64[T](f: () => T): MS[Z64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z64, T]()\n      }\n      var e = f()\n      var r = MS[Z64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN[T](f: () => T): MS[N, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N, T]()\n      }\n      var e = f()\n      var r = MS[N, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN8[T](f: () => T): MS[N8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N8, T]()\n      }\n      var e = f()\n      var r = MS[N8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN16[T](f: () => T): MS[N16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N16, T]()\n      }\n      var e = f()\n      var r = MS[N16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN32[T](f: () => T): MS[N32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N32, T]()\n      }\n      var e = f()\n      var r = MS[N32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN64[T](f: () => T): MS[N64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N64, T]()\n      }\n      var e = f()\n      var r = MS[N64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS8[T](f: () => T): MS[S8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S8, T]()\n      }\n      var e = f()\n      var r = MS[S8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS16[T](f: () => T): MS[S16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S16, T]()\n      }\n      var e = f()\n      var r = MS[S16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS32[T](f: () => T): MS[S32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S32, T]()\n      }\n      var e = f()\n      var r = MS[S32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS64[T](f: () => T): MS[S64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S64, T]()\n      }\n      var e = f()\n      var r = MS[S64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU8[T](f: () => T): MS[U8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U8, T]()\n      }\n      var e = f()\n      var r = MS[U8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU16[T](f: () => T): MS[U16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U16, T]()\n      }\n      var e = f()\n      var r = MS[U16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU32[T](f: () => T): MS[U32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U32, T]()\n      }\n      var e = f()\n      var r = MS[U32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU64[T](f: () => T): MS[U64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U64, T]()\n      }\n      var e = f()\n      var r = MS[U64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseZS(): ZS = {\n      val r = parseMSZ(parseZ _)\n      return r\n    }\n\n    def parseOption[T](f: () => T): Option[T] = {\n      val tpe = parseObjectTypes(typesOption)\n      tpe.native match {\n        case \"Some\" =>\n          parseObjectKey(\"value\")\n          val v = f()\n          parseObjectNext()\n          return Some(v)\n        case _ =>\n          return None()\n      }\n    }\n\n    def parseMOption[T](f: () => T): MOption[T] = {\n      val tpe = parseObjectTypes(typesOption)\n      tpe.native match {\n        case \"Some\" =>\n          parseObjectKey(\"value\")\n          val v = f()\n          parseObjectNext()\n          return MSome(v)\n        case _ =>\n          return MNone()\n      }\n    }\n\n    def parseEither[L, R](f0: () => L, f1: () => R): Either[L, R] = {\n      parseObjectType(\"Or\")\n      parseObjectKey(\"i\")\n      val o = offset\n      val i = parseZ()\n      parseObjectNext()\n      parseObjectKey(\"value\")\n      if (i == 1) {\n        val r = f1()\n        parseObjectNext()\n        return Either.Right(r)\n      } else {\n        if (i != 0) {\n          parseException(o, s\"Expecting 0 or 1, but found $i\")\n        }\n        val l = f0()\n        parseObjectNext()\n        return Either.Left(l)\n      }\n    }\n\n    def parseMEither[L, R](f0: () => L, f1: () => R): MEither[L, R] = {\n      parseObjectType(\"Or\")\n      parseObjectKey(\"i\")\n      val o = offset\n      val i = parseZ()\n      parseObjectNext()\n      parseObjectKey(\"value\")\n      if (i == 1) {\n        val r = f1()\n        parseObjectNext()\n        return MEither.Right(r)\n      } else {\n        if (i != 0) {\n          parseException(o, s\"Expecting 0 or 1, but found $i\")\n        }\n        val l = f0()\n        parseObjectNext()\n        return MEither.Left(l)\n      }\n    }\n\n    def parseMap[K, T](k: () => K, v: () => T): Map[K, T] = {\n      parseObjectType(\"Map\")\n\n      var r = Map.empty[K, T]\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseSet[T](f: () => T): Set[T] = {\n      parseObjectType(\"Set\")\n\n      var r = Set.empty[T]\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashMap[K, T](k: () => K, v: () => T): HashM
  #679 = Utf8               ap[K, T] = {\n      parseObjectType(\"HashMap\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashMap.emptyInit[K, T](size)\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSet[T](f: () => T): HashSet[T] = {\n      parseObjectType(\"HashSet\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSet.emptyInit[T](size)\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSMap[K, T](k: () => K, v: () => T): HashSMap[K, T] = {\n      parseObjectType(\"HashSMap\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSMap.emptyInit[K, T](size)\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSSet[T](f: () => T): HashSSet[T] = {\n      parseObjectType(\"HashSSet\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSSet.emptyInit[T](size)\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseStack[T](f: () => T): Stack[T] = {\n      val is = parseISZ(f)\n      return Stack(is)\n    }\n\n    def parseBag[T](f: () => T): Bag[T] = {\n      val map = parseMap(f, parseZ _)\n      return Bag(map)\n    }\n\n    def parseHashBag[T](f: () => T): HashBag[T] = {\n      val map = parseHashMap(f, parseZ _)\n      return HashBag(map)\n    }\n\n    def parseHashSBag[T](f: () => T): HashSBag[T] = {\n      val map = parseHashSMap(f, parseZ _)\n      return HashSBag(map)\n    }\n\n    def parsePoset[T](f: () => T): Poset[T] = {\n      def g(): HashSSet[Poset.Index] = {\n        val r = parseHashSSet(parseZ _)\n        return r\n      }\n      parseObjectType(\"Poset\")\n      parseObjectKey(\"nodes\")\n      val nodesInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"parents\")\n      val map = parseHashSMap(parseZ _, g _)\n      parseObjectNext()\n      val size = nodesInverse.size\n      var nodes = HashSMap.emptyInit[T, Poset.Index](size)\n      var parents = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var children = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var i: Z = 0\n      for (node <- nodesInverse) {\n        nodes = nodes + node ~> nodes.size\n        parents = parents + i ~> Poset.Internal.emptySet\n        children = children + i ~> Poset.Internal.emptySet\n        i = i + 1\n      }\n      var r = Poset[T](nodes, nodesInverse, parents, children)\n      for (e <- map.entries) {\n        val (n, s) = e\n        r = Poset.Internal.addParents(r, n, s.elements)\n      }\n      return r\n    }\n\n    def parseGraph[W, E](f: () => W, g: () => E): Graph[W, E] = {\n      def parseEdge(): Graph.Internal.Edge[E] = {\n        parseObjectBegin()\n        parseObjectKey(\"src\")\n        val src = parseZ()\n        parseObjectNext()\n        parseObjectKey(\"dest\")\n        val dest = parseZ()\n        val hasData = parseObjectNext()\n        if (hasData) {\n          val data = g()\n          return Graph.Internal.Edge.Data(src, dest, data)\n        } else {\n          return Graph.Internal.Edge.Plain(src, dest)\n        }\n      }\n\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val tipe = parseString()\n      parseObjectNext()\n      val multi = tipe == \"Graph\"\n      parseObjectKey(\"nodes\")\n      val nodesInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"edges\")\n      val edges = parseISZ(parseEdge _)\n      parseObjectNext()\n      var r: Graph[W, E] = if (multi) Graph.emptyMulti else Graph.empty\n      for (node <- nodesInverse) {\n        r = r * node\n      }\n      for (e <- edges) {\n        r = Graph.Internal.addEdge(r, e)\n      }\n      return r\n    }\n\n    def parseUnionFind[T](f: () => T): UnionFind[T] = {\n      parseObjectType(\"UnionFind\")\n      parseObjectKey(\"elements\")\n      val elementsInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"parentOf\")\n      val parentOf = parseISZ(parseZ _)\n      parseObjectNext()\n      parseObjectKey(\"sizeOf\")\n      val sizeOf = parseISZ(parseZ _)\n      parseObjectNext()\n      var elements = HashSMap.emptyInit[T, UnionFind.Index](elementsInverse.size)\n      for (e <- elementsInverse) {\n        elements = elements + e ~> elements.size\n      }\n      return UnionFind(elements, elementsInverse, parentOf, sizeOf)\n    }\n\n    def parseMessage(): message.Message = {\n      parseObjectType(\"Message\")\n      parseObjectKey(\"level\")\n      val level = message.Level.byOrdinal(parseZ()).getOrElse(message.Level.InternalError)\n      parseObjectNext()\n      parseObjectKey(\"message\")\n      val msg = parseString()\n      parseObjectNext()\n      parseObjectKey(\"posOpt\")\n      val posOpt = parseOption(parsePosition _)\n      parseObjectNext()\n      parseObjectKey(\"kind\")\n      val kind = parseString()\n      parseObjectNext()\n      return message.Message(level, posOpt, kind, msg)\n    }\n\n    def parsePosition(): message.Position = {\n      parseObjectType(\"Position\")\n      parseObjectKey(\"uriOpt\")\n      val uriOpt = parseOption(parseString _)\n      parseObjectNext()\n      parseObjectKey(\"beginLine\")\n      val beginLine = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"beginColumn\")\n      val beginColumn = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"endLine\")\n      val endLine = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"endColumn\")\n      val endColumn = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"offset\")\n      val offset = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"length\")\n      val length = parseU32()\n      parseObjectNext()\n      return message.FlatPos(uriOpt, beginLine, beginColumn, endLine, endColumn, offset, length)\n    }\n\n    def parseDocInfo(): message.DocInfo = {\n      parseObjectType(\"Position\")\n      parseObjectKey(\"uriOpt\")\n      val uriOpt = parseOption(parseString _)\n      parseObjectNext()\n      parseObjectKey(\"lineOffsets\")\n      val lineOffsets = parseISZ(parseU32 _)\n      parseObjectNext()\n      return message.DocInfo(uriOpt, lineOffsets)\n    }\n\n    def at(i: Z): C = {\n      if (0 <= i && i < input.size && errorOpt.isEmpty) {\n        return input(i)\n      }\n      return \'\\u0000\'\n    }\n\n    def detect(): ValueKind.Type = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'\"\' => return ValueKind.String\n        case \'{\' => return ValueKind.Object\n        case \'[\' => return ValueKind.Array\n        case \'t\' => return ValueKind.True\n        case \'f\' => return ValueKind.False\n        case \'n\' => return ValueKind.Null\n        case \'-\' => return ValueKind.Number\n        case \'0\' => return ValueKind.Number\n        case \'1\' => return ValueKind.Number\n        case \'2\' => return ValueKind.Number\n        case \'3\' => return ValueKind.Number\n        case \'4\' => return ValueKind.Number\n        case \'5\' => return ValueKind.Number\n        case \'6\' => return ValueKind.Number\n        case \'7\' => return ValueKind.Number\n        case \'8\' => return ValueKind.Number\n        case \'9\' => return ValueKind.Number\n        case _ =>\n          parseException(offset, \"Unexpected end-of-file.\")\n          return ValueKind.Null\n      }\n    }\n\n    def parseObjectType(expectedType: String): String = {\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val i = offset + 1\n      val value = parseString()\n      parseObjectNext()\n      if (value != expectedType) {\n        parseException(i, s\"Expected \'$expectedType\', but \'$value\' found.\")\n      }\n      return value\n    }\n\n    def parseObjectTypes(expectedTypes: ISZ[String]): String = {\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val i = offset + 1\n      val value = parseString()\n      parseObjectNext()\n      if (expectedTypes.nonEmpty && !ISZOps(expectedTypes).contains(value)) {\n        expectedTypes.size match {\n          case z\"1\" =>\n            parseException(i, s\"Expected \'${expectedTypes(0)}\', but \'$value\' found.\")\n          case z\"2\" =>\n            parseException(i, s\"Expected \'${expectedTypes(0)}\' or \'${expectedTypes(1)}\' , but \'$value\' found.\")\n          case _ =>\n            parseException(\n              i,\n              s\"Expected ${st\"\'${(ISZOps(expectedTypes).dropRight(1), \"\', \'\")}\', or \'${expectedTypes(expectedTypes.size - 1)}\'\".render} , but \'$value\' found.\"\n            )\n        }\n      }\n      return value\n    }\n\n    def parseObjectKey(expectedKey: String): String = {\n      errorIfEof(offset)\n      val i = offset + 1\n      val key = parseString()\n      if (key != expectedKey) {\n        parseException(i, s\"Expected \'$expectedKey\', but \'$key\' found.\")\n      }\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \':\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return key\n        case c =>\n          parseException(offset, s\"Expected \':\', but \'$c\' found.\")\n          return \"\"\n      }\n    }\n\n    def parseObjectKeys(expectedKeys: ISZ[String]): String = {\n      errorIfEof(offset)\n      val i = offset + 1\n      val key = parseString()\n      if (expectedKeys.nonEmpty && !ISZOps(expectedKeys).contains(key)) {\n        expectedKeys.size match {\n          case z\"1\" =>\n            parseException(i, s\"Expected \'${expectedKeys(0)}\', but \'$key\' found.\")\n          case z\"2\" =>\n            parseException(i, s\"Expected \'${expectedKeys(0)}\' or \'${expectedKeys(1)}\' , but \'$key\' found.\")\n          case _ =>\n            parseException(\n              i,\n              s\"Expected ${st\"\'${(ISZOps(expectedKeys).dropRight(1), \"\', \'\")}\', or \'${expectedKeys(expectedKeys.size - 1)}\'\".render} , but \'$key\' found.\"\n            )\n        }\n      }\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \':\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return key\n        case c =>\n          parseException(offset, s\"Expected \':\', but \'$c\' found.\")\n          return \"\"\n      }\n    }\n\n    def parseObjectBegin(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'{\' =>\n          offset = offset + 1\n          parseWhitespace()\n          errorIfEof(offset)\n          at(offset).native match {\n            case \'}\' =>\n              offset = offset + 1\n              return F\n            case _ =>\n              return T\n          }\n        case c =>\n          parseException(offset, s\"Expected \'{\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseObjectNext(): B = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \',\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return T\n        case \'}\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return F\n        case c =>\n          parseException(offset, s\"Expected \',\' or \'}\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseArrayBegin(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'[\' =>\n          offset = offset + 1\n          parseWhitespace()\n          errorIfEof(offset)\n          at(offset).native match {\n            case \']\' =>\n              offset = offset + 1\n              return F\n            case _ =>\n              return T\n          }\n        case c =>\n          parseException(offset, s\"Expected \'[\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseArrayNext(): B = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \',\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return T\n        case \']\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return F\n        case c =>\n          parseException(offset, s\"Expected \',\' or \']\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseNumber(): String = {\n      var r = ISZ[C]()\n\n      errorIfEof(offset)\n\n      var c = at(offset)\n      c.native match {\n        case \'-\' =>\n          r = r :+ c\n          c = incOffset(1)\n        case _ =>\n          if (!isDigit(c)) {\n            parseException(offset, s\"\"\"Expected a \'-\' or a digit but \'$c\' found.\"\"\")\n          }\n      }\n\n      c.native match {\n        case \'0\' =>\n          r = r :+ c\n          if (offset + 1 == input.size) {\n            offset = offset + 1\n            return conversions.String.fromCis(r)\n          }\n          c = incOffset(1)\n        case _ =>\n          r = r :+ c\n          if (offset + 1 == input.size) {\n            offset = offset + 1\n            return conversions.String.fromCis(r)\n          }\n          c = incOffset(1)\n          while (isDigit(c)) {\n            r = r :+ c\n            if (offset + 1 == input.size) {\n              offset = offset + 1\n              return conversions.String.fromCis(r)\n            }\n            c = incOffset(1)\n          }\n      }\n\n      c.native match {\n        case \'.\' =>\n          r = r :+ c\n          c = incOffset(1)\n          while (isDigit(c)) {\n            r = r :+ c\n            if (offset + 1 == input.size) {\n              offset = offset + 1\n              return conversions.String.fromCis(r)\n            }\n            c = incOffset(1)\n          }\n        case _ =>\n      }\n\n      c.native match {\n        case \'e\' =>\n        case \'E\' =>\n        case _ => return conversions.String.fromCis(r)\n      }\n      r = r :+ c\n      c = incOffset(1)\n      val hasPlusMinus: B = c.native match {\n        case \'+\' => T\n        case \'-\' => T\n        case _ => F\n      }\n      if (hasPlusMinus) {\n        r = r :+ c\n        c = incOffset(1)\n      }\n      while (isDigit(c)) {\n        r = r :+ c\n        if (offset + 1 == input.size) {\n          offset = offset + 1\n          return conversions.String.fromCis(r)\n        }\n        c = incOffset(1)\n      }\n      return conversions.String.fromCis(r)\n    }\n\n    def parseString(): String = {\n      errorIfEof(offset)\n\n      var r = ISZ[C]()\n\n      var c = at(offset)\n      c.native match {\n        case \'\"\' =>\n          c = incOffset(1)\n          while (c != \'\"\') {\n            c.native match {\n              case \'\\\\\' =>\n                c = incOffset(1)\n                c.native match {\n                  case \'\"\' => r = r :+ \'\"\'\n                  case \'\\\\\' => r = r :+ \'\\\\\'\n                  case \'/\' => r = r :+ \'/\'\n                  case \'b\' => r = r :+ \'\\b\'\n                  case \'f\' => r = r :+ \'\\f\'\n                  case \'n\' => r = r :+ \'\\n\'\n                  case \'r\' => r = r :+ \'\\r\'\n                  case \'t\' => r = r :+ \'\\t\'\n                  case \'u\' =>\n                    incOffset(4)\n                    val hex = slice(offset - 3, offset + 1)\n                    COps.fromUnicodeHex(hex) match {\n                      case Some(ch) => r = r :+ ch\n                      case _ =>\n                        parseException(offset - 3, s\"Expected a character hex but \'$hex\' found.\")\n                    }\n                  case _ =>\n                    parseException(offset, s\"Expected an escaped character but \'$c\' found.\")\n                }\n              case _ => r = r :+ c\n            }\n            c = incOffset(1)\n          }\n          offset = offset + 1\n          return conversions.String.fromCis(r)\n        case _ =>\n          parseException(offset, s\"\"\"Expected \'\"\' but \'$c\' found.\"\"\")\n          return \"\"\n      }\n    }\n\n    def parseConstant(text: String): Unit = {\n      errorIfEof(offset + text.size - 1)\n      val t = conversions.String.fromCis(slice(offset, offset + text.size))\n      if (t != text) {\n        parseException(offset, s\"Expected \'$text\', but \'$t\' found.\")\n      }\n      offset = offset + text.size\n      text.native match {\n        case \"true\" =>\n        case \"false\" =>\n        case \"null\" =>\n        case _ => parseException(offset, s\"Invalid constant value \'$text\'.\")\n      }\n    }\n\n    def computeLineColumn(i: Z): (Z, Z) = {\n      var line: Z = 1\n      var column: Z = 1\n      var j: Z = 0\n      while (j != i) {\n        at(j).native match {\n          case \'\\n\' =>\n            line = line + 1\n            column = 1\n          case _ => column = column + 1\n        }\n        j = j + 1\n      }\n      return (line, column)\n    }\n\n    def parseException(i: Z, msg: String): Unit = {\n      if (errorOpt.nonEmpty) {\n        return\n      }\n      val p = computeLineColumn(i)\n      errorOpt = Some(ErrorMsg(p._1, p._2, msg))\n      offset = input.size\n    }\n\n    def errorIfEof(i: Z): Unit = {\n      if (i >= input.size || errorOpt.nonEmpty) {\n        parseException(offset, \"Unexpected end-of-file.\")\n      }\n    }\n\n    def incOffset(n: Z): C = {\n      offset = offset + n\n      errorIfEof(offset)\n      return at(offset)\n    }\n\n    def parseWhitespace(): Unit = {\n      if (errorOpt.nonEmpty) {\n        return\n      }\n      if (offset >= input.size) {\n        return\n      }\n      var c = at(offset)\n      while (isWhitespace(c)) {\n        offset = offset + 1\n        if (offset >= input.size) {\n          return\n        }\n        c = at(offset)\n      }\n    }\n\n    @pure def isDigit(c: C): B = {\n      c.native match {\n        case \'0\' => return T\n        case \'1\' => return T\n        case \'2\' => return T\n        case \'3\' => return T\n        case \'4\' => return T\n        case \'5\' => return T\n        case \'6\' => return T\n        case \'7\' => return T\n        case \'8\' => return T\n        case \'9\' => return T\n        case _ => return F\n      }\n    }\n\n    @pure def isWhitespace(c: C): B = {\n      c.native match {\n        case \' \' => return T\n        case \'\\n\' => return T\n        case \'\\r\' => return T\n        case \'\\t\' => return T\n        case _ => return F\n      }\n    }\n\n    @pure def slice(start: Z, til: Z): ISZ[C] = {\n      var r = ISZ[C]()\n      for (i <- start until til) {\n        r = r :+ at(i)\n      }\n      return r\n    }\n  }\n\n  def parseAst[T](binding: JsonAstBinding[T], input: String): Either[T, ErrorMsg] = {\n    val parser = Parser.create(input)\n    val emptyKeys = ISZ[String]()\n\n    def parseString(): T = {\n      val s = parser.parseString()\n      return binding.toString(s)\n    }\n\n    def parseNumber(): T = {\n      val n = parser.parseNumber()\n      return binding.toNumber(n)\n    }\n\n    def parseTrue(): T = {\n      parser.parseConstant(\"true\")\n      return binding.toBoolean(T)\n    }\n\n    def parseFalse(): T = {\n      parser.parseConstant(\"false\")\n      return binding.toBoolean(F)\n    }\n\n    def parseNull(): T = {\n      parser.parseConstant(\"null\")\n      return binding.toNull\n    }\n\n    def parseArray(): T = {\n      var continue = parser.parseArrayBegin()\n      if (!continue) {\n        return binding.toArray(ISZ())\n      }\n      var v = parseValue()\n      var values =
  #680 = String             #679          // ap[K, T] = {\n      parseObjectType(\"HashMap\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashMap.emptyInit[K, T](size)\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSet[T](f: () => T): HashSet[T] = {\n      parseObjectType(\"HashSet\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSet.emptyInit[T](size)\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSMap[K, T](k: () => K, v: () => T): HashSMap[K, T] = {\n      parseObjectType(\"HashSMap\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSMap.emptyInit[K, T](size)\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSSet[T](f: () => T): HashSSet[T] = {\n      parseObjectType(\"HashSSet\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSSet.emptyInit[T](size)\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseStack[T](f: () => T): Stack[T] = {\n      val is = parseISZ(f)\n      return Stack(is)\n    }\n\n    def parseBag[T](f: () => T): Bag[T] = {\n      val map = parseMap(f, parseZ _)\n      return Bag(map)\n    }\n\n    def parseHashBag[T](f: () => T): HashBag[T] = {\n      val map = parseHashMap(f, parseZ _)\n      return HashBag(map)\n    }\n\n    def parseHashSBag[T](f: () => T): HashSBag[T] = {\n      val map = parseHashSMap(f, parseZ _)\n      return HashSBag(map)\n    }\n\n    def parsePoset[T](f: () => T): Poset[T] = {\n      def g(): HashSSet[Poset.Index] = {\n        val r = parseHashSSet(parseZ _)\n        return r\n      }\n      parseObjectType(\"Poset\")\n      parseObjectKey(\"nodes\")\n      val nodesInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"parents\")\n      val map = parseHashSMap(parseZ _, g _)\n      parseObjectNext()\n      val size = nodesInverse.size\n      var nodes = HashSMap.emptyInit[T, Poset.Index](size)\n      var parents = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var children = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var i: Z = 0\n      for (node <- nodesInverse) {\n        nodes = nodes + node ~> nodes.size\n        parents = parents + i ~> Poset.Internal.emptySet\n        children = children + i ~> Poset.Internal.emptySet\n        i = i + 1\n      }\n      var r = Poset[T](nodes, nodesInverse, parents, children)\n      for (e <- map.entries) {\n        val (n, s) = e\n        r = Poset.Internal.addParents(r, n, s.elements)\n      }\n      return r\n    }\n\n    def parseGraph[W, E](f: () => W, g: () => E): Graph[W, E] = {\n      def parseEdge(): Graph.Internal.Edge[E] = {\n        parseObjectBegin()\n        parseObjectKey(\"src\")\n        val src = parseZ()\n        parseObjectNext()\n        parseObjectKey(\"dest\")\n        val dest = parseZ()\n        val hasData = parseObjectNext()\n        if (hasData) {\n          val data = g()\n          return Graph.Internal.Edge.Data(src, dest, data)\n        } else {\n          return Graph.Internal.Edge.Plain(src, dest)\n        }\n      }\n\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val tipe = parseString()\n      parseObjectNext()\n      val multi = tipe == \"Graph\"\n      parseObjectKey(\"nodes\")\n      val nodesInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"edges\")\n      val edges = parseISZ(parseEdge _)\n      parseObjectNext()\n      var r: Graph[W, E] = if (multi) Graph.emptyMulti else Graph.empty\n      for (node <- nodesInverse) {\n        r = r * node\n      }\n      for (e <- edges) {\n        r = Graph.Internal.addEdge(r, e)\n      }\n      return r\n    }\n\n    def parseUnionFind[T](f: () => T): UnionFind[T] = {\n      parseObjectType(\"UnionFind\")\n      parseObjectKey(\"elements\")\n      val elementsInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"parentOf\")\n      val parentOf = parseISZ(parseZ _)\n      parseObjectNext()\n      parseObjectKey(\"sizeOf\")\n      val sizeOf = parseISZ(parseZ _)\n      parseObjectNext()\n      var elements = HashSMap.emptyInit[T, UnionFind.Index](elementsInverse.size)\n      for (e <- elementsInverse) {\n        elements = elements + e ~> elements.size\n      }\n      return UnionFind(elements, elementsInverse, parentOf, sizeOf)\n    }\n\n    def parseMessage(): message.Message = {\n      parseObjectType(\"Message\")\n      parseObjectKey(\"level\")\n      val level = message.Level.byOrdinal(parseZ()).getOrElse(message.Level.InternalError)\n      parseObjectNext()\n      parseObjectKey(\"message\")\n      val msg = parseString()\n      parseObjectNext()\n      parseObjectKey(\"posOpt\")\n      val posOpt = parseOption(parsePosition _)\n      parseObjectNext()\n      parseObjectKey(\"kind\")\n      val kind = parseString()\n      parseObjectNext()\n      return message.Message(level, posOpt, kind, msg)\n    }\n\n    def parsePosition(): message.Position = {\n      parseObjectType(\"Position\")\n      parseObjectKey(\"uriOpt\")\n      val uriOpt = parseOption(parseString _)\n      parseObjectNext()\n      parseObjectKey(\"beginLine\")\n      val beginLine = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"beginColumn\")\n      val beginColumn = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"endLine\")\n      val endLine = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"endColumn\")\n      val endColumn = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"offset\")\n      val offset = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"length\")\n      val length = parseU32()\n      parseObjectNext()\n      return message.FlatPos(uriOpt, beginLine, beginColumn, endLine, endColumn, offset, length)\n    }\n\n    def parseDocInfo(): message.DocInfo = {\n      parseObjectType(\"Position\")\n      parseObjectKey(\"uriOpt\")\n      val uriOpt = parseOption(parseString _)\n      parseObjectNext()\n      parseObjectKey(\"lineOffsets\")\n      val lineOffsets = parseISZ(parseU32 _)\n      parseObjectNext()\n      return message.DocInfo(uriOpt, lineOffsets)\n    }\n\n    def at(i: Z): C = {\n      if (0 <= i && i < input.size && errorOpt.isEmpty) {\n        return input(i)\n      }\n      return \'\\u0000\'\n    }\n\n    def detect(): ValueKind.Type = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'\"\' => return ValueKind.String\n        case \'{\' => return ValueKind.Object\n        case \'[\' => return ValueKind.Array\n        case \'t\' => return ValueKind.True\n        case \'f\' => return ValueKind.False\n        case \'n\' => return ValueKind.Null\n        case \'-\' => return ValueKind.Number\n        case \'0\' => return ValueKind.Number\n        case \'1\' => return ValueKind.Number\n        case \'2\' => return ValueKind.Number\n        case \'3\' => return ValueKind.Number\n        case \'4\' => return ValueKind.Number\n        case \'5\' => return ValueKind.Number\n        case \'6\' => return ValueKind.Number\n        case \'7\' => return ValueKind.Number\n        case \'8\' => return ValueKind.Number\n        case \'9\' => return ValueKind.Number\n        case _ =>\n          parseException(offset, \"Unexpected end-of-file.\")\n          return ValueKind.Null\n      }\n    }\n\n    def parseObjectType(expectedType: String): String = {\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val i = offset + 1\n      val value = parseString()\n      parseObjectNext()\n      if (value != expectedType) {\n        parseException(i, s\"Expected \'$expectedType\', but \'$value\' found.\")\n      }\n      return value\n    }\n\n    def parseObjectTypes(expectedTypes: ISZ[String]): String = {\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val i = offset + 1\n      val value = parseString()\n      parseObjectNext()\n      if (expectedTypes.nonEmpty && !ISZOps(expectedTypes).contains(value)) {\n        expectedTypes.size match {\n          case z\"1\" =>\n            parseException(i, s\"Expected \'${expectedTypes(0)}\', but \'$value\' found.\")\n          case z\"2\" =>\n            parseException(i, s\"Expected \'${expectedTypes(0)}\' or \'${expectedTypes(1)}\' , but \'$value\' found.\")\n          case _ =>\n            parseException(\n              i,\n              s\"Expected ${st\"\'${(ISZOps(expectedTypes).dropRight(1), \"\', \'\")}\', or \'${expectedTypes(expectedTypes.size - 1)}\'\".render} , but \'$value\' found.\"\n            )\n        }\n      }\n      return value\n    }\n\n    def parseObjectKey(expectedKey: String): String = {\n      errorIfEof(offset)\n      val i = offset + 1\n      val key = parseString()\n      if (key != expectedKey) {\n        parseException(i, s\"Expected \'$expectedKey\', but \'$key\' found.\")\n      }\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \':\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return key\n        case c =>\n          parseException(offset, s\"Expected \':\', but \'$c\' found.\")\n          return \"\"\n      }\n    }\n\n    def parseObjectKeys(expectedKeys: ISZ[String]): String = {\n      errorIfEof(offset)\n      val i = offset + 1\n      val key = parseString()\n      if (expectedKeys.nonEmpty && !ISZOps(expectedKeys).contains(key)) {\n        expectedKeys.size match {\n          case z\"1\" =>\n            parseException(i, s\"Expected \'${expectedKeys(0)}\', but \'$key\' found.\")\n          case z\"2\" =>\n            parseException(i, s\"Expected \'${expectedKeys(0)}\' or \'${expectedKeys(1)}\' , but \'$key\' found.\")\n          case _ =>\n            parseException(\n              i,\n              s\"Expected ${st\"\'${(ISZOps(expectedKeys).dropRight(1), \"\', \'\")}\', or \'${expectedKeys(expectedKeys.size - 1)}\'\".render} , but \'$key\' found.\"\n            )\n        }\n      }\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \':\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return key\n        case c =>\n          parseException(offset, s\"Expected \':\', but \'$c\' found.\")\n          return \"\"\n      }\n    }\n\n    def parseObjectBegin(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'{\' =>\n          offset = offset + 1\n          parseWhitespace()\n          errorIfEof(offset)\n          at(offset).native match {\n            case \'}\' =>\n              offset = offset + 1\n              return F\n            case _ =>\n              return T\n          }\n        case c =>\n          parseException(offset, s\"Expected \'{\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseObjectNext(): B = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \',\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return T\n        case \'}\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return F\n        case c =>\n          parseException(offset, s\"Expected \',\' or \'}\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseArrayBegin(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'[\' =>\n          offset = offset + 1\n          parseWhitespace()\n          errorIfEof(offset)\n          at(offset).native match {\n            case \']\' =>\n              offset = offset + 1\n              return F\n            case _ =>\n              return T\n          }\n        case c =>\n          parseException(offset, s\"Expected \'[\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseArrayNext(): B = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \',\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return T\n        case \']\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return F\n        case c =>\n          parseException(offset, s\"Expected \',\' or \']\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseNumber(): String = {\n      var r = ISZ[C]()\n\n      errorIfEof(offset)\n\n      var c = at(offset)\n      c.native match {\n        case \'-\' =>\n          r = r :+ c\n          c = incOffset(1)\n        case _ =>\n          if (!isDigit(c)) {\n            parseException(offset, s\"\"\"Expected a \'-\' or a digit but \'$c\' found.\"\"\")\n          }\n      }\n\n      c.native match {\n        case \'0\' =>\n          r = r :+ c\n          if (offset + 1 == input.size) {\n            offset = offset + 1\n            return conversions.String.fromCis(r)\n          }\n          c = incOffset(1)\n        case _ =>\n          r = r :+ c\n          if (offset + 1 == input.size) {\n            offset = offset + 1\n            return conversions.String.fromCis(r)\n          }\n          c = incOffset(1)\n          while (isDigit(c)) {\n            r = r :+ c\n            if (offset + 1 == input.size) {\n              offset = offset + 1\n              return conversions.String.fromCis(r)\n            }\n            c = incOffset(1)\n          }\n      }\n\n      c.native match {\n        case \'.\' =>\n          r = r :+ c\n          c = incOffset(1)\n          while (isDigit(c)) {\n            r = r :+ c\n            if (offset + 1 == input.size) {\n              offset = offset + 1\n              return conversions.String.fromCis(r)\n            }\n            c = incOffset(1)\n          }\n        case _ =>\n      }\n\n      c.native match {\n        case \'e\' =>\n        case \'E\' =>\n        case _ => return conversions.String.fromCis(r)\n      }\n      r = r :+ c\n      c = incOffset(1)\n      val hasPlusMinus: B = c.native match {\n        case \'+\' => T\n        case \'-\' => T\n        case _ => F\n      }\n      if (hasPlusMinus) {\n        r = r :+ c\n        c = incOffset(1)\n      }\n      while (isDigit(c)) {\n        r = r :+ c\n        if (offset + 1 == input.size) {\n          offset = offset + 1\n          return conversions.String.fromCis(r)\n        }\n        c = incOffset(1)\n      }\n      return conversions.String.fromCis(r)\n    }\n\n    def parseString(): String = {\n      errorIfEof(offset)\n\n      var r = ISZ[C]()\n\n      var c = at(offset)\n      c.native match {\n        case \'\"\' =>\n          c = incOffset(1)\n          while (c != \'\"\') {\n            c.native match {\n              case \'\\\\\' =>\n                c = incOffset(1)\n                c.native match {\n                  case \'\"\' => r = r :+ \'\"\'\n                  case \'\\\\\' => r = r :+ \'\\\\\'\n                  case \'/\' => r = r :+ \'/\'\n                  case \'b\' => r = r :+ \'\\b\'\n                  case \'f\' => r = r :+ \'\\f\'\n                  case \'n\' => r = r :+ \'\\n\'\n                  case \'r\' => r = r :+ \'\\r\'\n                  case \'t\' => r = r :+ \'\\t\'\n                  case \'u\' =>\n                    incOffset(4)\n                    val hex = slice(offset - 3, offset + 1)\n                    COps.fromUnicodeHex(hex) match {\n                      case Some(ch) => r = r :+ ch\n                      case _ =>\n                        parseException(offset - 3, s\"Expected a character hex but \'$hex\' found.\")\n                    }\n                  case _ =>\n                    parseException(offset, s\"Expected an escaped character but \'$c\' found.\")\n                }\n              case _ => r = r :+ c\n            }\n            c = incOffset(1)\n          }\n          offset = offset + 1\n          return conversions.String.fromCis(r)\n        case _ =>\n          parseException(offset, s\"\"\"Expected \'\"\' but \'$c\' found.\"\"\")\n          return \"\"\n      }\n    }\n\n    def parseConstant(text: String): Unit = {\n      errorIfEof(offset + text.size - 1)\n      val t = conversions.String.fromCis(slice(offset, offset + text.size))\n      if (t != text) {\n        parseException(offset, s\"Expected \'$text\', but \'$t\' found.\")\n      }\n      offset = offset + text.size\n      text.native match {\n        case \"true\" =>\n        case \"false\" =>\n        case \"null\" =>\n        case _ => parseException(offset, s\"Invalid constant value \'$text\'.\")\n      }\n    }\n\n    def computeLineColumn(i: Z): (Z, Z) = {\n      var line: Z = 1\n      var column: Z = 1\n      var j: Z = 0\n      while (j != i) {\n        at(j).native match {\n          case \'\\n\' =>\n            line = line + 1\n            column = 1\n          case _ => column = column + 1\n        }\n        j = j + 1\n      }\n      return (line, column)\n    }\n\n    def parseException(i: Z, msg: String): Unit = {\n      if (errorOpt.nonEmpty) {\n        return\n      }\n      val p = computeLineColumn(i)\n      errorOpt = Some(ErrorMsg(p._1, p._2, msg))\n      offset = input.size\n    }\n\n    def errorIfEof(i: Z): Unit = {\n      if (i >= input.size || errorOpt.nonEmpty) {\n        parseException(offset, \"Unexpected end-of-file.\")\n      }\n    }\n\n    def incOffset(n: Z): C = {\n      offset = offset + n\n      errorIfEof(offset)\n      return at(offset)\n    }\n\n    def parseWhitespace(): Unit = {\n      if (errorOpt.nonEmpty) {\n        return\n      }\n      if (offset >= input.size) {\n        return\n      }\n      var c = at(offset)\n      while (isWhitespace(c)) {\n        offset = offset + 1\n        if (offset >= input.size) {\n          return\n        }\n        c = at(offset)\n      }\n    }\n\n    @pure def isDigit(c: C): B = {\n      c.native match {\n        case \'0\' => return T\n        case \'1\' => return T\n        case \'2\' => return T\n        case \'3\' => return T\n        case \'4\' => return T\n        case \'5\' => return T\n        case \'6\' => return T\n        case \'7\' => return T\n        case \'8\' => return T\n        case \'9\' => return T\n        case _ => return F\n      }\n    }\n\n    @pure def isWhitespace(c: C): B = {\n      c.native match {\n        case \' \' => return T\n        case \'\\n\' => return T\n        case \'\\r\' => return T\n        case \'\\t\' => return T\n        case _ => return F\n      }\n    }\n\n    @pure def slice(start: Z, til: Z): ISZ[C] = {\n      var r = ISZ[C]()\n      for (i <- start until til) {\n        r = r :+ at(i)\n      }\n      return r\n    }\n  }\n\n  def parseAst[T](binding: JsonAstBinding[T], input: String): Either[T, ErrorMsg] = {\n    val parser = Parser.create(input)\n    val emptyKeys = ISZ[String]()\n\n    def parseString(): T = {\n      val s = parser.parseString()\n      return binding.toString(s)\n    }\n\n    def parseNumber(): T = {\n      val n = parser.parseNumber()\n      return binding.toNumber(n)\n    }\n\n    def parseTrue(): T = {\n      parser.parseConstant(\"true\")\n      return binding.toBoolean(T)\n    }\n\n    def parseFalse(): T = {\n      parser.parseConstant(\"false\")\n      return binding.toBoolean(F)\n    }\n\n    def parseNull(): T = {\n      parser.parseConstant(\"null\")\n      return binding.toNull\n    }\n\n    def parseArray(): T = {\n      var continue = parser.parseArrayBegin()\n      if (!continue) {\n        return binding.toArray(ISZ())\n      }\n      var v = parseValue()\n      var values =
  #681 = Utf8                ISZ[T](v)\n      continue = parser.parseArrayNext()\n      while (continue) {\n        v = parseValue()\n        values = values :+ v\n        continue = parser.parseArrayNext()\n      }\n      return binding.toArray(values)\n    }\n\n    def parseObject(): T = {\n      var continue = parser.parseObjectBegin()\n      if (!continue) {\n        return binding.toObject(ISZ())\n      }\n      var key = parser.parseObjectKeys(emptyKeys)\n      var value = parseValue()\n      var fields = ISZ[(String, T)]((key, value))\n      continue = parser.parseObjectNext()\n      while (continue) {\n        key = parser.parseObjectKeys(emptyKeys)\n        value = parseValue()\n        fields = fields :+ ((key, value))\n        continue = parser.parseObjectNext()\n      }\n      return binding.toObject(fields)\n    }\n\n    def parseValue(): T = {\n      val k = parser.detect()\n      k match {\n        case ValueKind.String => val r = parseString(); return r\n        case ValueKind.Object => val r = parseObject(); return r\n        case ValueKind.Array => val r = parseArray(); return r\n        case ValueKind.True => val r = parseTrue(); return r\n        case ValueKind.False => val r = parseFalse(); return r\n        case ValueKind.Null => val r = parseNull(); return r\n        case ValueKind.Number => val r = parseNumber(); return r\n      }\n    }\n\n    val r = parseValue()\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def printAst[T](binding: JsonAstBinding[T], v: T): ST = {\n    @pure def isSimple(o: T): B = {\n      binding.kind(o) match {\n        case ValueKind.Object => return F\n        case ValueKind.Array => return F\n        case _ => return T\n      }\n    }\n\n    @pure def printValue(o: T): ST = {\n      binding.kind(o) match {\n        case ValueKind.String =>\n          return Printer.printString(binding.fromString(o))\n        case ValueKind.Number =>\n          return Printer.printNumber(binding.fromNumber(o))\n        case ValueKind.Object =>\n          return Printer.printObject(for (p <- binding.fromObject(o)) yield (p._1, printValue(p._2)))\n        case ValueKind.Array =>\n          val es = binding.fromArray(o)\n          return Printer.printIS(ISZOps(es).forall(isSimple), es.map(printValue _))\n        case ValueKind.True => return Printer.trueSt\n        case ValueKind.False => return Printer.falseSt\n        case ValueKind.Null => return Printer.nullSt\n      }\n    }\n\n    return printValue(v)\n  }\n\n  @ext(\"JsonFun_Ext\") object Fun {\n    def printPure0[R](f: () => R @pure): String = $\n    def parsePure0[R](parser: Parser, f: String): () => R @pure = $\n\n    def print0[R](f: () => R): String = $\n    def parse0[R](parser: Parser, f: String): () => R = $\n\n    def printPure1[T1, R](f: T1 => R @pure): String = $\n    def parsePure1[T1, R](parser: Parser, f: String): T1 => R @pure = $\n\n    def print1[T1, R](f: T1 => R): String = $\n    def parse1[T1, R](parser: Parser, f: String): T1 => R = $\n    def printPure2[T1, T2, R](f: (T1, T2) => R @pure): String = $\n    def parsePure2[T1, T2, R](parser: Parser, f: String): (T1, T2) => R @pure = $\n\n    def print2[T1, T2, R](f: (T1, T2) => R): String = $\n    def parse2[T1, T2, R](parser: Parser, f: String): (T1, T2) => R = $\n\n    def printPure3[T1, T2, T3, R](f: (T1, T2, T3) => R @pure): String = $\n    def parsePure3[T1, T2, T3, R](parser: Parser, f: String): (T1, T2, T3) => R @pure = $\n\n    def print3[T1, T2, T3, R](f: (T1, T2, T3) => R): String = $\n    def parse3[T1, T2, T3, R](parser: Parser, f: String): (T1, T2, T3) => R = $\n\n    def printPure4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R @pure): String = $\n    def parsePure4[T1, T2, T3, T4, R](parser: Parser, f: String): (T1, T2, T3, T4) => R @pure = $\n\n    def print4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R): String = $\n    def parse4[T1, T2, T3, T4, R](parser: Parser, f: String): (T1, T2, T3, T4) => R = $\n\n    def printPure5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R @pure): String = $\n    def parsePure5[T1, T2, T3, T4, T5, R](parser: Parser, f: String): (T1, T2, T3, T4, T5) => R @pure = $\n\n    def print5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R): String = $\n    def parse5[T1, T2, T3, T4, T5, R](parser: Parser, f: String): (T1, T2, T3, T4, T5) => R = $\n\n    def printPure6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R @pure): String = $\n    def parsePure6[T1, T2, T3, T4, T5, T6, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6) => R @pure = $\n\n    def print6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R): String = $\n    def parse6[T1, T2, T3, T4, T5, T6, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6) => R = $\n\n    def printPure7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R @pure): String = $\n    def parsePure7[T1, T2, T3, T4, T5, T6, T7, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7) => R @pure = $\n\n    def print7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R): String = $\n    def parse7[T1, T2, T3, T4, T5, T6, T7, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7) => R = $\n\n    def printPure8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure): String = $\n    def parsePure8[T1, T2, T3, T4, T5, T6, T7, T8, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure = $\n\n    def print8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R): String = $\n    def parse8[T1, T2, T3, T4, T5, T6, T7, T8, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8) => R = $\n\n    def printPure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure): String = $\n    def parsePure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure = $\n\n    def print9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R): String = $\n    def parse9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R = $\n\n    def printPure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure): String = $\n    def parsePure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure = $\n\n    def print10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R): String = $\n    def parse10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R = $\n\n    def printPure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure): String = $\n    def parsePure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure = $\n\n    def print11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R): String = $\n    def parse11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R = $\n\n    def printPure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure): String = $\n    def parsePure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure = $\n\n    def print12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R): String = $\n    def parse12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R = $\n\n    def printPure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure): String = $\n    def parsePure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure = $\n\n    def print13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R): String = $\n    def parse13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R = $\n\n    def printPure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure): String = $\n    def parsePure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure = $\n\n    def print14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R): String = $\n    def parse14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R = $\n\n    def printPure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure): String = $\n    def parsePure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure = $\n\n    def print15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R): String = $\n    def parse15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R = $\n\n    def printPure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure): String = $\n    def parsePure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure = $\n\n    def print16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R): String = $\n    def parse16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R = $\n\n    def printPure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure): String = $\n    def parsePure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure = $\n\n    def print17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R): String = $\n    def parse17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R = $\n\n    def printPure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure): String = $\n    def parsePure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure = $\n\n    def print18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R): String = $\n    def parse18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R = $\n\n    def printPure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure): String = $\n    def parsePure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure = $\n\n    def print19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R): String = $\n    def parse19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R = $\n\n    def printPure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure): String = $\n    def parsePure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure = $\n\n    def print20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R): String = $\n    def parse20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R = $\n\n    def printPure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure): String = $\n    def parsePure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure = $\n\n    def print21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R): String = $\n    def parse21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R = $\n\n    def printPure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure): String = $\n    def parsePure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure = $\n\n    def print22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R): String = $\n    def parse22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R = $\n  }\n}\n
  #682 = String             #681          //  ISZ[T](v)\n      continue = parser.parseArrayNext()\n      while (continue) {\n        v = parseValue()\n        values = values :+ v\n        continue = parser.parseArrayNext()\n      }\n      return binding.toArray(values)\n    }\n\n    def parseObject(): T = {\n      var continue = parser.parseObjectBegin()\n      if (!continue) {\n        return binding.toObject(ISZ())\n      }\n      var key = parser.parseObjectKeys(emptyKeys)\n      var value = parseValue()\n      var fields = ISZ[(String, T)]((key, value))\n      continue = parser.parseObjectNext()\n      while (continue) {\n        key = parser.parseObjectKeys(emptyKeys)\n        value = parseValue()\n        fields = fields :+ ((key, value))\n        continue = parser.parseObjectNext()\n      }\n      return binding.toObject(fields)\n    }\n\n    def parseValue(): T = {\n      val k = parser.detect()\n      k match {\n        case ValueKind.String => val r = parseString(); return r\n        case ValueKind.Object => val r = parseObject(); return r\n        case ValueKind.Array => val r = parseArray(); return r\n        case ValueKind.True => val r = parseTrue(); return r\n        case ValueKind.False => val r = parseFalse(); return r\n        case ValueKind.Null => val r = parseNull(); return r\n        case ValueKind.Number => val r = parseNumber(); return r\n      }\n    }\n\n    val r = parseValue()\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def printAst[T](binding: JsonAstBinding[T], v: T): ST = {\n    @pure def isSimple(o: T): B = {\n      binding.kind(o) match {\n        case ValueKind.Object => return F\n        case ValueKind.Array => return F\n        case _ => return T\n      }\n    }\n\n    @pure def printValue(o: T): ST = {\n      binding.kind(o) match {\n        case ValueKind.String =>\n          return Printer.printString(binding.fromString(o))\n        case ValueKind.Number =>\n          return Printer.printNumber(binding.fromNumber(o))\n        case ValueKind.Object =>\n          return Printer.printObject(for (p <- binding.fromObject(o)) yield (p._1, printValue(p._2)))\n        case ValueKind.Array =>\n          val es = binding.fromArray(o)\n          return Printer.printIS(ISZOps(es).forall(isSimple), es.map(printValue _))\n        case ValueKind.True => return Printer.trueSt\n        case ValueKind.False => return Printer.falseSt\n        case ValueKind.Null => return Printer.nullSt\n      }\n    }\n\n    return printValue(v)\n  }\n\n  @ext(\"JsonFun_Ext\") object Fun {\n    def printPure0[R](f: () => R @pure): String = $\n    def parsePure0[R](parser: Parser, f: String): () => R @pure = $\n\n    def print0[R](f: () => R): String = $\n    def parse0[R](parser: Parser, f: String): () => R = $\n\n    def printPure1[T1, R](f: T1 => R @pure): String = $\n    def parsePure1[T1, R](parser: Parser, f: String): T1 => R @pure = $\n\n    def print1[T1, R](f: T1 => R): String = $\n    def parse1[T1, R](parser: Parser, f: String): T1 => R = $\n    def printPure2[T1, T2, R](f: (T1, T2) => R @pure): String = $\n    def parsePure2[T1, T2, R](parser: Parser, f: String): (T1, T2) => R @pure = $\n\n    def print2[T1, T2, R](f: (T1, T2) => R): String = $\n    def parse2[T1, T2, R](parser: Parser, f: String): (T1, T2) => R = $\n\n    def printPure3[T1, T2, T3, R](f: (T1, T2, T3) => R @pure): String = $\n    def parsePure3[T1, T2, T3, R](parser: Parser, f: String): (T1, T2, T3) => R @pure = $\n\n    def print3[T1, T2, T3, R](f: (T1, T2, T3) => R): String = $\n    def parse3[T1, T2, T3, R](parser: Parser, f: String): (T1, T2, T3) => R = $\n\n    def printPure4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R @pure): String = $\n    def parsePure4[T1, T2, T3, T4, R](parser: Parser, f: String): (T1, T2, T3, T4) => R @pure = $\n\n    def print4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R): String = $\n    def parse4[T1, T2, T3, T4, R](parser: Parser, f: String): (T1, T2, T3, T4) => R = $\n\n    def printPure5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R @pure): String = $\n    def parsePure5[T1, T2, T3, T4, T5, R](parser: Parser, f: String): (T1, T2, T3, T4, T5) => R @pure = $\n\n    def print5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R): String = $\n    def parse5[T1, T2, T3, T4, T5, R](parser: Parser, f: String): (T1, T2, T3, T4, T5) => R = $\n\n    def printPure6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R @pure): String = $\n    def parsePure6[T1, T2, T3, T4, T5, T6, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6) => R @pure = $\n\n    def print6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R): String = $\n    def parse6[T1, T2, T3, T4, T5, T6, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6) => R = $\n\n    def printPure7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R @pure): String = $\n    def parsePure7[T1, T2, T3, T4, T5, T6, T7, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7) => R @pure = $\n\n    def print7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R): String = $\n    def parse7[T1, T2, T3, T4, T5, T6, T7, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7) => R = $\n\n    def printPure8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure): String = $\n    def parsePure8[T1, T2, T3, T4, T5, T6, T7, T8, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure = $\n\n    def print8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R): String = $\n    def parse8[T1, T2, T3, T4, T5, T6, T7, T8, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8) => R = $\n\n    def printPure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure): String = $\n    def parsePure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure = $\n\n    def print9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R): String = $\n    def parse9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R = $\n\n    def printPure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure): String = $\n    def parsePure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure = $\n\n    def print10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R): String = $\n    def parse10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R = $\n\n    def printPure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure): String = $\n    def parsePure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure = $\n\n    def print11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R): String = $\n    def parse11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R = $\n\n    def printPure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure): String = $\n    def parsePure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure = $\n\n    def print12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R): String = $\n    def parse12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R = $\n\n    def printPure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure): String = $\n    def parsePure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure = $\n\n    def print13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R): String = $\n    def parse13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R = $\n\n    def printPure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure): String = $\n    def parsePure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure = $\n\n    def print14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R): String = $\n    def parse14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R = $\n\n    def printPure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure): String = $\n    def parsePure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure = $\n\n    def print15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R): String = $\n    def parse15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R = $\n\n    def printPure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure): String = $\n    def parsePure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure = $\n\n    def print16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R): String = $\n    def parse16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R = $\n\n    def printPure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure): String = $\n    def parsePure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure = $\n\n    def print17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R): String = $\n    def parse17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R = $\n\n    def printPure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure): String = $\n    def parsePure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure = $\n\n    def print18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R): String = $\n    def parse18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R = $\n\n    def printPure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure): String = $\n    def parsePure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure = $\n\n    def print19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R): String = $\n    def parse19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R = $\n\n    def printPure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure): String = $\n    def parsePure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure = $\n\n    def print20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R): String = $\n    def parse20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R = $\n\n    def printPure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure): String = $\n    def parsePure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure = $\n\n    def print21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R): String = $\n    def parse21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R = $\n\n    def printPure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure): String = $\n    def parsePure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure = $\n\n    def print22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R): String = $\n    def parse22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R = $\n  }\n}\n
  #683 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@record class MBox[T](var value: T)\n\n@record class MBox2[T1, T2](var value1: T1, var value2: T2)\n\n@record class MBox3[T1, T2, T3](var value1: T1, var value2: T2, var value3: T3)\n\n@record class MBox4[T1, T2, T3, T4](var value1: T1, var value2: T2, var value3: T3, var value4: T4)\n\n@record class MBox5[T1, T2, T3, T4, T5](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5)\n\n@record class MBox6[T1, T2, T3, T4, T5, T6](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6)\n\n@record class MBox7[T1, T2, T3, T4, T5, T6, T7](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7)\n\n@record class MBox8[T1, T2, T3, T4, T5, T6, T7, T8](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8)\n\n@record class MBox9[T1, T2, T3, T4, T5, T6, T7, T8, T9](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9)\n\n@record class MBox10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10)\n\n@record class MBox11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11)\n\n@record class MBox12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12)\n\n@record class MBox13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13)\n\n@record class MBox14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14)\n\n@record class MBox15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15)\n\n@record class MBox16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16)\n\n@record class MBox17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17)\n\n@record class MBox18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18)\n\n@record class MBox19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19)\n\n@record class MBox20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20)\n\n@record class MBox21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20, var value21: T21)\n\n@record class MBox22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20, var value21: T21, var value22: T22)\n
  #684 = String             #683          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@record class MBox[T](var value: T)\n\n@record class MBox2[T1, T2](var value1: T1, var value2: T2)\n\n@record class MBox3[T1, T2, T3](var value1: T1, var value2: T2, var value3: T3)\n\n@record class MBox4[T1, T2, T3, T4](var value1: T1, var value2: T2, var value3: T3, var value4: T4)\n\n@record class MBox5[T1, T2, T3, T4, T5](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5)\n\n@record class MBox6[T1, T2, T3, T4, T5, T6](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6)\n\n@record class MBox7[T1, T2, T3, T4, T5, T6, T7](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7)\n\n@record class MBox8[T1, T2, T3, T4, T5, T6, T7, T8](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8)\n\n@record class MBox9[T1, T2, T3, T4, T5, T6, T7, T8, T9](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9)\n\n@record class MBox10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10)\n\n@record class MBox11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11)\n\n@record class MBox12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12)\n\n@record class MBox13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13)\n\n@record class MBox14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14)\n\n@record class MBox15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15)\n\n@record class MBox16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16)\n\n@record class MBox17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17)\n\n@record class MBox18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18)\n\n@record class MBox19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19)\n\n@record class MBox20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20)\n\n@record class MBox21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20, var value21: T21)\n\n@record class MBox22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20, var value21: T21, var value22: T22)\n
  #685 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Graph {\n\n  type Index = Z\n\n  @datatype trait Edge[W, E] {\n    @pure def source: W\n    @pure def dest: W\n    @pure def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E]\n  }\n\n  object Edge {\n\n    @datatype class Plain[W, E](val source: W, val dest: W) extends Edge[W, E] {\n\n      @pure override def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E] = {\n        return Internal.Edge.Plain(map.get(source).get, map.get(dest).get)\n      }\n\n    }\n\n    @datatype class Data[W, E](val source: W, val dest: W, val data: E) extends Edge[W, E] {\n\n      @pure override def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E] = {\n        return Internal.Edge.Data(map.get(source).get, map.get(dest).get, data)\n      }\n\n    }\n\n  }\n\n  object Internal {\n\n    @datatype trait Edge[E] {\n      @pure def source: Graph.Index\n      @pure def dest: Graph.Index\n      @pure def toEdge[W](map: ISZ[W]): Graph.Edge[W, E]\n    }\n\n    @datatype trait Edges[E] {\n      @pure def elements: ISZ[Internal.Edge[E]]\n      @pure def size: Z\n      @pure def +(e: Internal.Edge[E]): Edges[E]\n      @pure def ++(es: ISZ[Internal.Edge[E]]): Edges[E]\n      @pure def -#(p: (Internal.Edge[E], Z)): Edges[E]\n    }\n\n    object Edges {\n\n      @datatype class Set[E](val set: HashSSet[Internal.Edge[E]]) extends Edges[E] {\n\n        @pure override def elements: ISZ[Internal.Edge[E]] = {\n          return set.elements\n        }\n\n        @pure override def size: Z = {\n          return set.size\n        }\n\n        @pure override def +(e: Graph.Internal.Edge[E]): Edges[E] = {\n          return this(set + e)\n        }\n\n        @pure override def ++(es: ISZ[Internal.Edge[E]]): Edges[E] = {\n          return this(set ++ es)\n        }\n\n        @pure override def -#(p: (Internal.Edge[E], Z)): Edges[E] = {\n          return this(set - p._1)\n        }\n      }\n\n      @datatype class Bag[E](val set: HashSBag[Internal.Edge[E]]) extends Edges[E] {\n\n        @pure override def elements: ISZ[Internal.Edge[E]] = {\n          return set.elements\n        }\n\n        @pure override def size: Z = {\n          return set.size\n        }\n\n        @pure override def +(e: Internal.Edge[E]): Edges[E] = {\n          return this(set + e)\n        }\n\n        @pure override def ++(es: ISZ[Internal.Edge[E]]): Edges[E] = {\n          return this(set ++ es)\n        }\n\n        @pure override def -#(p: (Internal.Edge[E], Z)): Edges[E] = {\n          return this(set -# p)\n        }\n      }\n\n      @pure def empty[E](multi: B): Edges[E] = {\n        return if (multi) Bag(HashSBag.empty) else Set(HashSSet.empty)\n      }\n\n    }\n\n    object Edge {\n\n      @datatype class Plain[E](val source: Graph.Index, val dest: Graph.Index) extends Edge[E] {\n\n        @pure override def toEdge[W](map: ISZ[W]): Graph.Edge[W, E] = {\n          return Graph.Edge.Plain(map(source), map(dest))\n        }\n\n      }\n\n      @datatype class Data[E](val source: Graph.Index, val dest: Graph.Index, val data: E) extends Edge[E] {\n\n        @pure override def toEdge[W](map: ISZ[W]): Graph.Edge[W, E] = {\n          return Graph.Edge.Data(map(source), map(dest), data)\n        }\n\n      }\n\n    }\n\n    @pure def addEdge[W, E](g: Graph[W, E], e: Internal.Edge[E]): Graph[W, E] = {\n      return g(\n        incomingEdges = g.incomingEdges + e.dest ~> (g.incomingEdges\n          .get(e.dest)\n          .getOrElse(Edges.empty[E](g.multi)) + e),\n        outgoingEdges = g.outgoingEdges + e.source ~> (g.outgoingEdges\n          .get(e.source)\n          .getOrElse(Edges.empty[E](g.multi)) + e)\n      )\n    }\n\n    @pure def addPlainEdge[W, E](g: Graph[W, E], src: Graph.Index, dst: Graph.Index): Graph[W, E] = {\n      return addEdge(g, Graph.Internal.Edge.Plain[E](src, dst))\n    }\n\n    @pure def addDataEdge[W, E](g: Graph[W, E], data: E, src: Graph.Index, dst: Graph.Index): Graph[W, E] = {\n      return addEdge(g, Graph.Internal.Edge.Data(src, dst, data))\n    }\n\n    @pure def removeEdge[W, E](g: Graph[W, E], e: Graph.Internal.Edge[E], n: Z): Graph[W, E] = {\n      if (g.incomingEdges.get(e.dest).isEmpty) {\n        return g\n      }\n      return g(\n        incomingEdges = g.incomingEdges + e.dest ~> (g.incomingEdges.get(e.dest).get -# e ~> n),\n        outgoingEdges = g.outgoingEdges + e.source ~> (g.outgoingEdges.get(e.source).get -# e ~> n)\n      )\n    }\n\n    @pure def incoming[W, E](g: Graph[W, E], dst: Graph.Index): ISZ[Graph.Internal.Edge[E]] = {\n      g.incomingEdges.get(dst) match {\n        case Some(s) => return s.elements\n        case _ => return ISZ()\n      }\n    }\n\n    @pure def outgoing[W, E](g: Graph[W, E], src: Graph.Index): ISZ[Graph.Internal.Edge[E]] = {\n      g.outgoingEdges.get(src) match {\n        case Some(s) => return s.elements\n        case _ => return ISZ()\n      }\n    }\n\n  }\n\n  @pure def empty[W, E]: Graph[W, E] = {\n    return Graph(HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty, 0, F)\n  }\n\n  @pure def emptyMulti[W, E]: Graph[W, E] = {\n    return Graph(HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty, 0, T)\n  }\n}\n\n@datatype class Graph[W, E](\n  val nodes: HashSMap[W, Graph.Index],\n  val nodesInverse: IS[Graph.Index, W],\n  val incomingEdges: HashSMap[Graph.Index, Graph.Internal.Edges[E]],\n  val outgoingEdges: HashSMap[Graph.Index, Graph.Internal.Edges[E]],\n  val nextNodeId: Graph.Index,\n  val multi: B\n) {\n\n  @pure def *(node: W): Graph[W, E] = {\n    nodes.get(node) match {\n      case Some(_) => return this\n      case _ =>\n        return this(\n          nodes + node ~> nextNodeId,\n          nodesInverse :+ node,\n          incomingEdges,\n          outgoingEdges,\n          nextNodeId + 1,\n          multi\n        )\n    }\n  }\n\n  @pure def --*[I](ns: IS[I, W]): Graph[W, E] = {\n    var r: Graph[W, E] = if (multi) Graph.emptyMulti[W, E] else Graph.empty[W, E]\n    val ins = HashSet ++ ns.map[Z](n => nodes.get(n).get)\n    for (es <- incomingEdges.values) {\n      for (e <- es.elements) {\n        if (ins.contains(e.source) && ins.contains(e.dest)) {\n          r = r.addEdge(e.toEdge(nodesInverse))\n        }\n      }\n    }\n    return r\n  }\n\n  @pure def +(edge: (W, W)): Graph[W, E] = {\n    return addPlainEdge(edge._1, edge._2)\n  }\n\n  @pure def +@(edge: ((W, W), E)): Graph[W, E] = {\n    return addDataEdge(edge._2, edge._1._1, edge._1._2)\n  }\n\n  @pure def -(edge: Graph.Edge[W, E]): Graph[W, E] = {\n    return removeEdgeN(edge, 1)\n  }\n\n  @pure def -#(p: (Graph.Edge[W, E], Z)): Graph[W, E] = {\n    return removeEdgeN(p._1, p._2)\n  }\n\n  @pure def --[I](edges: IS[I, Graph.Edge[W, E]]): Graph[W, E] = {\n    var r = this\n    for (e <- edges) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def incoming(dest: W): ISZ[Graph.Edge[W, E]] = {\n    nodes.get(dest) match {\n      case Some(dst) => return Graph.Internal.incoming(this, dst).map(e => e.toEdge(nodesInverse))\n      case _ => return ISZ()\n    }\n  }\n\n  @pure def outgoing(source: W): ISZ[Graph.Edge[W, E]] = {\n    nodes.get(source) match {\n      case Some(src) => Graph.Internal.outgoing(this, src).map[Graph.Edge[W, E]](e => e.toEdge(nodesInverse))\n      case _ => return ISZ()\n    }\n  }\n\n  @pure def addEdge(edge: Graph.Edge[W, E]): Graph[W, E] = {\n    return Graph.Internal.addEdge(this * edge.source * edge.dest, edge.toInternal(nodes))\n  }\n\n  @pure def addPlainEdge(source: W, dest: W): Graph[W, E] = {\n    val r = this * source * dest\n    return Graph.Internal.addPlainEdge(r, r.nodes.get(source).get, r.nodes.get(dest).get)\n  }\n\n  @pure def addDataEdge(data: E, source: W, dest: W): Graph[W, E] = {\n    val r = this * source * dest\n    return Graph.Internal.addDataEdge(r, data, r.nodes.get(source).get, r.nodes.get(dest).get)\n  }\n\n  @pure def allEdges: ISZ[Graph.Edge[W, E]] = {\n    return for (es <- incomingEdges.values; e <- es.elements) yield e.toEdge(nodesInverse)\n  }\n\n  @pure def removeEdgeN(edge: Graph.Edge[W, E], n: Z): Graph[W, E] = {\n    return Graph.Internal.removeEdge(this, edge.toInternal(nodes), n)\n  }\n\n  @pure def edges(source: W, dest: W): ISZ[Graph.Edge[W, E]] = {\n    return outgoing(source).filter(e => e.dest == dest)\n  }\n\n  @pure def numOfNodes: Z = {\n    return nodes.size\n  }\n\n  @pure def numOfEdges: Z = {\n    var r = z\"0\"\n    for (n <- incomingEdges.values.map[Z](s => s.size)) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure override def hash: Z = {\n    return (numOfNodes, numOfEdges).hash\n  }\n\n  @pure def isEqual(other: Graph[W, E]): B = {\n    if (nodes.size != other.nodes.size || incomingEdges.size != incomingEdges.size) {\n      return F\n    }\n    if (nodes.keySet != other.nodes.keySet) {\n      return F\n    }\n    val thisEdges: ISZ[Graph.Edge[W, E]] =\n      for (ess <- incomingEdges.values; es <- ess.elements) yield es.toEdge(nodesInverse)\n    val otherEdges: ISZ[Graph.Edge[W, E]] =\n      for (ess <- other.incomingEdges.values; es <- ess.elements) yield es.toEdge(other.nodesInverse)\n    return (HashSet ++ thisEdges ++ otherEdges).size == thisEdges.size\n  }\n\n  @pure def toST(attributes: ISZ[ST], f: W => ST @pure, g: E => ST @pure): ST = {\n    @pure def e2st(e: Graph.Internal.Edge[E]): ST = {\n      e match {\n        case Graph.Internal.Edge.Data(source, dest, data) => return st\"\"\"n$source -> n$dest ${g(data)}\"\"\"\n        case Graph.Internal.Edge.Plain(source, dest) => return st\"\"\"n$source -> n$dest\"\"\"\n      }\n    }\n    val nodes: ISZ[ST] = for (e <- this.nodes.entries) yield st\"\"\"n${e._2} ${f(e._1)}\"\"\"\n    val edges: ISZ[ST] = for (es <- incomingEdges.values; e <- es.elements) yield e2st(e)\n    val r =\n      st\"\"\"digraph G {\n      |\n      |  ${(attributes, \"\\n\")}\n      |\n      |  ${(nodes, \"\\n\")}\n      |\n      |  ${(edges, \"\\n\")}\n      |\n      |}\"\"\"\n    return r\n\n  }\n\n  @pure override def string: String = {\n    return toST(ISZ(), v => st\"\"\"[label=\"$v\"]\"\"\", e => st\"\"\"[label=\"$e\"]\"\"\").render\n  }\n}\n
  #686 = String             #685          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Graph {\n\n  type Index = Z\n\n  @datatype trait Edge[W, E] {\n    @pure def source: W\n    @pure def dest: W\n    @pure def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E]\n  }\n\n  object Edge {\n\n    @datatype class Plain[W, E](val source: W, val dest: W) extends Edge[W, E] {\n\n      @pure override def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E] = {\n        return Internal.Edge.Plain(map.get(source).get, map.get(dest).get)\n      }\n\n    }\n\n    @datatype class Data[W, E](val source: W, val dest: W, val data: E) extends Edge[W, E] {\n\n      @pure override def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E] = {\n        return Internal.Edge.Data(map.get(source).get, map.get(dest).get, data)\n      }\n\n    }\n\n  }\n\n  object Internal {\n\n    @datatype trait Edge[E] {\n      @pure def source: Graph.Index\n      @pure def dest: Graph.Index\n      @pure def toEdge[W](map: ISZ[W]): Graph.Edge[W, E]\n    }\n\n    @datatype trait Edges[E] {\n      @pure def elements: ISZ[Internal.Edge[E]]\n      @pure def size: Z\n      @pure def +(e: Internal.Edge[E]): Edges[E]\n      @pure def ++(es: ISZ[Internal.Edge[E]]): Edges[E]\n      @pure def -#(p: (Internal.Edge[E], Z)): Edges[E]\n    }\n\n    object Edges {\n\n      @datatype class Set[E](val set: HashSSet[Internal.Edge[E]]) extends Edges[E] {\n\n        @pure override def elements: ISZ[Internal.Edge[E]] = {\n          return set.elements\n        }\n\n        @pure override def size: Z = {\n          return set.size\n        }\n\n        @pure override def +(e: Graph.Internal.Edge[E]): Edges[E] = {\n          return this(set + e)\n        }\n\n        @pure override def ++(es: ISZ[Internal.Edge[E]]): Edges[E] = {\n          return this(set ++ es)\n        }\n\n        @pure override def -#(p: (Internal.Edge[E], Z)): Edges[E] = {\n          return this(set - p._1)\n        }\n      }\n\n      @datatype class Bag[E](val set: HashSBag[Internal.Edge[E]]) extends Edges[E] {\n\n        @pure override def elements: ISZ[Internal.Edge[E]] = {\n          return set.elements\n        }\n\n        @pure override def size: Z = {\n          return set.size\n        }\n\n        @pure override def +(e: Internal.Edge[E]): Edges[E] = {\n          return this(set + e)\n        }\n\n        @pure override def ++(es: ISZ[Internal.Edge[E]]): Edges[E] = {\n          return this(set ++ es)\n        }\n\n        @pure override def -#(p: (Internal.Edge[E], Z)): Edges[E] = {\n          return this(set -# p)\n        }\n      }\n\n      @pure def empty[E](multi: B): Edges[E] = {\n        return if (multi) Bag(HashSBag.empty) else Set(HashSSet.empty)\n      }\n\n    }\n\n    object Edge {\n\n      @datatype class Plain[E](val source: Graph.Index, val dest: Graph.Index) extends Edge[E] {\n\n        @pure override def toEdge[W](map: ISZ[W]): Graph.Edge[W, E] = {\n          return Graph.Edge.Plain(map(source), map(dest))\n        }\n\n      }\n\n      @datatype class Data[E](val source: Graph.Index, val dest: Graph.Index, val data: E) extends Edge[E] {\n\n        @pure override def toEdge[W](map: ISZ[W]): Graph.Edge[W, E] = {\n          return Graph.Edge.Data(map(source), map(dest), data)\n        }\n\n      }\n\n    }\n\n    @pure def addEdge[W, E](g: Graph[W, E], e: Internal.Edge[E]): Graph[W, E] = {\n      return g(\n        incomingEdges = g.incomingEdges + e.dest ~> (g.incomingEdges\n          .get(e.dest)\n          .getOrElse(Edges.empty[E](g.multi)) + e),\n        outgoingEdges = g.outgoingEdges + e.source ~> (g.outgoingEdges\n          .get(e.source)\n          .getOrElse(Edges.empty[E](g.multi)) + e)\n      )\n    }\n\n    @pure def addPlainEdge[W, E](g: Graph[W, E], src: Graph.Index, dst: Graph.Index): Graph[W, E] = {\n      return addEdge(g, Graph.Internal.Edge.Plain[E](src, dst))\n    }\n\n    @pure def addDataEdge[W, E](g: Graph[W, E], data: E, src: Graph.Index, dst: Graph.Index): Graph[W, E] = {\n      return addEdge(g, Graph.Internal.Edge.Data(src, dst, data))\n    }\n\n    @pure def removeEdge[W, E](g: Graph[W, E], e: Graph.Internal.Edge[E], n: Z): Graph[W, E] = {\n      if (g.incomingEdges.get(e.dest).isEmpty) {\n        return g\n      }\n      return g(\n        incomingEdges = g.incomingEdges + e.dest ~> (g.incomingEdges.get(e.dest).get -# e ~> n),\n        outgoingEdges = g.outgoingEdges + e.source ~> (g.outgoingEdges.get(e.source).get -# e ~> n)\n      )\n    }\n\n    @pure def incoming[W, E](g: Graph[W, E], dst: Graph.Index): ISZ[Graph.Internal.Edge[E]] = {\n      g.incomingEdges.get(dst) match {\n        case Some(s) => return s.elements\n        case _ => return ISZ()\n      }\n    }\n\n    @pure def outgoing[W, E](g: Graph[W, E], src: Graph.Index): ISZ[Graph.Internal.Edge[E]] = {\n      g.outgoingEdges.get(src) match {\n        case Some(s) => return s.elements\n        case _ => return ISZ()\n      }\n    }\n\n  }\n\n  @pure def empty[W, E]: Graph[W, E] = {\n    return Graph(HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty, 0, F)\n  }\n\n  @pure def emptyMulti[W, E]: Graph[W, E] = {\n    return Graph(HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty, 0, T)\n  }\n}\n\n@datatype class Graph[W, E](\n  val nodes: HashSMap[W, Graph.Index],\n  val nodesInverse: IS[Graph.Index, W],\n  val incomingEdges: HashSMap[Graph.Index, Graph.Internal.Edges[E]],\n  val outgoingEdges: HashSMap[Graph.Index, Graph.Internal.Edges[E]],\n  val nextNodeId: Graph.Index,\n  val multi: B\n) {\n\n  @pure def *(node: W): Graph[W, E] = {\n    nodes.get(node) match {\n      case Some(_) => return this\n      case _ =>\n        return this(\n          nodes + node ~> nextNodeId,\n          nodesInverse :+ node,\n          incomingEdges,\n          outgoingEdges,\n          nextNodeId + 1,\n          multi\n        )\n    }\n  }\n\n  @pure def --*[I](ns: IS[I, W]): Graph[W, E] = {\n    var r: Graph[W, E] = if (multi) Graph.emptyMulti[W, E] else Graph.empty[W, E]\n    val ins = HashSet ++ ns.map[Z](n => nodes.get(n).get)\n    for (es <- incomingEdges.values) {\n      for (e <- es.elements) {\n        if (ins.contains(e.source) && ins.contains(e.dest)) {\n          r = r.addEdge(e.toEdge(nodesInverse))\n        }\n      }\n    }\n    return r\n  }\n\n  @pure def +(edge: (W, W)): Graph[W, E] = {\n    return addPlainEdge(edge._1, edge._2)\n  }\n\n  @pure def +@(edge: ((W, W), E)): Graph[W, E] = {\n    return addDataEdge(edge._2, edge._1._1, edge._1._2)\n  }\n\n  @pure def -(edge: Graph.Edge[W, E]): Graph[W, E] = {\n    return removeEdgeN(edge, 1)\n  }\n\n  @pure def -#(p: (Graph.Edge[W, E], Z)): Graph[W, E] = {\n    return removeEdgeN(p._1, p._2)\n  }\n\n  @pure def --[I](edges: IS[I, Graph.Edge[W, E]]): Graph[W, E] = {\n    var r = this\n    for (e <- edges) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def incoming(dest: W): ISZ[Graph.Edge[W, E]] = {\n    nodes.get(dest) match {\n      case Some(dst) => return Graph.Internal.incoming(this, dst).map(e => e.toEdge(nodesInverse))\n      case _ => return ISZ()\n    }\n  }\n\n  @pure def outgoing(source: W): ISZ[Graph.Edge[W, E]] = {\n    nodes.get(source) match {\n      case Some(src) => Graph.Internal.outgoing(this, src).map[Graph.Edge[W, E]](e => e.toEdge(nodesInverse))\n      case _ => return ISZ()\n    }\n  }\n\n  @pure def addEdge(edge: Graph.Edge[W, E]): Graph[W, E] = {\n    return Graph.Internal.addEdge(this * edge.source * edge.dest, edge.toInternal(nodes))\n  }\n\n  @pure def addPlainEdge(source: W, dest: W): Graph[W, E] = {\n    val r = this * source * dest\n    return Graph.Internal.addPlainEdge(r, r.nodes.get(source).get, r.nodes.get(dest).get)\n  }\n\n  @pure def addDataEdge(data: E, source: W, dest: W): Graph[W, E] = {\n    val r = this * source * dest\n    return Graph.Internal.addDataEdge(r, data, r.nodes.get(source).get, r.nodes.get(dest).get)\n  }\n\n  @pure def allEdges: ISZ[Graph.Edge[W, E]] = {\n    return for (es <- incomingEdges.values; e <- es.elements) yield e.toEdge(nodesInverse)\n  }\n\n  @pure def removeEdgeN(edge: Graph.Edge[W, E], n: Z): Graph[W, E] = {\n    return Graph.Internal.removeEdge(this, edge.toInternal(nodes), n)\n  }\n\n  @pure def edges(source: W, dest: W): ISZ[Graph.Edge[W, E]] = {\n    return outgoing(source).filter(e => e.dest == dest)\n  }\n\n  @pure def numOfNodes: Z = {\n    return nodes.size\n  }\n\n  @pure def numOfEdges: Z = {\n    var r = z\"0\"\n    for (n <- incomingEdges.values.map[Z](s => s.size)) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure override def hash: Z = {\n    return (numOfNodes, numOfEdges).hash\n  }\n\n  @pure def isEqual(other: Graph[W, E]): B = {\n    if (nodes.size != other.nodes.size || incomingEdges.size != incomingEdges.size) {\n      return F\n    }\n    if (nodes.keySet != other.nodes.keySet) {\n      return F\n    }\n    val thisEdges: ISZ[Graph.Edge[W, E]] =\n      for (ess <- incomingEdges.values; es <- ess.elements) yield es.toEdge(nodesInverse)\n    val otherEdges: ISZ[Graph.Edge[W, E]] =\n      for (ess <- other.incomingEdges.values; es <- ess.elements) yield es.toEdge(other.nodesInverse)\n    return (HashSet ++ thisEdges ++ otherEdges).size == thisEdges.size\n  }\n\n  @pure def toST(attributes: ISZ[ST], f: W => ST @pure, g: E => ST @pure): ST = {\n    @pure def e2st(e: Graph.Internal.Edge[E]): ST = {\n      e match {\n        case Graph.Internal.Edge.Data(source, dest, data) => return st\"\"\"n$source -> n$dest ${g(data)}\"\"\"\n        case Graph.Internal.Edge.Plain(source, dest) => return st\"\"\"n$source -> n$dest\"\"\"\n      }\n    }\n    val nodes: ISZ[ST] = for (e <- this.nodes.entries) yield st\"\"\"n${e._2} ${f(e._1)}\"\"\"\n    val edges: ISZ[ST] = for (es <- incomingEdges.values; e <- es.elements) yield e2st(e)\n    val r =\n      st\"\"\"digraph G {\n      |\n      |  ${(attributes, \"\\n\")}\n      |\n      |  ${(nodes, \"\\n\")}\n      |\n      |  ${(edges, \"\\n\")}\n      |\n      |}\"\"\"\n    return r\n\n  }\n\n  @pure override def string: String = {\n    return toST(ISZ(), v => st\"\"\"[label=\"$v\"]\"\"\", e => st\"\"\"[label=\"$e\"]\"\"\").render\n  }\n}\n
  #687 = Utf8               // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from Project.scala\n\npackage org.sireum.project\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printProject(o: Project): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Project\"\"\"\"),\n        (\"modules\", printHashSMap(F, o.modules, printString _, printModule _)),\n        (\"poset\", printPoset(T, o.poset, printString _)),\n        (\"mavenRepoUrls\", printISZ(T, o.mavenRepoUrls, printString _))\n      ))\n    }\n\n    @pure def printTargetType(o: Target.Type): ST = {\n      val value: String = o match {\n        case Target.Jvm => \"Jvm\"\n        case Target.Js => \"Js\"\n      }\n      return printObject(ISZ(\n        (\"type\", printString(\"Target\")),\n        (\"value\", printString(value))\n      ))\n    }\n\n    @pure def printModule(o: Module): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Module\"\"\"\"),\n        (\"id\", printString(o.id)),\n        (\"basePath\", printString(o.basePath)),\n        (\"subPathOpt\", printOption(T, o.subPathOpt, printString _)),\n        (\"deps\", printISZ(T, o.deps, printString _)),\n        (\"targets\", printISZ(F, o.targets, printTargetType _)),\n        (\"ivyDeps\", printISZ(T, o.ivyDeps, printString _)),\n        (\"sources\", printISZ(T, o.sources, printString _)),\n        (\"resources\", printISZ(T, o.resources, printString _)),\n        (\"testSources\", printISZ(T, o.testSources, printString _)),\n        (\"testResources\", printISZ(T, o.testResources, printString _)),\n        (\"publishInfoOpt\", printOption(F, o.publishInfoOpt, printPublishInfo _))\n      ))\n    }\n\n    @pure def printPublishInfo(o: PublishInfo): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo\"\"\"\"),\n        (\"description\", printString(o.description)),\n        (\"url\", printString(o.url)),\n        (\"licenses\", printISZ(F, o.licenses, printPublishInfoLicense _)),\n        (\"developers\", printISZ(F, o.developers, printPublishInfoDeveloper _))\n      ))\n    }\n\n    @pure def printPublishInfoLicense(o: PublishInfo.License): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo.License\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"url\", printString(o.url)),\n        (\"distribution\", printString(o.distribution))\n      ))\n    }\n\n    @pure def printPublishInfoDeveloper(o: PublishInfo.Developer): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo.Developer\"\"\"\"),\n        (\"id\", printString(o.id)),\n        (\"name\", printString(o.name))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parseProject(): Project = {\n      val r = parseProjectT(F)\n      return r\n    }\n\n    def parseProjectT(typeParsed: B): Project = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Project\")\n      }\n      parser.parseObjectKey(\"modules\")\n      val modules = parser.parseHashSMap(parser.parseString _, parseModule _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"poset\")\n      val poset = parser.parsePoset(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"mavenRepoUrls\")\n      val mavenRepoUrls = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      return Project(modules, poset, mavenRepoUrls)\n    }\n\n    def parseTargetType(): Target.Type = {\n      val r = parseTargetT(F)\n      return r\n    }\n\n    def parseTargetT(typeParsed: B): Target.Type = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Target\")\n      }\n      parser.parseObjectKey(\"value\")\n      var i = parser.offset\n      val s = parser.parseString()\n      parser.parseObjectNext()\n      Target.byName(s) match {\n        case Some(r) => return r\n        case _ =>\n          parser.parseException(i, s\"Invalid element name \'$s\' for Target.\")\n          return Target.byOrdinal(0).get\n      }\n    }\n\n    def parseModule(): Module = {\n      val r = parseModuleT(F)\n      return r\n    }\n\n    def parseModuleT(typeParsed: B): Module = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Module\")\n      }\n      parser.parseObjectKey(\"id\")\n      val id = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"basePath\")\n      val basePath = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"subPathOpt\")\n      val subPathOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"deps\")\n      val deps = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"targets\")\n      val targets = parser.parseISZ(parseTargetType _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"ivyDeps\")\n      val ivyDeps = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"sources\")\n      val sources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"resources\")\n      val resources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"testSources\")\n      val testSources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"testResources\")\n      val testResources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"publishInfoOpt\")\n      val publishInfoOpt = parser.parseOption(parsePublishInfo _)\n      parser.parseObjectNext()\n      return Module(id, basePath, subPathOpt, deps, targets, ivyDeps, sources, resources, testSources, testResources, publishInfoOpt)\n    }\n\n    def parsePublishInfo(): PublishInfo = {\n      val r = parsePublishInfoT(F)\n      return r\n    }\n\n    def parsePublishInfoT(typeParsed: B): PublishInfo = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo\")\n      }\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"url\")\n      val url = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"licenses\")\n      val licenses = parser.parseISZ(parsePublishInfoLicense _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"developers\")\n      val developers = parser.parseISZ(parsePublishInfoDeveloper _)\n      parser.parseObjectNext()\n      return PublishInfo(description, url, licenses, developers)\n    }\n\n    def parsePublishInfoLicense(): PublishInfo.License = {\n      val r = parsePublishInfoLicenseT(F)\n      return r\n    }\n\n    def parsePublishInfoLicenseT(typeParsed: B): PublishInfo.License = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo.License\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"url\")\n      val url = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"distribution\")\n      val distribution = parser.parseString()\n      parser.parseObjectNext()\n      return PublishInfo.License(name, url, distribution)\n    }\n\n    def parsePublishInfoDeveloper(): PublishInfo.Developer = {\n      val r = parsePublishInfoDeveloperT(F)\n      return r\n    }\n\n    def parsePublishInfoDeveloperT(typeParsed: B): PublishInfo.Developer = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo.Developer\")\n      }\n      parser.parseObjectKey(\"id\")\n      val id = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      return PublishInfo.Developer(id, name)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromProject(o: Project, isCompact: B): String = {\n    val st = Printer.printProject(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toProject(s: String): Either[Project, Json.ErrorMsg] = {\n    def fProject(parser: Parser): Project = {\n      val r = parser.parseProject()\n      return r\n    }\n    val r = to(s, fProject _)\n    return r\n  }\n\n  def fromModule(o: Module, isCompact: B): String = {\n    val st = Printer.printModule(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toModule(s: String): Either[Module, Json.ErrorMsg] = {\n    def fModule(parser: Parser): Module = {\n      val r = parser.parseModule()\n      return r\n    }\n    val r = to(s, fModule _)\n    return r\n  }\n\n  def fromPublishInfo(o: PublishInfo, isCompact: B): String = {\n    val st = Printer.printPublishInfo(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfo(s: String): Either[PublishInfo, Json.ErrorMsg] = {\n    def fPublishInfo(parser: Parser): PublishInfo = {\n      val r = parser.parsePublishInfo()\n      return r\n    }\n    val r = to(s, fPublishInfo _)\n    return r\n  }\n\n  def fromPublishInfoLicense(o: PublishInfo.License, isCompact: B): String = {\n    val st = Printer.printPublishInfoLicense(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfoLicense(s: String): Either[PublishInfo.License, Json.ErrorMsg] = {\n    def fPublishInfoLicense(parser: Parser): PublishInfo.License = {\n      val r = parser.parsePublishInfoLicense()\n      return r\n    }\n    val r = to(s, fPublishInfoLicense _)\n    return r\n  }\n\n  def fromPublishInfoDeveloper(o: PublishInfo.Developer, isCompact: B): String = {\n    val st = Printer.printPublishInfoDeveloper(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfoDeveloper(s: String): Either[PublishInfo.Developer, Json.ErrorMsg] = {\n    def fPublishInfoDeveloper(parser: Parser): PublishInfo.Developer = {\n      val r = parser.parsePublishInfoDeveloper()\n      return r\n    }\n    val r = to(s, fPublishInfoDeveloper _)\n    return r\n  }\n\n}
  #688 = String             #687          // // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from Project.scala\n\npackage org.sireum.project\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printProject(o: Project): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Project\"\"\"\"),\n        (\"modules\", printHashSMap(F, o.modules, printString _, printModule _)),\n        (\"poset\", printPoset(T, o.poset, printString _)),\n        (\"mavenRepoUrls\", printISZ(T, o.mavenRepoUrls, printString _))\n      ))\n    }\n\n    @pure def printTargetType(o: Target.Type): ST = {\n      val value: String = o match {\n        case Target.Jvm => \"Jvm\"\n        case Target.Js => \"Js\"\n      }\n      return printObject(ISZ(\n        (\"type\", printString(\"Target\")),\n        (\"value\", printString(value))\n      ))\n    }\n\n    @pure def printModule(o: Module): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Module\"\"\"\"),\n        (\"id\", printString(o.id)),\n        (\"basePath\", printString(o.basePath)),\n        (\"subPathOpt\", printOption(T, o.subPathOpt, printString _)),\n        (\"deps\", printISZ(T, o.deps, printString _)),\n        (\"targets\", printISZ(F, o.targets, printTargetType _)),\n        (\"ivyDeps\", printISZ(T, o.ivyDeps, printString _)),\n        (\"sources\", printISZ(T, o.sources, printString _)),\n        (\"resources\", printISZ(T, o.resources, printString _)),\n        (\"testSources\", printISZ(T, o.testSources, printString _)),\n        (\"testResources\", printISZ(T, o.testResources, printString _)),\n        (\"publishInfoOpt\", printOption(F, o.publishInfoOpt, printPublishInfo _))\n      ))\n    }\n\n    @pure def printPublishInfo(o: PublishInfo): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo\"\"\"\"),\n        (\"description\", printString(o.description)),\n        (\"url\", printString(o.url)),\n        (\"licenses\", printISZ(F, o.licenses, printPublishInfoLicense _)),\n        (\"developers\", printISZ(F, o.developers, printPublishInfoDeveloper _))\n      ))\n    }\n\n    @pure def printPublishInfoLicense(o: PublishInfo.License): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo.License\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"url\", printString(o.url)),\n        (\"distribution\", printString(o.distribution))\n      ))\n    }\n\n    @pure def printPublishInfoDeveloper(o: PublishInfo.Developer): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo.Developer\"\"\"\"),\n        (\"id\", printString(o.id)),\n        (\"name\", printString(o.name))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parseProject(): Project = {\n      val r = parseProjectT(F)\n      return r\n    }\n\n    def parseProjectT(typeParsed: B): Project = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Project\")\n      }\n      parser.parseObjectKey(\"modules\")\n      val modules = parser.parseHashSMap(parser.parseString _, parseModule _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"poset\")\n      val poset = parser.parsePoset(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"mavenRepoUrls\")\n      val mavenRepoUrls = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      return Project(modules, poset, mavenRepoUrls)\n    }\n\n    def parseTargetType(): Target.Type = {\n      val r = parseTargetT(F)\n      return r\n    }\n\n    def parseTargetT(typeParsed: B): Target.Type = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Target\")\n      }\n      parser.parseObjectKey(\"value\")\n      var i = parser.offset\n      val s = parser.parseString()\n      parser.parseObjectNext()\n      Target.byName(s) match {\n        case Some(r) => return r\n        case _ =>\n          parser.parseException(i, s\"Invalid element name \'$s\' for Target.\")\n          return Target.byOrdinal(0).get\n      }\n    }\n\n    def parseModule(): Module = {\n      val r = parseModuleT(F)\n      return r\n    }\n\n    def parseModuleT(typeParsed: B): Module = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Module\")\n      }\n      parser.parseObjectKey(\"id\")\n      val id = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"basePath\")\n      val basePath = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"subPathOpt\")\n      val subPathOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"deps\")\n      val deps = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"targets\")\n      val targets = parser.parseISZ(parseTargetType _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"ivyDeps\")\n      val ivyDeps = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"sources\")\n      val sources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"resources\")\n      val resources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"testSources\")\n      val testSources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"testResources\")\n      val testResources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"publishInfoOpt\")\n      val publishInfoOpt = parser.parseOption(parsePublishInfo _)\n      parser.parseObjectNext()\n      return Module(id, basePath, subPathOpt, deps, targets, ivyDeps, sources, resources, testSources, testResources, publishInfoOpt)\n    }\n\n    def parsePublishInfo(): PublishInfo = {\n      val r = parsePublishInfoT(F)\n      return r\n    }\n\n    def parsePublishInfoT(typeParsed: B): PublishInfo = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo\")\n      }\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"url\")\n      val url = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"licenses\")\n      val licenses = parser.parseISZ(parsePublishInfoLicense _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"developers\")\n      val developers = parser.parseISZ(parsePublishInfoDeveloper _)\n      parser.parseObjectNext()\n      return PublishInfo(description, url, licenses, developers)\n    }\n\n    def parsePublishInfoLicense(): PublishInfo.License = {\n      val r = parsePublishInfoLicenseT(F)\n      return r\n    }\n\n    def parsePublishInfoLicenseT(typeParsed: B): PublishInfo.License = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo.License\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"url\")\n      val url = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"distribution\")\n      val distribution = parser.parseString()\n      parser.parseObjectNext()\n      return PublishInfo.License(name, url, distribution)\n    }\n\n    def parsePublishInfoDeveloper(): PublishInfo.Developer = {\n      val r = parsePublishInfoDeveloperT(F)\n      return r\n    }\n\n    def parsePublishInfoDeveloperT(typeParsed: B): PublishInfo.Developer = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo.Developer\")\n      }\n      parser.parseObjectKey(\"id\")\n      val id = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      return PublishInfo.Developer(id, name)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromProject(o: Project, isCompact: B): String = {\n    val st = Printer.printProject(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toProject(s: String): Either[Project, Json.ErrorMsg] = {\n    def fProject(parser: Parser): Project = {\n      val r = parser.parseProject()\n      return r\n    }\n    val r = to(s, fProject _)\n    return r\n  }\n\n  def fromModule(o: Module, isCompact: B): String = {\n    val st = Printer.printModule(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toModule(s: String): Either[Module, Json.ErrorMsg] = {\n    def fModule(parser: Parser): Module = {\n      val r = parser.parseModule()\n      return r\n    }\n    val r = to(s, fModule _)\n    return r\n  }\n\n  def fromPublishInfo(o: PublishInfo, isCompact: B): String = {\n    val st = Printer.printPublishInfo(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfo(s: String): Either[PublishInfo, Json.ErrorMsg] = {\n    def fPublishInfo(parser: Parser): PublishInfo = {\n      val r = parser.parsePublishInfo()\n      return r\n    }\n    val r = to(s, fPublishInfo _)\n    return r\n  }\n\n  def fromPublishInfoLicense(o: PublishInfo.License, isCompact: B): String = {\n    val st = Printer.printPublishInfoLicense(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfoLicense(s: String): Either[PublishInfo.License, Json.ErrorMsg] = {\n    def fPublishInfoLicense(parser: Parser): PublishInfo.License = {\n      val r = parser.parsePublishInfoLicense()\n      return r\n    }\n    val r = to(s, fPublishInfoLicense _)\n    return r\n  }\n\n  def fromPublishInfoDeveloper(o: PublishInfo.Developer, isCompact: B): String = {\n    val st = Printer.printPublishInfoDeveloper(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfoDeveloper(s: String): Either[PublishInfo.Developer, Json.ErrorMsg] = {\n    def fPublishInfoDeveloper(parser: Parser): PublishInfo.Developer = {\n      val r = parser.parsePublishInfoDeveloper()\n      return r\n    }\n    val r = to(s, fPublishInfoDeveloper _)\n    return r\n  }\n\n}
  #689 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\npackage org.sireum.project\n\nimport org.sireum._\n\nobject Project {\n  @strictpure def empty: Project = Project(HashSMap.empty, Poset.empty, ISZ())\n}\n\n@datatype class Project(val modules: HashSMap[String, Module],\n                        val poset: Poset[String],\n                        val mavenRepoUrls: ISZ[String]) {\n\n  @strictpure def +(module: Module): Project = Project(\n    modules = modules + module.id ~> module,\n    poset = poset.addParents(module.id, module.deps),\n    mavenRepoUrls = mavenRepoUrls\n  )\n\n  @strictpure def addMavenRepository(url: String): Project = Project(\n    modules = modules, poset = poset, mavenRepoUrls = mavenRepoUrls :+ url\n  )\n\n  @strictpure def addMavenRepositories(urls: ISZ[String]): Project = Project(\n    modules = modules, poset = poset, mavenRepoUrls = mavenRepoUrls ++ urls\n  )\n\n  @strictpure override def hash: Z = modules.hash\n\n  @strictpure def isEqual(other: Project): B = modules == other.modules\n\n  @strictpure def <=(other: Project): B = modules == (other.modules -- (other.modules.keys -- modules.keys))\n\n  @strictpure def >=(other: Project): B = (modules -- (modules.keys -- other.modules.keys)) == other.modules\n\n  @pure def ++(other: Project): Project = {\n    var r = this\n    var names = other.poset.rootNodes\n    while (names.nonEmpty) {\n      var newNames = HashSSet.empty[String]\n      for (name <- names) {\n        other.modules.get(name) match {\n          case Some(m) => r = r + m\n          case _ =>\n        }\n        newNames = newNames.union(other.poset.childrenOf(name))\n      }\n      names = newNames.elements\n    }\n    r = r(mavenRepoUrls = (HashSSet ++ r.mavenRepoUrls ++ other.mavenRepoUrls).elements)\n    return r\n  }\n\n  @pure def stripPubInfo: Project = {\n    var r = Project.empty\n    for (m <- modules.values) {\n      r = r + m(publishInfoOpt = None())\n    }\n    return r\n  }\n\n  @pure def slice(mids: ISZ[String]): Project = {\n    if (mids.isEmpty) {\n      return this\n    }\n    var tmids = HashSet.empty[String]\n    def rec(mid: String): Unit = {\n      tmids = tmids + mid\n      modules.get(mid) match {\n        case Some(m) =>\n          for (mDep <- m.deps) {\n            rec(mDep)\n          }\n        case _ =>\n      }\n    }\n    for (mid <- mids) {\n      rec(mid)\n    }\n    var r = Project.empty\n    for (p <- modules.entries if tmids.contains(p._1)) {\n      r = r + p._2\n    }\n    return r\n  }\n\n  @pure def openDeps: Map[String, ISZ[String]] = {\n    val mids = modules.keys\n    var r = Map.empty[String, ISZ[String]]\n    for (m <- modules.values) {\n      val diff = m.deps -- mids\n      if (diff.nonEmpty) {\n        r = r + m.id ~> diff\n      }\n    }\n    return r\n  }\n\n  @pure def illTargets: Map[String, Map[String, ISZ[Target.Type]]] = {\n    var r = Map.empty[String, Map[String, ISZ[Target.Type]]]\n    for (m <- modules.values) {\n      var map = Map.empty[String, ISZ[Target.Type]]\n      for (mDep <- m.deps) {\n        modules.get(mDep) match {\n          case Some(m2) =>\n            val diff = m.targets -- m2.targets\n            if (diff.nonEmpty) {\n              map = map + m2.id ~> diff\n            }\n          case _ =>\n        }\n      }\n      if (map.nonEmpty) {\n        r = r + m.id ~> map\n      }\n    }\n    return r\n  }\n\n}\n\n@enum object Target {\n  \"Jvm\"\n  \"Js\"\n}\n\n@datatype class Module(val id: String,\n                       val basePath: String,\n                       val subPathOpt: Option[String],\n                       val deps: ISZ[String],\n                       val targets: ISZ[Target.Type],\n                       val ivyDeps: ISZ[String],\n                       val sources: ISZ[String],\n                       val resources: ISZ[String],\n                       val testSources: ISZ[String],\n                       val testResources: ISZ[String],\n                       val publishInfoOpt: Option[PublishInfo]) {\n\n  @strictpure def hasTarget(target: Target.Type): B = ops.ISZOps(targets).contains(target)\n\n}\n\nobject Module {\n  val allTargets: ISZ[Target.Type] = ISZ(Target.Jvm, Target.Js)\n}\n\n@datatype class PublishInfo(val description: String,\n                            val url: String,\n                            val licenses: ISZ[PublishInfo.License],\n                            val developers: ISZ[PublishInfo.Developer])\n\nobject PublishInfo {\n\n  @datatype class License(val name: String,\n                          val url: String,\n                          val distribution: String)\n\n  @datatype class Developer(val id: String,\n                            val name: String)\n\n}\n
  #690 = String             #689          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\npackage org.sireum.project\n\nimport org.sireum._\n\nobject Project {\n  @strictpure def empty: Project = Project(HashSMap.empty, Poset.empty, ISZ())\n}\n\n@datatype class Project(val modules: HashSMap[String, Module],\n                        val poset: Poset[String],\n                        val mavenRepoUrls: ISZ[String]) {\n\n  @strictpure def +(module: Module): Project = Project(\n    modules = modules + module.id ~> module,\n    poset = poset.addParents(module.id, module.deps),\n    mavenRepoUrls = mavenRepoUrls\n  )\n\n  @strictpure def addMavenRepository(url: String): Project = Project(\n    modules = modules, poset = poset, mavenRepoUrls = mavenRepoUrls :+ url\n  )\n\n  @strictpure def addMavenRepositories(urls: ISZ[String]): Project = Project(\n    modules = modules, poset = poset, mavenRepoUrls = mavenRepoUrls ++ urls\n  )\n\n  @strictpure override def hash: Z = modules.hash\n\n  @strictpure def isEqual(other: Project): B = modules == other.modules\n\n  @strictpure def <=(other: Project): B = modules == (other.modules -- (other.modules.keys -- modules.keys))\n\n  @strictpure def >=(other: Project): B = (modules -- (modules.keys -- other.modules.keys)) == other.modules\n\n  @pure def ++(other: Project): Project = {\n    var r = this\n    var names = other.poset.rootNodes\n    while (names.nonEmpty) {\n      var newNames = HashSSet.empty[String]\n      for (name <- names) {\n        other.modules.get(name) match {\n          case Some(m) => r = r + m\n          case _ =>\n        }\n        newNames = newNames.union(other.poset.childrenOf(name))\n      }\n      names = newNames.elements\n    }\n    r = r(mavenRepoUrls = (HashSSet ++ r.mavenRepoUrls ++ other.mavenRepoUrls).elements)\n    return r\n  }\n\n  @pure def stripPubInfo: Project = {\n    var r = Project.empty\n    for (m <- modules.values) {\n      r = r + m(publishInfoOpt = None())\n    }\n    return r\n  }\n\n  @pure def slice(mids: ISZ[String]): Project = {\n    if (mids.isEmpty) {\n      return this\n    }\n    var tmids = HashSet.empty[String]\n    def rec(mid: String): Unit = {\n      tmids = tmids + mid\n      modules.get(mid) match {\n        case Some(m) =>\n          for (mDep <- m.deps) {\n            rec(mDep)\n          }\n        case _ =>\n      }\n    }\n    for (mid <- mids) {\n      rec(mid)\n    }\n    var r = Project.empty\n    for (p <- modules.entries if tmids.contains(p._1)) {\n      r = r + p._2\n    }\n    return r\n  }\n\n  @pure def openDeps: Map[String, ISZ[String]] = {\n    val mids = modules.keys\n    var r = Map.empty[String, ISZ[String]]\n    for (m <- modules.values) {\n      val diff = m.deps -- mids\n      if (diff.nonEmpty) {\n        r = r + m.id ~> diff\n      }\n    }\n    return r\n  }\n\n  @pure def illTargets: Map[String, Map[String, ISZ[Target.Type]]] = {\n    var r = Map.empty[String, Map[String, ISZ[Target.Type]]]\n    for (m <- modules.values) {\n      var map = Map.empty[String, ISZ[Target.Type]]\n      for (mDep <- m.deps) {\n        modules.get(mDep) match {\n          case Some(m2) =>\n            val diff = m.targets -- m2.targets\n            if (diff.nonEmpty) {\n              map = map + m2.id ~> diff\n            }\n          case _ =>\n        }\n      }\n      if (map.nonEmpty) {\n        r = r + m.id ~> map\n      }\n    }\n    return r\n  }\n\n}\n\n@enum object Target {\n  \"Jvm\"\n  \"Js\"\n}\n\n@datatype class Module(val id: String,\n                       val basePath: String,\n                       val subPathOpt: Option[String],\n                       val deps: ISZ[String],\n                       val targets: ISZ[Target.Type],\n                       val ivyDeps: ISZ[String],\n                       val sources: ISZ[String],\n                       val resources: ISZ[String],\n                       val testSources: ISZ[String],\n                       val testResources: ISZ[String],\n                       val publishInfoOpt: Option[PublishInfo]) {\n\n  @strictpure def hasTarget(target: Target.Type): B = ops.ISZOps(targets).contains(target)\n\n}\n\nobject Module {\n  val allTargets: ISZ[Target.Type] = ISZ(Target.Jvm, Target.Js)\n}\n\n@datatype class PublishInfo(val description: String,\n                            val url: String,\n                            val licenses: ISZ[PublishInfo.License],\n                            val developers: ISZ[PublishInfo.Developer])\n\nobject PublishInfo {\n\n  @datatype class License(val name: String,\n                          val url: String,\n                          val distribution: String)\n\n  @datatype class Developer(val id: String,\n                            val name: String)\n\n}\n
  #691 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject Bag {\n\n  @pure def empty[T]: Bag[T] = {\n    return Bag(Map.empty[T, Z])\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): Bag[T] = {\n    return Bag.empty[T] ++ s\n  }\n\n}\n\n@datatype class Bag[T](val map: Map[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): Bag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def addN(e: T, n: Z): Bag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def +#(p: (T, Z)): Bag[T] = {\n    val (e, n) = p\n    return addN(e, n)\n  }\n\n  @pure def ++[I](es: IS[I, T]): Bag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): Bag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](es: IS[I, T]): Bag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def \\(other: Bag[T]): Bag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def -#(p: (T, Z)): Bag[T] = {\n    val (e, n) = p\n    return removeN(e, n)\n  }\n\n  @pure def removeN(e: T, n: Z): Bag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: Bag[T]): Bag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: Bag[T]): Bag[T] = {\n    var r = this\n    for (e <- other.entries) {\n      r = r +# e._1 ~> e._2\n    }\n    return r\n  }\n\n  @pure def intersect(other: Bag[T]): Bag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: Bag[T]): Bag[T] = {\n    var r = Bag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r +# e._1 ~> n\n      } else {\n        r = r +# e._1 ~> m\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
  #692 = String             #691          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject Bag {\n\n  @pure def empty[T]: Bag[T] = {\n    return Bag(Map.empty[T, Z])\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): Bag[T] = {\n    return Bag.empty[T] ++ s\n  }\n\n}\n\n@datatype class Bag[T](val map: Map[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): Bag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def addN(e: T, n: Z): Bag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def +#(p: (T, Z)): Bag[T] = {\n    val (e, n) = p\n    return addN(e, n)\n  }\n\n  @pure def ++[I](es: IS[I, T]): Bag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): Bag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](es: IS[I, T]): Bag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def \\(other: Bag[T]): Bag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def -#(p: (T, Z)): Bag[T] = {\n    val (e, n) = p\n    return removeN(e, n)\n  }\n\n  @pure def removeN(e: T, n: Z): Bag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: Bag[T]): Bag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: Bag[T]): Bag[T] = {\n    var r = this\n    for (e <- other.entries) {\n      r = r +# e._1 ~> e._2\n    }\n    return r\n  }\n\n  @pure def intersect(other: Bag[T]): Bag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: Bag[T]): Bag[T] = {\n    var r = Bag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r +# e._1 ~> n\n      } else {\n        r = r +# e._1 ~> m\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
  #693 = Utf8               // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from Presentation.scala\n\npackage org.sireum.presentasi\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printPresentationEntry(o: Presentation.Entry): ST = {\n      o match {\n        case o: Presentation.SlideEntry => return printPresentationSlideEntry(o)\n        case o: Presentation.VideoEntry => return printPresentationVideoEntry(o)\n      }\n    }\n\n    @pure def printPresentationSlideEntry(o: Presentation.SlideEntry): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation.SlideEntry\"\"\"\"),\n        (\"path\", printString(o.path)),\n        (\"delay\", printZ(o.delay)),\n        (\"text\", printString(o.text))\n      ))\n    }\n\n    @pure def printPresentationVideoEntry(o: Presentation.VideoEntry): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation.VideoEntry\"\"\"\"),\n        (\"path\", printString(o.path)),\n        (\"delay\", printZ(o.delay)),\n        (\"volume\", printF64(o.volume)),\n        (\"rate\", printF64(o.rate)),\n        (\"start\", printF64(o.start)),\n        (\"end\", printF64(o.end)),\n        (\"useVideoDuration\", printB(o.useVideoDuration)),\n        (\"textOpt\", printOption(T, o.textOpt, printString _))\n      ))\n    }\n\n    @pure def printPresentation(o: Presentation): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"args\", printISZ(T, o.args, printString _)),\n        (\"delay\", printZ(o.delay)),\n        (\"vseekDelay\", printZ(o.vseekDelay)),\n        (\"textVolume\", printF64(o.textVolume)),\n        (\"trailing\", printZ(o.trailing)),\n        (\"granularity\", printZ(o.granularity)),\n        (\"entries\", printISZ(F, o.entries, printPresentationEntry _))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parsePresentationEntry(): Presentation.Entry = {\n      val t = parser.parseObjectTypes(ISZ(\"Presentation.SlideEntry\", \"Presentation.VideoEntry\"))\n      t.native match {\n        case \"Presentation.SlideEntry\" => val r = parsePresentationSlideEntryT(T); return r\n        case \"Presentation.VideoEntry\" => val r = parsePresentationVideoEntryT(T); return r\n        case _ => val r = parsePresentationVideoEntryT(T); return r\n      }\n    }\n\n    def parsePresentationSlideEntry(): Presentation.SlideEntry = {\n      val r = parsePresentationSlideEntryT(F)\n      return r\n    }\n\n    def parsePresentationSlideEntryT(typeParsed: B): Presentation.SlideEntry = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation.SlideEntry\")\n      }\n      parser.parseObjectKey(\"path\")\n      val path = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"text\")\n      val text = parser.parseString()\n      parser.parseObjectNext()\n      return Presentation.SlideEntry(path, delay, text)\n    }\n\n    def parsePresentationVideoEntry(): Presentation.VideoEntry = {\n      val r = parsePresentationVideoEntryT(F)\n      return r\n    }\n\n    def parsePresentationVideoEntryT(typeParsed: B): Presentation.VideoEntry = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation.VideoEntry\")\n      }\n      parser.parseObjectKey(\"path\")\n      val path = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"volume\")\n      val volume = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"rate\")\n      val rate = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"start\")\n      val start = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"end\")\n      val end = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"useVideoDuration\")\n      val useVideoDuration = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"textOpt\")\n      val textOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return Presentation.VideoEntry(path, delay, volume, rate, start, end, useVideoDuration, textOpt)\n    }\n\n    def parsePresentation(): Presentation = {\n      val r = parsePresentationT(F)\n      return r\n    }\n\n    def parsePresentationT(typeParsed: B): Presentation = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"args\")\n      val args = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"vseekDelay\")\n      val vseekDelay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"textVolume\")\n      val textVolume = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"trailing\")\n      val trailing = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"granularity\")\n      val granularity = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"entries\")\n      val entries = parser.parseISZ(parsePresentationEntry _)\n      parser.parseObjectNext()\n      return Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromPresentationEntry(o: Presentation.Entry, isCompact: B): String = {\n    val st = Printer.printPresentationEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationEntry(s: String): Either[Presentation.Entry, Json.ErrorMsg] = {\n    def fPresentationEntry(parser: Parser): Presentation.Entry = {\n      val r = parser.parsePresentationEntry()\n      return r\n    }\n    val r = to(s, fPresentationEntry _)\n    return r\n  }\n\n  def fromPresentationSlideEntry(o: Presentation.SlideEntry, isCompact: B): String = {\n    val st = Printer.printPresentationSlideEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationSlideEntry(s: String): Either[Presentation.SlideEntry, Json.ErrorMsg] = {\n    def fPresentationSlideEntry(parser: Parser): Presentation.SlideEntry = {\n      val r = parser.parsePresentationSlideEntry()\n      return r\n    }\n    val r = to(s, fPresentationSlideEntry _)\n    return r\n  }\n\n  def fromPresentationVideoEntry(o: Presentation.VideoEntry, isCompact: B): String = {\n    val st = Printer.printPresentationVideoEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationVideoEntry(s: String): Either[Presentation.VideoEntry, Json.ErrorMsg] = {\n    def fPresentationVideoEntry(parser: Parser): Presentation.VideoEntry = {\n      val r = parser.parsePresentationVideoEntry()\n      return r\n    }\n    val r = to(s, fPresentationVideoEntry _)\n    return r\n  }\n\n  def fromPresentation(o: Presentation, isCompact: B): String = {\n    val st = Printer.printPresentation(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentation(s: String): Either[Presentation, Json.ErrorMsg] = {\n    def fPresentation(parser: Parser): Presentation = {\n      val r = parser.parsePresentation()\n      return r\n    }\n    val r = to(s, fPresentation _)\n    return r\n  }\n\n}
  #694 = String             #693          // // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from Presentation.scala\n\npackage org.sireum.presentasi\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printPresentationEntry(o: Presentation.Entry): ST = {\n      o match {\n        case o: Presentation.SlideEntry => return printPresentationSlideEntry(o)\n        case o: Presentation.VideoEntry => return printPresentationVideoEntry(o)\n      }\n    }\n\n    @pure def printPresentationSlideEntry(o: Presentation.SlideEntry): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation.SlideEntry\"\"\"\"),\n        (\"path\", printString(o.path)),\n        (\"delay\", printZ(o.delay)),\n        (\"text\", printString(o.text))\n      ))\n    }\n\n    @pure def printPresentationVideoEntry(o: Presentation.VideoEntry): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation.VideoEntry\"\"\"\"),\n        (\"path\", printString(o.path)),\n        (\"delay\", printZ(o.delay)),\n        (\"volume\", printF64(o.volume)),\n        (\"rate\", printF64(o.rate)),\n        (\"start\", printF64(o.start)),\n        (\"end\", printF64(o.end)),\n        (\"useVideoDuration\", printB(o.useVideoDuration)),\n        (\"textOpt\", printOption(T, o.textOpt, printString _))\n      ))\n    }\n\n    @pure def printPresentation(o: Presentation): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"args\", printISZ(T, o.args, printString _)),\n        (\"delay\", printZ(o.delay)),\n        (\"vseekDelay\", printZ(o.vseekDelay)),\n        (\"textVolume\", printF64(o.textVolume)),\n        (\"trailing\", printZ(o.trailing)),\n        (\"granularity\", printZ(o.granularity)),\n        (\"entries\", printISZ(F, o.entries, printPresentationEntry _))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parsePresentationEntry(): Presentation.Entry = {\n      val t = parser.parseObjectTypes(ISZ(\"Presentation.SlideEntry\", \"Presentation.VideoEntry\"))\n      t.native match {\n        case \"Presentation.SlideEntry\" => val r = parsePresentationSlideEntryT(T); return r\n        case \"Presentation.VideoEntry\" => val r = parsePresentationVideoEntryT(T); return r\n        case _ => val r = parsePresentationVideoEntryT(T); return r\n      }\n    }\n\n    def parsePresentationSlideEntry(): Presentation.SlideEntry = {\n      val r = parsePresentationSlideEntryT(F)\n      return r\n    }\n\n    def parsePresentationSlideEntryT(typeParsed: B): Presentation.SlideEntry = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation.SlideEntry\")\n      }\n      parser.parseObjectKey(\"path\")\n      val path = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"text\")\n      val text = parser.parseString()\n      parser.parseObjectNext()\n      return Presentation.SlideEntry(path, delay, text)\n    }\n\n    def parsePresentationVideoEntry(): Presentation.VideoEntry = {\n      val r = parsePresentationVideoEntryT(F)\n      return r\n    }\n\n    def parsePresentationVideoEntryT(typeParsed: B): Presentation.VideoEntry = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation.VideoEntry\")\n      }\n      parser.parseObjectKey(\"path\")\n      val path = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"volume\")\n      val volume = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"rate\")\n      val rate = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"start\")\n      val start = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"end\")\n      val end = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"useVideoDuration\")\n      val useVideoDuration = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"textOpt\")\n      val textOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return Presentation.VideoEntry(path, delay, volume, rate, start, end, useVideoDuration, textOpt)\n    }\n\n    def parsePresentation(): Presentation = {\n      val r = parsePresentationT(F)\n      return r\n    }\n\n    def parsePresentationT(typeParsed: B): Presentation = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"args\")\n      val args = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"vseekDelay\")\n      val vseekDelay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"textVolume\")\n      val textVolume = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"trailing\")\n      val trailing = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"granularity\")\n      val granularity = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"entries\")\n      val entries = parser.parseISZ(parsePresentationEntry _)\n      parser.parseObjectNext()\n      return Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromPresentationEntry(o: Presentation.Entry, isCompact: B): String = {\n    val st = Printer.printPresentationEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationEntry(s: String): Either[Presentation.Entry, Json.ErrorMsg] = {\n    def fPresentationEntry(parser: Parser): Presentation.Entry = {\n      val r = parser.parsePresentationEntry()\n      return r\n    }\n    val r = to(s, fPresentationEntry _)\n    return r\n  }\n\n  def fromPresentationSlideEntry(o: Presentation.SlideEntry, isCompact: B): String = {\n    val st = Printer.printPresentationSlideEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationSlideEntry(s: String): Either[Presentation.SlideEntry, Json.ErrorMsg] = {\n    def fPresentationSlideEntry(parser: Parser): Presentation.SlideEntry = {\n      val r = parser.parsePresentationSlideEntry()\n      return r\n    }\n    val r = to(s, fPresentationSlideEntry _)\n    return r\n  }\n\n  def fromPresentationVideoEntry(o: Presentation.VideoEntry, isCompact: B): String = {\n    val st = Printer.printPresentationVideoEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationVideoEntry(s: String): Either[Presentation.VideoEntry, Json.ErrorMsg] = {\n    def fPresentationVideoEntry(parser: Parser): Presentation.VideoEntry = {\n      val r = parser.parsePresentationVideoEntry()\n      return r\n    }\n    val r = to(s, fPresentationVideoEntry _)\n    return r\n  }\n\n  def fromPresentation(o: Presentation, isCompact: B): String = {\n    val st = Printer.printPresentation(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentation(s: String): Either[Presentation, Json.ErrorMsg] = {\n    def fPresentation(parser: Parser): Presentation = {\n      val r = parser.parsePresentation()\n      return r\n    }\n    val r = to(s, fPresentation _)\n    return r\n  }\n\n}
  #695 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.presentasi\n\nimport org.sireum._\n\nobject Presentation {\n\n  @datatype trait Entry {\n    @pure def path: String\n    @pure def delay: Z\n  }\n\n  @datatype class SlideEntry(val path: String,\n                             val delay: Z,\n                             val text: String) extends Entry\n\n  @datatype class VideoEntry(val path: String,\n                             val delay: Z,\n                             val volume: F64,\n                             val rate: F64,\n                             val start: F64,\n                             val end: F64,\n                             val useVideoDuration: B,\n                             val textOpt: Option[String]) extends Entry\n\n  type Slide = SlideEntry\n  type Video = VideoEntry\n\n  val empty: Presentation = Presentation(\"Presentasi\", ISZ(), 2000, 250, 1.0, 2000, 1, ISZ())\n\n  val Slide: Slide = SlideEntry(\"\", 0, \"\")\n\n  val Video: Video = VideoEntry(\"\", 0, 1.0, 1.0, 0.0, 0.0, F, None())\n\n}\n\n@datatype class Presentation(val name: String,\n                             val args: ISZ[String],\n                             val delay: Z,\n                             val vseekDelay: Z,\n                             val textVolume: F64,\n                             val trailing: Z,\n                             val granularity: Z,\n                             val entries: ISZ[Presentation.Entry]) {\n\n  @strictpure def +(entry: Presentation.Entry): Presentation =\n    Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries :+ entry)\n\n  @strictpure def ++(es: ISZ[Presentation.Entry]): Presentation =\n    Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries ++ es)\n\n  def cli(args: ISZ[String]): Unit = {\n    val thisL = this\n    println(JSON.fromPresentation(thisL(args = args), T))\n  }\n\n}\n
  #696 = String             #695          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.presentasi\n\nimport org.sireum._\n\nobject Presentation {\n\n  @datatype trait Entry {\n    @pure def path: String\n    @pure def delay: Z\n  }\n\n  @datatype class SlideEntry(val path: String,\n                             val delay: Z,\n                             val text: String) extends Entry\n\n  @datatype class VideoEntry(val path: String,\n                             val delay: Z,\n                             val volume: F64,\n                             val rate: F64,\n                             val start: F64,\n                             val end: F64,\n                             val useVideoDuration: B,\n                             val textOpt: Option[String]) extends Entry\n\n  type Slide = SlideEntry\n  type Video = VideoEntry\n\n  val empty: Presentation = Presentation(\"Presentasi\", ISZ(), 2000, 250, 1.0, 2000, 1, ISZ())\n\n  val Slide: Slide = SlideEntry(\"\", 0, \"\")\n\n  val Video: Video = VideoEntry(\"\", 0, 1.0, 1.0, 0.0, 0.0, F, None())\n\n}\n\n@datatype class Presentation(val name: String,\n                             val args: ISZ[String],\n                             val delay: Z,\n                             val vseekDelay: Z,\n                             val textVolume: F64,\n                             val trailing: Z,\n                             val granularity: Z,\n                             val entries: ISZ[Presentation.Entry]) {\n\n  @strictpure def +(entry: Presentation.Entry): Presentation =\n    Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries :+ entry)\n\n  @strictpure def ++(es: ISZ[Presentation.Entry]): Presentation =\n    Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries ++ es)\n\n  def cli(args: ISZ[String]): Unit = {\n    val thisL = this\n    println(JSON.fromPresentation(thisL(args = args), T))\n  }\n\n}\n
  #697 = Utf8               // #Sireum\n/*\nAdapted from: https://github.com/msgpack4z/msgpack4z-native with the following license:\n\nCopyright (c) 2015 msgpack4z-core contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\npackage org.sireum\n\nimport U8._\nimport U16._\nimport U32._\nimport U64._\nimport S8._\nimport S16._\nimport S32._\nimport S64._\n\nobject MessagePack {\n\n  @enum object Kind {\n    \"NIL\"\n    \"BOOLEAN\"\n    \"INTEGER\"\n    \"FLOAT\"\n    \"STRING\"\n    \"ARRAY\"\n    \"MAP\"\n    \"BINARY\"\n    \"EXTENSION\"\n    \"NONE\"\n  }\n\n  val TimestampExtType: S8 = s8\"-1\"\n  val StringPoolExtType: S8 = s8\"0\"\n  val DocInfoExtType: S8 = s8\"1\"\n  val LastExtType: S8 = DocInfoExtType\n\n  object Code {\n    val POSFIXINT_MASK: U8 = u8\"0x80\"\n    val FIXMAP_PREFIX: U8 = u8\"0x80\"\n    val FIXARRAY_PREFIX: U8 = u8\"0x90\"\n    val FIXSTR_PREFIX: U8 = u8\"0xA0\"\n    val NIL: U8 = u8\"0xC0\"\n    val FALSE: U8 = u8\"0xC2\"\n    val TRUE: U8 = u8\"0xC3\"\n    val BIN8: U8 = u8\"0xC4\"\n    val BIN16: U8 = u8\"0xC5\"\n    val BIN32: U8 = u8\"0xC6\"\n    val EXT8: U8 = u8\"0xC7\"\n    val EXT16: U8 = u8\"0xC8\"\n    val EXT32: U8 = u8\"0xC9\"\n    val FLOAT32: U8 = u8\"0xCA\"\n    val FLOAT64: U8 = u8\"0xCB\"\n    val UINT8: U8 = u8\"0xCC\"\n    val UINT16: U8 = u8\"0xCD\"\n    val UINT32: U8 = u8\"0xCE\"\n    val UINT64: U8 = u8\"0xCF\"\n    val INT8: U8 = u8\"0xD0\"\n    val INT16: U8 = u8\"0xD1\"\n    val INT32: U8 = u8\"0xD2\"\n    val INT64: U8 = u8\"0xD3\"\n    val FIXEXT1: U8 = u8\"0xD4\"\n    val FIXEXT2: U8 = u8\"0xD5\"\n    val FIXEXT4: U8 = u8\"0xD6\"\n    val FIXEXT8: U8 = u8\"0xD7\"\n    val FIXEXT16: U8 = u8\"0xD8\"\n    val STR8: U8 = u8\"0xD9\"\n    val STR16: U8 = u8\"0xDA\"\n    val STR32: U8 = u8\"0xDB\"\n    val ARRAY16: U8 = u8\"0xDC\"\n    val ARRAY32: U8 = u8\"0xDD\"\n    val MAP16: U8 = u8\"0xDE\"\n    val MAP32: U8 = u8\"0xDF\"\n    val NEGFIXINT_PREFIX: U8 = u8\"0xE0\"\n\n    val formatTable: IS[U8, Kind.Type] = {\n      @pure def getType0(n: U8): Kind.Type = {\n        if (isPosFixInt(n) || isNegFixInt(n)) {\n          return Kind.INTEGER\n        } else if (Code.isFixStr(n)) {\n          return Kind.STRING\n        } else if (Code.isFixedArray(n)) {\n          return Kind.ARRAY\n        } else if (Code.isFixedMap(n)) {\n          return Kind.MAP\n        } else {\n          n match {\n            case Code.NIL => return Kind.NIL\n            case Code.FALSE => return Kind.BOOLEAN\n            case Code.TRUE => return Kind.BOOLEAN\n            case Code.BIN8 => return Kind.BINARY\n            case Code.BIN16 => return Kind.BINARY\n            case Code.BIN32 => return Kind.BINARY\n            case Code.FLOAT32 => return Kind.FLOAT\n            case Code.FLOAT64 => return Kind.FLOAT\n            case Code.UINT8 => return Kind.INTEGER\n            case Code.UINT16 => return Kind.INTEGER\n            case Code.UINT32 => return Kind.INTEGER\n            case Code.UINT64 => return Kind.INTEGER\n            case Code.INT8 => return Kind.INTEGER\n            case Code.INT16 => return Kind.INTEGER\n            case Code.INT32 => return Kind.INTEGER\n            case Code.INT64 => return Kind.INTEGER\n            case Code.STR8 => return Kind.STRING\n            case Code.STR16 => return Kind.STRING\n            case Code.STR32 => return Kind.STRING\n            case Code.ARRAY16 => return Kind.ARRAY\n            case Code.ARRAY32 => return Kind.ARRAY\n            case Code.MAP16 => return Kind.MAP\n            case Code.MAP32 => return Kind.MAP\n            case Code.FIXEXT1 => return Kind.EXTENSION\n            case Code.FIXEXT2 => return Kind.EXTENSION\n            case Code.FIXEXT4 => return Kind.EXTENSION\n            case Code.FIXEXT8 => return Kind.EXTENSION\n            case Code.FIXEXT16 => return Kind.EXTENSION\n            case Code.EXT8 => return Kind.EXTENSION\n            case Code.EXT16 => return Kind.EXTENSION\n            case Code.EXT32 => return Kind.EXTENSION\n            case _ => return Kind.NONE\n          }\n        }\n      }\n\n      var a = IS[U8, Kind.Type]()\n      var n = 0\n      var i = u8\"0\"\n      while (n <= 256) {\n        a = a :+ getType0(i)\n        n = n + 1\n        i = i + u8\"1\"\n      }\n      a\n    }\n\n    @pure def getType(n: U8): Kind.Type = {\n      return formatTable(n)\n    }\n\n    @pure def isFixInt(n: U8): B = {\n      val v = n & u8\"0xFF\"\n      return v <= u8\"0x7F\" || v >= u8\"0xE0\"\n    }\n\n    @pure def isPosFixInt(n: U8): B = {\n      return (n & POSFIXINT_MASK) == u8\"0\"\n    }\n\n    @pure def isNegFixInt(n: U8): B = {\n      return (n & NEGFIXINT_PREFIX) == NEGFIXINT_PREFIX\n    }\n\n    @pure def isFixStr(n: U8): B = {\n      return (n & u8\"0xE0\") == Code.FIXSTR_PREFIX\n    }\n\n    @pure def isFixedArray(n: U8): B = {\n      return (n & u8\"0xF0\") == Code.FIXARRAY_PREFIX\n    }\n\n    @pure def isFixedMap(n: U8): B = {\n      return (n & u8\"0xF0\") == Code.FIXMAP_PREFIX\n    }\n\n    @pure def isFixedRaw(n: U8): B = {\n      return (n & u8\"0xE0\") == Code.FIXSTR_PREFIX\n    }\n\n    @pure def isExt(n: U8): B = {\n      n match {\n        case Code.EXT8 => return T\n        case Code.EXT16 => return T\n        case Code.EXT32 => return T\n        case Code.FIXEXT1 => return T\n        case Code.FIXEXT2 => return T\n        case Code.FIXEXT4 => return T\n        case Code.FIXEXT8 => return T\n        case Code.FIXEXT16 => return T\n        case _ => return F\n      }\n    }\n\n  }\n\n  @record trait Writer {\n\n    def result: ISZ[U8]\n\n    def writeB(b: B): Unit\n\n    def writeC(c: C): Unit = {\n      writeU32(conversions.C.toU32(c))\n    }\n\n    def writeZ(n: Z): Unit\n\n    def writeZ8(n: Z8): Unit = {\n      writeS8(conversions.Z8.toS8(n))\n    }\n\n    def writeZ16(n: Z16): Unit = {\n      writeS16(conversions.Z16.toS16(n))\n    }\n\n    def writeZ32(n: Z32): Unit = {\n      writeS32(conversions.Z32.toS32(n))\n    }\n\n    def writeZ64(n: Z64): Unit = {\n      writeS64(conversions.Z64.toS64(n))\n    }\n\n    def writeN(n: N): Unit = {\n      writeZ(conversions.N.toZ(n))\n    }\n\n    def writeN8(n: N8): Unit = {\n      writeU8(conversions.N8.toU8(n))\n    }\n\n    def writeN16(n: N16): Unit = {\n      writeU16(conversions.N16.toU16(n))\n    }\n\n    def writeN32(n: N32): Unit = {\n      writeU32(conversions.N32.toU32(n))\n    }\n\n    def writeN64(n: N64): Unit = {\n      writeU64(conversions.N64.toU64(n))\n    }\n\n    def writeS8(n: S8): Unit\n\n    def writeS16(n: S16): Unit\n\n    def writeS32(n: S32): Unit\n\n    def writeS64(n: S64): Unit\n\n    def writeU8(n: U8): Unit\n\n    def writeU16(n: U16): Unit\n\n    def writeU32(n: U32): Unit\n\n    def writeU64(n: U64): Unit\n\n    def writeR(n: R): Unit = {\n      writeString(n.string)\n    }\n\n    def writeF32(n: F32): Unit\n\n    def writeF64(n: F64): Unit\n\n    def writeString(s: String): Unit\n\n    def writeOption[T](o: Option[T], f: T => Unit): Unit = {\n      o match {\n        case Some(e) => f(e)\n        case _ => writeNil()\n      }\n    }\n\n    def writeMOption[T](o: MOption[T], f: T => Unit): Unit = {\n      o match {\n        case MSome(e) => f(e)\n        case _ => writeNil()\n      }\n    }\n\n    def writeEither[L, R](o: Either[L, R], l: L => Unit, r: R => Unit): Unit = {\n      o match {\n        case Either.Left(e) => l(e)\n        case Either.Right(e) =>\n          writeNil()\n          r(e)\n      }\n    }\n\n    def writeMEither[L, R](o: MEither[L, R], l: L => Unit, r: R => Unit): Unit = {\n      o match {\n        case MEither.Left(e) => l(e)\n        case MEither.Right(e) =>\n          writeNil()\n          r(e)\n      }\n    }\n\n    def writeISZ[E](s: IS[Z, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ8[E](s: IS[Z8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ16[E](s: IS[Z16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ32[E](s: IS[Z32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ64[E](s: IS[Z64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN[E](s: IS[N, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN8[E](s: IS[N8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN16[E](s: IS[N16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN32[E](s: IS[N32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN64[E](s: IS[N64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS8[E](s: IS[S8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS16[E](s: IS[S16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS32[E](s: IS[S32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS64[E](s: IS[S64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU8[E](s: IS[U8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU16[E](s: IS[U16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU32[E](s: IS[U32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU64[E](s: IS[U64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ[E](s: MS[Z, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ8[E](s: MS[Z8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ16[E](s: MS[Z16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ32[E](s: MS[Z32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ64[E](s: MS[Z64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN[E](s: MS[N, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN8[E](s: MS[N8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN16[E](s: MS[N16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN32[E](s: MS[N32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN64[E](s: MS[N64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS8[E](s: MS[S8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS16[E](s: MS[S16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS32[E](s: MS[S32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS64[E](s: MS[S64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU8[E](s: MS[U8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU16[E](s: MS[U16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU32[E](s: MS[U32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU64[E](s: MS[U64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeZS(s: ZS): Unit = {\n      writeMSZ(s, writeZ _)\n    }\n\n    def writeMap[K, T](o: Map[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeSet[T](o: Set[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeHashMap[K, T](o: HashMap[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeHashSet[T](o: HashSet[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeHashSMap[K, T](o: HashSMap[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeHashSSet[T](o: HashSSet[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeStack[T](o: Stack[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeBag[T](o: Bag[T], f: T => Unit): Unit = {\n      writeMap(o.map, f, writeZ _)\n    }\n\n    def writeHashBag[T](o: HashBag[T], f: T => Unit): Unit = {\n      writeHashMap(o.map, f, writeZ _)\n    }\n\n    def writeHashSBag[T](o: HashSBag[T], f: T => Unit): Unit = {\n      writeHashSMap(o.map, f, writeZ _)\n    }\n\n    def writePoset[T](o: Poset[T], f: T => Unit): Unit = {\n      def g(s: HashSSet[Poset.Index]): Unit = {\n        writeHashSSet(s, writeZ _)\n      }\n      writeISZ(o.nodesInverse, f)\n      writeHashSMap(o.parents, writeZ _, g _)\n    }\n\n    def writeGraph[W, E](o: Graph[W, E], f: W => Unit, g: E => Unit): Unit = {\n      def writeEdge(edge: Graph.Internal.Edge[E]): Unit = {\n        edge match {\n          case Graph.Internal.Edge.Plain(src, dest) =>\n            writeZ(src)\n            writeZ(dest)\n            writeNil()\n          case Graph.Internal.Edge.Data(src, dest, data) =>\n            writeZ(src)\n            writeZ(dest)\n            g(data)\n        }\n      }\n      val edges: ISZ[Graph.Internal.Edge[E]] =\n        for (es <- o.outgoingEdges.values; e <- es.elements) yield e\n      writeB(o.multi)\n      writeISZ(o.nodesInverse, f)\n      writeISZ(edges, writeEdge _)\n    }\n\n    def writeUnionFind[T](o: UnionFind[T], f: T => Unit): Unit = {\n      writeISZ(o.elementsInverse, f)\n      writeISZ(o.parentOf, writeZ _)\n      writeISZ(o.sizeOf, writeZ _)\n    }\n\n    def writeMessage(o: message.Message): Unit = {\n      writeZ(o.level.ordinal)\n      writeOption(o.posOpt, writePosition _)\n      writeString(o.kind)\n      writeString(o.text)\n    }\n\n    def writePosition(o: message.Position): Unit\n\n    def writeDocInfo(o: message.DocInfo): Unit\n\n    def writeArrayHeader(n: Z): Unit\n\n    def writeBinary(array: ISZ[U8]): Unit\n\n    def writeNil(): Unit\n\n    def writeMapHeader(n: Z): Unit\n\n    def writeExtTypeHeader(extType: S8, payloadLen: Z): Unit\n\n    def writePayload(data: ISZ[U8]): Unit\n  }\n\n  object Writer {\n\n    @record class Impl(val pooling: B, var buf: MSZ[U8], var size: Z) extends Writer {\n\n      var stringPool: HashSMap[String, Z] = HashSMap.emptyInit(1024)\n      var docInfoPool: HashSMap[message.DocInfo, Z] = HashSMap.emptyInit(1024)\n\n      def result: ISZ[U8] = {\n        if (pooling) {\n          val strings = stringPool.keys\n          val poolBufferSize: Z = {\n            var r: Z = 0\n            for (s <- strings) {\n              r = r + s.size * 2\n            }\n            r + 4\n          }\n          val (poolBuf, poolBufSize): (MSZ[U8], Z) = {\n            val r = Impl(F, MSZ.create(poolBufferSize, u8\"0\"), 0)\n            r.writeExtTypeHeader(StringPoolExtType, strings.size)\n            for (s <- strings) {\n              r.writeStringNoPool(s)\n            }\n            r.writeExtTypeHeader(DocInfoExtType, docInfoPool.size)\n            for (di <- docInfoPool.keys) {\n              r.writeDocInfoNoPool(di)\n            }\n            (r.buf, r.size)\n          }\n\n          val r = MSZ.create(poolBufSize + size, u8\"0\")\n          var i = 0\n          while (i < poolBufSize) {\n            r(i) = poolBuf(i)\n            i = i + 1\n          }\n          i = 0\n          while (i < size) {\n            r(i + poolBufSize) = buf(i)\n            i = i + 1\n          }\n          return r.toIS\n        } else {\n          val r = MSZ.create(size, u8\"0\")\n          var i = 0\n          while (i < size) {\n            r(i) = buf(i)\n            i = i + 1\n          }\n          return r.toIS\n        }\n      }\n\n      def addString(s: String): Z = {\n        stringPool.get(s) match {\n          case Some(i) => return i\n          case _ =>\n            val i = stringPool.size\n            stringPool = stringPool + s ~> i\n            return i\n        }\n      }\n\n      def addU8(n: U8): Unit = {\n        if (size == buf.size) {\n          val newBuf = MSZ.create(buf.size * 2 + 1, u8\"0\")\n          for (i <- z\"0\" until buf.size) {\n            newBuf(i) = buf(i)\n          }\n          buf = newBuf\n        }\n        buf(size) = n\n        size = size + 1\n      }\n\n      def addU16(n: U16): Unit = {\n        addU8(conversions.U16.toU8((n >>> u16\"8\") & u16\"0xFF\"))\n        addU8(conversions.U16.toU8(n & u16\"0xFF\"))\n      }\n\n      def addU32(n: U32): Unit = {\n        addU8(conversions.U32.toU8((n >>> u32\"24\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8((n >>> u32\"16\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8((n >>> u32\"8\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8(n & u32\"0xFF\"))\n      }\n\n      def addU64(n: U64): Unit = {\n        addU8(conversions.U64.toU8((n >>> u64\"56\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"48\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"40\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"32\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"24\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"16\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"8\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8(n & u64\"0xFF\"))\n      }\n\n      def addS8(n: S8): Unit = {\n        addU8(conversions.S8.toRawU8(n))\n      }\n\n      def addS16(n: S16): Unit = {\n        addU8(conversions.S16.toU8((n >>> s16\"8\") & s16\"0xFF\"))\n        addU8(conversions.S16.toU8(n & s16\"0xFF\"))\n      }\n\n      def addS32(n: S32): Unit = {\n        addU8(conversions.S32.toU8((n >>> s32\"24\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8((n >>> s32\"16\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8((n >>> s32\"8\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8(n & s32\"0xFF\"))\n      }\n\n      def addS64(n: S64): Unit = {\n        addU8(conversions.S64.toU8((n >>> s64\"56\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"48\") & s64\"0xFF\"))\n        addU8(conver
  #698 = String             #697          // // #Sireum\n/*\nAdapted from: https://github.com/msgpack4z/msgpack4z-native with the following license:\n\nCopyright (c) 2015 msgpack4z-core contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\npackage org.sireum\n\nimport U8._\nimport U16._\nimport U32._\nimport U64._\nimport S8._\nimport S16._\nimport S32._\nimport S64._\n\nobject MessagePack {\n\n  @enum object Kind {\n    \"NIL\"\n    \"BOOLEAN\"\n    \"INTEGER\"\n    \"FLOAT\"\n    \"STRING\"\n    \"ARRAY\"\n    \"MAP\"\n    \"BINARY\"\n    \"EXTENSION\"\n    \"NONE\"\n  }\n\n  val TimestampExtType: S8 = s8\"-1\"\n  val StringPoolExtType: S8 = s8\"0\"\n  val DocInfoExtType: S8 = s8\"1\"\n  val LastExtType: S8 = DocInfoExtType\n\n  object Code {\n    val POSFIXINT_MASK: U8 = u8\"0x80\"\n    val FIXMAP_PREFIX: U8 = u8\"0x80\"\n    val FIXARRAY_PREFIX: U8 = u8\"0x90\"\n    val FIXSTR_PREFIX: U8 = u8\"0xA0\"\n    val NIL: U8 = u8\"0xC0\"\n    val FALSE: U8 = u8\"0xC2\"\n    val TRUE: U8 = u8\"0xC3\"\n    val BIN8: U8 = u8\"0xC4\"\n    val BIN16: U8 = u8\"0xC5\"\n    val BIN32: U8 = u8\"0xC6\"\n    val EXT8: U8 = u8\"0xC7\"\n    val EXT16: U8 = u8\"0xC8\"\n    val EXT32: U8 = u8\"0xC9\"\n    val FLOAT32: U8 = u8\"0xCA\"\n    val FLOAT64: U8 = u8\"0xCB\"\n    val UINT8: U8 = u8\"0xCC\"\n    val UINT16: U8 = u8\"0xCD\"\n    val UINT32: U8 = u8\"0xCE\"\n    val UINT64: U8 = u8\"0xCF\"\n    val INT8: U8 = u8\"0xD0\"\n    val INT16: U8 = u8\"0xD1\"\n    val INT32: U8 = u8\"0xD2\"\n    val INT64: U8 = u8\"0xD3\"\n    val FIXEXT1: U8 = u8\"0xD4\"\n    val FIXEXT2: U8 = u8\"0xD5\"\n    val FIXEXT4: U8 = u8\"0xD6\"\n    val FIXEXT8: U8 = u8\"0xD7\"\n    val FIXEXT16: U8 = u8\"0xD8\"\n    val STR8: U8 = u8\"0xD9\"\n    val STR16: U8 = u8\"0xDA\"\n    val STR32: U8 = u8\"0xDB\"\n    val ARRAY16: U8 = u8\"0xDC\"\n    val ARRAY32: U8 = u8\"0xDD\"\n    val MAP16: U8 = u8\"0xDE\"\n    val MAP32: U8 = u8\"0xDF\"\n    val NEGFIXINT_PREFIX: U8 = u8\"0xE0\"\n\n    val formatTable: IS[U8, Kind.Type] = {\n      @pure def getType0(n: U8): Kind.Type = {\n        if (isPosFixInt(n) || isNegFixInt(n)) {\n          return Kind.INTEGER\n        } else if (Code.isFixStr(n)) {\n          return Kind.STRING\n        } else if (Code.isFixedArray(n)) {\n          return Kind.ARRAY\n        } else if (Code.isFixedMap(n)) {\n          return Kind.MAP\n        } else {\n          n match {\n            case Code.NIL => return Kind.NIL\n            case Code.FALSE => return Kind.BOOLEAN\n            case Code.TRUE => return Kind.BOOLEAN\n            case Code.BIN8 => return Kind.BINARY\n            case Code.BIN16 => return Kind.BINARY\n            case Code.BIN32 => return Kind.BINARY\n            case Code.FLOAT32 => return Kind.FLOAT\n            case Code.FLOAT64 => return Kind.FLOAT\n            case Code.UINT8 => return Kind.INTEGER\n            case Code.UINT16 => return Kind.INTEGER\n            case Code.UINT32 => return Kind.INTEGER\n            case Code.UINT64 => return Kind.INTEGER\n            case Code.INT8 => return Kind.INTEGER\n            case Code.INT16 => return Kind.INTEGER\n            case Code.INT32 => return Kind.INTEGER\n            case Code.INT64 => return Kind.INTEGER\n            case Code.STR8 => return Kind.STRING\n            case Code.STR16 => return Kind.STRING\n            case Code.STR32 => return Kind.STRING\n            case Code.ARRAY16 => return Kind.ARRAY\n            case Code.ARRAY32 => return Kind.ARRAY\n            case Code.MAP16 => return Kind.MAP\n            case Code.MAP32 => return Kind.MAP\n            case Code.FIXEXT1 => return Kind.EXTENSION\n            case Code.FIXEXT2 => return Kind.EXTENSION\n            case Code.FIXEXT4 => return Kind.EXTENSION\n            case Code.FIXEXT8 => return Kind.EXTENSION\n            case Code.FIXEXT16 => return Kind.EXTENSION\n            case Code.EXT8 => return Kind.EXTENSION\n            case Code.EXT16 => return Kind.EXTENSION\n            case Code.EXT32 => return Kind.EXTENSION\n            case _ => return Kind.NONE\n          }\n        }\n      }\n\n      var a = IS[U8, Kind.Type]()\n      var n = 0\n      var i = u8\"0\"\n      while (n <= 256) {\n        a = a :+ getType0(i)\n        n = n + 1\n        i = i + u8\"1\"\n      }\n      a\n    }\n\n    @pure def getType(n: U8): Kind.Type = {\n      return formatTable(n)\n    }\n\n    @pure def isFixInt(n: U8): B = {\n      val v = n & u8\"0xFF\"\n      return v <= u8\"0x7F\" || v >= u8\"0xE0\"\n    }\n\n    @pure def isPosFixInt(n: U8): B = {\n      return (n & POSFIXINT_MASK) == u8\"0\"\n    }\n\n    @pure def isNegFixInt(n: U8): B = {\n      return (n & NEGFIXINT_PREFIX) == NEGFIXINT_PREFIX\n    }\n\n    @pure def isFixStr(n: U8): B = {\n      return (n & u8\"0xE0\") == Code.FIXSTR_PREFIX\n    }\n\n    @pure def isFixedArray(n: U8): B = {\n      return (n & u8\"0xF0\") == Code.FIXARRAY_PREFIX\n    }\n\n    @pure def isFixedMap(n: U8): B = {\n      return (n & u8\"0xF0\") == Code.FIXMAP_PREFIX\n    }\n\n    @pure def isFixedRaw(n: U8): B = {\n      return (n & u8\"0xE0\") == Code.FIXSTR_PREFIX\n    }\n\n    @pure def isExt(n: U8): B = {\n      n match {\n        case Code.EXT8 => return T\n        case Code.EXT16 => return T\n        case Code.EXT32 => return T\n        case Code.FIXEXT1 => return T\n        case Code.FIXEXT2 => return T\n        case Code.FIXEXT4 => return T\n        case Code.FIXEXT8 => return T\n        case Code.FIXEXT16 => return T\n        case _ => return F\n      }\n    }\n\n  }\n\n  @record trait Writer {\n\n    def result: ISZ[U8]\n\n    def writeB(b: B): Unit\n\n    def writeC(c: C): Unit = {\n      writeU32(conversions.C.toU32(c))\n    }\n\n    def writeZ(n: Z): Unit\n\n    def writeZ8(n: Z8): Unit = {\n      writeS8(conversions.Z8.toS8(n))\n    }\n\n    def writeZ16(n: Z16): Unit = {\n      writeS16(conversions.Z16.toS16(n))\n    }\n\n    def writeZ32(n: Z32): Unit = {\n      writeS32(conversions.Z32.toS32(n))\n    }\n\n    def writeZ64(n: Z64): Unit = {\n      writeS64(conversions.Z64.toS64(n))\n    }\n\n    def writeN(n: N): Unit = {\n      writeZ(conversions.N.toZ(n))\n    }\n\n    def writeN8(n: N8): Unit = {\n      writeU8(conversions.N8.toU8(n))\n    }\n\n    def writeN16(n: N16): Unit = {\n      writeU16(conversions.N16.toU16(n))\n    }\n\n    def writeN32(n: N32): Unit = {\n      writeU32(conversions.N32.toU32(n))\n    }\n\n    def writeN64(n: N64): Unit = {\n      writeU64(conversions.N64.toU64(n))\n    }\n\n    def writeS8(n: S8): Unit\n\n    def writeS16(n: S16): Unit\n\n    def writeS32(n: S32): Unit\n\n    def writeS64(n: S64): Unit\n\n    def writeU8(n: U8): Unit\n\n    def writeU16(n: U16): Unit\n\n    def writeU32(n: U32): Unit\n\n    def writeU64(n: U64): Unit\n\n    def writeR(n: R): Unit = {\n      writeString(n.string)\n    }\n\n    def writeF32(n: F32): Unit\n\n    def writeF64(n: F64): Unit\n\n    def writeString(s: String): Unit\n\n    def writeOption[T](o: Option[T], f: T => Unit): Unit = {\n      o match {\n        case Some(e) => f(e)\n        case _ => writeNil()\n      }\n    }\n\n    def writeMOption[T](o: MOption[T], f: T => Unit): Unit = {\n      o match {\n        case MSome(e) => f(e)\n        case _ => writeNil()\n      }\n    }\n\n    def writeEither[L, R](o: Either[L, R], l: L => Unit, r: R => Unit): Unit = {\n      o match {\n        case Either.Left(e) => l(e)\n        case Either.Right(e) =>\n          writeNil()\n          r(e)\n      }\n    }\n\n    def writeMEither[L, R](o: MEither[L, R], l: L => Unit, r: R => Unit): Unit = {\n      o match {\n        case MEither.Left(e) => l(e)\n        case MEither.Right(e) =>\n          writeNil()\n          r(e)\n      }\n    }\n\n    def writeISZ[E](s: IS[Z, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ8[E](s: IS[Z8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ16[E](s: IS[Z16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ32[E](s: IS[Z32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ64[E](s: IS[Z64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN[E](s: IS[N, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN8[E](s: IS[N8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN16[E](s: IS[N16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN32[E](s: IS[N32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN64[E](s: IS[N64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS8[E](s: IS[S8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS16[E](s: IS[S16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS32[E](s: IS[S32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS64[E](s: IS[S64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU8[E](s: IS[U8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU16[E](s: IS[U16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU32[E](s: IS[U32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU64[E](s: IS[U64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ[E](s: MS[Z, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ8[E](s: MS[Z8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ16[E](s: MS[Z16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ32[E](s: MS[Z32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ64[E](s: MS[Z64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN[E](s: MS[N, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN8[E](s: MS[N8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN16[E](s: MS[N16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN32[E](s: MS[N32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN64[E](s: MS[N64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS8[E](s: MS[S8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS16[E](s: MS[S16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS32[E](s: MS[S32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS64[E](s: MS[S64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU8[E](s: MS[U8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU16[E](s: MS[U16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU32[E](s: MS[U32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU64[E](s: MS[U64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeZS(s: ZS): Unit = {\n      writeMSZ(s, writeZ _)\n    }\n\n    def writeMap[K, T](o: Map[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeSet[T](o: Set[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeHashMap[K, T](o: HashMap[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeHashSet[T](o: HashSet[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeHashSMap[K, T](o: HashSMap[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeHashSSet[T](o: HashSSet[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeStack[T](o: Stack[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeBag[T](o: Bag[T], f: T => Unit): Unit = {\n      writeMap(o.map, f, writeZ _)\n    }\n\n    def writeHashBag[T](o: HashBag[T], f: T => Unit): Unit = {\n      writeHashMap(o.map, f, writeZ _)\n    }\n\n    def writeHashSBag[T](o: HashSBag[T], f: T => Unit): Unit = {\n      writeHashSMap(o.map, f, writeZ _)\n    }\n\n    def writePoset[T](o: Poset[T], f: T => Unit): Unit = {\n      def g(s: HashSSet[Poset.Index]): Unit = {\n        writeHashSSet(s, writeZ _)\n      }\n      writeISZ(o.nodesInverse, f)\n      writeHashSMap(o.parents, writeZ _, g _)\n    }\n\n    def writeGraph[W, E](o: Graph[W, E], f: W => Unit, g: E => Unit): Unit = {\n      def writeEdge(edge: Graph.Internal.Edge[E]): Unit = {\n        edge match {\n          case Graph.Internal.Edge.Plain(src, dest) =>\n            writeZ(src)\n            writeZ(dest)\n            writeNil()\n          case Graph.Internal.Edge.Data(src, dest, data) =>\n            writeZ(src)\n            writeZ(dest)\n            g(data)\n        }\n      }\n      val edges: ISZ[Graph.Internal.Edge[E]] =\n        for (es <- o.outgoingEdges.values; e <- es.elements) yield e\n      writeB(o.multi)\n      writeISZ(o.nodesInverse, f)\n      writeISZ(edges, writeEdge _)\n    }\n\n    def writeUnionFind[T](o: UnionFind[T], f: T => Unit): Unit = {\n      writeISZ(o.elementsInverse, f)\n      writeISZ(o.parentOf, writeZ _)\n      writeISZ(o.sizeOf, writeZ _)\n    }\n\n    def writeMessage(o: message.Message): Unit = {\n      writeZ(o.level.ordinal)\n      writeOption(o.posOpt, writePosition _)\n      writeString(o.kind)\n      writeString(o.text)\n    }\n\n    def writePosition(o: message.Position): Unit\n\n    def writeDocInfo(o: message.DocInfo): Unit\n\n    def writeArrayHeader(n: Z): Unit\n\n    def writeBinary(array: ISZ[U8]): Unit\n\n    def writeNil(): Unit\n\n    def writeMapHeader(n: Z): Unit\n\n    def writeExtTypeHeader(extType: S8, payloadLen: Z): Unit\n\n    def writePayload(data: ISZ[U8]): Unit\n  }\n\n  object Writer {\n\n    @record class Impl(val pooling: B, var buf: MSZ[U8], var size: Z) extends Writer {\n\n      var stringPool: HashSMap[String, Z] = HashSMap.emptyInit(1024)\n      var docInfoPool: HashSMap[message.DocInfo, Z] = HashSMap.emptyInit(1024)\n\n      def result: ISZ[U8] = {\n        if (pooling) {\n          val strings = stringPool.keys\n          val poolBufferSize: Z = {\n            var r: Z = 0\n            for (s <- strings) {\n              r = r + s.size * 2\n            }\n            r + 4\n          }\n          val (poolBuf, poolBufSize): (MSZ[U8], Z) = {\n            val r = Impl(F, MSZ.create(poolBufferSize, u8\"0\"), 0)\n            r.writeExtTypeHeader(StringPoolExtType, strings.size)\n            for (s <- strings) {\n              r.writeStringNoPool(s)\n            }\n            r.writeExtTypeHeader(DocInfoExtType, docInfoPool.size)\n            for (di <- docInfoPool.keys) {\n              r.writeDocInfoNoPool(di)\n            }\n            (r.buf, r.size)\n          }\n\n          val r = MSZ.create(poolBufSize + size, u8\"0\")\n          var i = 0\n          while (i < poolBufSize) {\n            r(i) = poolBuf(i)\n            i = i + 1\n          }\n          i = 0\n          while (i < size) {\n            r(i + poolBufSize) = buf(i)\n            i = i + 1\n          }\n          return r.toIS\n        } else {\n          val r = MSZ.create(size, u8\"0\")\n          var i = 0\n          while (i < size) {\n            r(i) = buf(i)\n            i = i + 1\n          }\n          return r.toIS\n        }\n      }\n\n      def addString(s: String): Z = {\n        stringPool.get(s) match {\n          case Some(i) => return i\n          case _ =>\n            val i = stringPool.size\n            stringPool = stringPool + s ~> i\n            return i\n        }\n      }\n\n      def addU8(n: U8): Unit = {\n        if (size == buf.size) {\n          val newBuf = MSZ.create(buf.size * 2 + 1, u8\"0\")\n          for (i <- z\"0\" until buf.size) {\n            newBuf(i) = buf(i)\n          }\n          buf = newBuf\n        }\n        buf(size) = n\n        size = size + 1\n      }\n\n      def addU16(n: U16): Unit = {\n        addU8(conversions.U16.toU8((n >>> u16\"8\") & u16\"0xFF\"))\n        addU8(conversions.U16.toU8(n & u16\"0xFF\"))\n      }\n\n      def addU32(n: U32): Unit = {\n        addU8(conversions.U32.toU8((n >>> u32\"24\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8((n >>> u32\"16\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8((n >>> u32\"8\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8(n & u32\"0xFF\"))\n      }\n\n      def addU64(n: U64): Unit = {\n        addU8(conversions.U64.toU8((n >>> u64\"56\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"48\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"40\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"32\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"24\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"16\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"8\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8(n & u64\"0xFF\"))\n      }\n\n      def addS8(n: S8): Unit = {\n        addU8(conversions.S8.toRawU8(n))\n      }\n\n      def addS16(n: S16): Unit = {\n        addU8(conversions.S16.toU8((n >>> s16\"8\") & s16\"0xFF\"))\n        addU8(conversions.S16.toU8(n & s16\"0xFF\"))\n      }\n\n      def addS32(n: S32): Unit = {\n        addU8(conversions.S32.toU8((n >>> s32\"24\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8((n >>> s32\"16\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8((n >>> s32\"8\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8(n & s32\"0xFF\"))\n      }\n\n      def addS64(n: S64): Unit = {\n        addU8(conversions.S64.toU8((n >>> s64\"56\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"48\") & s64\"0xFF\"))\n        addU8(conver
  #699 = Utf8               sions.S64.toU8((n >>> s64\"40\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"32\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"24\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"16\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"8\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8(n & s64\"0xFF\"))\n      }\n\n      def writeU8(n: U8): Unit = {\n        if (n > u8\"127\") {\n          addU8(Code.UINT8)\n          addU8(n)\n        } else {\n          writeS8(conversions.U8.toS8(n))\n        }\n      }\n\n      def writeS8(n: S8): Unit = {\n        if (n < -(s8\"1\" << s8\"5\")) {\n          addU8(Code.INT8)\n          addS8(n)\n        } else {\n          addS8(n)\n        }\n      }\n\n      def writeU16(n: U16): Unit = {\n        if (n > u16\"32767\") {\n          addU8(Code.UINT16)\n          addU16(n)\n        } else {\n          writeS16(conversions.U16.toS16(n))\n        }\n      }\n\n      def writeS16(n: S16): Unit = {\n        if (n < -(s16\"1\" << s16\"5\")) {\n          if (n < -(s16\"1\" << s16\"7\")) {\n            addU8(Code.INT16)\n            addS16(n)\n          } else {\n            addU8(Code.INT8)\n            addS8(conversions.S16.toS8(n))\n          }\n        } else if (n < (s16\"1\" << s16\"7\")) {\n          addS8(conversions.S16.toS8(n))\n        } else {\n          if (n < (s16\"1\" << s16\"8\")) {\n            addU8(Code.UINT8)\n            addU8(conversions.S16.toU8(n))\n          } else {\n            addU8(Code.UINT16)\n            addU16(conversions.S16.toU16(n))\n          }\n        }\n      }\n\n      def writeU32(n: U32): Unit = {\n        if (n > u32\"2147483647\") {\n          addU8(Code.UINT32)\n          addU32(n)\n        } else {\n          writeS32(conversions.U32.toS32(n))\n        }\n      }\n\n      def writeS32(n: S32): Unit = {\n        if (n < -(s32\"1\" << s32\"5\")) {\n          if (n < -(s32\"1\" << s32\"15\")) {\n            addU8(Code.INT32)\n            addS32(n)\n          } else if (n < -(s32\"1\" << s32\"7\")) {\n            addU8(Code.INT16)\n            addS16(conversions.S32.toS16(n))\n          } else {\n            addU8(Code.INT8)\n            addS8(conversions.S32.toS8(n))\n          }\n        } else if (n < (s32\"1\" << s32\"7\")) {\n          addS8(conversions.S32.toS8(n))\n        } else {\n          if (n < (s32\"1\" << s32\"8\")) {\n            addU8(Code.UINT8)\n            addU8(conversions.S32.toU8(n))\n          } else if (n < (s32\"1\" << s32\"16\")) {\n            addU8(Code.UINT16)\n            addU16(conversions.S32.toU16(n))\n          } else {\n            addU8(Code.UINT32)\n            addU32(conversions.S32.toU32(n))\n          }\n        }\n      }\n\n      def writeU64(n: U64): Unit = {\n        if (n > u64\"9223372036854775807\") {\n          addU8(Code.UINT64)\n          addU64(n)\n        } else {\n          writeS64(conversions.U64.toS64(n))\n        }\n      }\n\n      def writeS64(n: S64): Unit = {\n        if (n < -(s64\"1\" << s64\"5\")) {\n          if (n < -(s64\"1\" << s64\"15\")) {\n            if (n < -(s64\"1\" << s64\"31\")) {\n              addU8(Code.INT64)\n              addS64(n)\n            } else {\n              addU8(Code.INT32)\n              addS32(conversions.S64.toS32(n))\n            }\n          } else {\n            if (n < -(s64\"1\" << s64\"7\")) {\n              addU8(Code.INT16)\n              addS16(conversions.S64.toS16(n))\n            } else {\n              addU8(Code.INT8)\n              addS8(conversions.S64.toS8(n))\n            }\n          }\n        } else if (n < (s64\"1\" << s64\"7\")) {\n          addS8(conversions.S64.toS8(n))\n        } else {\n          if (n < (s64\"1\" << s64\"16\")) {\n            if (n < (s64\"1\" << s64\"8\")) {\n              addU8(Code.UINT8)\n              addU8(conversions.S64.toU8(n))\n            } else {\n              addU8(Code.UINT16)\n              addU16(conversions.S64.toU16(n))\n            }\n          } else {\n            if (n < (s64\"1\" << s64\"32\")) {\n              addU8(Code.UINT32)\n              addU32(conversions.S64.toU32(n))\n            } else {\n              addU8(Code.UINT64)\n              addU64(conversions.S64.toU64(n))\n            }\n          }\n        }\n      }\n\n      def writeZ(n: Z): Unit = {\n        if (-9223372036854775808L <= n && n <= 9223372036854775807L) {\n          writeS64(conversions.Z.toS64(n))\n        } else if (0 <= n && n <= z\"18446744073709551615\") {\n          writeU64(conversions.Z.toU64(n))\n        } else {\n          writeBinary(conversions.Z.toBinary(n))\n        }\n      }\n\n      def writeF32(n: F32): Unit = {\n        addU8(Code.FLOAT32)\n        addU32(conversions.F32.toRawU32(n))\n      }\n\n      def writeF64(n: F64): Unit = {\n        addU8(Code.FLOAT64)\n        addU64(conversions.F64.toRawU64(n))\n      }\n\n      def writeArrayHeader(n: Z): Unit = {\n        Contract(Requires(0 <= n, n <= z\"4294967295\"))\n\n        if (n < 16 /* 1 << 4 */ ) {\n          addU8(Code.FIXARRAY_PREFIX | conversions.Z.toU8(n))\n        } else if (n < 65536 /* 1 << 16 */ ) {\n          addU8(Code.ARRAY16)\n          addS16(conversions.Z.toS16(n))\n        } else {\n          addU8(Code.ARRAY32)\n          addS32(conversions.Z.toS32(n))\n        }\n      }\n\n      def writeBinary(array: ISZ[U8]): Unit = {\n        Contract(Requires(0 <= array.size, array.size <= z\"4294967295\"))\n\n        val len = array.size\n        if (len < 256 /* 1 << 8 */ ) {\n          addU8(Code.BIN8)\n          addU8(conversions.Z.toU8(len))\n        } else if (len < 65536 /* 1 << 16 */ ) {\n          addU8(Code.BIN16)\n          addU16(conversions.Z.toU16(len))\n        } else {\n          addU8(Code.BIN32)\n          addU32(conversions.Z.toU32(len))\n        }\n        for (e <- array) {\n          addU8(e)\n        }\n      }\n\n      def writeNil(): Unit = {\n        addU8(Code.NIL)\n      }\n\n      def writeMapHeader(n: Z): Unit = {\n        Contract(Requires(0 <= n, n <= z\"4294967295\"))\n        if (n < 16 /* 1 << 4 */ ) {\n          addU8(Code.FIXMAP_PREFIX | conversions.Z.toU8(n))\n        } else if (n < 65536 /* 1 << 16 */ ) {\n          addU8(Code.MAP16)\n          addU16(conversions.Z.toU16(n))\n        } else {\n          addU8(Code.MAP32)\n          addU32(conversions.Z.toU32(n))\n        }\n      }\n\n      def writeB(b: B): Unit = {\n        addU8(if (b) Code.TRUE else Code.FALSE)\n      }\n\n      def writeStringNoPool(s: String): Unit = {\n        val size = s.size\n        writeZ(size)\n        val cis = conversions.String.toCis(s)\n        for (i <- z\"0\" until size) {\n          writeU32(conversions.C.toU32(cis(i)))\n        }\n      }\n\n      /*\n      def writeStringNoPool(s: String): Unit = {\n        val bis = conversions.String.toBis(s)\n        val len = bis.size\n        if (len < 32 /* 1 << 5 */ ) {\n          addU8(Code.FIXSTR_PREFIX | conversions.Z.toU8(len))\n        } else if (len < 256 /* 1 << 8 */ ) {\n          addU8(Code.STR8)\n          addU8(conversions.Z.toU8(len))\n        } else if (len < 65536 /* 1 << 16 */ ) {\n          addU8(Code.STR16)\n          addU16(conversions.Z.toU16(len))\n        } else {\n          addU8(Code.STR32)\n          addU32(conversions.Z.toU32(len))\n        }\n        for (e <- bis) {\n          addU8(e)\n        }\n      }\n       */\n\n      def writeString(s: String): Unit = {\n        Contract(Requires(0 <= s.size * 2, s.size * 2 <= z\"4294967295\"))\n\n        if (pooling) {\n          val i = addString(s)\n          writeZ(i)\n        } else {\n          writeStringNoPool(s)\n        }\n      }\n\n      def writeExtTypeHeader(extType: S8, payloadLen: Z): Unit = {\n        Contract(Requires(extType >= s8\"0\", 0 <= payloadLen, payloadLen <= z\"4294967295\"))\n\n        if (payloadLen < 256 /* 1 << 8 */ ) {\n          payloadLen match {\n            case z\"1\" =>\n              addU8(Code.FIXEXT1)\n              addS8(extType)\n            case z\"2\" =>\n              addU8(Code.FIXEXT2)\n              addS8(extType)\n            case z\"4\" =>\n              addU8(Code.FIXEXT4)\n              addS8(extType)\n            case z\"8\" =>\n              addU8(Code.FIXEXT8)\n              addS8(extType)\n            case z\"16\" =>\n              addU8(Code.FIXEXT16)\n              addS8(extType)\n            case _ =>\n              addU8(Code.EXT8)\n              addU8(conversions.Z.toU8(payloadLen))\n              addS8(extType)\n          }\n        } else if (payloadLen < 65536 /* 1 << 16 */ ) {\n          addU8(Code.EXT16)\n          addU16(conversions.Z.toU16(payloadLen))\n          addS8(extType)\n        } else {\n          addU8(Code.EXT32)\n          addU32(conversions.Z.toU32(payloadLen))\n          addS8(extType)\n        }\n      }\n\n      def writePayload(data: ISZ[U8]): Unit = {\n        for (e <- data) {\n          addU8(e)\n        }\n      }\n\n      def writePosition(o: message.Position): Unit = {\n        o match {\n          case o: message.PosInfo if pooling =>\n            writeB(T)\n            writeDocInfo(o.info)\n            writeU64(o.offsetLength)\n          case _ =>\n            writeB(F)\n            writeOption(o.uriOpt, writeString _)\n            writeU32(conversions.Z.toU32(o.beginLine))\n            writeU32(conversions.Z.toU32(o.beginColumn))\n            writeU32(conversions.Z.toU32(o.endLine))\n            writeU32(conversions.Z.toU32(o.endColumn))\n            writeU32(conversions.Z.toU32(o.offset))\n            writeU32(conversions.Z.toU32(o.length))\n        }\n      }\n\n      def writeDocInfoNoPool(o: message.DocInfo): Unit = {\n        writeOption(o.uriOpt, writeString _)\n        writeISZ(o.lineOffsets, writeU32 _)\n      }\n\n      def writeDocInfo(o: message.DocInfo): Unit = {\n        if (pooling) {\n          val n: Z = docInfoPool.get(o) match {\n            case Some(m) => m\n            case _ =>\n              val m = docInfoPool.size\n              docInfoPool = docInfoPool + o ~> m\n              m\n          }\n          writeZ(n)\n        } else {\n          writeDocInfoNoPool(o)\n        }\n      }\n\n    }\n\n  }\n\n  @record trait Reader {\n\n    def init(): Unit\n\n    def error(offset: Z, msg: String): Unit\n\n    def curr: Z\n\n    def readB(): B\n\n    def readC(): C = {\n      val n = readU32()\n      return conversions.U32.toC(n)\n    }\n\n    def readZ(): Z\n\n    def expectZ(n: Z): Unit\n\n    @pure def fix8(n: Z): Z = {\n      if (n > 127) {\n        return n - 256\n      }\n      return n\n    }\n\n    def readZ8(): Z8 = {\n      val n = readZ()\n      return conversions.Z.toZ8(fix8(n))\n    }\n\n    def readZ16(): Z16 = {\n      val n = readZ()\n      return conversions.Z.toZ16(n)\n    }\n\n    def readZ32(): Z32 = {\n      val n = readZ()\n      return conversions.Z.toZ32(n)\n    }\n\n    def readZ64(): Z64 = {\n      val n = readZ()\n      return conversions.Z.toZ64(n)\n    }\n\n    def readN(): N = {\n      val n = readZ()\n      return conversions.Z.toN(n)\n    }\n\n    def readN8(): N8 = {\n      val n = readZ()\n      return conversions.Z.toN8(n)\n    }\n\n    def readN16(): N16 = {\n      val n = readZ()\n      return conversions.Z.toN16(n)\n    }\n\n    def readN32(): N32 = {\n      val n = readZ()\n      return conversions.Z.toN32(n)\n    }\n\n    def readN64(): N64 = {\n      val n = readZ()\n      return conversions.Z.toN64(n)\n    }\n\n    def readS8(): S8 = {\n      val n = readZ()\n      return conversions.Z.toS8(fix8(n))\n    }\n\n    def readS16(): S16 = {\n      val n = readZ()\n      return conversions.Z.toS16(n)\n    }\n\n    def readS32(): S32 = {\n      val n = readZ()\n      return conversions.Z.toS32(n)\n    }\n\n    def readS64(): S64 = {\n      val n = readZ()\n      return conversions.Z.toS64(n)\n    }\n\n    def readU8(): U8 = {\n      val n = readZ()\n      return conversions.Z.toU8(n)\n    }\n\n    def readU16(): U16 = {\n      val n = readZ()\n      return conversions.Z.toU16(n)\n    }\n\n    def readU32(): U32 = {\n      val n = readZ()\n      return conversions.Z.toU32(n)\n    }\n\n    def readU64(): U64 = {\n      val n = readZ()\n      return conversions.Z.toU64(n)\n    }\n\n    def readR(): R\n\n    def readF32(): F32\n\n    def readF64(): F64\n\n    def readString(): String\n\n    def readOption[T](f: () => T): Option[T] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        return None[T]()\n      } else {\n        val o = f()\n        return Some[T](o)\n      }\n    }\n\n    def readMOption[T](f: () => T): MOption[T] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        return MNone[T]()\n      } else {\n        val o = f()\n        return MSome[T](o)\n      }\n    }\n\n    def readEither[L, R](l: () => L, r: () => R): Either[L, R] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        val o = r()\n        return Either.Right(o)\n      } else {\n        val o = l()\n        return Either.Left(o)\n      }\n    }\n\n    def readMEither[L, R](l: () => L, r: () => R): MEither[L, R] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        val o = r()\n        return MEither.Right(o)\n      } else {\n        val o = l()\n        return MEither.Left(o)\n      }\n    }\n\n    def readISZ[E](f: () => E): IS[Z, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ8[E](f: () => E): IS[Z8, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ16[E](f: () => E): IS[Z16, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ32[E](f: () => E): IS[Z32, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ64[E](f: () => E): IS[Z64, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN[E](f: () => E): IS[N, E] = {\n      val size = readArrayHeader()\n      var r = IS[N, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN8[E](f: () => E): IS[N8, E] = {\n      val size = readArrayHeader()\n      var r = IS[N8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN16[E](f: () => E): IS[N16, E] = {\n      val size = readArrayHeader()\n      var r = IS[N16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN32[E](f: () => E): IS[N32, E] = {\n      val size = readArrayHeader()\n      var r = IS[N32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN64[E](f: () => E): IS[N64, E] = {\n      val size = readArrayHeader()\n      var r = IS[N64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS8[E](f: () => E): IS[S8, E] = {\n      val size = readArrayHeader()\n      var r = IS[S8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS16[E](f: () => E): IS[S16, E] = {\n      val size = readArrayHeader()\n      var r = IS[S16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS32[E](f: () => E): IS[S32, E] = {\n      val size = readArrayHeader()\n      var r = IS[S32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS64[E](f: () => E): IS[S64, E] = {\n      val size = readArrayHeader()\n      var r = IS[S64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU8[E](f: () => E): IS[U8, E] = {\n      val size = readArrayHeader()\n      var r = IS[U8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU16[E](f: () => E): IS[U16, E] = {\n      val size = readArrayHeader()\n      var r = IS[U16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU32[E](f: () => E): IS[U32, E] = {\n      val size = readArrayHeader()\n      var r = IS[U32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU64[E](f: () => E): IS[U64, E] = {\n      val size = readArrayHeader()\n      var r = IS[U64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ[E](f: () => E): MS[Z, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ8[E](f: () => E): MS[Z8, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ16[E](f: () => E): MS[Z16, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ32[E](f: () => E): MS[Z32, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ64[E](f: () => E): MS[Z64, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN[E](f: () => E): MS[N, E] = {\n      val size = readArrayHeader()\n      var r = MS[N, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN8[E](f: () => E): MS[N8, E] = {\n      val size = readArrayHeader()\n      var r = MS[N8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN16[E](f: () => E): MS[N16, E] = {\n      val size = readArrayHeader()\n      var r = MS[N16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN32[E](f: () => E): MS[N32, E] = {\n      val size = readArrayHeader()\n      var r = MS[N32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN64[E](f: () => E): MS[N64, E] = {\n      val size = readArrayHeader()\n      var r = MS[N64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS8[E](f: () => E): MS[S8, E] = {\n      val size = readArrayHeader()\n      var r = MS[S8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS16[E](f: () => E): MS[S16, E] = {\n      val size = readArrayHeader()\n      var r = MS[S16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS32[E](f: () => E): MS[S32, E] = {\n      val size = readArrayHeader()\n      var r = MS[S32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i =
  #700 = String             #699          // sions.S64.toU8((n >>> s64\"40\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"32\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"24\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"16\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"8\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8(n & s64\"0xFF\"))\n      }\n\n      def writeU8(n: U8): Unit = {\n        if (n > u8\"127\") {\n          addU8(Code.UINT8)\n          addU8(n)\n        } else {\n          writeS8(conversions.U8.toS8(n))\n        }\n      }\n\n      def writeS8(n: S8): Unit = {\n        if (n < -(s8\"1\" << s8\"5\")) {\n          addU8(Code.INT8)\n          addS8(n)\n        } else {\n          addS8(n)\n        }\n      }\n\n      def writeU16(n: U16): Unit = {\n        if (n > u16\"32767\") {\n          addU8(Code.UINT16)\n          addU16(n)\n        } else {\n          writeS16(conversions.U16.toS16(n))\n        }\n      }\n\n      def writeS16(n: S16): Unit = {\n        if (n < -(s16\"1\" << s16\"5\")) {\n          if (n < -(s16\"1\" << s16\"7\")) {\n            addU8(Code.INT16)\n            addS16(n)\n          } else {\n            addU8(Code.INT8)\n            addS8(conversions.S16.toS8(n))\n          }\n        } else if (n < (s16\"1\" << s16\"7\")) {\n          addS8(conversions.S16.toS8(n))\n        } else {\n          if (n < (s16\"1\" << s16\"8\")) {\n            addU8(Code.UINT8)\n            addU8(conversions.S16.toU8(n))\n          } else {\n            addU8(Code.UINT16)\n            addU16(conversions.S16.toU16(n))\n          }\n        }\n      }\n\n      def writeU32(n: U32): Unit = {\n        if (n > u32\"2147483647\") {\n          addU8(Code.UINT32)\n          addU32(n)\n        } else {\n          writeS32(conversions.U32.toS32(n))\n        }\n      }\n\n      def writeS32(n: S32): Unit = {\n        if (n < -(s32\"1\" << s32\"5\")) {\n          if (n < -(s32\"1\" << s32\"15\")) {\n            addU8(Code.INT32)\n            addS32(n)\n          } else if (n < -(s32\"1\" << s32\"7\")) {\n            addU8(Code.INT16)\n            addS16(conversions.S32.toS16(n))\n          } else {\n            addU8(Code.INT8)\n            addS8(conversions.S32.toS8(n))\n          }\n        } else if (n < (s32\"1\" << s32\"7\")) {\n          addS8(conversions.S32.toS8(n))\n        } else {\n          if (n < (s32\"1\" << s32\"8\")) {\n            addU8(Code.UINT8)\n            addU8(conversions.S32.toU8(n))\n          } else if (n < (s32\"1\" << s32\"16\")) {\n            addU8(Code.UINT16)\n            addU16(conversions.S32.toU16(n))\n          } else {\n            addU8(Code.UINT32)\n            addU32(conversions.S32.toU32(n))\n          }\n        }\n      }\n\n      def writeU64(n: U64): Unit = {\n        if (n > u64\"9223372036854775807\") {\n          addU8(Code.UINT64)\n          addU64(n)\n        } else {\n          writeS64(conversions.U64.toS64(n))\n        }\n      }\n\n      def writeS64(n: S64): Unit = {\n        if (n < -(s64\"1\" << s64\"5\")) {\n          if (n < -(s64\"1\" << s64\"15\")) {\n            if (n < -(s64\"1\" << s64\"31\")) {\n              addU8(Code.INT64)\n              addS64(n)\n            } else {\n              addU8(Code.INT32)\n              addS32(conversions.S64.toS32(n))\n            }\n          } else {\n            if (n < -(s64\"1\" << s64\"7\")) {\n              addU8(Code.INT16)\n              addS16(conversions.S64.toS16(n))\n            } else {\n              addU8(Code.INT8)\n              addS8(conversions.S64.toS8(n))\n            }\n          }\n        } else if (n < (s64\"1\" << s64\"7\")) {\n          addS8(conversions.S64.toS8(n))\n        } else {\n          if (n < (s64\"1\" << s64\"16\")) {\n            if (n < (s64\"1\" << s64\"8\")) {\n              addU8(Code.UINT8)\n              addU8(conversions.S64.toU8(n))\n            } else {\n              addU8(Code.UINT16)\n              addU16(conversions.S64.toU16(n))\n            }\n          } else {\n            if (n < (s64\"1\" << s64\"32\")) {\n              addU8(Code.UINT32)\n              addU32(conversions.S64.toU32(n))\n            } else {\n              addU8(Code.UINT64)\n              addU64(conversions.S64.toU64(n))\n            }\n          }\n        }\n      }\n\n      def writeZ(n: Z): Unit = {\n        if (-9223372036854775808L <= n && n <= 9223372036854775807L) {\n          writeS64(conversions.Z.toS64(n))\n        } else if (0 <= n && n <= z\"18446744073709551615\") {\n          writeU64(conversions.Z.toU64(n))\n        } else {\n          writeBinary(conversions.Z.toBinary(n))\n        }\n      }\n\n      def writeF32(n: F32): Unit = {\n        addU8(Code.FLOAT32)\n        addU32(conversions.F32.toRawU32(n))\n      }\n\n      def writeF64(n: F64): Unit = {\n        addU8(Code.FLOAT64)\n        addU64(conversions.F64.toRawU64(n))\n      }\n\n      def writeArrayHeader(n: Z): Unit = {\n        Contract(Requires(0 <= n, n <= z\"4294967295\"))\n\n        if (n < 16 /* 1 << 4 */ ) {\n          addU8(Code.FIXARRAY_PREFIX | conversions.Z.toU8(n))\n        } else if (n < 65536 /* 1 << 16 */ ) {\n          addU8(Code.ARRAY16)\n          addS16(conversions.Z.toS16(n))\n        } else {\n          addU8(Code.ARRAY32)\n          addS32(conversions.Z.toS32(n))\n        }\n      }\n\n      def writeBinary(array: ISZ[U8]): Unit = {\n        Contract(Requires(0 <= array.size, array.size <= z\"4294967295\"))\n\n        val len = array.size\n        if (len < 256 /* 1 << 8 */ ) {\n          addU8(Code.BIN8)\n          addU8(conversions.Z.toU8(len))\n        } else if (len < 65536 /* 1 << 16 */ ) {\n          addU8(Code.BIN16)\n          addU16(conversions.Z.toU16(len))\n        } else {\n          addU8(Code.BIN32)\n          addU32(conversions.Z.toU32(len))\n        }\n        for (e <- array) {\n          addU8(e)\n        }\n      }\n\n      def writeNil(): Unit = {\n        addU8(Code.NIL)\n      }\n\n      def writeMapHeader(n: Z): Unit = {\n        Contract(Requires(0 <= n, n <= z\"4294967295\"))\n        if (n < 16 /* 1 << 4 */ ) {\n          addU8(Code.FIXMAP_PREFIX | conversions.Z.toU8(n))\n        } else if (n < 65536 /* 1 << 16 */ ) {\n          addU8(Code.MAP16)\n          addU16(conversions.Z.toU16(n))\n        } else {\n          addU8(Code.MAP32)\n          addU32(conversions.Z.toU32(n))\n        }\n      }\n\n      def writeB(b: B): Unit = {\n        addU8(if (b) Code.TRUE else Code.FALSE)\n      }\n\n      def writeStringNoPool(s: String): Unit = {\n        val size = s.size\n        writeZ(size)\n        val cis = conversions.String.toCis(s)\n        for (i <- z\"0\" until size) {\n          writeU32(conversions.C.toU32(cis(i)))\n        }\n      }\n\n      /*\n      def writeStringNoPool(s: String): Unit = {\n        val bis = conversions.String.toBis(s)\n        val len = bis.size\n        if (len < 32 /* 1 << 5 */ ) {\n          addU8(Code.FIXSTR_PREFIX | conversions.Z.toU8(len))\n        } else if (len < 256 /* 1 << 8 */ ) {\n          addU8(Code.STR8)\n          addU8(conversions.Z.toU8(len))\n        } else if (len < 65536 /* 1 << 16 */ ) {\n          addU8(Code.STR16)\n          addU16(conversions.Z.toU16(len))\n        } else {\n          addU8(Code.STR32)\n          addU32(conversions.Z.toU32(len))\n        }\n        for (e <- bis) {\n          addU8(e)\n        }\n      }\n       */\n\n      def writeString(s: String): Unit = {\n        Contract(Requires(0 <= s.size * 2, s.size * 2 <= z\"4294967295\"))\n\n        if (pooling) {\n          val i = addString(s)\n          writeZ(i)\n        } else {\n          writeStringNoPool(s)\n        }\n      }\n\n      def writeExtTypeHeader(extType: S8, payloadLen: Z): Unit = {\n        Contract(Requires(extType >= s8\"0\", 0 <= payloadLen, payloadLen <= z\"4294967295\"))\n\n        if (payloadLen < 256 /* 1 << 8 */ ) {\n          payloadLen match {\n            case z\"1\" =>\n              addU8(Code.FIXEXT1)\n              addS8(extType)\n            case z\"2\" =>\n              addU8(Code.FIXEXT2)\n              addS8(extType)\n            case z\"4\" =>\n              addU8(Code.FIXEXT4)\n              addS8(extType)\n            case z\"8\" =>\n              addU8(Code.FIXEXT8)\n              addS8(extType)\n            case z\"16\" =>\n              addU8(Code.FIXEXT16)\n              addS8(extType)\n            case _ =>\n              addU8(Code.EXT8)\n              addU8(conversions.Z.toU8(payloadLen))\n              addS8(extType)\n          }\n        } else if (payloadLen < 65536 /* 1 << 16 */ ) {\n          addU8(Code.EXT16)\n          addU16(conversions.Z.toU16(payloadLen))\n          addS8(extType)\n        } else {\n          addU8(Code.EXT32)\n          addU32(conversions.Z.toU32(payloadLen))\n          addS8(extType)\n        }\n      }\n\n      def writePayload(data: ISZ[U8]): Unit = {\n        for (e <- data) {\n          addU8(e)\n        }\n      }\n\n      def writePosition(o: message.Position): Unit = {\n        o match {\n          case o: message.PosInfo if pooling =>\n            writeB(T)\n            writeDocInfo(o.info)\n            writeU64(o.offsetLength)\n          case _ =>\n            writeB(F)\n            writeOption(o.uriOpt, writeString _)\n            writeU32(conversions.Z.toU32(o.beginLine))\n            writeU32(conversions.Z.toU32(o.beginColumn))\n            writeU32(conversions.Z.toU32(o.endLine))\n            writeU32(conversions.Z.toU32(o.endColumn))\n            writeU32(conversions.Z.toU32(o.offset))\n            writeU32(conversions.Z.toU32(o.length))\n        }\n      }\n\n      def writeDocInfoNoPool(o: message.DocInfo): Unit = {\n        writeOption(o.uriOpt, writeString _)\n        writeISZ(o.lineOffsets, writeU32 _)\n      }\n\n      def writeDocInfo(o: message.DocInfo): Unit = {\n        if (pooling) {\n          val n: Z = docInfoPool.get(o) match {\n            case Some(m) => m\n            case _ =>\n              val m = docInfoPool.size\n              docInfoPool = docInfoPool + o ~> m\n              m\n          }\n          writeZ(n)\n        } else {\n          writeDocInfoNoPool(o)\n        }\n      }\n\n    }\n\n  }\n\n  @record trait Reader {\n\n    def init(): Unit\n\n    def error(offset: Z, msg: String): Unit\n\n    def curr: Z\n\n    def readB(): B\n\n    def readC(): C = {\n      val n = readU32()\n      return conversions.U32.toC(n)\n    }\n\n    def readZ(): Z\n\n    def expectZ(n: Z): Unit\n\n    @pure def fix8(n: Z): Z = {\n      if (n > 127) {\n        return n - 256\n      }\n      return n\n    }\n\n    def readZ8(): Z8 = {\n      val n = readZ()\n      return conversions.Z.toZ8(fix8(n))\n    }\n\n    def readZ16(): Z16 = {\n      val n = readZ()\n      return conversions.Z.toZ16(n)\n    }\n\n    def readZ32(): Z32 = {\n      val n = readZ()\n      return conversions.Z.toZ32(n)\n    }\n\n    def readZ64(): Z64 = {\n      val n = readZ()\n      return conversions.Z.toZ64(n)\n    }\n\n    def readN(): N = {\n      val n = readZ()\n      return conversions.Z.toN(n)\n    }\n\n    def readN8(): N8 = {\n      val n = readZ()\n      return conversions.Z.toN8(n)\n    }\n\n    def readN16(): N16 = {\n      val n = readZ()\n      return conversions.Z.toN16(n)\n    }\n\n    def readN32(): N32 = {\n      val n = readZ()\n      return conversions.Z.toN32(n)\n    }\n\n    def readN64(): N64 = {\n      val n = readZ()\n      return conversions.Z.toN64(n)\n    }\n\n    def readS8(): S8 = {\n      val n = readZ()\n      return conversions.Z.toS8(fix8(n))\n    }\n\n    def readS16(): S16 = {\n      val n = readZ()\n      return conversions.Z.toS16(n)\n    }\n\n    def readS32(): S32 = {\n      val n = readZ()\n      return conversions.Z.toS32(n)\n    }\n\n    def readS64(): S64 = {\n      val n = readZ()\n      return conversions.Z.toS64(n)\n    }\n\n    def readU8(): U8 = {\n      val n = readZ()\n      return conversions.Z.toU8(n)\n    }\n\n    def readU16(): U16 = {\n      val n = readZ()\n      return conversions.Z.toU16(n)\n    }\n\n    def readU32(): U32 = {\n      val n = readZ()\n      return conversions.Z.toU32(n)\n    }\n\n    def readU64(): U64 = {\n      val n = readZ()\n      return conversions.Z.toU64(n)\n    }\n\n    def readR(): R\n\n    def readF32(): F32\n\n    def readF64(): F64\n\n    def readString(): String\n\n    def readOption[T](f: () => T): Option[T] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        return None[T]()\n      } else {\n        val o = f()\n        return Some[T](o)\n      }\n    }\n\n    def readMOption[T](f: () => T): MOption[T] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        return MNone[T]()\n      } else {\n        val o = f()\n        return MSome[T](o)\n      }\n    }\n\n    def readEither[L, R](l: () => L, r: () => R): Either[L, R] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        val o = r()\n        return Either.Right(o)\n      } else {\n        val o = l()\n        return Either.Left(o)\n      }\n    }\n\n    def readMEither[L, R](l: () => L, r: () => R): MEither[L, R] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        val o = r()\n        return MEither.Right(o)\n      } else {\n        val o = l()\n        return MEither.Left(o)\n      }\n    }\n\n    def readISZ[E](f: () => E): IS[Z, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ8[E](f: () => E): IS[Z8, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ16[E](f: () => E): IS[Z16, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ32[E](f: () => E): IS[Z32, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ64[E](f: () => E): IS[Z64, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN[E](f: () => E): IS[N, E] = {\n      val size = readArrayHeader()\n      var r = IS[N, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN8[E](f: () => E): IS[N8, E] = {\n      val size = readArrayHeader()\n      var r = IS[N8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN16[E](f: () => E): IS[N16, E] = {\n      val size = readArrayHeader()\n      var r = IS[N16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN32[E](f: () => E): IS[N32, E] = {\n      val size = readArrayHeader()\n      var r = IS[N32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN64[E](f: () => E): IS[N64, E] = {\n      val size = readArrayHeader()\n      var r = IS[N64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS8[E](f: () => E): IS[S8, E] = {\n      val size = readArrayHeader()\n      var r = IS[S8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS16[E](f: () => E): IS[S16, E] = {\n      val size = readArrayHeader()\n      var r = IS[S16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS32[E](f: () => E): IS[S32, E] = {\n      val size = readArrayHeader()\n      var r = IS[S32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS64[E](f: () => E): IS[S64, E] = {\n      val size = readArrayHeader()\n      var r = IS[S64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU8[E](f: () => E): IS[U8, E] = {\n      val size = readArrayHeader()\n      var r = IS[U8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU16[E](f: () => E): IS[U16, E] = {\n      val size = readArrayHeader()\n      var r = IS[U16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU32[E](f: () => E): IS[U32, E] = {\n      val size = readArrayHeader()\n      var r = IS[U32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU64[E](f: () => E): IS[U64, E] = {\n      val size = readArrayHeader()\n      var r = IS[U64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ[E](f: () => E): MS[Z, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ8[E](f: () => E): MS[Z8, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ16[E](f: () => E): MS[Z16, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ32[E](f: () => E): MS[Z32, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ64[E](f: () => E): MS[Z64, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN[E](f: () => E): MS[N, E] = {\n      val size = readArrayHeader()\n      var r = MS[N, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN8[E](f: () => E): MS[N8, E] = {\n      val size = readArrayHeader()\n      var r = MS[N8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN16[E](f: () => E): MS[N16, E] = {\n      val size = readArrayHeader()\n      var r = MS[N16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN32[E](f: () => E): MS[N32, E] = {\n      val size = readArrayHeader()\n      var r = MS[N32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN64[E](f: () => E): MS[N64, E] = {\n      val size = readArrayHeader()\n      var r = MS[N64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS8[E](f: () => E): MS[S8, E] = {\n      val size = readArrayHeader()\n      var r = MS[S8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS16[E](f: () => E): MS[S16, E] = {\n      val size = readArrayHeader()\n      var r = MS[S16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS32[E](f: () => E): MS[S32, E] = {\n      val size = readArrayHeader()\n      var r = MS[S32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i =
  #701 = Utf8                i + 1\n      }\n      return r\n    }\n\n    def readMSS64[E](f: () => E): MS[S64, E] = {\n      val size = readArrayHeader()\n      var r = MS[S64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU8[E](f: () => E): MS[U8, E] = {\n      val size = readArrayHeader()\n      var r = MS[U8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU16[E](f: () => E): MS[U16, E] = {\n      val size = readArrayHeader()\n      var r = MS[U16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU32[E](f: () => E): MS[U32, E] = {\n      val size = readArrayHeader()\n      var r = MS[U32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU64[E](f: () => E): MS[U64, E] = {\n      val size = readArrayHeader()\n      var r = MS[U64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readZS(): ZS = {\n      val r = readMSZ(readZ _)\n      return r\n    }\n\n    def readMap[K, T](f: () => K, g: () => T): Map[K, T] = {\n      val size = readMapHeader()\n      var r = Map.empty[K, T]\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readSet[T](f: () => T): Set[T] = {\n      val size = readArrayHeader()\n      var r = Set.empty[T]\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashMap[K, T](f: () => K, g: () => T): HashMap[K, T] = {\n      val size = readMapHeader()\n      var r = HashMap.emptyInit[K, T](size)\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSet[T](f: () => T): HashSet[T] = {\n      val size = readArrayHeader()\n      var r = HashSet.emptyInit[T](size)\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSMap[K, T](f: () => K, g: () => T): HashSMap[K, T] = {\n      val size = readMapHeader()\n      var r = HashSMap.emptyInit[K, T](size)\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSSet[T](f: () => T): HashSSet[T] = {\n      val size = readArrayHeader()\n      var r = HashSSet.emptyInit[T](size)\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readStack[T](f: () => T): Stack[T] = {\n      val s = readISZ(f)\n      return Stack(s)\n    }\n\n    def readBag[T](f: () => T): Bag[T] = {\n      val map = readMap(f, readZ _)\n      return Bag(map)\n    }\n\n    def readHashBag[T](f: () => T): HashBag[T] = {\n      val map = readHashMap(f, readZ _)\n      return HashBag(map)\n    }\n\n    def readHashSBag[T](f: () => T): HashSBag[T] = {\n      val map = readHashSMap(f, readZ _)\n      return HashSBag(map)\n    }\n\n    def readPoset[T](f: () => T): Poset[T] = {\n      def g(): HashSSet[Poset.Index] = {\n        val r = readHashSSet(readZ _)\n        return r\n      }\n      val nodesInverse = readISZ(f)\n      val map = readHashSMap(readZ _, g _)\n      val size = nodesInverse.size\n      var nodes = HashSMap.emptyInit[T, Poset.Index](size)\n      var parents = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var children = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var i: Z = 0\n      for (node <- nodesInverse) {\n        nodes = nodes + node ~> nodes.size\n        parents = parents + i ~> Poset.Internal.emptySet\n        children = children + i ~> Poset.Internal.emptySet\n        i = i + 1\n      }\n      var r = Poset[T](nodes, nodesInverse, parents, children)\n      for (e <- map.entries) {\n        val (n, s) = e\n        r = Poset.Internal.addParents(r, n, s.elements)\n      }\n      return r\n    }\n\n    def readGraph[W, E](f: () => W, g: () => E): Graph[W, E] = {\n      def readEdge(): Graph.Internal.Edge[E] = {\n        val src = readZ()\n        val dest = readZ()\n        val isPlain = skipIfNil()\n        if (isPlain) {\n          return Graph.Internal.Edge.Plain(src, dest)\n        } else {\n          val data = g()\n          return Graph.Internal.Edge.Data(src, dest, data)\n        }\n      }\n      val multi = readB()\n      val nodesInverse = readISZ(f)\n      val edges = readISZ(readEdge _)\n      var r: Graph[W, E] = if (multi) Graph.emptyMulti else Graph.empty\n      for (node <- nodesInverse) {\n        r = r * node\n      }\n      for (e <- edges) {\n        r = Graph.Internal.addEdge(r, e)\n      }\n      return r\n    }\n\n    def readUnionFind[T](f: () => T): UnionFind[T] = {\n      val elementsInverse = readISZ(f)\n      val parentOf = readISZ(readZ _)\n      val sizeOf = readISZ(readZ _)\n      var elements = HashSMap.emptyInit[T, UnionFind.Index](elementsInverse.size)\n      for (e <- elementsInverse) {\n        elements = elements + e ~> elements.size\n      }\n      return UnionFind(elements, elementsInverse, parentOf, sizeOf)\n    }\n\n    def readMessage(): message.Message = {\n      val level = message.Level.byOrdinal(readZ()).getOrElse(message.Level.InternalError)\n      val posOpt = readOption(readPosition _)\n      val kind = readString()\n      val text = readString()\n      return message.Message(level, posOpt, kind, text)\n    }\n\n    def readPosition(): message.Position = {\n      val isPosInfo = readB()\n      if (isPosInfo) {\n        val info = readDocInfo()\n        val offsetLength = readU64()\n        return message.PosInfo(info, offsetLength)\n      } else {\n        val uriOpt = readOption(readString _)\n        val beginLine = readU32()\n        val beginColumn = readU32()\n        val endLine = readU32()\n        val endColumn = readU32()\n        val offset = readU32()\n        val length = readU32()\n        return message.FlatPos(uriOpt, beginLine, beginColumn, endLine, endColumn, offset, length)\n      }\n    }\n\n    def readDocInfo(): message.DocInfo\n\n    def readArrayHeader(): Z\n\n    def readBinary(): ISZ[U8]\n\n    def skipIfNil(): B\n\n    def readMapHeader(): Z\n\n    def readExtTypeHeader(): Option[(S8, Z)]\n\n    def readPayload(n: Z): ISZ[U8]\n\n    def skip(n: Z): Unit\n  }\n\n  @datatype class ErrorMsg(val offset: Z, val message: String)\n\n  object Reader {\n\n    @record class Impl(val buf: ISZ[U8], var curr: Z) extends Reader {\n      var pooling: B = F\n      var stringPool: MSZ[String] = MSZ()\n      var docInfoPool: MSZ[message.DocInfo] = MSZ()\n\n      var errorOpt: Option[ErrorMsg] = None()\n\n      var initialized: B = F\n\n      def init(): Unit = {\n        initialized = T\n        val r = peek()\n        pooling = Code.isExt(r)\n        if (pooling) {\n          var pOpt = readExtTypeHeader()\n          pOpt match {\n            case Some((t, size)) =>\n              assert(t == StringPoolExtType)\n              stringPool = MSZ.create(size, \"\")\n              var i = 0\n              while (i < size) {\n                val s = readStringNoPool()\n                stringPool(i) = s\n                i = i + 1\n              }\n            case _ =>\n          }\n          pOpt = readExtTypeHeader()\n          pOpt match {\n            case Some((t, size)) =>\n              assert(t == DocInfoExtType)\n              docInfoPool = MSZ.create(size, message.DocInfo(None(), ISZ()))\n              var i = 0\n              while (i < size) {\n                val docInfo = readDocInfoNoPool()\n                docInfoPool(i) = docInfo\n                i = i + 1\n              }\n            case _ =>\n          }\n        }\n      }\n\n      def peek(): U8 = {\n        if (errorOpt.nonEmpty) {\n          return u8\"0\"\n        }\n        if (curr >= buf.size) {\n          error(curr, \"Attempted to read more byte than available.\")\n          return u8\"0\"\n        }\n        return buf(curr)\n      }\n\n      def read8(): U8 = {\n        assert(initialized, \"MessagePack.Reader.init() has not been called.\")\n        val r = peek()\n        skip(1)\n        return r\n      }\n\n      def read16(): U16 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        return (conversions.U8.toU16(ch1) << u16\"8\") +\n          conversions.U8.toU16(ch2)\n      }\n\n      def read32(): U32 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        val ch3 = read8()\n        val ch4 = read8()\n        return (conversions.U8.toU32(ch1) << u32\"24\") +\n          (conversions.U8.toU32(ch2) << u32\"16\") +\n          (conversions.U8.toU32(ch3) << u32\"8\") +\n          conversions.U8.toU32(ch4)\n      }\n\n      def read64(): U64 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        val ch3 = read8()\n        val ch4 = read8()\n        val ch5 = read8()\n        val ch6 = read8()\n        val ch7 = read8()\n        val ch8 = read8()\n        return (conversions.U8.toU64(ch1) << u64\"56\") +\n          (conversions.U8.toU64(ch2) << u64\"48\") +\n          (conversions.U8.toU64(ch3) << u64\"40\") +\n          (conversions.U8.toU64(ch4) << u64\"32\") +\n          (conversions.U8.toU64(ch5) << u64\"24\") +\n          (conversions.U8.toU64(ch6) << u64\"16\") +\n          (conversions.U8.toU64(ch7) << u64\"8\") +\n          conversions.U8.toU64(ch8)\n      }\n\n      def error(offset: Z, msg: String): Unit = {\n        errorOpt match {\n          case Some(_) =>\n          case _ => errorOpt = Some(ErrorMsg(offset, msg))\n        }\n      }\n\n      def readB(): B = {\n        val code = read8()\n        code match {\n          case Code.TRUE => return T\n          case Code.FALSE => return F\n          case _ => error(curr - 1, s\"Expecting a B, but found code $code.\"); return F\n        }\n      }\n\n      def readZ(): Z = {\n        val code = read8()\n        if (Code.isFixInt(code)) {\n          return conversions.S8.toZ(conversions.U8.toRawS8(code))\n        }\n        code match {\n          case Code.INT8 =>\n            val n = read8()\n            return conversions.S8.toZ(conversions.U8.toRawS8(n))\n          case Code.INT16 =>\n            val n = read16()\n            return conversions.S16.toZ(conversions.U16.toRawS16(n))\n          case Code.INT32 =>\n            val n = read32()\n            return conversions.S32.toZ(conversions.U32.toRawS32(n))\n          case Code.INT64 =>\n            val n = read64()\n            return conversions.S64.toZ(conversions.U64.toRawS64(n))\n          case Code.UINT8 =>\n            val n = read8()\n            return conversions.U8.toZ(n)\n          case Code.UINT16 =>\n            val n = read16()\n            return conversions.U16.toZ(n)\n          case Code.UINT32 =>\n            val n = read32()\n            return conversions.U32.toZ(n)\n          case Code.UINT64 =>\n            val n = read64()\n            return conversions.U64.toZ(n)\n          case _ =>\n            if (code == Code.BIN8 || code == Code.BIN16 || code == Code.BIN32) {\n              skip(-1)\n              val bin = readBinary()\n              return conversions.Z.fromBinary(bin)\n            } else {\n              error(curr - 1, s\"Expecting an integer, but found code $code.\")\n              return 0\n            }\n        }\n      }\n\n      def expectZ(n: Z): Unit = {\n        val start = curr\n        val m = readZ()\n        if (n != m) {\n          error(start, s\"Expecting $n, but found $m.\")\n        }\n      }\n\n      def readR(): R = {\n        val start = curr\n        val s = readString()\n        R(s) match {\n          case Some(r) => return r\n          case _ => error(start, s\"Expecting a R, but found $s.\"); return r\"0\"\n        }\n      }\n\n      def readF32(): F32 = {\n        val code = read8()\n        code match {\n          case Code.FLOAT32 =>\n          case _ => error(curr - 1, s\"Expecting a F32, but found code $code.\"); return 0f\n        }\n        val n = read32()\n        return conversions.U32.toRawF32(n)\n      }\n\n      def readF64(): F64 = {\n        val code = read8()\n        code match {\n          case Code.FLOAT64 =>\n          case _ => error(curr - 1, s\"Expecting a F64, but found code $code.\"); return 0d\n        }\n        val n = read64()\n        return conversions.U64.toRawF64(n)\n      }\n\n      def readStringNoPool(): String = {\n        val size = readZ()\n        val ms = MSZ.create[C](size, \'\\u0000\')\n        for (i <- z\"0\" until size) {\n          val c = readU32()\n          ms(i) = conversions.U32.toC(c)\n        }\n        return conversions.String.fromCms(ms)\n      }\n\n      /*\n      def readStringNoPool(): String = {\n        val code = read8()\n        val len: Z = {\n          var r: Z = 0\n          if (Code.isFixStr(code)) {\n            r = conversions.U8.toZ(u8\"0x1F\" & code)\n          } else {\n            code match {\n              case Code.STR8 =>\n                val n = read8()\n                r = conversions.U8.toZ(n)\n              case Code.STR16 =>\n                val n = read16()\n                r = conversions.U16.toZ(n)\n              case Code.STR32 =>\n                val n = read32()\n                r = conversions.U32.toZ(n)\n              case _ => halt(s\"Expecting a String, but found $code\")\n            }\n          }\n          r\n        }\n        val a = MSZ.create(len, u8\"0\")\n        var i = 0\n        while (i < len) {\n          a(i) = read8()\n          i = i + 1\n        }\n        return conversions.String.fromBms(a)\n      }\n       */\n\n      def readDocInfo(): message.DocInfo = {\n        if (pooling) {\n          val n = readZ()\n          return docInfoPool(n)\n        } else {\n          val r = readDocInfoNoPool()\n          return r\n        }\n      }\n\n      def readDocInfoNoPool(): message.DocInfo = {\n        val uriOpt = readOption(readString _)\n        val lineOffsets = readISZ(readU32 _)\n        return message.DocInfo(uriOpt, lineOffsets)\n      }\n\n      def readString(): String = {\n        if (pooling) {\n          val index = readZ()\n          return stringPool(index)\n        } else {\n          val r = readStringNoPool()\n          return r\n        }\n      }\n\n      def readArrayHeader(): Z = {\n        val code = read8()\n        if (Code.isFixedArray(code)) {\n          return conversions.U8.toZ(code & u8\"0x0F\")\n        } else {\n          code match {\n            case Code.ARRAY16 =>\n              val r = read16()\n              return conversions.U16.toZ(r)\n            case Code.ARRAY32 =>\n              val r = read32()\n              return conversions.U32.toZ(r)\n            case _ => error(curr - 1, s\"Expecting an array, but found code $code\"); return 0\n          }\n        }\n      }\n\n      def readBinary(): ISZ[U8] = {\n        val code = read8()\n        val len: Z = {\n          var r: Z = 0\n          if (Code.isFixedRaw(code)) {\n            r = conversions.U8.toZ(u8\"0x1F\" & code)\n          } else {\n            code match {\n              case Code.BIN8 =>\n                val n = read8()\n                r = conversions.U8.toZ(n)\n              case Code.BIN16 =>\n                val n = read16()\n                r = conversions.U16.toZ(n)\n              case Code.BIN32 =>\n                val n = read32()\n                r = conversions.U32.toZ(n)\n              case _ => error(curr - 1, s\"Expecting a binary, but found $code\"); return ISZ()\n            }\n          }\n          r\n        }\n        val a = MSZ.create(len, u8\"0\")\n        var i = 0\n        while (i < len) {\n          a(i) = read8()\n          i = i + 1\n        }\n        return a.toIS\n      }\n\n      def skipIfNil(): B = {\n        if (errorOpt.nonEmpty) {\n          return T\n        }\n        val n = peek()\n        val r = n == Code.NIL\n        if (r) {\n          skip(1)\n        }\n        return r\n      }\n\n      def readMapHeader(): Z = {\n        val code = read8()\n        if (Code.isFixedMap(code)) {\n          return conversions.U8.toZ(code & u8\"0x0F\")\n        } else {\n          code match {\n            case Code.MAP16 =>\n              val r = read16()\n              return conversions.U16.toZ(r)\n            case Code.MAP32 =>\n              val r = read32()\n              return conversions.U32.toZ(r)\n            case _ => error(curr - 1, s\"Expecting a map, but found code $code\"); return 0\n          }\n        }\n      }\n\n      def readExtTypeHeader(): Option[(S8, Z)] = {\n        val code = read8()\n        code match {\n          case Code.FIXEXT1 =>\n            val extType = readS8()\n            return Some((extType, 1))\n          case Code.FIXEXT2 =>\n            val extType = readS8()\n            return Some((extType, 2))\n          case Code.FIXEXT4 =>\n            val extType = readS8()\n            return Some((extType, 4))\n          case Code.FIXEXT8 =>\n            val extType = readS8()\n            return Some((extType, 8))\n          case Code.FIXEXT16 =>\n            val extType = readS8()\n            return Some((extType, 16))\n          case Code.EXT8 =>\n            val n = read8()\n            val length = conversions.U8.toZ(n & u8\"0xFF\")\n            val extType = readS8()\n            return Some((extType, length))\n          case Code.EXT16 =>\n            val n = read16()\n            val length = conversions.U16.toZ(n & u16\"0xFFFF\")\n            val extType = readS8()\n            return Some((extType, length))\n          case Code.EXT32 =>\n            val length = conversions.U32.toZ(read32())\n            val extType = readS8()\n            return Some((extType, length))\n          case _ => error(curr - 1, s\"Expecting an ext type, but found code $code\"); return None()\n        }\n      }\n\n      def readPayload(n: Z): ISZ[U8] = {\n        val r = MSZ.create(n, u8\"0\")\n        var i = 0\n        while (i < n) {\n          r(i) = read8()\n          i = i + 1\n        }\n        return r.toIS\n      }\n\n      def skip(n: Z): Unit = {\n        Contract(Requires(0 <= curr + n, curr + n <= buf.size))\n        curr = curr + n\n      }\n    }\n\n  }\n\n  def writer(pooling: B): Writer.Impl = {\n    return Writer.Impl(pooling, MS.create(1024, u8\"0\"), 0)\n  }\n\n  def reader(data: ISZ[U8]): Reader.Impl = {\n    return Reader.Impl(data, 0)\n  }\n\n  @ext(\"MessagePackFun_Ext\") object Fun {\n    def writePure0[R](f: () => R @pure): ISZ[U8] = $\n    def readPure0[R](reader: Reader.Impl, f: ISZ[U8]): () => R @pure = $\n\n    def write0[R](f: () => R): ISZ[U8] = $\n    def read0[R](reader: Reader.Impl, f: ISZ[U8]): () => R = $\n\n    def writePure1[T1, R](f: T1 => R @pure): ISZ[U8] = $\n    def readPure1[T1, R](reader: Reader.Impl, f: ISZ[U8]): T1 => R @pure = $\n\n    def write1[T1, R](f: T1 => R): ISZ[U8] = $\n    def read1[T1, R](reader: Reader.Impl, f: ISZ[U8]): T1 => R = $\n    def writePure2[T1, T2, R](f: (T1, T2) => R @pure): ISZ[U8] = $\n    def readPure2[T1, T2, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2) => R @pure = $\n\n    def write2[T1, T2, R](f: (T1, T2) => R): ISZ[U8] = $\n    def read2[T1, T2, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2) => R = $\n\n    def writePure3[T1, T2, T3, R](f: (T1, T2, T3) => R @pure): ISZ[U8] = $\n    def readPure3[T1, T2, T3, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3) => R @pure = $\n\n    def write3[T1, T2, T3, R](f: (T1, T2, T3) => R): ISZ[U8] = $\n    def read3[T1, T2, T3, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3) => R = $\n\n    def writePure4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R @pure): ISZ[U8] = $\n    def readPure4[T1, T2, T3, T4, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4) => R @pure = $\n\n    def write4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R): ISZ[U8] = $\n    def read4[T1, T2, T3, T4, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4) => R = $\n\n    def writePure5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R @pure): ISZ[U8] = $\n    def readPure5[T1, T2, T3, T4, T5, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5) => R @pure = $\n\n    def write5[T1, T2, T3, T4, T5, R](
  #702 = String             #701          //  i + 1\n      }\n      return r\n    }\n\n    def readMSS64[E](f: () => E): MS[S64, E] = {\n      val size = readArrayHeader()\n      var r = MS[S64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU8[E](f: () => E): MS[U8, E] = {\n      val size = readArrayHeader()\n      var r = MS[U8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU16[E](f: () => E): MS[U16, E] = {\n      val size = readArrayHeader()\n      var r = MS[U16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU32[E](f: () => E): MS[U32, E] = {\n      val size = readArrayHeader()\n      var r = MS[U32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU64[E](f: () => E): MS[U64, E] = {\n      val size = readArrayHeader()\n      var r = MS[U64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readZS(): ZS = {\n      val r = readMSZ(readZ _)\n      return r\n    }\n\n    def readMap[K, T](f: () => K, g: () => T): Map[K, T] = {\n      val size = readMapHeader()\n      var r = Map.empty[K, T]\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readSet[T](f: () => T): Set[T] = {\n      val size = readArrayHeader()\n      var r = Set.empty[T]\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashMap[K, T](f: () => K, g: () => T): HashMap[K, T] = {\n      val size = readMapHeader()\n      var r = HashMap.emptyInit[K, T](size)\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSet[T](f: () => T): HashSet[T] = {\n      val size = readArrayHeader()\n      var r = HashSet.emptyInit[T](size)\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSMap[K, T](f: () => K, g: () => T): HashSMap[K, T] = {\n      val size = readMapHeader()\n      var r = HashSMap.emptyInit[K, T](size)\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSSet[T](f: () => T): HashSSet[T] = {\n      val size = readArrayHeader()\n      var r = HashSSet.emptyInit[T](size)\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readStack[T](f: () => T): Stack[T] = {\n      val s = readISZ(f)\n      return Stack(s)\n    }\n\n    def readBag[T](f: () => T): Bag[T] = {\n      val map = readMap(f, readZ _)\n      return Bag(map)\n    }\n\n    def readHashBag[T](f: () => T): HashBag[T] = {\n      val map = readHashMap(f, readZ _)\n      return HashBag(map)\n    }\n\n    def readHashSBag[T](f: () => T): HashSBag[T] = {\n      val map = readHashSMap(f, readZ _)\n      return HashSBag(map)\n    }\n\n    def readPoset[T](f: () => T): Poset[T] = {\n      def g(): HashSSet[Poset.Index] = {\n        val r = readHashSSet(readZ _)\n        return r\n      }\n      val nodesInverse = readISZ(f)\n      val map = readHashSMap(readZ _, g _)\n      val size = nodesInverse.size\n      var nodes = HashSMap.emptyInit[T, Poset.Index](size)\n      var parents = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var children = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var i: Z = 0\n      for (node <- nodesInverse) {\n        nodes = nodes + node ~> nodes.size\n        parents = parents + i ~> Poset.Internal.emptySet\n        children = children + i ~> Poset.Internal.emptySet\n        i = i + 1\n      }\n      var r = Poset[T](nodes, nodesInverse, parents, children)\n      for (e <- map.entries) {\n        val (n, s) = e\n        r = Poset.Internal.addParents(r, n, s.elements)\n      }\n      return r\n    }\n\n    def readGraph[W, E](f: () => W, g: () => E): Graph[W, E] = {\n      def readEdge(): Graph.Internal.Edge[E] = {\n        val src = readZ()\n        val dest = readZ()\n        val isPlain = skipIfNil()\n        if (isPlain) {\n          return Graph.Internal.Edge.Plain(src, dest)\n        } else {\n          val data = g()\n          return Graph.Internal.Edge.Data(src, dest, data)\n        }\n      }\n      val multi = readB()\n      val nodesInverse = readISZ(f)\n      val edges = readISZ(readEdge _)\n      var r: Graph[W, E] = if (multi) Graph.emptyMulti else Graph.empty\n      for (node <- nodesInverse) {\n        r = r * node\n      }\n      for (e <- edges) {\n        r = Graph.Internal.addEdge(r, e)\n      }\n      return r\n    }\n\n    def readUnionFind[T](f: () => T): UnionFind[T] = {\n      val elementsInverse = readISZ(f)\n      val parentOf = readISZ(readZ _)\n      val sizeOf = readISZ(readZ _)\n      var elements = HashSMap.emptyInit[T, UnionFind.Index](elementsInverse.size)\n      for (e <- elementsInverse) {\n        elements = elements + e ~> elements.size\n      }\n      return UnionFind(elements, elementsInverse, parentOf, sizeOf)\n    }\n\n    def readMessage(): message.Message = {\n      val level = message.Level.byOrdinal(readZ()).getOrElse(message.Level.InternalError)\n      val posOpt = readOption(readPosition _)\n      val kind = readString()\n      val text = readString()\n      return message.Message(level, posOpt, kind, text)\n    }\n\n    def readPosition(): message.Position = {\n      val isPosInfo = readB()\n      if (isPosInfo) {\n        val info = readDocInfo()\n        val offsetLength = readU64()\n        return message.PosInfo(info, offsetLength)\n      } else {\n        val uriOpt = readOption(readString _)\n        val beginLine = readU32()\n        val beginColumn = readU32()\n        val endLine = readU32()\n        val endColumn = readU32()\n        val offset = readU32()\n        val length = readU32()\n        return message.FlatPos(uriOpt, beginLine, beginColumn, endLine, endColumn, offset, length)\n      }\n    }\n\n    def readDocInfo(): message.DocInfo\n\n    def readArrayHeader(): Z\n\n    def readBinary(): ISZ[U8]\n\n    def skipIfNil(): B\n\n    def readMapHeader(): Z\n\n    def readExtTypeHeader(): Option[(S8, Z)]\n\n    def readPayload(n: Z): ISZ[U8]\n\n    def skip(n: Z): Unit\n  }\n\n  @datatype class ErrorMsg(val offset: Z, val message: String)\n\n  object Reader {\n\n    @record class Impl(val buf: ISZ[U8], var curr: Z) extends Reader {\n      var pooling: B = F\n      var stringPool: MSZ[String] = MSZ()\n      var docInfoPool: MSZ[message.DocInfo] = MSZ()\n\n      var errorOpt: Option[ErrorMsg] = None()\n\n      var initialized: B = F\n\n      def init(): Unit = {\n        initialized = T\n        val r = peek()\n        pooling = Code.isExt(r)\n        if (pooling) {\n          var pOpt = readExtTypeHeader()\n          pOpt match {\n            case Some((t, size)) =>\n              assert(t == StringPoolExtType)\n              stringPool = MSZ.create(size, \"\")\n              var i = 0\n              while (i < size) {\n                val s = readStringNoPool()\n                stringPool(i) = s\n                i = i + 1\n              }\n            case _ =>\n          }\n          pOpt = readExtTypeHeader()\n          pOpt match {\n            case Some((t, size)) =>\n              assert(t == DocInfoExtType)\n              docInfoPool = MSZ.create(size, message.DocInfo(None(), ISZ()))\n              var i = 0\n              while (i < size) {\n                val docInfo = readDocInfoNoPool()\n                docInfoPool(i) = docInfo\n                i = i + 1\n              }\n            case _ =>\n          }\n        }\n      }\n\n      def peek(): U8 = {\n        if (errorOpt.nonEmpty) {\n          return u8\"0\"\n        }\n        if (curr >= buf.size) {\n          error(curr, \"Attempted to read more byte than available.\")\n          return u8\"0\"\n        }\n        return buf(curr)\n      }\n\n      def read8(): U8 = {\n        assert(initialized, \"MessagePack.Reader.init() has not been called.\")\n        val r = peek()\n        skip(1)\n        return r\n      }\n\n      def read16(): U16 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        return (conversions.U8.toU16(ch1) << u16\"8\") +\n          conversions.U8.toU16(ch2)\n      }\n\n      def read32(): U32 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        val ch3 = read8()\n        val ch4 = read8()\n        return (conversions.U8.toU32(ch1) << u32\"24\") +\n          (conversions.U8.toU32(ch2) << u32\"16\") +\n          (conversions.U8.toU32(ch3) << u32\"8\") +\n          conversions.U8.toU32(ch4)\n      }\n\n      def read64(): U64 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        val ch3 = read8()\n        val ch4 = read8()\n        val ch5 = read8()\n        val ch6 = read8()\n        val ch7 = read8()\n        val ch8 = read8()\n        return (conversions.U8.toU64(ch1) << u64\"56\") +\n          (conversions.U8.toU64(ch2) << u64\"48\") +\n          (conversions.U8.toU64(ch3) << u64\"40\") +\n          (conversions.U8.toU64(ch4) << u64\"32\") +\n          (conversions.U8.toU64(ch5) << u64\"24\") +\n          (conversions.U8.toU64(ch6) << u64\"16\") +\n          (conversions.U8.toU64(ch7) << u64\"8\") +\n          conversions.U8.toU64(ch8)\n      }\n\n      def error(offset: Z, msg: String): Unit = {\n        errorOpt match {\n          case Some(_) =>\n          case _ => errorOpt = Some(ErrorMsg(offset, msg))\n        }\n      }\n\n      def readB(): B = {\n        val code = read8()\n        code match {\n          case Code.TRUE => return T\n          case Code.FALSE => return F\n          case _ => error(curr - 1, s\"Expecting a B, but found code $code.\"); return F\n        }\n      }\n\n      def readZ(): Z = {\n        val code = read8()\n        if (Code.isFixInt(code)) {\n          return conversions.S8.toZ(conversions.U8.toRawS8(code))\n        }\n        code match {\n          case Code.INT8 =>\n            val n = read8()\n            return conversions.S8.toZ(conversions.U8.toRawS8(n))\n          case Code.INT16 =>\n            val n = read16()\n            return conversions.S16.toZ(conversions.U16.toRawS16(n))\n          case Code.INT32 =>\n            val n = read32()\n            return conversions.S32.toZ(conversions.U32.toRawS32(n))\n          case Code.INT64 =>\n            val n = read64()\n            return conversions.S64.toZ(conversions.U64.toRawS64(n))\n          case Code.UINT8 =>\n            val n = read8()\n            return conversions.U8.toZ(n)\n          case Code.UINT16 =>\n            val n = read16()\n            return conversions.U16.toZ(n)\n          case Code.UINT32 =>\n            val n = read32()\n            return conversions.U32.toZ(n)\n          case Code.UINT64 =>\n            val n = read64()\n            return conversions.U64.toZ(n)\n          case _ =>\n            if (code == Code.BIN8 || code == Code.BIN16 || code == Code.BIN32) {\n              skip(-1)\n              val bin = readBinary()\n              return conversions.Z.fromBinary(bin)\n            } else {\n              error(curr - 1, s\"Expecting an integer, but found code $code.\")\n              return 0\n            }\n        }\n      }\n\n      def expectZ(n: Z): Unit = {\n        val start = curr\n        val m = readZ()\n        if (n != m) {\n          error(start, s\"Expecting $n, but found $m.\")\n        }\n      }\n\n      def readR(): R = {\n        val start = curr\n        val s = readString()\n        R(s) match {\n          case Some(r) => return r\n          case _ => error(start, s\"Expecting a R, but found $s.\"); return r\"0\"\n        }\n      }\n\n      def readF32(): F32 = {\n        val code = read8()\n        code match {\n          case Code.FLOAT32 =>\n          case _ => error(curr - 1, s\"Expecting a F32, but found code $code.\"); return 0f\n        }\n        val n = read32()\n        return conversions.U32.toRawF32(n)\n      }\n\n      def readF64(): F64 = {\n        val code = read8()\n        code match {\n          case Code.FLOAT64 =>\n          case _ => error(curr - 1, s\"Expecting a F64, but found code $code.\"); return 0d\n        }\n        val n = read64()\n        return conversions.U64.toRawF64(n)\n      }\n\n      def readStringNoPool(): String = {\n        val size = readZ()\n        val ms = MSZ.create[C](size, \'\\u0000\')\n        for (i <- z\"0\" until size) {\n          val c = readU32()\n          ms(i) = conversions.U32.toC(c)\n        }\n        return conversions.String.fromCms(ms)\n      }\n\n      /*\n      def readStringNoPool(): String = {\n        val code = read8()\n        val len: Z = {\n          var r: Z = 0\n          if (Code.isFixStr(code)) {\n            r = conversions.U8.toZ(u8\"0x1F\" & code)\n          } else {\n            code match {\n              case Code.STR8 =>\n                val n = read8()\n                r = conversions.U8.toZ(n)\n              case Code.STR16 =>\n                val n = read16()\n                r = conversions.U16.toZ(n)\n              case Code.STR32 =>\n                val n = read32()\n                r = conversions.U32.toZ(n)\n              case _ => halt(s\"Expecting a String, but found $code\")\n            }\n          }\n          r\n        }\n        val a = MSZ.create(len, u8\"0\")\n        var i = 0\n        while (i < len) {\n          a(i) = read8()\n          i = i + 1\n        }\n        return conversions.String.fromBms(a)\n      }\n       */\n\n      def readDocInfo(): message.DocInfo = {\n        if (pooling) {\n          val n = readZ()\n          return docInfoPool(n)\n        } else {\n          val r = readDocInfoNoPool()\n          return r\n        }\n      }\n\n      def readDocInfoNoPool(): message.DocInfo = {\n        val uriOpt = readOption(readString _)\n        val lineOffsets = readISZ(readU32 _)\n        return message.DocInfo(uriOpt, lineOffsets)\n      }\n\n      def readString(): String = {\n        if (pooling) {\n          val index = readZ()\n          return stringPool(index)\n        } else {\n          val r = readStringNoPool()\n          return r\n        }\n      }\n\n      def readArrayHeader(): Z = {\n        val code = read8()\n        if (Code.isFixedArray(code)) {\n          return conversions.U8.toZ(code & u8\"0x0F\")\n        } else {\n          code match {\n            case Code.ARRAY16 =>\n              val r = read16()\n              return conversions.U16.toZ(r)\n            case Code.ARRAY32 =>\n              val r = read32()\n              return conversions.U32.toZ(r)\n            case _ => error(curr - 1, s\"Expecting an array, but found code $code\"); return 0\n          }\n        }\n      }\n\n      def readBinary(): ISZ[U8] = {\n        val code = read8()\n        val len: Z = {\n          var r: Z = 0\n          if (Code.isFixedRaw(code)) {\n            r = conversions.U8.toZ(u8\"0x1F\" & code)\n          } else {\n            code match {\n              case Code.BIN8 =>\n                val n = read8()\n                r = conversions.U8.toZ(n)\n              case Code.BIN16 =>\n                val n = read16()\n                r = conversions.U16.toZ(n)\n              case Code.BIN32 =>\n                val n = read32()\n                r = conversions.U32.toZ(n)\n              case _ => error(curr - 1, s\"Expecting a binary, but found $code\"); return ISZ()\n            }\n          }\n          r\n        }\n        val a = MSZ.create(len, u8\"0\")\n        var i = 0\n        while (i < len) {\n          a(i) = read8()\n          i = i + 1\n        }\n        return a.toIS\n      }\n\n      def skipIfNil(): B = {\n        if (errorOpt.nonEmpty) {\n          return T\n        }\n        val n = peek()\n        val r = n == Code.NIL\n        if (r) {\n          skip(1)\n        }\n        return r\n      }\n\n      def readMapHeader(): Z = {\n        val code = read8()\n        if (Code.isFixedMap(code)) {\n          return conversions.U8.toZ(code & u8\"0x0F\")\n        } else {\n          code match {\n            case Code.MAP16 =>\n              val r = read16()\n              return conversions.U16.toZ(r)\n            case Code.MAP32 =>\n              val r = read32()\n              return conversions.U32.toZ(r)\n            case _ => error(curr - 1, s\"Expecting a map, but found code $code\"); return 0\n          }\n        }\n      }\n\n      def readExtTypeHeader(): Option[(S8, Z)] = {\n        val code = read8()\n        code match {\n          case Code.FIXEXT1 =>\n            val extType = readS8()\n            return Some((extType, 1))\n          case Code.FIXEXT2 =>\n            val extType = readS8()\n            return Some((extType, 2))\n          case Code.FIXEXT4 =>\n            val extType = readS8()\n            return Some((extType, 4))\n          case Code.FIXEXT8 =>\n            val extType = readS8()\n            return Some((extType, 8))\n          case Code.FIXEXT16 =>\n            val extType = readS8()\n            return Some((extType, 16))\n          case Code.EXT8 =>\n            val n = read8()\n            val length = conversions.U8.toZ(n & u8\"0xFF\")\n            val extType = readS8()\n            return Some((extType, length))\n          case Code.EXT16 =>\n            val n = read16()\n            val length = conversions.U16.toZ(n & u16\"0xFFFF\")\n            val extType = readS8()\n            return Some((extType, length))\n          case Code.EXT32 =>\n            val length = conversions.U32.toZ(read32())\n            val extType = readS8()\n            return Some((extType, length))\n          case _ => error(curr - 1, s\"Expecting an ext type, but found code $code\"); return None()\n        }\n      }\n\n      def readPayload(n: Z): ISZ[U8] = {\n        val r = MSZ.create(n, u8\"0\")\n        var i = 0\n        while (i < n) {\n          r(i) = read8()\n          i = i + 1\n        }\n        return r.toIS\n      }\n\n      def skip(n: Z): Unit = {\n        Contract(Requires(0 <= curr + n, curr + n <= buf.size))\n        curr = curr + n\n      }\n    }\n\n  }\n\n  def writer(pooling: B): Writer.Impl = {\n    return Writer.Impl(pooling, MS.create(1024, u8\"0\"), 0)\n  }\n\n  def reader(data: ISZ[U8]): Reader.Impl = {\n    return Reader.Impl(data, 0)\n  }\n\n  @ext(\"MessagePackFun_Ext\") object Fun {\n    def writePure0[R](f: () => R @pure): ISZ[U8] = $\n    def readPure0[R](reader: Reader.Impl, f: ISZ[U8]): () => R @pure = $\n\n    def write0[R](f: () => R): ISZ[U8] = $\n    def read0[R](reader: Reader.Impl, f: ISZ[U8]): () => R = $\n\n    def writePure1[T1, R](f: T1 => R @pure): ISZ[U8] = $\n    def readPure1[T1, R](reader: Reader.Impl, f: ISZ[U8]): T1 => R @pure = $\n\n    def write1[T1, R](f: T1 => R): ISZ[U8] = $\n    def read1[T1, R](reader: Reader.Impl, f: ISZ[U8]): T1 => R = $\n    def writePure2[T1, T2, R](f: (T1, T2) => R @pure): ISZ[U8] = $\n    def readPure2[T1, T2, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2) => R @pure = $\n\n    def write2[T1, T2, R](f: (T1, T2) => R): ISZ[U8] = $\n    def read2[T1, T2, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2) => R = $\n\n    def writePure3[T1, T2, T3, R](f: (T1, T2, T3) => R @pure): ISZ[U8] = $\n    def readPure3[T1, T2, T3, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3) => R @pure = $\n\n    def write3[T1, T2, T3, R](f: (T1, T2, T3) => R): ISZ[U8] = $\n    def read3[T1, T2, T3, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3) => R = $\n\n    def writePure4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R @pure): ISZ[U8] = $\n    def readPure4[T1, T2, T3, T4, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4) => R @pure = $\n\n    def write4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R): ISZ[U8] = $\n    def read4[T1, T2, T3, T4, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4) => R = $\n\n    def writePure5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R @pure): ISZ[U8] = $\n    def readPure5[T1, T2, T3, T4, T5, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5) => R @pure = $\n\n    def write5[T1, T2, T3, T4, T5, R](
  #703 = Utf8               f: (T1, T2, T3, T4, T5) => R): ISZ[U8] = $\n    def read5[T1, T2, T3, T4, T5, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5) => R = $\n\n    def writePure6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R @pure): ISZ[U8] = $\n    def readPure6[T1, T2, T3, T4, T5, T6, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6) => R @pure = $\n\n    def write6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R): ISZ[U8] = $\n    def read6[T1, T2, T3, T4, T5, T6, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6) => R = $\n\n    def writePure7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R @pure): ISZ[U8] = $\n    def readPure7[T1, T2, T3, T4, T5, T6, T7, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7) => R @pure = $\n\n    def write7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R): ISZ[U8] = $\n    def read7[T1, T2, T3, T4, T5, T6, T7, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7) => R = $\n\n    def writePure8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure): ISZ[U8] = $\n    def readPure8[T1, T2, T3, T4, T5, T6, T7, T8, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure = $\n\n    def write8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R): ISZ[U8] = $\n    def read8[T1, T2, T3, T4, T5, T6, T7, T8, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8) => R = $\n\n    def writePure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure): ISZ[U8] = $\n    def readPure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure = $\n\n    def write9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R): ISZ[U8] = $\n    def read9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R = $\n\n    def writePure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure): ISZ[U8] = $\n    def readPure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure = $\n\n    def write10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R): ISZ[U8] = $\n    def read10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R = $\n\n    def writePure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure): ISZ[U8] = $\n    def readPure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure = $\n\n    def write11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R): ISZ[U8] = $\n    def read11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R = $\n\n    def writePure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure): ISZ[U8] = $\n    def readPure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure = $\n\n    def write12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R): ISZ[U8] = $\n    def read12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R = $\n\n    def writePure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure): ISZ[U8] = $\n    def readPure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure = $\n\n    def write13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R): ISZ[U8] = $\n    def read13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R = $\n\n    def writePure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure): ISZ[U8] = $\n    def readPure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure = $\n\n    def write14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R): ISZ[U8] = $\n    def read14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R = $\n\n    def writePure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure): ISZ[U8] = $\n    def readPure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure = $\n\n    def write15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R): ISZ[U8] = $\n    def read15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R = $\n\n    def writePure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure): ISZ[U8] = $\n    def readPure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure = $\n\n    def write16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R): ISZ[U8] = $\n    def read16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R = $\n\n    def writePure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure): ISZ[U8] = $\n    def readPure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure = $\n\n    def write17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R): ISZ[U8] = $\n    def read17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R = $\n\n    def writePure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure): ISZ[U8] = $\n    def readPure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure = $\n\n    def write18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R): ISZ[U8] = $\n    def read18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R = $\n\n    def writePure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure): ISZ[U8] = $\n    def readPure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure = $\n\n    def write19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R): ISZ[U8] = $\n    def read19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R = $\n\n    def writePure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure): ISZ[U8] = $\n    def readPure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure = $\n\n    def write20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R): ISZ[U8] = $\n    def read20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R = $\n\n    def writePure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure): ISZ[U8] = $\n    def readPure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure = $\n\n    def write21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R): ISZ[U8] = $\n    def read21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R = $\n\n    def writePure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure): ISZ[U8] = $\n    def readPure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure = $\n\n    def write22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R): ISZ[U8] = $\n    def read22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R = $\n  }\n}\n
  #704 = String             #703          // f: (T1, T2, T3, T4, T5) => R): ISZ[U8] = $\n    def read5[T1, T2, T3, T4, T5, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5) => R = $\n\n    def writePure6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R @pure): ISZ[U8] = $\n    def readPure6[T1, T2, T3, T4, T5, T6, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6) => R @pure = $\n\n    def write6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R): ISZ[U8] = $\n    def read6[T1, T2, T3, T4, T5, T6, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6) => R = $\n\n    def writePure7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R @pure): ISZ[U8] = $\n    def readPure7[T1, T2, T3, T4, T5, T6, T7, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7) => R @pure = $\n\n    def write7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R): ISZ[U8] = $\n    def read7[T1, T2, T3, T4, T5, T6, T7, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7) => R = $\n\n    def writePure8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure): ISZ[U8] = $\n    def readPure8[T1, T2, T3, T4, T5, T6, T7, T8, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure = $\n\n    def write8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R): ISZ[U8] = $\n    def read8[T1, T2, T3, T4, T5, T6, T7, T8, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8) => R = $\n\n    def writePure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure): ISZ[U8] = $\n    def readPure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure = $\n\n    def write9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R): ISZ[U8] = $\n    def read9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R = $\n\n    def writePure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure): ISZ[U8] = $\n    def readPure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure = $\n\n    def write10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R): ISZ[U8] = $\n    def read10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R = $\n\n    def writePure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure): ISZ[U8] = $\n    def readPure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure = $\n\n    def write11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R): ISZ[U8] = $\n    def read11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R = $\n\n    def writePure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure): ISZ[U8] = $\n    def readPure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure = $\n\n    def write12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R): ISZ[U8] = $\n    def read12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R = $\n\n    def writePure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure): ISZ[U8] = $\n    def readPure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure = $\n\n    def write13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R): ISZ[U8] = $\n    def read13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R = $\n\n    def writePure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure): ISZ[U8] = $\n    def readPure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure = $\n\n    def write14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R): ISZ[U8] = $\n    def read14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R = $\n\n    def writePure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure): ISZ[U8] = $\n    def readPure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure = $\n\n    def write15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R): ISZ[U8] = $\n    def read15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R = $\n\n    def writePure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure): ISZ[U8] = $\n    def readPure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure = $\n\n    def write16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R): ISZ[U8] = $\n    def read16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R = $\n\n    def writePure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure): ISZ[U8] = $\n    def readPure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure = $\n\n    def write17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R): ISZ[U8] = $\n    def read17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R = $\n\n    def writePure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure): ISZ[U8] = $\n    def readPure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure = $\n\n    def write18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R): ISZ[U8] = $\n    def read18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R = $\n\n    def writePure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure): ISZ[U8] = $\n    def readPure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure = $\n\n    def write19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R): ISZ[U8] = $\n    def read19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R = $\n\n    def writePure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure): ISZ[U8] = $\n    def readPure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure = $\n\n    def write20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R): ISZ[U8] = $\n    def read20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R = $\n\n    def writePure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure): ISZ[U8] = $\n    def readPure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure = $\n\n    def write21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R): ISZ[U8] = $\n    def read21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R = $\n\n    def writePure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure): ISZ[U8] = $\n    def readPure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure = $\n\n    def write22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R): ISZ[U8] = $\n    def read22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R = $\n  }\n}\n
  #705 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject justification {\n\n  @just def Premise: Unit = $\n\n  @just def Auto(stepNumbers: ISZ[StepId]): Unit = $\n\n  @just def Lift(app: Unit): Unit = $\n\n  object natded {\n\n    object prop {\n\n      @just(\"andI\") def AndI(p: StepId, q: StepId): Unit = $\n\n      @just(\"andE1\") def AndE1(pAndQ: StepId): Unit = $\n\n      @just(\"andE2\") def AndE2(pAndQ: StepId): Unit = $\n\n      @just(\"orI1\") def OrI1(p: StepId): Unit = $\n\n      @just(\"orI2\") def OrI2(q: StepId): Unit = $\n\n      @just def OrE(pOrQ: StepId, pToRSub: StepId, qToRSub: StepId): Unit = $\n\n      @just def ImplyI(assumePToQSub: StepId): Unit = $\n\n      @just(\"implyE\") def ImplyE(pImplyQ: StepId, q: StepId): Unit = $\n\n      @just def NegI(assumePToBottomSub: StepId): Unit = $\n\n      @just(\"negE\") def NegE(p: StepId, notP: StepId): Unit = $\n\n      @just def BottomE(bottom: StepId): Unit = $\n\n      @just def PbC(assumeNotRToBottom: StepId): Unit = $\n\n      @pure def andI(p: B, q: B): Unit = {\n        Deduce((p, q) |- (p & q))\n      }\n\n      @pure def andE1(p: B, q: B): Unit = {\n        Deduce((p & q) |- p)\n      }\n\n      @pure def andE2(p: B, q: B): Unit = {\n        Deduce((p & q) |- q)\n      }\n\n      @pure def orI1(p: B, q: B): Unit = {\n        Deduce(p |- (p | q))\n      }\n\n      @pure def orI2(p: B, q: B): Unit = {\n        Deduce(q |- (p | q))\n      }\n\n      @pure def implyE(p: B, q: B): Unit = {\n        Deduce((p ->: q, p) |- q)\n      }\n\n      @pure def negE(p: B): Unit = {\n        Deduce((p, !p) |- F)\n      }\n    }\n\n    object pred {\n\n      @just def AllI(assumeAToAllSub: StepId): Unit = $\n\n      @just(\"allE\") def AllE[T](allP: StepId): Unit = $\n\n      @just(\"existsI\") def ExistsI[T](PE: StepId): Unit = $\n\n      @just def ExistsE[T](existsP: StepId, aPaToQSub: StepId): Unit = $\n\n      @pure def allE[T](P: T => B@pure, E: T): Unit = {\n        Deduce(All { (x: T) => P(x) } |- P(E))\n      }\n\n      @pure def existsI[T](P: T => B@pure, E: T): Unit = {\n        Deduce(P(E) |- Exists { (x: T) => P(x) })\n      }\n\n    }\n\n  }\n}\n
  #706 = String             #705          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject justification {\n\n  @just def Premise: Unit = $\n\n  @just def Auto(stepNumbers: ISZ[StepId]): Unit = $\n\n  @just def Lift(app: Unit): Unit = $\n\n  object natded {\n\n    object prop {\n\n      @just(\"andI\") def AndI(p: StepId, q: StepId): Unit = $\n\n      @just(\"andE1\") def AndE1(pAndQ: StepId): Unit = $\n\n      @just(\"andE2\") def AndE2(pAndQ: StepId): Unit = $\n\n      @just(\"orI1\") def OrI1(p: StepId): Unit = $\n\n      @just(\"orI2\") def OrI2(q: StepId): Unit = $\n\n      @just def OrE(pOrQ: StepId, pToRSub: StepId, qToRSub: StepId): Unit = $\n\n      @just def ImplyI(assumePToQSub: StepId): Unit = $\n\n      @just(\"implyE\") def ImplyE(pImplyQ: StepId, q: StepId): Unit = $\n\n      @just def NegI(assumePToBottomSub: StepId): Unit = $\n\n      @just(\"negE\") def NegE(p: StepId, notP: StepId): Unit = $\n\n      @just def BottomE(bottom: StepId): Unit = $\n\n      @just def PbC(assumeNotRToBottom: StepId): Unit = $\n\n      @pure def andI(p: B, q: B): Unit = {\n        Deduce((p, q) |- (p & q))\n      }\n\n      @pure def andE1(p: B, q: B): Unit = {\n        Deduce((p & q) |- p)\n      }\n\n      @pure def andE2(p: B, q: B): Unit = {\n        Deduce((p & q) |- q)\n      }\n\n      @pure def orI1(p: B, q: B): Unit = {\n        Deduce(p |- (p | q))\n      }\n\n      @pure def orI2(p: B, q: B): Unit = {\n        Deduce(q |- (p | q))\n      }\n\n      @pure def implyE(p: B, q: B): Unit = {\n        Deduce((p ->: q, p) |- q)\n      }\n\n      @pure def negE(p: B): Unit = {\n        Deduce((p, !p) |- F)\n      }\n    }\n\n    object pred {\n\n      @just def AllI(assumeAToAllSub: StepId): Unit = $\n\n      @just(\"allE\") def AllE[T](allP: StepId): Unit = $\n\n      @just(\"existsI\") def ExistsI[T](PE: StepId): Unit = $\n\n      @just def ExistsE[T](existsP: StepId, aPaToQSub: StepId): Unit = $\n\n      @pure def allE[T](P: T => B@pure, E: T): Unit = {\n        Deduce(All { (x: T) => P(x) } |- P(E))\n      }\n\n      @pure def existsI[T](P: T => B@pure, E: T): Unit = {\n        Deduce(P(E) |- Exists { (x: T) => P(x) })\n      }\n\n    }\n\n  }\n}\n
  #707 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSMap {\n\n  @pure def empty[K, T]: HashSMap[K, T] = {\n    return HashSMap(HashMap.empty, ISZ())\n  }\n\n  @pure def emptyInit[K, T](initialCapacity: Z): HashSMap[K, T] = {\n    return HashSMap(HashMap.emptyInit(initialCapacity), ISZ())\n  }\n\n  @pure def ++[I, K, T](s: IS[I, (K, T)]): HashSMap[K, T] = {\n    return HashSMap.emptyInit[K, T](s.size) ++ s\n  }\n\n}\n\n@datatype class HashSMap[K, T](val map: HashMap[K, T], val keys: ISZ[K]) {\n\n  @pure def size: Z = {\n    return keys.size\n  }\n\n  @pure def entries: ISZ[(K, T)] = {\n    return for (k <- keys) yield (k, map.get(k).get)\n  }\n\n  @pure def values: ISZ[T] = {\n    return for (k <- keys) yield map.get(k).get\n  }\n\n  @pure def keySet: ISZ[K] = {\n    return keys\n  }\n\n  @pure def valueSet: Set[T] = {\n    return Set.empty[T] ++ values\n  }\n\n  @pure def +(p: (K, T)): HashSMap[K, T] = {\n    val newMap = map + p\n    return HashSMap(newMap, if (newMap.size == map.size) keys else keys :+ p._1)\n  }\n\n  @pure def ++[I](entries: IS[I, (K, T)]): HashSMap[K, T] = {\n    if (entries.isEmpty) {\n      return this\n    }\n    var newMap = map\n    var newKeys = keys\n    for (kv <- entries) {\n      val oldNewMapSize = newMap.size\n      newMap = newMap + kv\n      if (newMap.size != oldNewMapSize) {\n        newKeys = newKeys :+ kv._1\n      }\n    }\n    return HashSMap(newMap, newKeys)\n  }\n\n  @pure def get(key: K): Option[T] = {\n    return map.get(key)\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    return map.entry(key)\n  }\n\n  @pure def --(keys: ISZ[K]): HashSMap[K, T] = {\n    return HashSMap(map -- keys, this.keys -- keys)\n  }\n\n  @pure def -(p: (K, T)): HashSMap[K, T] = {\n    return HashSMap(map - p, keys - p._1)\n  }\n\n  @pure def contains(key: K): B = {\n    return map.contains(key)\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEqual(other: HashSMap[K, T]): B = {\n    return map.isEqual(other.map)\n  }\n\n}\n
  #708 = String             #707          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSMap {\n\n  @pure def empty[K, T]: HashSMap[K, T] = {\n    return HashSMap(HashMap.empty, ISZ())\n  }\n\n  @pure def emptyInit[K, T](initialCapacity: Z): HashSMap[K, T] = {\n    return HashSMap(HashMap.emptyInit(initialCapacity), ISZ())\n  }\n\n  @pure def ++[I, K, T](s: IS[I, (K, T)]): HashSMap[K, T] = {\n    return HashSMap.emptyInit[K, T](s.size) ++ s\n  }\n\n}\n\n@datatype class HashSMap[K, T](val map: HashMap[K, T], val keys: ISZ[K]) {\n\n  @pure def size: Z = {\n    return keys.size\n  }\n\n  @pure def entries: ISZ[(K, T)] = {\n    return for (k <- keys) yield (k, map.get(k).get)\n  }\n\n  @pure def values: ISZ[T] = {\n    return for (k <- keys) yield map.get(k).get\n  }\n\n  @pure def keySet: ISZ[K] = {\n    return keys\n  }\n\n  @pure def valueSet: Set[T] = {\n    return Set.empty[T] ++ values\n  }\n\n  @pure def +(p: (K, T)): HashSMap[K, T] = {\n    val newMap = map + p\n    return HashSMap(newMap, if (newMap.size == map.size) keys else keys :+ p._1)\n  }\n\n  @pure def ++[I](entries: IS[I, (K, T)]): HashSMap[K, T] = {\n    if (entries.isEmpty) {\n      return this\n    }\n    var newMap = map\n    var newKeys = keys\n    for (kv <- entries) {\n      val oldNewMapSize = newMap.size\n      newMap = newMap + kv\n      if (newMap.size != oldNewMapSize) {\n        newKeys = newKeys :+ kv._1\n      }\n    }\n    return HashSMap(newMap, newKeys)\n  }\n\n  @pure def get(key: K): Option[T] = {\n    return map.get(key)\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    return map.entry(key)\n  }\n\n  @pure def --(keys: ISZ[K]): HashSMap[K, T] = {\n    return HashSMap(map -- keys, this.keys -- keys)\n  }\n\n  @pure def -(p: (K, T)): HashSMap[K, T] = {\n    return HashSMap(map - p, keys - p._1)\n  }\n\n  @pure def contains(key: K): B = {\n    return map.contains(key)\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEqual(other: HashSMap[K, T]): B = {\n    return map.isEqual(other.map)\n  }\n\n}\n
  #709 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n ∀ rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject SeqUtil {\n\n  object IS {\n\n    @strictpure def sizeEq[I, T](s: IS[I, T], size: Z): B = s.size == size\n\n    @strictpure def unique[I, T](s: IS[I, T]): B = ∀(s.indices)(i => ∀(s.indices)(j => (i != j) ->: (s(i) != s(j))))\n\n    @strictpure def pair1Eq[I, T1, T2](s1: IS[I, (T1, T2)], s2: IS[I, T1]): B =\n      sizeEq(s1, s2.size) && ∀(s1.indices)(i => s1(i)._1 == s2(i))\n\n    @strictpure def pair2Eq[I, T1, T2](s1: IS[I, (T1, T2)], s2: IS[I, T2]): B =\n      sizeEq(s1, s2.size) && ∀(s1.indices)(i => s1(i)._2 == s2(i))\n  }\n\n\n}\n
  #710 = String             #709          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n ∀ rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject SeqUtil {\n\n  object IS {\n\n    @strictpure def sizeEq[I, T](s: IS[I, T], size: Z): B = s.size == size\n\n    @strictpure def unique[I, T](s: IS[I, T]): B = ∀(s.indices)(i => ∀(s.indices)(j => (i != j) ->: (s(i) != s(j))))\n\n    @strictpure def pair1Eq[I, T1, T2](s1: IS[I, (T1, T2)], s2: IS[I, T1]): B =\n      sizeEq(s1, s2.size) && ∀(s1.indices)(i => s1(i)._1 == s2(i))\n\n    @strictpure def pair2Eq[I, T1, T2](s1: IS[I, (T1, T2)], s2: IS[I, T2]): B =\n      sizeEq(s1, s2.size) && ∀(s1.indices)(i => s1(i)._2 == s2(i))\n  }\n\n\n}\n
  #711 = Utf8               // #Sireum\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Li Haoyi (haoyi.sg@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n */\n\npackage org.sireum\n\n// Adapted from https://github.com/lihaoyi/geny\n\n@msig trait MJen[T] {\n\n  def generate(f: T => MJen.Action): MJen.Action\n\n  def foreach[V](f: T => V): Unit = {\n    def ap(o: T): MJen.Action = {\n      f(o)\n      return MJen.Continue\n    }\n\n    generate(ap _)\n  }\n\n  def find(f: T => B): MOption[T] = {\n    var result: MOption[T] = MNone()\n\n    def ap(o: T): MJen.Action = {\n      val r = f(o)\n      if (!r) {\n        return MJen.Continue\n      } else {\n        result = MSome(o)\n        return MJen.End\n      }\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  def exists(f: T => B): B = {\n    val r = find(f)\n    return r.nonEmpty\n  }\n\n  @pure def contains(o: T): B = {\n    return exists(e => e == o)\n  }\n\n  def forall(f: T => B): B = {\n    def ap(o: T): B = {\n      val r = f(o)\n      return !r\n    }\n    val r = exists(ap _)\n    return !r\n  }\n\n  @pure def count(): Z = {\n    return countIf(_ => T)\n  }\n\n  def countIf(p: T => B): Z = {\n    var result = 0\n\n    def ap(o: T): MJen.Action = {\n      val r = p(o)\n      if (r) {\n        result = result + 1\n      }\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  @pure def fold[U](initial: U, f: (U, T) => U@pure): U = {\n    return foldLeft(initial, f)\n  }\n\n  @pure def foldLeft[U](initial: U, f: (U, T) => U@pure): U = {\n    var r = initial\n\n    def ap(o: T): MJen.Action = {\n      r = f(r, o)\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def reduce(f: (T, T) => T@pure): MOption[T] = {\n    return reduceLeft(f)\n  }\n\n  @pure def reduceLeft(f: (T, T) => T@pure): MOption[T] = {\n    var r: MOption[T] = MNone()\n\n    def ap(o: T): MJen.Action = {\n      r = r match {\n        case MSome(prev) => MSome(f(prev, o))\n        case _ => MSome(o)\n      }\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def filter(p: T => B@pure): MJen[T] = {\n    return MJen.Internal.Filtered(this, p)\n  }\n\n  def withFilter(p: T => B): MJen[T] = {\n    return MJen.Internal.Filtered(this, p)\n  }\n\n  @pure def map[U](f: T => U@pure): MJen[U] = {\n    return MJen.Internal.Mapped(this, f)\n  }\n\n  @pure def flatMap[U](f: T => MJen[U]@pure): MJen[U] = {\n    return MJen.Internal.FlatMapped(this, f)\n  }\n\n  @pure def flatten[U](f: T => MJen[U]@pure): MJen[U] = {\n    return this.flatMap(o => f(o))\n  }\n\n  @pure def slice(start: Z, end: Z): MJen[T] = {\n    return MJen.Internal.Sliced(this, start, end)\n  }\n\n  @pure def take(n: Z): MJen[T] = {\n    return slice(0, n)\n  }\n\n  @pure def drop(n: Z): MJen[T] = {\n    return slice(n, -1)\n  }\n\n  @pure def takeWhile(p: T => B): MJen[T] = {\n    return MJen.Internal.TakeWhile(this, p)\n  }\n\n  @pure def dropWhile(p: T => B): MJen[T] = {\n    return MJen.Internal.DropWhile(this, p)\n  }\n\n  @pure def zipWithIndex: MJen[(T, Z)] = {\n    return MJen.Internal.ZipWithIndexed(this)\n  }\n\n  @pure def zip[U](other: MJen[U]): MJen[(T, U)] = {\n    return MJen.Internal.Zipped(this, other)\n  }\n\n  @pure def product[U](other: MJen[U]): MJen[(T, U)] = {\n    return MJen.Internal.Product(this, other)\n  }\n\n  @pure def ++(other: MJen[T]): MJen[T] = {\n    return MJen.Internal.Concat(this, other)\n  }\n\n  @pure def head: T = {\n    return take(1).toMSZ(0)\n  }\n\n  @pure def headOption: MOption[T] = {\n    val s = take(1).toMSZ\n    return if (s.isEmpty) MNone() else MSome(s(0))\n  }\n\n  @pure def toMSZ: MSZ[T] = {\n    val r = toMS(MSZ[T]())\n    return r\n  }\n\n  @pure def toMS[I](init: MS[I, T]): MS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def mkStringWrap(start: String, sep: String, end: String): String = {\n    return st\"$start${(toMSZ, sep)}$end\".render\n  }\n\n  @pure def mkString(sep: String): String = {\n    return mkStringWrap(\"\", sep, \"\")\n  }\n\n}\n\nobject MJen {\n\n  type Action = B\n  val Continue: Action = T\n  val End: Action = F\n\n  object Internal {\n\n    @record class ISImpl[I, T](val s: IS[I, T]) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($s)\"\n      }\n    }\n\n    @record class MSImpl[I, T](val s: MS[I, T]) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($s)\"\n      }\n    }\n\n    @record class MapImpl[K, T](val m: Map[K, T]) extends MJen[(K, T)] {\n      override def generate(f: ((K, T)) => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- m.entries) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($m)\"\n      }\n    }\n\n    @record class HashMapImpl[K, T](val m: HashMap[K, T]) extends MJen[(K, T)] {\n      override def generate(f: ((K, T)) => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (ms <- m.mapEntries) {\n          if (ms.nonEmpty) {\n            for (e <- ms.entries) {\n              last = f(e)\n              if (!last) {\n                return MJen.End\n              }\n            }\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($m)\"\n      }\n    }\n\n    @record class Filtered[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return MJen.Continue\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.filter($p)\"\n      }\n    }\n\n    @record class Mapped[U, T](val gen: MJen[T], val f: T => U@pure) extends MJen[U] {\n      override def generate(g: U => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          val r = g(f(o))\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.map($f)\"\n      }\n    }\n\n    @record class FlatMapped[U, T](val gen: MJen[T], val f: T => MJen[U]@pure) extends MJen[U] {\n      override def generate(g: U => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          def ap2(o2: U): MJen.Action = {\n            val r = g(o2)\n            return r\n          }\n\n          val r = f(o).generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.flatMap($f)\"\n      }\n    }\n\n    @record class Sliced[T](val gen: MJen[T], val start: Z, val end: Z) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var count = 0\n\n        def ap(o: T): MJen.Action = {\n          if (count < start) {\n            count = count + 1\n            return MJen.Continue\n          } else if (count < end || end < 0) {\n            count = count + 1\n            if (count != end) {\n              return f(o)\n            } else {\n              f(o)\n              return MJen.End\n            }\n          } else {\n            return MJen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return if (end < 0) s\"$gen.slice($start, ~)\" else s\"$gen.slice($start, $end)\"\n      }\n    }\n\n    @record class TakeWhile[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return MJen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.takeWhile($p)\"\n      }\n    }\n\n    @record class DropWhile[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var started = F\n\n        def ap(o: T): MJen.Action = {\n          if (!started) {\n            var r = p(o)\n            if (r) {\n              return MJen.Continue\n            } else {\n              started = T\n              r = f(o)\n              return r\n            }\n          } else {\n            val r = f(o)\n            return r\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.dropWhile($p)\"\n      }\n    }\n\n    @record class ZipWithIndexed[T](val gen: MJen[T]) extends MJen[(T, Z)] {\n      def generate(f: ((T, Z)) => MJen.Action): MJen.Action = {\n        var i = 0\n\n        def ap(o: T): MJen.Action = {\n          val r = f((o, i))\n          i = i + 1\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zipWithIndex\"\n      }\n    }\n\n    @record class Zipped[T, U](val gen: MJen[T], val gen2: MJen[U]) extends MJen[(T, U)] {\n      def generate(f: ((T, U)) => MJen.Action): MJen.Action = {\n        var g = gen\n        var g2 = gen2\n        var i = 1\n        while (true) {\n          (g.headOption, g2.headOption) match {\n            case (MSome(h), MSome(h2)) =>\n              val r = f((h, h2))\n              if (r) {\n                g = gen.drop(i)\n                g2 = gen2.drop(i)\n              } else {\n                return MJen.End\n              }\n            case _ => return MJen.End\n          }\n          i = i + 1\n        }\n        return MJen.End\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n    @record class Concat[T](val gen: MJen[T], val gen2: MJen[T]) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var r = gen.generate(f)\n        if (!r) {\n          return MJen.End\n        }\n        r = gen2.generate(f)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen ++ $gen2\"\n      }\n    }\n\n    @record class Product[T, U](val gen: MJen[T], val gen2: MJen[U]) extends MJen[(T, U)] {\n      def generate(f: ((T, U)) => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          def ap2(o2: U): MJen.Action = {\n            val r = f((o, o2))\n            return r\n          }\n\n          val r = gen2.generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n  }\n\n  @pure def IS[I, T](s: IS[I, T]): MJen[T] = {\n    return Internal.ISImpl(s)\n  }\n\n  @pure def MS[I, T](s: MS[I, T]): MJen[T] = {\n    return Internal.MSImpl(s)\n  }\n\n  @pure def Map[K, T](m: Map[K, T]): MJen[(K, T)] = {\n    return Internal.MapImpl(m)\n  }\n\n  @pure def Set[T](s: Set[T]): MJen[T] = {\n    return Internal.ISImpl(s.elements)\n  }\n\n  @pure def HashMap[K, T](m: HashMap[K, T]): MJen[(K, T)] = {\n    return Internal.HashMapImpl(m)\n  }\n\n  @pure def HashSet[T](s: HashSet[T]): MJen[T] = {\n    return Internal.HashMapImpl(s.map).map(p => p._1)\n  }\n\n  @pure def HashSMap[K, T](m: HashSMap[K, T]): MJen[(K, T)] = {\n    return IS(m.keys).map(k => (k, m.get(k).get))\n  }\n\n  @pure def HashSSet[T](s: HashSSet[T]): MJen[T] = {\n    return HashSMap(s.map).map(p => p._1)\n  }\n}\n
  #712 = String             #711          // // #Sireum\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Li Haoyi (haoyi.sg@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n */\n\npackage org.sireum\n\n// Adapted from https://github.com/lihaoyi/geny\n\n@msig trait MJen[T] {\n\n  def generate(f: T => MJen.Action): MJen.Action\n\n  def foreach[V](f: T => V): Unit = {\n    def ap(o: T): MJen.Action = {\n      f(o)\n      return MJen.Continue\n    }\n\n    generate(ap _)\n  }\n\n  def find(f: T => B): MOption[T] = {\n    var result: MOption[T] = MNone()\n\n    def ap(o: T): MJen.Action = {\n      val r = f(o)\n      if (!r) {\n        return MJen.Continue\n      } else {\n        result = MSome(o)\n        return MJen.End\n      }\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  def exists(f: T => B): B = {\n    val r = find(f)\n    return r.nonEmpty\n  }\n\n  @pure def contains(o: T): B = {\n    return exists(e => e == o)\n  }\n\n  def forall(f: T => B): B = {\n    def ap(o: T): B = {\n      val r = f(o)\n      return !r\n    }\n    val r = exists(ap _)\n    return !r\n  }\n\n  @pure def count(): Z = {\n    return countIf(_ => T)\n  }\n\n  def countIf(p: T => B): Z = {\n    var result = 0\n\n    def ap(o: T): MJen.Action = {\n      val r = p(o)\n      if (r) {\n        result = result + 1\n      }\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  @pure def fold[U](initial: U, f: (U, T) => U@pure): U = {\n    return foldLeft(initial, f)\n  }\n\n  @pure def foldLeft[U](initial: U, f: (U, T) => U@pure): U = {\n    var r = initial\n\n    def ap(o: T): MJen.Action = {\n      r = f(r, o)\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def reduce(f: (T, T) => T@pure): MOption[T] = {\n    return reduceLeft(f)\n  }\n\n  @pure def reduceLeft(f: (T, T) => T@pure): MOption[T] = {\n    var r: MOption[T] = MNone()\n\n    def ap(o: T): MJen.Action = {\n      r = r match {\n        case MSome(prev) => MSome(f(prev, o))\n        case _ => MSome(o)\n      }\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def filter(p: T => B@pure): MJen[T] = {\n    return MJen.Internal.Filtered(this, p)\n  }\n\n  def withFilter(p: T => B): MJen[T] = {\n    return MJen.Internal.Filtered(this, p)\n  }\n\n  @pure def map[U](f: T => U@pure): MJen[U] = {\n    return MJen.Internal.Mapped(this, f)\n  }\n\n  @pure def flatMap[U](f: T => MJen[U]@pure): MJen[U] = {\n    return MJen.Internal.FlatMapped(this, f)\n  }\n\n  @pure def flatten[U](f: T => MJen[U]@pure): MJen[U] = {\n    return this.flatMap(o => f(o))\n  }\n\n  @pure def slice(start: Z, end: Z): MJen[T] = {\n    return MJen.Internal.Sliced(this, start, end)\n  }\n\n  @pure def take(n: Z): MJen[T] = {\n    return slice(0, n)\n  }\n\n  @pure def drop(n: Z): MJen[T] = {\n    return slice(n, -1)\n  }\n\n  @pure def takeWhile(p: T => B): MJen[T] = {\n    return MJen.Internal.TakeWhile(this, p)\n  }\n\n  @pure def dropWhile(p: T => B): MJen[T] = {\n    return MJen.Internal.DropWhile(this, p)\n  }\n\n  @pure def zipWithIndex: MJen[(T, Z)] = {\n    return MJen.Internal.ZipWithIndexed(this)\n  }\n\n  @pure def zip[U](other: MJen[U]): MJen[(T, U)] = {\n    return MJen.Internal.Zipped(this, other)\n  }\n\n  @pure def product[U](other: MJen[U]): MJen[(T, U)] = {\n    return MJen.Internal.Product(this, other)\n  }\n\n  @pure def ++(other: MJen[T]): MJen[T] = {\n    return MJen.Internal.Concat(this, other)\n  }\n\n  @pure def head: T = {\n    return take(1).toMSZ(0)\n  }\n\n  @pure def headOption: MOption[T] = {\n    val s = take(1).toMSZ\n    return if (s.isEmpty) MNone() else MSome(s(0))\n  }\n\n  @pure def toMSZ: MSZ[T] = {\n    val r = toMS(MSZ[T]())\n    return r\n  }\n\n  @pure def toMS[I](init: MS[I, T]): MS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def mkStringWrap(start: String, sep: String, end: String): String = {\n    return st\"$start${(toMSZ, sep)}$end\".render\n  }\n\n  @pure def mkString(sep: String): String = {\n    return mkStringWrap(\"\", sep, \"\")\n  }\n\n}\n\nobject MJen {\n\n  type Action = B\n  val Continue: Action = T\n  val End: Action = F\n\n  object Internal {\n\n    @record class ISImpl[I, T](val s: IS[I, T]) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($s)\"\n      }\n    }\n\n    @record class MSImpl[I, T](val s: MS[I, T]) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($s)\"\n      }\n    }\n\n    @record class MapImpl[K, T](val m: Map[K, T]) extends MJen[(K, T)] {\n      override def generate(f: ((K, T)) => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- m.entries) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($m)\"\n      }\n    }\n\n    @record class HashMapImpl[K, T](val m: HashMap[K, T]) extends MJen[(K, T)] {\n      override def generate(f: ((K, T)) => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (ms <- m.mapEntries) {\n          if (ms.nonEmpty) {\n            for (e <- ms.entries) {\n              last = f(e)\n              if (!last) {\n                return MJen.End\n              }\n            }\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($m)\"\n      }\n    }\n\n    @record class Filtered[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return MJen.Continue\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.filter($p)\"\n      }\n    }\n\n    @record class Mapped[U, T](val gen: MJen[T], val f: T => U@pure) extends MJen[U] {\n      override def generate(g: U => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          val r = g(f(o))\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.map($f)\"\n      }\n    }\n\n    @record class FlatMapped[U, T](val gen: MJen[T], val f: T => MJen[U]@pure) extends MJen[U] {\n      override def generate(g: U => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          def ap2(o2: U): MJen.Action = {\n            val r = g(o2)\n            return r\n          }\n\n          val r = f(o).generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.flatMap($f)\"\n      }\n    }\n\n    @record class Sliced[T](val gen: MJen[T], val start: Z, val end: Z) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var count = 0\n\n        def ap(o: T): MJen.Action = {\n          if (count < start) {\n            count = count + 1\n            return MJen.Continue\n          } else if (count < end || end < 0) {\n            count = count + 1\n            if (count != end) {\n              return f(o)\n            } else {\n              f(o)\n              return MJen.End\n            }\n          } else {\n            return MJen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return if (end < 0) s\"$gen.slice($start, ~)\" else s\"$gen.slice($start, $end)\"\n      }\n    }\n\n    @record class TakeWhile[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return MJen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.takeWhile($p)\"\n      }\n    }\n\n    @record class DropWhile[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var started = F\n\n        def ap(o: T): MJen.Action = {\n          if (!started) {\n            var r = p(o)\n            if (r) {\n              return MJen.Continue\n            } else {\n              started = T\n              r = f(o)\n              return r\n            }\n          } else {\n            val r = f(o)\n            return r\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.dropWhile($p)\"\n      }\n    }\n\n    @record class ZipWithIndexed[T](val gen: MJen[T]) extends MJen[(T, Z)] {\n      def generate(f: ((T, Z)) => MJen.Action): MJen.Action = {\n        var i = 0\n\n        def ap(o: T): MJen.Action = {\n          val r = f((o, i))\n          i = i + 1\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zipWithIndex\"\n      }\n    }\n\n    @record class Zipped[T, U](val gen: MJen[T], val gen2: MJen[U]) extends MJen[(T, U)] {\n      def generate(f: ((T, U)) => MJen.Action): MJen.Action = {\n        var g = gen\n        var g2 = gen2\n        var i = 1\n        while (true) {\n          (g.headOption, g2.headOption) match {\n            case (MSome(h), MSome(h2)) =>\n              val r = f((h, h2))\n              if (r) {\n                g = gen.drop(i)\n                g2 = gen2.drop(i)\n              } else {\n                return MJen.End\n              }\n            case _ => return MJen.End\n          }\n          i = i + 1\n        }\n        return MJen.End\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n    @record class Concat[T](val gen: MJen[T], val gen2: MJen[T]) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var r = gen.generate(f)\n        if (!r) {\n          return MJen.End\n        }\n        r = gen2.generate(f)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen ++ $gen2\"\n      }\n    }\n\n    @record class Product[T, U](val gen: MJen[T], val gen2: MJen[U]) extends MJen[(T, U)] {\n      def generate(f: ((T, U)) => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          def ap2(o2: U): MJen.Action = {\n            val r = f((o, o2))\n            return r\n          }\n\n          val r = gen2.generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n  }\n\n  @pure def IS[I, T](s: IS[I, T]): MJen[T] = {\n    return Internal.ISImpl(s)\n  }\n\n  @pure def MS[I, T](s: MS[I, T]): MJen[T] = {\n    return Internal.MSImpl(s)\n  }\n\n  @pure def Map[K, T](m: Map[K, T]): MJen[(K, T)] = {\n    return Internal.MapImpl(m)\n  }\n\n  @pure def Set[T](s: Set[T]): MJen[T] = {\n    return Internal.ISImpl(s.elements)\n  }\n\n  @pure def HashMap[K, T](m: HashMap[K, T]): MJen[(K, T)] = {\n    return Internal.HashMapImpl(m)\n  }\n\n  @pure def HashSet[T](s: HashSet[T]): MJen[T] = {\n    return Internal.HashMapImpl(s.map).map(p => p._1)\n  }\n\n  @pure def HashSMap[K, T](m: HashSMap[K, T]): MJen[(K, T)] = {\n    return IS(m.keys).map(k => (k, m.get(k).get))\n  }\n\n  @pure def HashSSet[T](s: HashSSet[T]): MJen[T] = {\n    return HashSMap(s.map).map(p => p._1)\n  }\n}\n
  #713 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSSet {\n\n  @pure def empty[T]: HashSSet[T] = {\n    return HashSSet(HashSMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSSet[T] = {\n    return HashSSet(HashSMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSSet[T] = {\n    return HashSSet.emptyInit[T](s.size) ++ s\n  }\n}\n\n@datatype class HashSSet[T](val map: HashSMap[T, B]) {\n\n  @pure def +(e: T): HashSSet[T] = {\n    return HashSSet(map + e ~> T)\n  }\n\n  @pure def ++[I](is: IS[I, T]): HashSSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSSet[T] = {\n    return HashSSet(map - e ~> T)\n  }\n\n  @pure def --[I](is: IS[I, T]): HashSSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    return map.contains(e)\n  }\n\n  @pure def union(other: HashSSet[T]): HashSSet[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSSet[T]): HashSSet[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSSet[T]): HashSSet[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSSet[T]): HashSSet[T] = {\n    var r = HashSSet.emptyInit[T](size)\n    for (e <- other.map.keys) {\n      if (contains(e)) {\n        r = r + e\n      }\n    }\n    return r\n  }\n\n  @pure def \\(other: HashSSet[T]): HashSSet[T] = {\n    return this -- other.elements\n  }\n\n  @pure def isEqual(other: HashSSet[T]): B = {\n    return map.isEqual(other.map)\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    return map.size\n  }\n\n  @pure def elements: ISZ[T] = {\n    return map.keys\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
  #714 = String             #713          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSSet {\n\n  @pure def empty[T]: HashSSet[T] = {\n    return HashSSet(HashSMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSSet[T] = {\n    return HashSSet(HashSMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSSet[T] = {\n    return HashSSet.emptyInit[T](s.size) ++ s\n  }\n}\n\n@datatype class HashSSet[T](val map: HashSMap[T, B]) {\n\n  @pure def +(e: T): HashSSet[T] = {\n    return HashSSet(map + e ~> T)\n  }\n\n  @pure def ++[I](is: IS[I, T]): HashSSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSSet[T] = {\n    return HashSSet(map - e ~> T)\n  }\n\n  @pure def --[I](is: IS[I, T]): HashSSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    return map.contains(e)\n  }\n\n  @pure def union(other: HashSSet[T]): HashSSet[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSSet[T]): HashSSet[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSSet[T]): HashSSet[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSSet[T]): HashSSet[T] = {\n    var r = HashSSet.emptyInit[T](size)\n    for (e <- other.map.keys) {\n      if (contains(e)) {\n        r = r + e\n      }\n    }\n    return r\n  }\n\n  @pure def \\(other: HashSSet[T]): HashSSet[T] = {\n    return this -- other.elements\n  }\n\n  @pure def isEqual(other: HashSSet[T]): B = {\n    return map.isEqual(other.map)\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    return map.size\n  }\n\n  @pure def elements: ISZ[T] = {\n    return map.keys\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
  #715 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.bitcodec\n\nimport org.sireum._\nimport org.sireum.ops.Bits.Context\n\nobject Runtime {\n\n  @msig trait Composite {\n\n    def wellFormed: Z\n\n    def decode(input: ISZ[B], context: Context): Unit\n\n    def encode(output: MSZ[B], context: Context): Unit\n\n  }\n\n  @msig trait MComposite {\n\n    def wellFormed: Z\n\n    def decode(input: MSZ[B], context: Context): Unit\n\n    def encode(output: MSZ[B], context: Context): Unit\n\n  }\n\n}\n
  #716 = String             #715          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.bitcodec\n\nimport org.sireum._\nimport org.sireum.ops.Bits.Context\n\nobject Runtime {\n\n  @msig trait Composite {\n\n    def wellFormed: Z\n\n    def decode(input: ISZ[B], context: Context): Unit\n\n    def encode(output: MSZ[B], context: Context): Unit\n\n  }\n\n  @msig trait MComposite {\n\n    def wellFormed: Z\n\n    def decode(input: MSZ[B], context: Context): Unit\n\n    def encode(output: MSZ[B], context: Context): Unit\n\n  }\n\n}\n
  #717 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.bitcodec\n\nimport org.sireum._\n\n\n@datatype trait Spec {\n\n  def name: String\n\n  def isScalar: B\n\n  def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z]\n\n  @memoize def maxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n    return computeMaxSizeOpt(enumMaxSize)\n  }\n\n  def toJSON(isCompact: B): String = {\n    return Spec.Ext.toJSON(this, isCompact)\n  }\n\n}\n\nobject Spec {\n\n  type Concat = ConcatImpl\n  type Union[T] = UnionImpl[T]\n  type PredUnion = PredUnionImpl\n  type GenUnion = GenUnionImpl\n\n  @datatype trait Base extends Spec\n\n  @datatype trait Composite extends Base {\n    @strictpure def isScalar: B = F\n\n    @pure def as(name: String): Composite\n\n    @pure def asOpt: Option[String]\n  }\n\n  @datatype class Boolean(val name: String) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(1)\n    }\n    @strictpure def isScalar: B = T\n  }\n\n  @datatype class Bits(val name: String, val size: Z) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size)\n    }\n    @strictpure def isScalar: B = size <= 64\n  }\n\n  @datatype class BytesImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 8)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Byte(name: String): BytesImpl = {\n    return BytesImpl(name, 1, T, None(), None())\n  }\n\n  @pure def ByteConst(name: String, value: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(value))\n    return BytesImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def ByteRange(name: String, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(min) && conversions.Z.isInRangeSigned8(max) && min <= max)\n    return BytesImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UByte(name: String): BytesImpl = {\n    return BytesImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UByteConst(name: String, value: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(value))\n    return BytesImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UByteRange(name: String, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(min) && conversions.Z.isInRangeUnsigned8(max) && min <= max)\n    return BytesImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Bytes(name: String, size: Z): BytesImpl = {\n    return BytesImpl(name, size, T, None(), None())\n  }\n\n  @pure def BytesRange(name: String, size: Z, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(min) && conversions.Z.isInRangeSigned8(max) && min <= max)\n    return BytesImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UBytes(name: String, size: Z): BytesImpl = {\n    return BytesImpl(name, size, F, None(), None())\n  }\n\n  @pure def UBytesRange(name: String, size: Z, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(min) && conversions.Z.isInRangeUnsigned8(max) && min <= max)\n    return BytesImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class ShortsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 16)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Short(name: String): ShortsImpl = {\n    return ShortsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def ShortConst(name: String, value: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(value))\n    return ShortsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def ShortRange(name: String, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(min) && conversions.Z.isInRangeSigned16(max) && min <= max)\n    return ShortsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UShort(name: String): ShortsImpl = {\n    return ShortsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UShortConst(name: String, value: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(value))\n    return ShortsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UShortRange(name: String, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(min) && conversions.Z.isInRangeUnsigned16(max) && min <= max)\n    return ShortsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Shorts(name: String, size: Z): ShortsImpl = {\n    return ShortsImpl(name, size, T, None(), None())\n  }\n\n  @pure def ShortsRange(name: String, size: Z, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(min) && conversions.Z.isInRangeSigned16(max) && min <= max)\n    return ShortsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UShorts(name: String, size: Z): ShortsImpl = {\n    return ShortsImpl(name, size, F, None(), None())\n  }\n\n  @pure def UShortsRange(name: String, size: Z, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(min) && conversions.Z.isInRangeUnsigned16(max) && min <= max)\n    return ShortsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class IntsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 32)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Int(name: String): IntsImpl = {\n    return IntsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def IntConst(name: String, value: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(value))\n    return IntsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def IntRange(name: String, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(min) && conversions.Z.isInRangeSigned32(max) && min <= max)\n    return IntsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UInt(name: String): IntsImpl = {\n    return IntsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UIntConst(name: String, value: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(value))\n    return IntsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UIntRange(name: String, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(min) && conversions.Z.isInRangeUnsigned32(max) && min <= max)\n    return IntsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Ints(name: String, size: Z): IntsImpl = {\n    return IntsImpl(name, size, T, None(), None())\n  }\n\n  @pure def IntsRange(name: String, size: Z, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(min) && conversions.Z.isInRangeSigned32(max) && min <= max)\n    return IntsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UInts(name: String, size: Z): IntsImpl = {\n    return IntsImpl(name, size, F, None(), None())\n  }\n\n  @pure def UIntsRange(name: String, size: Z, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(min) && conversions.Z.isInRangeUnsigned32(max) && min <= max)\n    return IntsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class LongsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 64)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Long(name: String): LongsImpl = {\n    return LongsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def LongConst(name: String, value: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(value))\n    return LongsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def LongRange(name: String, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(min) && conversions.Z.isInRangeSigned64(max) && min <= max)\n    return LongsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def ULong(name: String): LongsImpl = {\n    return LongsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def ULongConst(name: String, value: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(value))\n    return LongsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def ULongRange(name: String, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(min) && conversions.Z.isInRangeUnsigned64(max) && min <= max)\n    return LongsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Longs(name: String, size: Z): LongsImpl = {\n    return LongsImpl(name, size, T, None(), None())\n  }\n\n  @pure def LongsRange(name: String, size: Z, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(min) && conversions.Z.isInRangeSigned64(max) && min <= max)\n    return LongsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def ULongs(name: String, size: Z): LongsImpl = {\n    return LongsImpl(name, size, F, None(), None())\n  }\n\n  @pure def ULongsRange(name: String, size: Z, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(min) && conversions.Z.isInRangeUnsigned64(max) && min <= max)\n    return LongsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class FloatsImpl(val name: String, val size: Z, val minOpt: Option[F32], val maxOpt: Option[F32]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 32)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Float(name: String): FloatsImpl = {\n    return FloatsImpl(name, 1, None(), None())\n  }\n\n  @pure def FloatRange(name: String, min: F32, max: F32): FloatsImpl = {\n    return FloatsImpl(name, 1, Some(min), Some(max))\n  }\n\n  @pure def Floats(name: String, size: Z): FloatsImpl = {\n    return FloatsImpl(name, size, None(), None())\n  }\n\n  @pure def FloatsRange(name: String, size: Z, min: F32, max: F32): FloatsImpl = {\n    return FloatsImpl(name, size, Some(min), Some(max))\n  }\n\n  @datatype class DoublesImpl(val name: String, val size: Z, val minOpt: Option[F64], val maxOpt: Option[F64]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 64)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Double(name: String): DoublesImpl = {\n    return DoublesImpl(name, 1, None(), None())\n  }\n\n  @pure def DoubleRange(name: String, min: F64, max: F64): DoublesImpl = {\n    return DoublesImpl(name, 1, Some(min), Some(max))\n  }\n\n  @pure def Doubles(name: String, size: Z): DoublesImpl = {\n    return DoublesImpl(name, size, None(), None())\n  }\n\n  @pure def DoublesRange(name: String, size: Z, min: F64, max: F64): DoublesImpl = {\n    return DoublesImpl(name, size, Some(min), Some(max))\n  }\n\n  @datatype class Enum(val name: String, val objectName: String) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(enumMaxSize(objectName))\n    }\n    @strictpure def isScalar: B = T\n  }\n\n  @strictpure def Concat(name: String, elements: ISZ[Spec]): ConcatImpl = ConcatImpl(name, elements, None())\n\n  @datatype class ConcatImpl(val name: String, val elements: ISZ[Spec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var r: Z = 0\n      for (e <- elements) {\n        e.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(maxSize) => r = r + maxSize\n          case _ => return None()\n        }\n      }\n      return Some(r)\n    }\n\n    @strictpure def as(name: String): ConcatImpl = this(asOpt = Some(name))\n  }\n\n  @datatype trait Poly {\n    def polyDesc: Spec.PolyDesc\n  }\n\n  @datatype class PolyDesc(val compName: String, val name: String, val max: Z, val dependsOn: ISZ[String], val elementsOpt: Option[ISZ[Spec]], val asOpt: Option[String])\n\n  @strictpure def Union[T](name: String, dependsOn: ISZ[String], choice: T => Z@pure, subs: ISZ[Spec]): UnionImpl[T] =\n    UnionImpl[T](name, dependsOn, choice, subs, None())\n\n  @datatype class UnionImpl[T](val name: String,\n                               val dependsOn: ISZ[String],\n                               @hidden val choice: T => Z@pure,\n                               val subs: ISZ[Spec],\n                               @hidden val asOpt: Option[String]) extends Composite with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Union\", name, -1, dependsOn, Some(subs), asOpt)\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n\n    @strictpure def as(name: String): UnionImpl[T] = this(asOpt = Some(name))\n  }\n\n  @datatype class RepeatImpl[T](val name: String,\n                                val maxElements: Z,\n                                val dependsOn: ISZ[String],\n                                @hidden val size: T => Z@pure,\n                                val element: Base) extends Spec with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Repeat\", name, maxElements, dependsOn, Some(ISZ(element)), None())\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def Repeat[T](name: String, dependsOn: ISZ[String], size: T => Z@pure, element: Base): RepeatImpl[T] = {\n    return RepeatImpl(name, -1, dependsOn, size, element)\n  }\n\n  @pure def BoundedRepeat[T](name: String, maxElements: Z, dependsOn: ISZ[String], size: T => Z@pure, element: Base): RepeatImpl[T] = {\n    assert(maxElements >= 0, s\"BoundedRepeat \'$name\' maxElements must be non-negative\")\n    return RepeatImpl(name, maxElements, dependsOn, size, element)\n  }\n\n  @datatype class RawImpl[T](val name: String,\n                             val maxSize: Z,\n                             val dependsOn: ISZ[String],\n                             @hidden val size: T => Z@pure) extends Spec with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Raw\", name, maxSize, dependsOn, None(), None())\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return if (maxSize >= 0) Some(maxSize) else None()\n    }\n  }\n\n  @pure def Raw[T](name: String, dependsOn: ISZ[String], size: T => Z@pure): RawImpl[T] = {\n    return RawImpl[T](name, -1, dependsOn, size)\n  }\n\n  @pure def BoundedRaw[T](name: String, maxSize: Z, dependsOn: ISZ[String], size: T => Z@pure): RawImpl[T] = {\n    assert(maxSize >= 0, s\"BoundedRaw \'$name\' maxSize must be non-negative\")\n    return RawImpl[T](name, maxSize, dependsOn, size)\n  }\n\n  @strictpure def PredUnion(name: String, subs: ISZ[PredSpec]): PredUnionImpl = PredUnionImpl(name, subs, None())\n\n  @datatype class PredUnionImpl(val name: String, val subs: ISZ[PredSpec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.maxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n    @strictpure def as(name: String): PredUnionImpl = this(asOpt = Some(name))\n  }\n\n  @datatype class PredRepeatWhileImpl(val name: String, val maxElements: Z, val preds: ISZ[Pred], val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def FixedRepeat(name: String, numOfElements: Z, element: Base): PredRepeatWhileImpl = {\n    return PredRepeatWhileImpl(name, numOfElements, ISZ(), element)\n  }\n\n  @pure def PredRepeatWhile(name: String, preds: ISZ[Pred], element: Base): PredRepeatWhileImpl = {\n    return PredRepeatWhileImpl(name, -1, preds, element)\n  }\n\n  @pure def BoundedPredRepeatWhile(name: String, maxElements: Z, preds: ISZ[Pred], element: Base): PredRepeatWhileImpl = {\n    assert(maxElements >= 0, s\"BoundedPredRepeatWhile \'$name\' maxElements must be non-negative\")\n    return PredRepeatWhileImpl(name, maxElements, preds, element)\n  }\n\n  @datatype class PredRepeatUntilImpl(val name: String, val maxElements: Z, val preds: ISZ[Pred], val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def PredRepeatUntil(name: String, preds: ISZ[Pred], element: Base): PredRepeatUntilImpl = {\n    return PredRepeatUntilImpl(name, -1, preds, element)\n  }\n\n  @pure def BoundedPredRepeatUntil(name: String, maxElements: Z, preds: ISZ[Pred], element: Base): PredRepeatUntilImpl = {\n    assert(maxElements >= 0, s\"BoundedPredRepeatWhile \'$name\' maxElements must be non-negative\")\n    return PredRepeatUntilImpl(name, maxElements, preds, element)\n  }\n\n  @strictpure def GenUnion(name: String, subs: ISZ[Spec]): GenUnionImpl = GenUnionImpl(name, subs, None())\n\n  @datatype class GenUnionImpl(val name: String, val subs: ISZ[Spec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n    @strictpure def as(name: String): GenUnionImpl = this(asOpt = Some(name))\n  }\n\n  @datatype class GenRepeatImpl(val name: String, val maxElements: Z, val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n
  #718 = String             #717          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.bitcodec\n\nimport org.sireum._\n\n\n@datatype trait Spec {\n\n  def name: String\n\n  def isScalar: B\n\n  def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z]\n\n  @memoize def maxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n    return computeMaxSizeOpt(enumMaxSize)\n  }\n\n  def toJSON(isCompact: B): String = {\n    return Spec.Ext.toJSON(this, isCompact)\n  }\n\n}\n\nobject Spec {\n\n  type Concat = ConcatImpl\n  type Union[T] = UnionImpl[T]\n  type PredUnion = PredUnionImpl\n  type GenUnion = GenUnionImpl\n\n  @datatype trait Base extends Spec\n\n  @datatype trait Composite extends Base {\n    @strictpure def isScalar: B = F\n\n    @pure def as(name: String): Composite\n\n    @pure def asOpt: Option[String]\n  }\n\n  @datatype class Boolean(val name: String) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(1)\n    }\n    @strictpure def isScalar: B = T\n  }\n\n  @datatype class Bits(val name: String, val size: Z) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size)\n    }\n    @strictpure def isScalar: B = size <= 64\n  }\n\n  @datatype class BytesImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 8)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Byte(name: String): BytesImpl = {\n    return BytesImpl(name, 1, T, None(), None())\n  }\n\n  @pure def ByteConst(name: String, value: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(value))\n    return BytesImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def ByteRange(name: String, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(min) && conversions.Z.isInRangeSigned8(max) && min <= max)\n    return BytesImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UByte(name: String): BytesImpl = {\n    return BytesImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UByteConst(name: String, value: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(value))\n    return BytesImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UByteRange(name: String, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(min) && conversions.Z.isInRangeUnsigned8(max) && min <= max)\n    return BytesImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Bytes(name: String, size: Z): BytesImpl = {\n    return BytesImpl(name, size, T, None(), None())\n  }\n\n  @pure def BytesRange(name: String, size: Z, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(min) && conversions.Z.isInRangeSigned8(max) && min <= max)\n    return BytesImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UBytes(name: String, size: Z): BytesImpl = {\n    return BytesImpl(name, size, F, None(), None())\n  }\n\n  @pure def UBytesRange(name: String, size: Z, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(min) && conversions.Z.isInRangeUnsigned8(max) && min <= max)\n    return BytesImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class ShortsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 16)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Short(name: String): ShortsImpl = {\n    return ShortsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def ShortConst(name: String, value: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(value))\n    return ShortsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def ShortRange(name: String, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(min) && conversions.Z.isInRangeSigned16(max) && min <= max)\n    return ShortsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UShort(name: String): ShortsImpl = {\n    return ShortsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UShortConst(name: String, value: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(value))\n    return ShortsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UShortRange(name: String, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(min) && conversions.Z.isInRangeUnsigned16(max) && min <= max)\n    return ShortsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Shorts(name: String, size: Z): ShortsImpl = {\n    return ShortsImpl(name, size, T, None(), None())\n  }\n\n  @pure def ShortsRange(name: String, size: Z, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(min) && conversions.Z.isInRangeSigned16(max) && min <= max)\n    return ShortsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UShorts(name: String, size: Z): ShortsImpl = {\n    return ShortsImpl(name, size, F, None(), None())\n  }\n\n  @pure def UShortsRange(name: String, size: Z, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(min) && conversions.Z.isInRangeUnsigned16(max) && min <= max)\n    return ShortsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class IntsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 32)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Int(name: String): IntsImpl = {\n    return IntsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def IntConst(name: String, value: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(value))\n    return IntsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def IntRange(name: String, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(min) && conversions.Z.isInRangeSigned32(max) && min <= max)\n    return IntsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UInt(name: String): IntsImpl = {\n    return IntsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UIntConst(name: String, value: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(value))\n    return IntsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UIntRange(name: String, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(min) && conversions.Z.isInRangeUnsigned32(max) && min <= max)\n    return IntsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Ints(name: String, size: Z): IntsImpl = {\n    return IntsImpl(name, size, T, None(), None())\n  }\n\n  @pure def IntsRange(name: String, size: Z, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(min) && conversions.Z.isInRangeSigned32(max) && min <= max)\n    return IntsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UInts(name: String, size: Z): IntsImpl = {\n    return IntsImpl(name, size, F, None(), None())\n  }\n\n  @pure def UIntsRange(name: String, size: Z, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(min) && conversions.Z.isInRangeUnsigned32(max) && min <= max)\n    return IntsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class LongsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 64)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Long(name: String): LongsImpl = {\n    return LongsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def LongConst(name: String, value: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(value))\n    return LongsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def LongRange(name: String, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(min) && conversions.Z.isInRangeSigned64(max) && min <= max)\n    return LongsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def ULong(name: String): LongsImpl = {\n    return LongsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def ULongConst(name: String, value: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(value))\n    return LongsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def ULongRange(name: String, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(min) && conversions.Z.isInRangeUnsigned64(max) && min <= max)\n    return LongsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Longs(name: String, size: Z): LongsImpl = {\n    return LongsImpl(name, size, T, None(), None())\n  }\n\n  @pure def LongsRange(name: String, size: Z, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(min) && conversions.Z.isInRangeSigned64(max) && min <= max)\n    return LongsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def ULongs(name: String, size: Z): LongsImpl = {\n    return LongsImpl(name, size, F, None(), None())\n  }\n\n  @pure def ULongsRange(name: String, size: Z, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(min) && conversions.Z.isInRangeUnsigned64(max) && min <= max)\n    return LongsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class FloatsImpl(val name: String, val size: Z, val minOpt: Option[F32], val maxOpt: Option[F32]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 32)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Float(name: String): FloatsImpl = {\n    return FloatsImpl(name, 1, None(), None())\n  }\n\n  @pure def FloatRange(name: String, min: F32, max: F32): FloatsImpl = {\n    return FloatsImpl(name, 1, Some(min), Some(max))\n  }\n\n  @pure def Floats(name: String, size: Z): FloatsImpl = {\n    return FloatsImpl(name, size, None(), None())\n  }\n\n  @pure def FloatsRange(name: String, size: Z, min: F32, max: F32): FloatsImpl = {\n    return FloatsImpl(name, size, Some(min), Some(max))\n  }\n\n  @datatype class DoublesImpl(val name: String, val size: Z, val minOpt: Option[F64], val maxOpt: Option[F64]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 64)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Double(name: String): DoublesImpl = {\n    return DoublesImpl(name, 1, None(), None())\n  }\n\n  @pure def DoubleRange(name: String, min: F64, max: F64): DoublesImpl = {\n    return DoublesImpl(name, 1, Some(min), Some(max))\n  }\n\n  @pure def Doubles(name: String, size: Z): DoublesImpl = {\n    return DoublesImpl(name, size, None(), None())\n  }\n\n  @pure def DoublesRange(name: String, size: Z, min: F64, max: F64): DoublesImpl = {\n    return DoublesImpl(name, size, Some(min), Some(max))\n  }\n\n  @datatype class Enum(val name: String, val objectName: String) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(enumMaxSize(objectName))\n    }\n    @strictpure def isScalar: B = T\n  }\n\n  @strictpure def Concat(name: String, elements: ISZ[Spec]): ConcatImpl = ConcatImpl(name, elements, None())\n\n  @datatype class ConcatImpl(val name: String, val elements: ISZ[Spec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var r: Z = 0\n      for (e <- elements) {\n        e.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(maxSize) => r = r + maxSize\n          case _ => return None()\n        }\n      }\n      return Some(r)\n    }\n\n    @strictpure def as(name: String): ConcatImpl = this(asOpt = Some(name))\n  }\n\n  @datatype trait Poly {\n    def polyDesc: Spec.PolyDesc\n  }\n\n  @datatype class PolyDesc(val compName: String, val name: String, val max: Z, val dependsOn: ISZ[String], val elementsOpt: Option[ISZ[Spec]], val asOpt: Option[String])\n\n  @strictpure def Union[T](name: String, dependsOn: ISZ[String], choice: T => Z@pure, subs: ISZ[Spec]): UnionImpl[T] =\n    UnionImpl[T](name, dependsOn, choice, subs, None())\n\n  @datatype class UnionImpl[T](val name: String,\n                               val dependsOn: ISZ[String],\n                               @hidden val choice: T => Z@pure,\n                               val subs: ISZ[Spec],\n                               @hidden val asOpt: Option[String]) extends Composite with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Union\", name, -1, dependsOn, Some(subs), asOpt)\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n\n    @strictpure def as(name: String): UnionImpl[T] = this(asOpt = Some(name))\n  }\n\n  @datatype class RepeatImpl[T](val name: String,\n                                val maxElements: Z,\n                                val dependsOn: ISZ[String],\n                                @hidden val size: T => Z@pure,\n                                val element: Base) extends Spec with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Repeat\", name, maxElements, dependsOn, Some(ISZ(element)), None())\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def Repeat[T](name: String, dependsOn: ISZ[String], size: T => Z@pure, element: Base): RepeatImpl[T] = {\n    return RepeatImpl(name, -1, dependsOn, size, element)\n  }\n\n  @pure def BoundedRepeat[T](name: String, maxElements: Z, dependsOn: ISZ[String], size: T => Z@pure, element: Base): RepeatImpl[T] = {\n    assert(maxElements >= 0, s\"BoundedRepeat \'$name\' maxElements must be non-negative\")\n    return RepeatImpl(name, maxElements, dependsOn, size, element)\n  }\n\n  @datatype class RawImpl[T](val name: String,\n                             val maxSize: Z,\n                             val dependsOn: ISZ[String],\n                             @hidden val size: T => Z@pure) extends Spec with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Raw\", name, maxSize, dependsOn, None(), None())\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return if (maxSize >= 0) Some(maxSize) else None()\n    }\n  }\n\n  @pure def Raw[T](name: String, dependsOn: ISZ[String], size: T => Z@pure): RawImpl[T] = {\n    return RawImpl[T](name, -1, dependsOn, size)\n  }\n\n  @pure def BoundedRaw[T](name: String, maxSize: Z, dependsOn: ISZ[String], size: T => Z@pure): RawImpl[T] = {\n    assert(maxSize >= 0, s\"BoundedRaw \'$name\' maxSize must be non-negative\")\n    return RawImpl[T](name, maxSize, dependsOn, size)\n  }\n\n  @strictpure def PredUnion(name: String, subs: ISZ[PredSpec]): PredUnionImpl = PredUnionImpl(name, subs, None())\n\n  @datatype class PredUnionImpl(val name: String, val subs: ISZ[PredSpec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.maxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n    @strictpure def as(name: String): PredUnionImpl = this(asOpt = Some(name))\n  }\n\n  @datatype class PredRepeatWhileImpl(val name: String, val maxElements: Z, val preds: ISZ[Pred], val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def FixedRepeat(name: String, numOfElements: Z, element: Base): PredRepeatWhileImpl = {\n    return PredRepeatWhileImpl(name, numOfElements, ISZ(), element)\n  }\n\n  @pure def PredRepeatWhile(name: String, preds: ISZ[Pred], element: Base): PredRepeatWhileImpl = {\n    return PredRepeatWhileImpl(name, -1, preds, element)\n  }\n\n  @pure def BoundedPredRepeatWhile(name: String, maxElements: Z, preds: ISZ[Pred], element: Base): PredRepeatWhileImpl = {\n    assert(maxElements >= 0, s\"BoundedPredRepeatWhile \'$name\' maxElements must be non-negative\")\n    return PredRepeatWhileImpl(name, maxElements, preds, element)\n  }\n\n  @datatype class PredRepeatUntilImpl(val name: String, val maxElements: Z, val preds: ISZ[Pred], val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def PredRepeatUntil(name: String, preds: ISZ[Pred], element: Base): PredRepeatUntilImpl = {\n    return PredRepeatUntilImpl(name, -1, preds, element)\n  }\n\n  @pure def BoundedPredRepeatUntil(name: String, maxElements: Z, preds: ISZ[Pred], element: Base): PredRepeatUntilImpl = {\n    assert(maxElements >= 0, s\"BoundedPredRepeatWhile \'$name\' maxElements must be non-negative\")\n    return PredRepeatUntilImpl(name, maxElements, preds, element)\n  }\n\n  @strictpure def GenUnion(name: String, subs: ISZ[Spec]): GenUnionImpl = GenUnionImpl(name, subs, None())\n\n  @datatype class GenUnionImpl(val name: String, val subs: ISZ[Spec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n    @strictpure def as(name: String): GenUnionImpl = this(asOpt = Some(name))\n  }\n\n  @datatype class GenRepeatImpl(val name: String, val maxElements: Z, val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n
  #719 = Utf8                   element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def GenRepeat(name: String, element: Base): GenRepeatImpl = {\n    return GenRepeatImpl(name, -1, element)\n  }\n\n  @pure def BoundedGenRepeat(name: String, maxElements: Z, element: Base): GenRepeatImpl = {\n    assert(maxElements >= 0, s\"BoundedGenRepeat \'$name\' maxElements must be non-negative\")\n    return GenRepeatImpl(name, maxElements, element)\n  }\n\n  @datatype class GenRawImpl(val name: String, val maxSize: Z) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return if (maxSize >= 0) Some(maxSize) else None()\n    }\n  }\n\n  @pure def GenRaw(name: String): GenRawImpl = {\n    return GenRawImpl(name, -1)\n  }\n\n  @pure def BoundedGenRaw(name: String, maxSize: Z): GenRawImpl = {\n    assert(maxSize >= 0, s\"BoundedGenRaw \'$name\' maxSize must be non-negative\")\n    return GenRawImpl(name, maxSize)\n  }\n\n  @datatype class Pads(val size: Z) extends Spec {\n    def name: String = {\n      return \"\"\n    }\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size)\n    }\n  }\n\n  @datatype class PredSpec(val preds: ISZ[Pred], val spec: Spec) {\n    def maxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return spec.computeMaxSizeOpt(enumMaxSize)\n    }\n  }\n\n  @datatype trait Pred\n\n  object Pred {\n\n    @datatype class Boolean(val value: B) extends Pred\n\n    @datatype class Bits(val size: Z, val value: Z) extends Pred\n\n    @datatype class Bytes(val value: ISZ[Z]) extends Pred\n\n    @datatype class Shorts(val value: ISZ[Z]) extends Pred\n\n    @datatype class Ints(val value: ISZ[Z]) extends Pred\n\n    @datatype class Longs(val value: ISZ[Z]) extends Pred\n\n    @datatype class Floats(val value: ISZ[F32]) extends Pred\n\n    @datatype class Doubles(val value: ISZ[F64]) extends Pred\n\n    @datatype class Skip(val size: Z) extends Pred\n\n    @datatype class Between(val size: Z, val lo: Z, val hi: Z) extends Pred\n\n    @datatype class Not(val pred: Pred) extends Pred\n\n    @datatype class Or(val preds: ISZ[Pred]) extends Pred\n\n\n  }\n\n  @pure def boolean(value: B): Pred.Boolean = {\n    return Pred.Boolean(value)\n  }\n\n  @pure def bits(size: Z, value: Z): Pred.Bits = {\n    return Pred.Bits(size, value)\n  }\n\n  @pure def bytes(value: ISZ[Z]): Pred.Bytes = {\n    return Pred.Bytes(value)\n  }\n\n  @pure def shorts(value: ISZ[Z]): Pred.Shorts = {\n    return Pred.Shorts(value)\n  }\n\n  @pure def ints(value: ISZ[Z]): Pred.Ints = {\n    return Pred.Ints(value)\n  }\n\n  @pure def longs(value: ISZ[Z]): Pred.Longs = {\n    return Pred.Longs(value)\n  }\n\n  @pure def skip(size: Z): Pred.Skip = {\n    return Pred.Skip(size)\n  }\n\n  @pure def between(size: Z, lo: Z, hi: Z): Pred.Between = {\n    return Pred.Between(size, lo, hi)\n  }\n\n  @pure def not(pred: Pred): Pred.Not = {\n    return Pred.Not(pred)\n  }\n\n  @pure def or(preds: ISZ[Pred]): Pred.Or = {\n    return Pred.Or(preds)\n  }\n\n  @pure def fromJSON(s: String): Either[Spec, Json.ErrorMsg] = {\n    return Ext.fromJSON(s)\n  }\n\n  @ext(\"Spec_Ext\") object Ext {\n    def toJSON(o: Spec, isCompact: B): String = $\n    def fromJSON(s: String): Either[Spec, Json.ErrorMsg] = $\n  }\n}\n
  #720 = String             #719          //     element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def GenRepeat(name: String, element: Base): GenRepeatImpl = {\n    return GenRepeatImpl(name, -1, element)\n  }\n\n  @pure def BoundedGenRepeat(name: String, maxElements: Z, element: Base): GenRepeatImpl = {\n    assert(maxElements >= 0, s\"BoundedGenRepeat \'$name\' maxElements must be non-negative\")\n    return GenRepeatImpl(name, maxElements, element)\n  }\n\n  @datatype class GenRawImpl(val name: String, val maxSize: Z) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return if (maxSize >= 0) Some(maxSize) else None()\n    }\n  }\n\n  @pure def GenRaw(name: String): GenRawImpl = {\n    return GenRawImpl(name, -1)\n  }\n\n  @pure def BoundedGenRaw(name: String, maxSize: Z): GenRawImpl = {\n    assert(maxSize >= 0, s\"BoundedGenRaw \'$name\' maxSize must be non-negative\")\n    return GenRawImpl(name, maxSize)\n  }\n\n  @datatype class Pads(val size: Z) extends Spec {\n    def name: String = {\n      return \"\"\n    }\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size)\n    }\n  }\n\n  @datatype class PredSpec(val preds: ISZ[Pred], val spec: Spec) {\n    def maxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return spec.computeMaxSizeOpt(enumMaxSize)\n    }\n  }\n\n  @datatype trait Pred\n\n  object Pred {\n\n    @datatype class Boolean(val value: B) extends Pred\n\n    @datatype class Bits(val size: Z, val value: Z) extends Pred\n\n    @datatype class Bytes(val value: ISZ[Z]) extends Pred\n\n    @datatype class Shorts(val value: ISZ[Z]) extends Pred\n\n    @datatype class Ints(val value: ISZ[Z]) extends Pred\n\n    @datatype class Longs(val value: ISZ[Z]) extends Pred\n\n    @datatype class Floats(val value: ISZ[F32]) extends Pred\n\n    @datatype class Doubles(val value: ISZ[F64]) extends Pred\n\n    @datatype class Skip(val size: Z) extends Pred\n\n    @datatype class Between(val size: Z, val lo: Z, val hi: Z) extends Pred\n\n    @datatype class Not(val pred: Pred) extends Pred\n\n    @datatype class Or(val preds: ISZ[Pred]) extends Pred\n\n\n  }\n\n  @pure def boolean(value: B): Pred.Boolean = {\n    return Pred.Boolean(value)\n  }\n\n  @pure def bits(size: Z, value: Z): Pred.Bits = {\n    return Pred.Bits(size, value)\n  }\n\n  @pure def bytes(value: ISZ[Z]): Pred.Bytes = {\n    return Pred.Bytes(value)\n  }\n\n  @pure def shorts(value: ISZ[Z]): Pred.Shorts = {\n    return Pred.Shorts(value)\n  }\n\n  @pure def ints(value: ISZ[Z]): Pred.Ints = {\n    return Pred.Ints(value)\n  }\n\n  @pure def longs(value: ISZ[Z]): Pred.Longs = {\n    return Pred.Longs(value)\n  }\n\n  @pure def skip(size: Z): Pred.Skip = {\n    return Pred.Skip(size)\n  }\n\n  @pure def between(size: Z, lo: Z, hi: Z): Pred.Between = {\n    return Pred.Between(size, lo, hi)\n  }\n\n  @pure def not(pred: Pred): Pred.Not = {\n    return Pred.Not(pred)\n  }\n\n  @pure def or(preds: ISZ[Pred]): Pred.Or = {\n    return Pred.Or(preds)\n  }\n\n  @pure def fromJSON(s: String): Either[Spec, Json.ErrorMsg] = {\n    return Ext.fromJSON(s)\n  }\n\n  @ext(\"Spec_Ext\") object Ext {\n    def toJSON(o: Spec, isCompact: B): String = $\n    def fromJSON(s: String): Either[Spec, Json.ErrorMsg] = $\n  }\n}\n
  #721 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\n\n@datatype class COps(val c: C) {\n\n  @pure def toUnicodeHex: (C, C, C, C) = {\n    return (COps.hex2c(c >>> \'\\u000C\'), COps.hex2c((c >>> \'\\u0008\') & \'\\u000F\'), COps.hex2c((c >>> \'\\u0004\') & \'\\u000F\'), COps.hex2c(c & \'\\u000F\'))\n  }\n\n  @pure def toUpper: C = {\n    if (\'a\' <= c && c <= \'z\') {\n      return c - \'\\u0020\'\n    } else {\n      return c\n    }\n  }\n\n  @pure def toLower: C = {\n    if (\'A\' <= c && c <= \'Z\') {\n      return c + \'\\u0020\'\n    } else {\n      return c\n    }\n  }\n\n  @pure def escapeString: String = {\n    c match {\n      case \'\\b\' => return \"\\\\b\"\n      case \'\\t\' => return \"\\\\t\"\n      case \'\\n\' => return \"\\\\n\"\n      case \'\\f\' => return \"\\\\f\"\n      case \'\\r\' => return \"\\\\r\"\n      case \'\"\' =>  return \"\\\\\\\"\"\n      case \'\\\'\' => return \"\\\\\\\'\"\n      case \'\\\\\' => return \"\\\\\\\\\"\n      case _ =>\n    }\n    if (\'\\u0020\' <= c && c <= \'\\u007e\') {\n      return c.string\n    } else if (c > \'\\uFFFF\') {\n      var r: String = \"\"\n      for (cpc <- conversions.C.toCodePoints(c)) {\n        r = s\"$r${COps(cpc).escapeString}\"\n      }\n      return r\n    } else {\n      val q = toUnicodeHex\n      return s\"\\\\u${q._1}${q._2}${q._3}${q._4}\"\n    }\n  }\n\n}\n\nobject COps {\n  @pure def c2hex(c: C): Option[C] = {\n    c.native match {\n      case \'0\' => return Some(\'\\u0000\')\n      case \'1\' => return Some(\'\\u0001\')\n      case \'2\' => return Some(\'\\u0002\')\n      case \'3\' => return Some(\'\\u0003\')\n      case \'4\' => return Some(\'\\u0004\')\n      case \'5\' => return Some(\'\\u0005\')\n      case \'6\' => return Some(\'\\u0006\')\n      case \'7\' => return Some(\'\\u0007\')\n      case \'8\' => return Some(\'\\u0008\')\n      case \'9\' => return Some(\'\\u0009\')\n      case \'a\' => return Some(\'\\u000A\')\n      case \'A\' => return Some(\'\\u000A\')\n      case \'b\' => return Some(\'\\u000B\')\n      case \'B\' => return Some(\'\\u000B\')\n      case \'c\' => return Some(\'\\u000C\')\n      case \'C\' => return Some(\'\\u000C\')\n      case \'d\' => return Some(\'\\u000D\')\n      case \'D\' => return Some(\'\\u000D\')\n      case \'e\' => return Some(\'\\u000E\')\n      case \'E\' => return Some(\'\\u000E\')\n      case \'f\' => return Some(\'\\u000F\')\n      case \'F\' => return Some(\'\\u000F\')\n      case _ => return None[C]()\n    }\n  }\n\n  @pure def hex2c(c: C): C = {\n    val r: C = (c & \'\\u000F\').native match {\n      case \'\\u0000\' => \'0\'\n      case \'\\u0001\' => \'1\'\n      case \'\\u0002\' => \'2\'\n      case \'\\u0003\' => \'3\'\n      case \'\\u0004\' => \'4\'\n      case \'\\u0005\' => \'5\'\n      case \'\\u0006\' => \'6\'\n      case \'\\u0007\' => \'7\'\n      case \'\\u0008\' => \'8\'\n      case \'\\u0009\' => \'9\'\n      case \'\\u000A\' => \'A\'\n      case \'\\u000B\' => \'B\'\n      case \'\\u000C\' => \'C\'\n      case \'\\u000D\' => \'D\'\n      case \'\\u000E\' => \'E\'\n      case \'\\u000F\' => \'F\'\n    }\n    return r\n  }\n\n  @pure def fromUnicodeHex(hex: ISZ[C]): Option[C] = {\n    if (hex.size != 4) {\n      return None[C]()\n    }\n    (c2hex(hex(0)), c2hex(hex(1)), c2hex(hex(2)), c2hex(hex(3))) match {\n      case (Some(c1), Some(c2), Some(c3), Some(c4)) =>\n        return Some((c1 << \'\\u000c\') | (c2 << \'\\u0008\') | (c3 << \'\\u0004\') | c4)\n      case _ => return None[C]()\n    }\n  }\n}
  #722 = String             #721          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\n\n@datatype class COps(val c: C) {\n\n  @pure def toUnicodeHex: (C, C, C, C) = {\n    return (COps.hex2c(c >>> \'\\u000C\'), COps.hex2c((c >>> \'\\u0008\') & \'\\u000F\'), COps.hex2c((c >>> \'\\u0004\') & \'\\u000F\'), COps.hex2c(c & \'\\u000F\'))\n  }\n\n  @pure def toUpper: C = {\n    if (\'a\' <= c && c <= \'z\') {\n      return c - \'\\u0020\'\n    } else {\n      return c\n    }\n  }\n\n  @pure def toLower: C = {\n    if (\'A\' <= c && c <= \'Z\') {\n      return c + \'\\u0020\'\n    } else {\n      return c\n    }\n  }\n\n  @pure def escapeString: String = {\n    c match {\n      case \'\\b\' => return \"\\\\b\"\n      case \'\\t\' => return \"\\\\t\"\n      case \'\\n\' => return \"\\\\n\"\n      case \'\\f\' => return \"\\\\f\"\n      case \'\\r\' => return \"\\\\r\"\n      case \'\"\' =>  return \"\\\\\\\"\"\n      case \'\\\'\' => return \"\\\\\\\'\"\n      case \'\\\\\' => return \"\\\\\\\\\"\n      case _ =>\n    }\n    if (\'\\u0020\' <= c && c <= \'\\u007e\') {\n      return c.string\n    } else if (c > \'\\uFFFF\') {\n      var r: String = \"\"\n      for (cpc <- conversions.C.toCodePoints(c)) {\n        r = s\"$r${COps(cpc).escapeString}\"\n      }\n      return r\n    } else {\n      val q = toUnicodeHex\n      return s\"\\\\u${q._1}${q._2}${q._3}${q._4}\"\n    }\n  }\n\n}\n\nobject COps {\n  @pure def c2hex(c: C): Option[C] = {\n    c.native match {\n      case \'0\' => return Some(\'\\u0000\')\n      case \'1\' => return Some(\'\\u0001\')\n      case \'2\' => return Some(\'\\u0002\')\n      case \'3\' => return Some(\'\\u0003\')\n      case \'4\' => return Some(\'\\u0004\')\n      case \'5\' => return Some(\'\\u0005\')\n      case \'6\' => return Some(\'\\u0006\')\n      case \'7\' => return Some(\'\\u0007\')\n      case \'8\' => return Some(\'\\u0008\')\n      case \'9\' => return Some(\'\\u0009\')\n      case \'a\' => return Some(\'\\u000A\')\n      case \'A\' => return Some(\'\\u000A\')\n      case \'b\' => return Some(\'\\u000B\')\n      case \'B\' => return Some(\'\\u000B\')\n      case \'c\' => return Some(\'\\u000C\')\n      case \'C\' => return Some(\'\\u000C\')\n      case \'d\' => return Some(\'\\u000D\')\n      case \'D\' => return Some(\'\\u000D\')\n      case \'e\' => return Some(\'\\u000E\')\n      case \'E\' => return Some(\'\\u000E\')\n      case \'f\' => return Some(\'\\u000F\')\n      case \'F\' => return Some(\'\\u000F\')\n      case _ => return None[C]()\n    }\n  }\n\n  @pure def hex2c(c: C): C = {\n    val r: C = (c & \'\\u000F\').native match {\n      case \'\\u0000\' => \'0\'\n      case \'\\u0001\' => \'1\'\n      case \'\\u0002\' => \'2\'\n      case \'\\u0003\' => \'3\'\n      case \'\\u0004\' => \'4\'\n      case \'\\u0005\' => \'5\'\n      case \'\\u0006\' => \'6\'\n      case \'\\u0007\' => \'7\'\n      case \'\\u0008\' => \'8\'\n      case \'\\u0009\' => \'9\'\n      case \'\\u000A\' => \'A\'\n      case \'\\u000B\' => \'B\'\n      case \'\\u000C\' => \'C\'\n      case \'\\u000D\' => \'D\'\n      case \'\\u000E\' => \'E\'\n      case \'\\u000F\' => \'F\'\n    }\n    return r\n  }\n\n  @pure def fromUnicodeHex(hex: ISZ[C]): Option[C] = {\n    if (hex.size != 4) {\n      return None[C]()\n    }\n    (c2hex(hex(0)), c2hex(hex(1)), c2hex(hex(2)), c2hex(hex(3))) match {\n      case (Some(c1), Some(c2), Some(c3), Some(c4)) =>\n        return Some((c1 << \'\\u000c\') | (c2 << \'\\u0008\') | (c3 << \'\\u0004\') | c4)\n      case _ => return None[C]()\n    }\n  }\n}
  #723 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.message.Reporter\n\nobject StringOps {\n  @pure def replace(content: ISZ[C], offsetOldNewStringMap: HashMap[Z, (String, String)]): Either[String, String] = {\n    if (offsetOldNewStringMap.isEmpty) {\n      return Either.Left(conversions.String.fromCis(content))\n    }\n    var m = offsetOldNewStringMap\n    var r = ISZ[C]()\n    val size = content.size\n    var i: Z = 0\n    while (i < size) {\n      m.get(i) match {\n        case Some(pair@(oldString, newString)) =>\n          val oldChars = conversions.String.toCis(oldString)\n          for (j <- 0 until oldChars.size) {\n            if (i + j >= size || content(i + j) != oldChars(j)) {\n              var cs = ISZ[C]()\n              for (k <- 0 until oldChars.size if i + k < size) {\n                cs = cs :+ content(i + k)\n              }\n              return Either.Right(st\"\"\"Expecting \"${(oldChars, \"\")}\" at offset $i, but found \"${(cs, \"\")}\" instead\"\"\".render)\n            }\n          }\n          r = r ++ conversions.String.toCis(newString)\n          i = i + oldString.size\n          m = m - i ~> pair\n        case _ =>\n          r = r :+ content(i)\n          i = i + 1\n      }\n    }\n    return Either.Left(conversions.String.fromCis(r))\n  }\n\n  @pure def substring(cis: ISZ[C], start: Z, until: Z): String = {\n    if (until - start <= 0) {\n      return \"\"\n    }\n    val ms = MSZ.create[C](until - start, \'\\u0000\')\n    var i = start\n    var j = 0\n    while (i < until) {\n      ms(j) = cis(i)\n      i = i + 1\n      j = j + 1\n    }\n    return conversions.String.fromCms(ms)\n  }\n\n  @pure def replaceAllLiterally(cis: ISZ[C], from: String, to: String): String = {\n    var r = ISZ[C]()\n    var i: Z = 0\n    val toSize = to.size\n    val fromSize = from.size\n    val fromCis = conversions.String.toCis(from)\n    val toCis = conversions.String.toCis(to)\n    val size = cis.size\n    while (i + fromSize < size) {\n      var j = 0\n      var found = T\n      while (i + j < size && j < fromSize && found) {\n        if (cis(i + j) != fromCis(j)) {\n          found = F\n        }\n        j = j + 1\n      }\n      if (found && j == fromSize) {\n        for (j <- 0 until toSize) {\n          r = r :+ toCis(j)\n        }\n        i = i + fromSize - 1\n      } else {\n        r = r :+ cis(i)\n      }\n      i = i + 1\n    }\n\n    var isSuffix = F\n    if(i + fromSize == size) {\n      var index = i\n      while(index < size && cis(index) == fromCis(index - i)) {\n        index = index + 1\n      }\n      isSuffix = index == size\n    }\n\n    if(isSuffix) {\n      r = r ++ toCis\n    } else {\n      while (i < size) {\n        r = r :+ cis(i)\n        i = i + 1\n      }\n    }\n    return conversions.String.fromCis(r)\n  }\n}\n\n@datatype class StringOps(val s: String) {\n\n  @pure def first: C = {\n//    l\"\"\" requires s.size > 0 \"\"\"\n    return conversions.String.toCis(s)(0)\n  }\n\n  @pure def substring(start: Z, until: Z): String = {\n//    l\"\"\" requires 0 ≤ start ∧ start < s.size\n//                  start ≤ until\n//                  until ≤ s.size\n//         ensures  result.size ≡ until - start\n//                  ∀i: [0, result.size) result(i) ≡ s(start + i) \"\"\"\n    return StringOps.substring(conversions.String.toCis(s), start, until)\n  }\n\n  @pure def startsWith(other: String): B = {\n//    l\"\"\" ensures  result ≡ ((size >= other.size) ∧\n//                            ∀i: [0, other.size) s(i) ≡ other(i)) \"\"\"\n    if (s.size < other.size) {\n      return F\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    for (i <- z\"0\" until other.size) {\n      if (otherCis(i) != cis(i)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def endsWith(other: String): B = {\n//    l\"\"\" ensures  result ≡ ((size >= other.size) ∧\n//                            ∀i: [0, other.size) s(i + other.size - s.size) ≡ other(i)) \"\"\"\n    if (s.size < other.size) {\n      return F\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    val offset = s.size - other.size\n    for (i <- other.size - 1 to 0 by -1) {\n      if (otherCis(i) != cis(offset + i)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def firstToUpper: String = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size\n//                  result(0) ≡ conversions.COps(s(0)).toUpper\n//                  ∀i: [1, s.size) result(i) ≡ s(i)   \"\"\"\n    val cms = conversions.String.toCms(s)\n    cms(0) = COps(cms(0)).toUpper\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def toUpper: String = {\n    val cms = conversions.String.toCms(s)\n    for (i <- 0 until cms.size) {\n      cms(i) = COps(cms(i)).toUpper\n    }\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def firstToLower: String = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size\n//                  result(0) ≡ conversions.COps(s(0)).toLower\n//                  ∀i: [1, s.size) result(i) ≡ s(i)   \"\"\"\n    val cms = conversions.String.toCms(s)\n    cms(0) = COps(cms(0)).toLower\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def toLower: String = {\n    val cms = conversions.String.toCms(s)\n    for (i <- 0 until cms.size) {\n      cms(i) = COps(cms(i)).toLower\n    }\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def contains(other: String): B = {\n    return stringIndexOf(other) >= 0\n  }\n\n  @pure def stringIndexOf(other: String): Z = {\n    return stringIndexOfFrom(other, 0)\n  }\n\n  @pure def stringIndexOfFrom(other: String, offset: Z): Z = {\n    val size = s.size\n    if (!(0 <= offset && offset < size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    val otherSize = other.size\n    var i = offset\n    while (i + otherSize <= size) {\n      var j = 0\n      var found = T\n      while (j < otherSize && found) {\n        if (cis(i + j) != otherCis(j)) {\n          found = F\n        }\n        j = j + 1\n      }\n      if (found) {\n        return i\n      }\n      i = i + 1\n    }\n    return -1\n  }\n\n  @pure def indexOf(c: C): Z = {\n    return indexOfFrom(c, 0)\n  }\n\n  @pure def indexOfFrom(c: C, offset: Z): Z = {\n    if (!(0 <= offset && offset < s.size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    for (i <- offset until s.size) {\n      if (cis(i) == c) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  @pure def lastIndexOf(c: C): Z = {\n    return lastIndexOfFrom(c, s.size - 1)\n  }\n\n  @pure def lastIndexOfFrom(c: C, offset: Z): Z = {\n    if (!(0 <= offset && offset < s.size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    for (i <- offset to 0 by -1) {\n      if (cis(i) == c) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  @pure def replaceAllChars(from: C, to: C): String = {\n    val cs = conversions.String.toCms(s)\n    for (i <- 0 until cs.size if cs(i) == from) {\n      cs(i) = to\n    }\n    return conversions.String.fromCms(cs)\n  }\n\n  @pure def replaceAllLiterally(from: String, to: String): String = {\n    return StringOps.replaceAllLiterally(conversions.String.toCis(s), from, to)\n  }\n\n  @pure def split(isSep: C => B @pure): ISZ[String] = {\n    var r = ISZ[String]()\n    val cis = conversions.String.toCis(s)\n    var last = 0\n    val size = s.size\n    while (last < size && isSep(cis(last))) {\n      last = last + 1\n    }\n    var i = last\n    while (i < size) {\n      if (isSep(cis(i)) && last != i) {\n        r = r :+ StringOps.substring(cis, last, i)\n        i = i + 1\n        while (i < size && isSep(cis(i))) {\n          i = i + 1\n        }\n        last = i\n      }\n      i = i + 1\n    }\n    if (last < size) {\n      r = r :+ StringOps.substring(cis, last, i)\n    }\n    return r\n  }\n\n  @pure def trim: String = {\n    var i = 0\n    val size = s.size\n    val cis = conversions.String.toCis(s)\n    while (i < size && cis(i).isWhitespace) {\n      i = i + 1\n    }\n    var j = size - 1\n    while (j >= 0 && cis(j).isWhitespace) {\n      j = j - 1\n    }\n    return if (i <= j) StringOps.substring(cis, i, j + 1) else \"\"\n  }\n\n  @pure def trimTrailing: String = {\n    val size = s.size\n    val cis = conversions.String.toCis(s)\n    var j = size - 1\n    while (j >= 0 && cis(j).isWhitespace) {\n      j = j - 1\n    }\n    return if (0 <= j) StringOps.substring(cis, 0, j + 1) else \"\"\n  }\n\n  @pure def size: Z = {\n    return s.size\n  }\n\n\n  def collectSections(errorKind: String,\n                      beginMarker: String,\n                      endMarker: String,\n                      reporter: Reporter): HashSMap[String, String] = {\n    var r = HashSMap.empty[String, String]\n    val lines = ops.StringOps(s).split(c => c == \'\\n\')\n    val size = lines.size\n    var i = 0\n    while (i < size) {\n      val line = lines(i)\n      val lOps = ops.StringOps(ops.StringOps(line).trim)\n      if (lOps.startsWith(beginMarker)) {\n        val name = ops.StringOps(lOps.substring(beginMarker.size, lOps.size)).trim\n        val beginLine = i\n        i = i + 1\n        var found = F\n        var code = ISZ[String]()\n        while (i < size && !found) {\n          val line2 = lines(i)\n          val lOps2 = ops.StringOps(ops.StringOps(line2).trim)\n          if (lOps2.startsWith(endMarker)) {\n            found = T\n            val name2 = ops.StringOps(lOps2.substring(endMarker.size, lOps2.size)).trim\n            if (name != name2) {\n              reporter.error(None(), errorKind,\n                s\"Mismatch marker at lines ${beginLine + 1} and ${i + 1} ($name != $name2)\")\n              return r\n            }\n            r = r + name ~> st\"${(code, \"\\n\")}\".render\n          } else {\n            code = code :+ ops.StringOps(line2).trimTrailing\n          }\n          i = i + 1\n        }\n        if (!found) {\n          reporter.error(None(), errorKind, s\"Unclosed marker at line ${beginLine + 1} for $name\")\n        }\n      }\n      i = i + 1\n    }\n    return r\n  }\n\n  @pure def escapeST: ST = {\n    return st\"\"\"${(for (c <- conversions.String.toCis(s)) yield ops.COps(c).escapeString, \"\")}\"\"\"\n  }\n\n  @pure def replaceStrings(offsetOldNewStringMap: HashMap[Z, (String, String)]): Either[String, String] = {\n    return StringOps.replace(conversions.String.toCis(s), offsetOldNewStringMap)\n  }\n\n  @pure def compareVersion(other: String): Z = {\n    @pure def removePrefix(str: String): String = {\n      val cis = conversions.String.toCis(str)\n      var i = 0\n      while (i < cis.size) {\n        val c = cis(i)\n        if (c === \'_\' || (\'a\' <= c && c <= \'z\') || (\'A\' <= c && c <= \'Z\') || c === \'$\') {\n          i = i + 1\n        } else {\n          return ops.StringOps(str).substring(i, str.size)\n        }\n      }\n      return \"\"\n    }\n    val v1Ops = ops.StringOps(removePrefix(s))\n    val v2Ops = ops.StringOps(removePrefix(other))\n    val p = (c: C) => c === \'.\'\n    val v1s = v1Ops.split(p)\n    val v2s = v2Ops.split(p)\n    val size: Z = if (v1s.size <= v2s.size) v1s.size else v2s.size\n    for (i <- 0 until size) {\n      (Z(v1s(i)), Z(v2s(i))) match {\n        case (Some(v1), Some(v2)) =>\n          if (v1 < v2) {\n            return -1\n          } else if (v1 > v2) {\n            return 1\n          }\n        case (_, _) =>\n          return 0\n      }\n    }\n    return 0\n  }\n}\n
  #724 = String             #723          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.message.Reporter\n\nobject StringOps {\n  @pure def replace(content: ISZ[C], offsetOldNewStringMap: HashMap[Z, (String, String)]): Either[String, String] = {\n    if (offsetOldNewStringMap.isEmpty) {\n      return Either.Left(conversions.String.fromCis(content))\n    }\n    var m = offsetOldNewStringMap\n    var r = ISZ[C]()\n    val size = content.size\n    var i: Z = 0\n    while (i < size) {\n      m.get(i) match {\n        case Some(pair@(oldString, newString)) =>\n          val oldChars = conversions.String.toCis(oldString)\n          for (j <- 0 until oldChars.size) {\n            if (i + j >= size || content(i + j) != oldChars(j)) {\n              var cs = ISZ[C]()\n              for (k <- 0 until oldChars.size if i + k < size) {\n                cs = cs :+ content(i + k)\n              }\n              return Either.Right(st\"\"\"Expecting \"${(oldChars, \"\")}\" at offset $i, but found \"${(cs, \"\")}\" instead\"\"\".render)\n            }\n          }\n          r = r ++ conversions.String.toCis(newString)\n          i = i + oldString.size\n          m = m - i ~> pair\n        case _ =>\n          r = r :+ content(i)\n          i = i + 1\n      }\n    }\n    return Either.Left(conversions.String.fromCis(r))\n  }\n\n  @pure def substring(cis: ISZ[C], start: Z, until: Z): String = {\n    if (until - start <= 0) {\n      return \"\"\n    }\n    val ms = MSZ.create[C](until - start, \'\\u0000\')\n    var i = start\n    var j = 0\n    while (i < until) {\n      ms(j) = cis(i)\n      i = i + 1\n      j = j + 1\n    }\n    return conversions.String.fromCms(ms)\n  }\n\n  @pure def replaceAllLiterally(cis: ISZ[C], from: String, to: String): String = {\n    var r = ISZ[C]()\n    var i: Z = 0\n    val toSize = to.size\n    val fromSize = from.size\n    val fromCis = conversions.String.toCis(from)\n    val toCis = conversions.String.toCis(to)\n    val size = cis.size\n    while (i + fromSize < size) {\n      var j = 0\n      var found = T\n      while (i + j < size && j < fromSize && found) {\n        if (cis(i + j) != fromCis(j)) {\n          found = F\n        }\n        j = j + 1\n      }\n      if (found && j == fromSize) {\n        for (j <- 0 until toSize) {\n          r = r :+ toCis(j)\n        }\n        i = i + fromSize - 1\n      } else {\n        r = r :+ cis(i)\n      }\n      i = i + 1\n    }\n\n    var isSuffix = F\n    if(i + fromSize == size) {\n      var index = i\n      while(index < size && cis(index) == fromCis(index - i)) {\n        index = index + 1\n      }\n      isSuffix = index == size\n    }\n\n    if(isSuffix) {\n      r = r ++ toCis\n    } else {\n      while (i < size) {\n        r = r :+ cis(i)\n        i = i + 1\n      }\n    }\n    return conversions.String.fromCis(r)\n  }\n}\n\n@datatype class StringOps(val s: String) {\n\n  @pure def first: C = {\n//    l\"\"\" requires s.size > 0 \"\"\"\n    return conversions.String.toCis(s)(0)\n  }\n\n  @pure def substring(start: Z, until: Z): String = {\n//    l\"\"\" requires 0 ≤ start ∧ start < s.size\n//                  start ≤ until\n//                  until ≤ s.size\n//         ensures  result.size ≡ until - start\n//                  ∀i: [0, result.size) result(i) ≡ s(start + i) \"\"\"\n    return StringOps.substring(conversions.String.toCis(s), start, until)\n  }\n\n  @pure def startsWith(other: String): B = {\n//    l\"\"\" ensures  result ≡ ((size >= other.size) ∧\n//                            ∀i: [0, other.size) s(i) ≡ other(i)) \"\"\"\n    if (s.size < other.size) {\n      return F\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    for (i <- z\"0\" until other.size) {\n      if (otherCis(i) != cis(i)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def endsWith(other: String): B = {\n//    l\"\"\" ensures  result ≡ ((size >= other.size) ∧\n//                            ∀i: [0, other.size) s(i + other.size - s.size) ≡ other(i)) \"\"\"\n    if (s.size < other.size) {\n      return F\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    val offset = s.size - other.size\n    for (i <- other.size - 1 to 0 by -1) {\n      if (otherCis(i) != cis(offset + i)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def firstToUpper: String = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size\n//                  result(0) ≡ conversions.COps(s(0)).toUpper\n//                  ∀i: [1, s.size) result(i) ≡ s(i)   \"\"\"\n    val cms = conversions.String.toCms(s)\n    cms(0) = COps(cms(0)).toUpper\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def toUpper: String = {\n    val cms = conversions.String.toCms(s)\n    for (i <- 0 until cms.size) {\n      cms(i) = COps(cms(i)).toUpper\n    }\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def firstToLower: String = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size\n//                  result(0) ≡ conversions.COps(s(0)).toLower\n//                  ∀i: [1, s.size) result(i) ≡ s(i)   \"\"\"\n    val cms = conversions.String.toCms(s)\n    cms(0) = COps(cms(0)).toLower\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def toLower: String = {\n    val cms = conversions.String.toCms(s)\n    for (i <- 0 until cms.size) {\n      cms(i) = COps(cms(i)).toLower\n    }\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def contains(other: String): B = {\n    return stringIndexOf(other) >= 0\n  }\n\n  @pure def stringIndexOf(other: String): Z = {\n    return stringIndexOfFrom(other, 0)\n  }\n\n  @pure def stringIndexOfFrom(other: String, offset: Z): Z = {\n    val size = s.size\n    if (!(0 <= offset && offset < size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    val otherSize = other.size\n    var i = offset\n    while (i + otherSize <= size) {\n      var j = 0\n      var found = T\n      while (j < otherSize && found) {\n        if (cis(i + j) != otherCis(j)) {\n          found = F\n        }\n        j = j + 1\n      }\n      if (found) {\n        return i\n      }\n      i = i + 1\n    }\n    return -1\n  }\n\n  @pure def indexOf(c: C): Z = {\n    return indexOfFrom(c, 0)\n  }\n\n  @pure def indexOfFrom(c: C, offset: Z): Z = {\n    if (!(0 <= offset && offset < s.size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    for (i <- offset until s.size) {\n      if (cis(i) == c) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  @pure def lastIndexOf(c: C): Z = {\n    return lastIndexOfFrom(c, s.size - 1)\n  }\n\n  @pure def lastIndexOfFrom(c: C, offset: Z): Z = {\n    if (!(0 <= offset && offset < s.size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    for (i <- offset to 0 by -1) {\n      if (cis(i) == c) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  @pure def replaceAllChars(from: C, to: C): String = {\n    val cs = conversions.String.toCms(s)\n    for (i <- 0 until cs.size if cs(i) == from) {\n      cs(i) = to\n    }\n    return conversions.String.fromCms(cs)\n  }\n\n  @pure def replaceAllLiterally(from: String, to: String): String = {\n    return StringOps.replaceAllLiterally(conversions.String.toCis(s), from, to)\n  }\n\n  @pure def split(isSep: C => B @pure): ISZ[String] = {\n    var r = ISZ[String]()\n    val cis = conversions.String.toCis(s)\n    var last = 0\n    val size = s.size\n    while (last < size && isSep(cis(last))) {\n      last = last + 1\n    }\n    var i = last\n    while (i < size) {\n      if (isSep(cis(i)) && last != i) {\n        r = r :+ StringOps.substring(cis, last, i)\n        i = i + 1\n        while (i < size && isSep(cis(i))) {\n          i = i + 1\n        }\n        last = i\n      }\n      i = i + 1\n    }\n    if (last < size) {\n      r = r :+ StringOps.substring(cis, last, i)\n    }\n    return r\n  }\n\n  @pure def trim: String = {\n    var i = 0\n    val size = s.size\n    val cis = conversions.String.toCis(s)\n    while (i < size && cis(i).isWhitespace) {\n      i = i + 1\n    }\n    var j = size - 1\n    while (j >= 0 && cis(j).isWhitespace) {\n      j = j - 1\n    }\n    return if (i <= j) StringOps.substring(cis, i, j + 1) else \"\"\n  }\n\n  @pure def trimTrailing: String = {\n    val size = s.size\n    val cis = conversions.String.toCis(s)\n    var j = size - 1\n    while (j >= 0 && cis(j).isWhitespace) {\n      j = j - 1\n    }\n    return if (0 <= j) StringOps.substring(cis, 0, j + 1) else \"\"\n  }\n\n  @pure def size: Z = {\n    return s.size\n  }\n\n\n  def collectSections(errorKind: String,\n                      beginMarker: String,\n                      endMarker: String,\n                      reporter: Reporter): HashSMap[String, String] = {\n    var r = HashSMap.empty[String, String]\n    val lines = ops.StringOps(s).split(c => c == \'\\n\')\n    val size = lines.size\n    var i = 0\n    while (i < size) {\n      val line = lines(i)\n      val lOps = ops.StringOps(ops.StringOps(line).trim)\n      if (lOps.startsWith(beginMarker)) {\n        val name = ops.StringOps(lOps.substring(beginMarker.size, lOps.size)).trim\n        val beginLine = i\n        i = i + 1\n        var found = F\n        var code = ISZ[String]()\n        while (i < size && !found) {\n          val line2 = lines(i)\n          val lOps2 = ops.StringOps(ops.StringOps(line2).trim)\n          if (lOps2.startsWith(endMarker)) {\n            found = T\n            val name2 = ops.StringOps(lOps2.substring(endMarker.size, lOps2.size)).trim\n            if (name != name2) {\n              reporter.error(None(), errorKind,\n                s\"Mismatch marker at lines ${beginLine + 1} and ${i + 1} ($name != $name2)\")\n              return r\n            }\n            r = r + name ~> st\"${(code, \"\\n\")}\".render\n          } else {\n            code = code :+ ops.StringOps(line2).trimTrailing\n          }\n          i = i + 1\n        }\n        if (!found) {\n          reporter.error(None(), errorKind, s\"Unclosed marker at line ${beginLine + 1} for $name\")\n        }\n      }\n      i = i + 1\n    }\n    return r\n  }\n\n  @pure def escapeST: ST = {\n    return st\"\"\"${(for (c <- conversions.String.toCis(s)) yield ops.COps(c).escapeString, \"\")}\"\"\"\n  }\n\n  @pure def replaceStrings(offsetOldNewStringMap: HashMap[Z, (String, String)]): Either[String, String] = {\n    return StringOps.replace(conversions.String.toCis(s), offsetOldNewStringMap)\n  }\n\n  @pure def compareVersion(other: String): Z = {\n    @pure def removePrefix(str: String): String = {\n      val cis = conversions.String.toCis(str)\n      var i = 0\n      while (i < cis.size) {\n        val c = cis(i)\n        if (c === \'_\' || (\'a\' <= c && c <= \'z\') || (\'A\' <= c && c <= \'Z\') || c === \'$\') {\n          i = i + 1\n        } else {\n          return ops.StringOps(str).substring(i, str.size)\n        }\n      }\n      return \"\"\n    }\n    val v1Ops = ops.StringOps(removePrefix(s))\n    val v2Ops = ops.StringOps(removePrefix(other))\n    val p = (c: C) => c === \'.\'\n    val v1s = v1Ops.split(p)\n    val v2s = v2Ops.split(p)\n    val size: Z = if (v1s.size <= v2s.size) v1s.size else v2s.size\n    for (i <- 0 until size) {\n      (Z(v1s(i)), Z(v2s(i))) match {\n        case (Some(v1), Some(v2)) =>\n          if (v1 < v2) {\n            return -1\n          } else if (v1 > v2) {\n            return 1\n          }\n        case (_, _) =>\n          return 0\n      }\n    }\n    return 0\n  }\n}\n
  #725 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Hariharan Thiagarajan, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.Graph\n\n@datatype class GraphOps[W, E](val graph: Graph[W, E]) {\n\n  @pure def getEdgeData(e: Graph.Edge[W, E]): Option[E] = {\n    e match {\n      case Graph.Edge.Data(_, _, ed) => return Some[E](ed)\n      case _ => return None[E]()\n    }\n  }\n\n  @pure def getAllSuccessor(v: W): Set[W] = {\n    if (graph.outgoingEdges.get(graph.nodes.get(v).get).nonEmpty) {\n      return Set.empty[W] ++ (for (es <- graph.outgoingEdges.get(graph.nodes.get(v).get).get.elements)\n        yield graph.nodesInverse(es.dest))\n    } else {\n      return Set.empty[W]\n    }\n  }\n\n  @pure def getAllPredecessor(v: W): Set[W] = {\n    if (graph.incomingEdges.get(graph.nodes.get(v).get).nonEmpty) {\n      return Set.empty[W] ++ (for (es <- graph.incomingEdges.get(graph.nodes.get(v).get).get.elements)\n        yield graph.nodesInverse(es.source))\n    } else {\n      return Set.empty[W]\n    }\n\n  }\n\n  @pure def getSCC: ISZ[HashSSet[W]] = {\n    var result = ISZ[HashSSet[W]]()\n    var discoveryMap: HashSMap[W, (B, B)] =\n      HashSMap ++ (for (v <- graph.nodes.keys) yield (v, (F, F)))\n\n    def resetDiscoveryMap(): Unit = {\n      discoveryMap = HashSMap ++ (for (e <- discoveryMap.entries) yield (e._1, (F, F)))\n    }\n\n    def setDiscovered(v: W): B = {\n      return discoveryMap.get(v).exists { cf =>\n        discoveryMap = discoveryMap + ((v, (T, cf._2)))\n        T\n      }\n    }\n\n    def setBoth(v: W): Unit = {\n      discoveryMap = discoveryMap + ((v, (T, T)))\n    }\n\n    def isAllMySuccDiscovered(v: W): B = {\n      return ISZOps(for (s <- getAllSuccessor(v).elements; e <- discoveryMap.get(s).toIS) yield e._1)\n        .foldLeft((c: B, n: B) => c & n, T)\n    }\n\n    def dfs(v: W, isFirst: B): ISZ[W] = {\n      var r = ISZ[W]()\n      var stack = Stack.empty[W]\n      stack = stack.push(v)\n\n      while (stack.nonEmpty) {\n        val current = stack.pop.get\n        stack = current._2\n        if (discoveryMap.get(current._1).nonEmpty\n          && !discoveryMap.get(current._1).get._1) {\n          setDiscovered(current._1)\n          if (!isFirst) {\n            r = r :+ current._1\n          }\n          setBoth(current._1)\n          stack = stack.push(current._1)\n\n          val nexts: Set[W] = if (isFirst) getAllSuccessor(current._1) else getAllPredecessor(current._1)\n\n          for (n <- nexts.elements) {\n            if (!discoveryMap.get(n).get._1) {\n              stack = stack.push(n)\n            }\n          }\n\n        } else if (discoveryMap.get(current._1).get._2 && isFirst) {\n          r = current._1 +: r\n        }\n      }\n      return r\n    }\n\n    var orderedNodes = ISZ[W]()\n\n    for (k <- graph.nodes.keys) {\n      if (!discoveryMap.get(k).get._1) {\n        orderedNodes = dfs(k, T) ++ orderedNodes\n      }\n    }\n    resetDiscoveryMap()\n    for (k <- orderedNodes) {\n      if (!discoveryMap.get(k).get._1) {\n        result = result :+ HashSSet.empty[W] ++ dfs(k, F)\n      }\n    }\n    return result\n  }\n\n  @pure def getCycles: ISZ[ISZ[W]] = {\n    val sccs = getSCC\n    var loops = ISZ[ISZ[W]]()\n    var bSets = HashSMap.empty[W, Set[W]]\n    var stack = Stack.empty[W]\n    var marked = Set.empty[W]\n    var removed = HashSMap.empty[W, Set[W]]\n    var position = HashSMap.empty[W, Z]\n    var reach = HashSMap.empty[W, B] ++ (for (k <- graph.nodes.keys) yield (k, F))\n\n    def cycle(v: W, tq: Z): B = {\n      var q = tq\n      var foundCycle = F\n      marked = marked + v\n      stack = stack.push(v)\n      val t = stack.size\n      position = position + ((v, t))\n      if (!reach.get(v).get) {\n        q = t\n      }\n      val avRemoved: Set[W] = removed.get(v) match {\n        case Some(r) => r\n        case _ => Set.empty[W]\n      }\n\n      for (wV <- getAllSuccessor(v).elements) {\n        if (!avRemoved.contains(wV)) {\n          if (!marked.contains(wV)) {\n            val gotCycle = cycle(wV, q)\n            if (gotCycle) {\n              foundCycle = T\n            } else {\n              noCycle(v, wV)\n            }\n          } else if (position.get(wV).nonEmpty && position.get(wV).get <= q) {\n            foundCycle = T\n            var cycle = ISZ[W]()\n            val elements = stack.elements\n            var current = stack.peek.get\n            var break = T\n            var i = 0\n            while (i < elements.size && break) {\n              current = elements(i)\n              if (wV == current) {\n                break = F\n              }\n              i = i + 1\n            }\n            cycle = cycle :+ wV\n            break = T\n            while (i < elements.size && break) {\n              current = elements(i)\n              cycle = cycle :+ current\n              if (current == v) {\n                break = F\n              }\n              i = i + 1\n            }\n            loops = loops :+ cycle\n          } else {\n            noCycle(v, wV)\n          }\n        }\n      }\n      stack = stack.pop.get._2\n      if (foundCycle) {\n        unmark(v)\n      }\n      reach = reach + ((v, T))\n      position = position + ((v, graph.nodes.size))\n      return foundCycle\n    }\n\n    def unmark(x: W): Unit = {\n      marked = marked - x\n      val temp: Set[W] = bSets.get(x) match {\n        case Some(bsx) => bsx\n        case _ => Set.empty[W]\n      }\n\n      for (y <- temp.elements) {\n        val t: Set[W] = removed.get(y) match {\n          case Some(ry) => ry - x\n          case _ => Set.empty[W] - x\n        }\n        removed = removed + ((y, t))\n        if (marked.contains(y)) {\n          unmark(y)\n        }\n      }\n      bSets = bSets + ((x, Set.empty[W]))\n    }\n\n    def noCycle(x: W, y: W): Unit = {\n      val t1: Set[W] = bSets.get(y) match {\n        case Some(bs) => bs\n        case _ => Set.empty[W]\n      }\n      bSets = bSets + ((y, t1))\n      val t2: Set[W] = removed.get(x) match {\n        case Some(rx) => rx + y\n        case _ => Set.empty[W] + y\n      }\n      removed = removed + ((x, t2))\n    }\n\n    var startNodes = ISZ[W]()\n    for (scc <- sccs) {\n      var max: Z = -1\n      var startNode = scc.elements(0)\n      for (node <- scc.elements) {\n        val inedges = graph.incomingEdges.get(graph.nodes.get(node).get)\n        val inDegree: Z = if (inedges.nonEmpty) inedges.get.size else 0\n        if (inDegree > max) {\n          max = inDegree\n          startNode = node\n        }\n      }\n      startNodes = startNodes :+ startNode\n    }\n\n    for (n <- startNodes) {\n      cycle(n, 0)\n    }\n\n    return loops\n  }\n\n  @pure def forwardReach(criteria: ISZ[W]): ISZ[W] = {\n    val r = reachable(criteria, T)\n    return r\n  }\n\n  @pure def backwardReach(criteria: ISZ[W]): ISZ[W] = {\n    val r = reachable(criteria, F)\n    return r\n  }\n\n  @pure def reachable(criteria: ISZ[W], isForward: B): ISZ[W] = {\n    var workList = ISZ[W]()\n    workList = workList ++ criteria\n    var result = HashSSet.empty[W]\n\n    while (workList.nonEmpty) {\n      val current = ISZOps(workList).first\n      if (!result.contains(current)) {\n        val next: Set[W] =\n          if (isForward)\n            getAllSuccessor(current)\n          else getAllPredecessor(current)\n        workList = workList ++ next.elements\n        result = result + current\n      }\n      workList = ISZOps(workList).tail\n    }\n    return result.elements\n  }\n\n}\n
  #726 = String             #725          // // #Sireum\n/*\n Copyright (c) 2017-2022, Hariharan Thiagarajan, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.Graph\n\n@datatype class GraphOps[W, E](val graph: Graph[W, E]) {\n\n  @pure def getEdgeData(e: Graph.Edge[W, E]): Option[E] = {\n    e match {\n      case Graph.Edge.Data(_, _, ed) => return Some[E](ed)\n      case _ => return None[E]()\n    }\n  }\n\n  @pure def getAllSuccessor(v: W): Set[W] = {\n    if (graph.outgoingEdges.get(graph.nodes.get(v).get).nonEmpty) {\n      return Set.empty[W] ++ (for (es <- graph.outgoingEdges.get(graph.nodes.get(v).get).get.elements)\n        yield graph.nodesInverse(es.dest))\n    } else {\n      return Set.empty[W]\n    }\n  }\n\n  @pure def getAllPredecessor(v: W): Set[W] = {\n    if (graph.incomingEdges.get(graph.nodes.get(v).get).nonEmpty) {\n      return Set.empty[W] ++ (for (es <- graph.incomingEdges.get(graph.nodes.get(v).get).get.elements)\n        yield graph.nodesInverse(es.source))\n    } else {\n      return Set.empty[W]\n    }\n\n  }\n\n  @pure def getSCC: ISZ[HashSSet[W]] = {\n    var result = ISZ[HashSSet[W]]()\n    var discoveryMap: HashSMap[W, (B, B)] =\n      HashSMap ++ (for (v <- graph.nodes.keys) yield (v, (F, F)))\n\n    def resetDiscoveryMap(): Unit = {\n      discoveryMap = HashSMap ++ (for (e <- discoveryMap.entries) yield (e._1, (F, F)))\n    }\n\n    def setDiscovered(v: W): B = {\n      return discoveryMap.get(v).exists { cf =>\n        discoveryMap = discoveryMap + ((v, (T, cf._2)))\n        T\n      }\n    }\n\n    def setBoth(v: W): Unit = {\n      discoveryMap = discoveryMap + ((v, (T, T)))\n    }\n\n    def isAllMySuccDiscovered(v: W): B = {\n      return ISZOps(for (s <- getAllSuccessor(v).elements; e <- discoveryMap.get(s).toIS) yield e._1)\n        .foldLeft((c: B, n: B) => c & n, T)\n    }\n\n    def dfs(v: W, isFirst: B): ISZ[W] = {\n      var r = ISZ[W]()\n      var stack = Stack.empty[W]\n      stack = stack.push(v)\n\n      while (stack.nonEmpty) {\n        val current = stack.pop.get\n        stack = current._2\n        if (discoveryMap.get(current._1).nonEmpty\n          && !discoveryMap.get(current._1).get._1) {\n          setDiscovered(current._1)\n          if (!isFirst) {\n            r = r :+ current._1\n          }\n          setBoth(current._1)\n          stack = stack.push(current._1)\n\n          val nexts: Set[W] = if (isFirst) getAllSuccessor(current._1) else getAllPredecessor(current._1)\n\n          for (n <- nexts.elements) {\n            if (!discoveryMap.get(n).get._1) {\n              stack = stack.push(n)\n            }\n          }\n\n        } else if (discoveryMap.get(current._1).get._2 && isFirst) {\n          r = current._1 +: r\n        }\n      }\n      return r\n    }\n\n    var orderedNodes = ISZ[W]()\n\n    for (k <- graph.nodes.keys) {\n      if (!discoveryMap.get(k).get._1) {\n        orderedNodes = dfs(k, T) ++ orderedNodes\n      }\n    }\n    resetDiscoveryMap()\n    for (k <- orderedNodes) {\n      if (!discoveryMap.get(k).get._1) {\n        result = result :+ HashSSet.empty[W] ++ dfs(k, F)\n      }\n    }\n    return result\n  }\n\n  @pure def getCycles: ISZ[ISZ[W]] = {\n    val sccs = getSCC\n    var loops = ISZ[ISZ[W]]()\n    var bSets = HashSMap.empty[W, Set[W]]\n    var stack = Stack.empty[W]\n    var marked = Set.empty[W]\n    var removed = HashSMap.empty[W, Set[W]]\n    var position = HashSMap.empty[W, Z]\n    var reach = HashSMap.empty[W, B] ++ (for (k <- graph.nodes.keys) yield (k, F))\n\n    def cycle(v: W, tq: Z): B = {\n      var q = tq\n      var foundCycle = F\n      marked = marked + v\n      stack = stack.push(v)\n      val t = stack.size\n      position = position + ((v, t))\n      if (!reach.get(v).get) {\n        q = t\n      }\n      val avRemoved: Set[W] = removed.get(v) match {\n        case Some(r) => r\n        case _ => Set.empty[W]\n      }\n\n      for (wV <- getAllSuccessor(v).elements) {\n        if (!avRemoved.contains(wV)) {\n          if (!marked.contains(wV)) {\n            val gotCycle = cycle(wV, q)\n            if (gotCycle) {\n              foundCycle = T\n            } else {\n              noCycle(v, wV)\n            }\n          } else if (position.get(wV).nonEmpty && position.get(wV).get <= q) {\n            foundCycle = T\n            var cycle = ISZ[W]()\n            val elements = stack.elements\n            var current = stack.peek.get\n            var break = T\n            var i = 0\n            while (i < elements.size && break) {\n              current = elements(i)\n              if (wV == current) {\n                break = F\n              }\n              i = i + 1\n            }\n            cycle = cycle :+ wV\n            break = T\n            while (i < elements.size && break) {\n              current = elements(i)\n              cycle = cycle :+ current\n              if (current == v) {\n                break = F\n              }\n              i = i + 1\n            }\n            loops = loops :+ cycle\n          } else {\n            noCycle(v, wV)\n          }\n        }\n      }\n      stack = stack.pop.get._2\n      if (foundCycle) {\n        unmark(v)\n      }\n      reach = reach + ((v, T))\n      position = position + ((v, graph.nodes.size))\n      return foundCycle\n    }\n\n    def unmark(x: W): Unit = {\n      marked = marked - x\n      val temp: Set[W] = bSets.get(x) match {\n        case Some(bsx) => bsx\n        case _ => Set.empty[W]\n      }\n\n      for (y <- temp.elements) {\n        val t: Set[W] = removed.get(y) match {\n          case Some(ry) => ry - x\n          case _ => Set.empty[W] - x\n        }\n        removed = removed + ((y, t))\n        if (marked.contains(y)) {\n          unmark(y)\n        }\n      }\n      bSets = bSets + ((x, Set.empty[W]))\n    }\n\n    def noCycle(x: W, y: W): Unit = {\n      val t1: Set[W] = bSets.get(y) match {\n        case Some(bs) => bs\n        case _ => Set.empty[W]\n      }\n      bSets = bSets + ((y, t1))\n      val t2: Set[W] = removed.get(x) match {\n        case Some(rx) => rx + y\n        case _ => Set.empty[W] + y\n      }\n      removed = removed + ((x, t2))\n    }\n\n    var startNodes = ISZ[W]()\n    for (scc <- sccs) {\n      var max: Z = -1\n      var startNode = scc.elements(0)\n      for (node <- scc.elements) {\n        val inedges = graph.incomingEdges.get(graph.nodes.get(node).get)\n        val inDegree: Z = if (inedges.nonEmpty) inedges.get.size else 0\n        if (inDegree > max) {\n          max = inDegree\n          startNode = node\n        }\n      }\n      startNodes = startNodes :+ startNode\n    }\n\n    for (n <- startNodes) {\n      cycle(n, 0)\n    }\n\n    return loops\n  }\n\n  @pure def forwardReach(criteria: ISZ[W]): ISZ[W] = {\n    val r = reachable(criteria, T)\n    return r\n  }\n\n  @pure def backwardReach(criteria: ISZ[W]): ISZ[W] = {\n    val r = reachable(criteria, F)\n    return r\n  }\n\n  @pure def reachable(criteria: ISZ[W], isForward: B): ISZ[W] = {\n    var workList = ISZ[W]()\n    workList = workList ++ criteria\n    var result = HashSSet.empty[W]\n\n    while (workList.nonEmpty) {\n      val current = ISZOps(workList).first\n      if (!result.contains(current)) {\n        val next: Set[W] =\n          if (isForward)\n            getAllSuccessor(current)\n          else getAllPredecessor(current)\n        workList = workList ++ next.elements\n        result = result + current\n      }\n      workList = ISZOps(workList).tail\n    }\n    return result.elements\n  }\n\n}\n
  #727 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\n\n@sig trait ISOps[I, T] {\n\n  @pure def contains(e: T): B\n\n  @pure def exists(p: T => B @pure): B\n\n  @pure def first: T\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def forall(p: T => B @pure): B\n\n  @pure def indexOf(e: T): I\n\n  @pure def last: T\n\n  @pure def :+(e: T): IS[I, T]\n\n  @pure def +:(e: T): IS[I, T]\n\n  @pure def ++(other: IS[I, T]): IS[I, T]\n\n  @pure def chunk(size: Z): IS[Z, IS[I, T]]\n\n  @pure def drop(size: Z): IS[I, T]\n\n  @pure def dropRight(size: Z): IS[I, T]\n\n  @pure def filter(p: T => B @pure): IS[I, T]\n\n  @pure def filterNot(p: T => B @pure): IS[Z, T]\n\n  @pure def insert(i: I, e: T): IS[I, T]\n\n  @pure def laxSlice(from: I, til: I): IS[I, T]\n\n  @pure def map[U](f: T => U @pure): IS[I, U]\n\n  @pure def remove(i: I): IS[I, T]\n\n  @pure def reverse: IS[I, T]\n\n  @pure def slice(from: I, til: I): IS[I, T]\n\n  @pure def sortWith(lt: (T, T) => B @pure): IS[I, T]\n\n  @pure def tail: IS[I, T]\n\n  @pure def take(size: Z): IS[I, T]\n\n  @pure def takeRight(size: Z): IS[Z, T]\n\n  @pure def zip[T2](other: IS[Z, T2]): IS[Z, (T, T2)]\n\n}\n\n@msig trait MSOps[I, T] {\n\n  @pure def contains(e: T): B\n\n  @pure def exists(p: T => B @pure): B\n\n  @pure def first: T\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def forall(p: T => B @pure): B\n\n  @pure def indexOf(e: T): I\n\n  @pure def last: T\n\n  @pure def :+(e: T): MS[I, T]\n\n  @pure def +:(e: T): MS[I, T]\n\n  @pure def ++(other: MS[I, T]): MS[I, T]\n\n  @pure def chunk(size: Z): MS[Z, MS[I, T]]\n\n  @pure def drop(size: Z): MS[I, T]\n\n  @pure def dropRight(size: Z): MS[I, T]\n\n  @pure def filter(p: T => B @pure): MS[I, T]\n\n  @pure def filterNot(p: T => B @pure): MS[Z, T]\n\n  @pure def insert(i: I, e: T): MS[I, T]\n\n  @pure def laxSlice(from: I, til: I): MS[I, T]\n\n  @pure def map[U](f: T => U @pure): MS[I, U]\n\n  @pure def remove(i: I): MS[I, T]\n\n  @pure def reverse: MS[I, T]\n\n  @pure def slice(from: I, til: I): MS[I, T]\n\n  @pure def sortWith(lt: (T, T) => B @pure): MS[I, T]\n\n  @pure def tail: MS[I, T]\n\n  @pure def take(size: Z): MS[I, T]\n\n  @pure def takeRight(size: Z): MS[Z, T]\n\n  @pure def zip[T2](other: MS[Z, T2]): MS[Z, (T, T2)]\n\n}\n\n@ext object ISZOpsUtil {\n\n  @pure def parMap[V, U](s: IS[Z, V], f: V => U @pure): IS[Z, U] = $\n\n  def mParMap[V, U](s: IS[Z, V], f: V => U): IS[Z, U] = $\n\n  @pure def parMapCores[V, U](s: IS[Z, V], f: V => U @pure, numOfCores: Z): IS[Z, U] = $\n\n  def mParMapCores[V, U](s: IS[Z, V], f: V => U, numOfCores: Z): IS[Z, U] = $\n\n  @pure def sortWith[T](s: IS[Z, T], lt: (T, T) => B @pure): IS[Z, T] = $\n\n}\n\n@datatype class ISZOps[T](val s: IS[Z, T]) extends ISOps[Z, T] {\n\n  @pure def :+(e: T): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [0, result.size)  result(i) ≡ s(i)\n//                 result(result.size - 1) ≡ e            \"\"\"\n\n    return s :+ e\n  }\n\n  @pure def +:(e: T): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [1, result.size)  result(i) ≡ s(i - 1)\n//                 result(0) ≡ e                              \"\"\"\n\n    return e +: s\n  }\n\n  @pure def ++(other: IS[Z, T]): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + other.size\n//                 ∀i: [0, s.size)  result(i) ≡ s(i)\n//                 ∀i: [0, other.size)  result(s.size + i) ≡ other(i) \"\"\"\n\n    return s ++ other\n  }\n\n  @pure def chunk(size: Z): IS[Z, IS[Z, T]] = {\n//    l\"\"\" requires 0 < size\n//                  size <= s.size\n//         ensures  if (s.size % size ≡ 0) result.size * size ≡ s.size\n//                    else (result.size - 1) * size + s.size % size ≡ s.size\n//                  if (s.size % size ≡ 0) ∀i: [0, result.size)  result(i).size ≡ size\n//                    else ∀i: [0, result.size - 1)  result(i).size ≡ size\n//                  s.size % size ≠ 0 → result(result.size - 1).size ≡ s.size % size\n//                  ∀i: [0, result.size)\n//                    ∀j: [0, result(i).size)\n//                      s(i * result.size + j) ≡ result(i)(j)                          \"\"\"\n\n    var r = IS[Z, IS[Z, T]]()\n    var chunk = IS[Z, T]()\n    for (e <- s) {\n      if (chunk.size == size) {\n        r = r :+ chunk\n        chunk = IS[Z, T]()\n      }\n      chunk = chunk :+ e\n    }\n    if (chunk.nonEmpty) {\n      r = r :+ chunk\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) s(i) ≡ e) \"\"\"\n\n    for (v <- s) {\n      if (v == e) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def drop(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(size + i) \"\"\"\n\n    return laxSlice(size, s.size)\n  }\n\n  @pure def dropRight(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, s.size - size)\n  }\n\n  @pure def exists(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (p(e)) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def filter(p: T => B @pure): IS[Z, T] = {\n\n    var r = IS[Z, T]()\n    for (e <- s) {\n      if (p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def filterNot(p: T => B @pure): IS[Z, T] = {\n\n    var r = IS[Z, T]()\n    for (e <- s) {\n      if (!p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def first: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(0) \"\"\"\n\n    return s(0)\n  }\n\n  @pure def forall(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∀i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (!p(e)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  def mFoldLeft[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  def mFoldRight[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  @pure def insert(i: Z, e: T): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i <= s.size\n//         ensures  result.size ≡ s.size + 1\n//                  ∀j: [0, i) result(j) ≡ s(j)\n//                  result(i) ≡ e\n//                  ∀j: [j, s.size) result(j + 1) ≡ s(j) \"\"\"\n    return (laxSlice(0, i) :+ e) ++ laxSlice(i, s.size)\n  }\n\n  @pure def last: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(s.size - 1) \"\"\"\n\n    return s(s.size - 1)\n  }\n\n  @pure def indexOf(e: T): Z = {\n//    l\"\"\" ensures (0 ≤ result ∧ result < s.size) → s(result) ≡ e\n//                 (result ≡ s.size) ≡ (∀i: [0, s.size) s(i) ≠ e)\n//                 ∃i: [0, s.size) s(i) ≡ e ∧ (∀j: [0, i) s(j) ≠ e) → result ≡ i\n//                 0 ≤ result\n//                 result ≤ s.size                                \"\"\"\n    for (i <- z\"0\" until s.size if e == s(i)) {\n      return i\n    }\n    return s.size\n  }\n\n  @pure def laxSlice(from: Z, til: Z): IS[Z, T] = {\n//    l\"\"\" ensures if (til > from) result.size ≡ NO(til).min(s.size) - NO(0).max(from)\n//                   else result.size ≡ 0\n//                 ∀i: [i, result.size) result(i) ≡ s(NO(0).max(from) + i)               \"\"\"\n\n    if (from >= til || s.isEmpty) {\n      return ISZ()\n    }\n    val start: Z = if (from < 0) 0 else from\n    val until: Z = if (til <= s.size) til else s.size\n    val len = until - start\n    val r = MSZ.create(len, s(0))\n    for (i <- 0 until len) {\n      r(i) = s(start + i)\n    }\n    return r.toIS\n  }\n\n  @pure def map[U](f: T => U @pure): IS[Z, U] = {\n//    l\"\"\" ensures result.size ≡ s.size\n//                 ∀i: [0, result.size)  result(i) ≡ f(s(i)) \"\"\"\n\n    return s.map(f)\n  }\n\n  @pure def parMap[U](f: T => U @pure): IS[Z, U] = {\n    return ISZOpsUtil.parMap(s, f)\n  }\n\n  @pure def mParMap[U](f: T => U): IS[Z, U] = {\n    return ISZOpsUtil.mParMap(s, f)\n  }\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.ISZOps(parMap(f)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.ISZOps(mParMap(f)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.ISZOps(parMap(f)).foldRight(g, init)\n  }\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.ISZOps(mParMap(f)).mFoldRight(g, init)\n  }\n\n  @pure def parMapCores[U](f: T => U @pure, numOfCores: Z): IS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return ISZOpsUtil.parMapCores(s, f, numOfCores)\n    } else {\n      return map(f)\n    }\n  }\n\n  @pure def mParMapCores[U](f: T => U, numOfCores: Z): IS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return ISZOpsUtil.mParMapCores(s, f, numOfCores)\n    } else {\n      return for (e <- s) yield f(e)\n    }\n  }\n\n  @pure def parMapFoldLeftCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(parMapCores(f, numOfCores)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeftCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(mParMapCores(f, numOfCores)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRightCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(parMapCores(f, numOfCores)).foldRight(g, init)\n  }\n\n  def mParMapFoldRightCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(mParMapCores(f, numOfCores)).mFoldRight(g, init)\n  }\n\n  @pure def remove(i: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i < s.size\n//         ensures  result.size ≡ s.size - 1\n//                  ∀j: [0, i)  result(j) ≡ s(j)\n//                  ∀j: [i, result.size)  result(j) ≡ s(j + 1)\n//     \"\"\"\n    return laxSlice(0, i) ++ laxSlice(i + 1, s.size)\n  }\n\n  @pure def reverse: IS[Z, T] = {\n//    l\"\"\" ensures  result.size ≡ s.size\n//                  ∀i: [0, s.size)  result(i) ≡ s(s.size - 1 - i)\n//     \"\"\"\n\n    return for (i <- s.size - 1 to 0 by -1) yield s(i)\n  }\n\n\n  @pure def slice(from: Z, til: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ from\n//                  from < s.size\n//                  0 ≤ til\n//                  til ≤ s.size\n//                  from ≤ til\n//         ensures  result.size ≡ til - from\n//                  ∀i: [0, result.size) result(i) ≡ s(from + i) \"\"\"\n\n    return laxSlice(from, til)\n  }\n\n  @pure def sortWith(lt: (T, T) => B @pure): IS[Z, T] = {\n    return ISZOpsUtil.sortWith(s, lt)\n  }\n\n  @pure def tail: IS[Z, T] = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size - 1\n//                  ∀i: [0, result.size)  result(i) ≡ s(i + 1) \"\"\"\n    return drop(1)\n  }\n\n  @pure def take(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, size)\n  }\n\n  @pure def takeRight(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(s.size - size + i) \"\"\"\n\n    return laxSlice(s.size - size, s.size)\n  }\n\n  @pure def zip[T2](other: IS[Z, T2]): IS[Z, (T, T2)] = {\n//    l\"\"\" requires s.size ≡ other.size\n//         ensures  result ≡ s.size\n//                  ∀i: [0, result.size)  result(i) ≡ ((s(i), other(i))) \"\"\"\n    var i = 0\n    val sz = s.size\n    var r = ISZ[(T, T2)]()\n    while (i < sz) {\n      r = r :+ ((s(i), other(i)))\n      i = i + 1\n    }\n    return r\n  }\n}\n\n\n@ext object MSZOpsUtil {\n\n  @pure def parMap[V, U](s: MS[Z, V], f: V => U @pure): MS[Z, U] = $\n\n  def mParMap[V, U](s: MS[Z, V], f: V => U): MS[Z, U] = $\n\n  @pure def parMapCores[V, U](s: MS[Z, V], f: V => U @pure, numOfCores: Z): MS[Z, U] = $\n\n  def mParMapCores[V, U](s: MS[Z, V], f: V => U, numOfCores: Z): MS[Z, U] = $\n\n  @pure def sortWith[T](s: MS[Z, T], lt: (T, T) => B @pure): MS[Z, T] = $\n\n}\n\n@record class MSZOps[T](val s: MS[Z, T]) extends MSOps[Z, T] {\n\n  @pure def :+(e: T): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [0, result.size)  result(i) ≡ s(i)\n//                 result(result.size - 1) ≡ e            \"\"\"\n\n    return s :+ e\n  }\n\n  @pure def +:(e: T): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [1, result.size)  result(i) ≡ s(i - 1)\n//                 result(0) ≡ e                              \"\"\"\n\n    return e +: s\n  }\n\n  @pure def ++(other: MS[Z, T]): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + other.size\n//                 ∀i: [0, s.size)  result(i) ≡ s(i)\n//                 ∀i: [0, other.size)  result(s.size + i) ≡ other(i) \"\"\"\n\n    return s ++ other\n  }\n\n  @pure def chunk(size: Z): MS[Z, MS[Z, T]] = {\n//    l\"\"\" requires 0 < size\n//                  size <= s.size\n//         ensures  if (s.size % size ≡ 0) result.size * size ≡ s.size\n//                    else (result.size - 1) * size + s.size % size ≡ s.size\n//                  if (s.size % size ≡ 0) ∀i: [0, result.size)  result(i).size ≡ size\n//                    else ∀i: [0, result.size - 1)  result(i).size ≡ size\n//                  s.size % size ≠ 0 → result(result.size - 1).size ≡ s.size % size\n//                  ∀i: [0, result.size)\n//                    ∀j: [0, result(i).size)\n//                      s(i * result.size + j) ≡ result(i)(j)                          \"\"\"\n\n    var r = MS[Z, MS[Z, T]]()\n    var chunk = MS[Z, T]()\n    for (e <- s) {\n      if (chunk.size == size) {\n        r = r :+ chunk\n        chunk = MS[Z, T]()\n      }\n      chunk = chunk :+ e\n    }\n    if (chunk.nonEmpty) {\n      r = r :+ chunk\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) s(i) ≡ e) \"\"\"\n\n    for (v <- s) {\n      if (v == e) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def drop(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(size + i) \"\"\"\n\n    return laxSlice(size, s.size)\n  }\n\n  @pure def dropRight(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, s.size - size)\n  }\n\n  @pure def exists(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (p(e)) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def filter(p: T => B @pure): MS[Z, T] = {\n\n    var r = MS[Z, T]()\n    for (e <- s) {\n      if (p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def filterNot(p: T => B @pure): MS[Z, T] = {\n\n    var r = MS[Z, T]()\n    for (e <- s) {\n      if (!p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def first: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(0) \"\"\"\n\n    return s(0)\n  }\n\n  @pure def forall(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∀i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (!p(e)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R = {\n//    l\"\"\" ensures result ≡ ISOps.foldLeftSpec(s, f, init, s.size - 1) \"\"\"\n\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R = {\n//    l\"\"\" ensures result ≡ ISOps.foldRightSpec(s, f, init, s.size - 1) \"\"\"\n\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  def mFoldLeft[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  def mFoldRight[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  @pure def insert(i: Z, e: T): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i <= s.size\n//         ensures  result.size ≡ s.size + 1\n//                  ∀j: [0, i) result(j) ≡ s(j)\n//                  result(i) ≡ e\n//                  ∀j: [j, s.size) result(j + 1) ≡ s(j) \"\"\"\n    return (laxSlice(0, i) :+ e) ++ laxSlice(i, s.size)\n  }\n\n  @pure def last: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(s.size - 1) \"\"\"\n\n    return s(s.size - 1)\n  }\n\n  @pure def indexOf(e: T): Z = {\n//    l\"\"\" ensures (0 ≤ result ∧ result < s.size) → s(result) ≡ e\n//                 (result ≡ s.size) ≡ (∀i: [0, s.size) s(i) ≠ e)\n//                 ∃i: [0, s.size) s(i) ≡ e ∧ (∀j: [0, i) s(j) ≠ e) → result ≡ i\n//                 0 ≤ result\n//                 result ≤ s.size                                \"\"\"\n    for (i <- z\"0\" until s.size if e == s(i)) {\n      return i\n    }\n    return s.size\n  }\n\n  @pure def laxSlice(from: Z, til: Z): MS[Z, T] = {\n//    l\"\"\" ensures if (til > from) result.size ≡ NO(til).min(s.size) - NO(0).max(from)\n//                   else result.size ≡ 0\n//                 ∀i: [i, result.size) result(i) ≡ s(NO(0).max(from) + i)               \"\"\"\n\n    var r = MS[Z, T]()\n    for (i <- from until til if 0 <= i && i < s.size) {\n      r = r :+ s(i)\n    }\n    return r\n  }\n\n  @pure def map[U](f: T => U @pure): MS[Z, U] = {\n//    l\"\"\" ensures result.size ≡ s.size\n//                 ∀i: [0, result.size)  re
  #728 = String             #727          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\n\n@sig trait ISOps[I, T] {\n\n  @pure def contains(e: T): B\n\n  @pure def exists(p: T => B @pure): B\n\n  @pure def first: T\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def forall(p: T => B @pure): B\n\n  @pure def indexOf(e: T): I\n\n  @pure def last: T\n\n  @pure def :+(e: T): IS[I, T]\n\n  @pure def +:(e: T): IS[I, T]\n\n  @pure def ++(other: IS[I, T]): IS[I, T]\n\n  @pure def chunk(size: Z): IS[Z, IS[I, T]]\n\n  @pure def drop(size: Z): IS[I, T]\n\n  @pure def dropRight(size: Z): IS[I, T]\n\n  @pure def filter(p: T => B @pure): IS[I, T]\n\n  @pure def filterNot(p: T => B @pure): IS[Z, T]\n\n  @pure def insert(i: I, e: T): IS[I, T]\n\n  @pure def laxSlice(from: I, til: I): IS[I, T]\n\n  @pure def map[U](f: T => U @pure): IS[I, U]\n\n  @pure def remove(i: I): IS[I, T]\n\n  @pure def reverse: IS[I, T]\n\n  @pure def slice(from: I, til: I): IS[I, T]\n\n  @pure def sortWith(lt: (T, T) => B @pure): IS[I, T]\n\n  @pure def tail: IS[I, T]\n\n  @pure def take(size: Z): IS[I, T]\n\n  @pure def takeRight(size: Z): IS[Z, T]\n\n  @pure def zip[T2](other: IS[Z, T2]): IS[Z, (T, T2)]\n\n}\n\n@msig trait MSOps[I, T] {\n\n  @pure def contains(e: T): B\n\n  @pure def exists(p: T => B @pure): B\n\n  @pure def first: T\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def forall(p: T => B @pure): B\n\n  @pure def indexOf(e: T): I\n\n  @pure def last: T\n\n  @pure def :+(e: T): MS[I, T]\n\n  @pure def +:(e: T): MS[I, T]\n\n  @pure def ++(other: MS[I, T]): MS[I, T]\n\n  @pure def chunk(size: Z): MS[Z, MS[I, T]]\n\n  @pure def drop(size: Z): MS[I, T]\n\n  @pure def dropRight(size: Z): MS[I, T]\n\n  @pure def filter(p: T => B @pure): MS[I, T]\n\n  @pure def filterNot(p: T => B @pure): MS[Z, T]\n\n  @pure def insert(i: I, e: T): MS[I, T]\n\n  @pure def laxSlice(from: I, til: I): MS[I, T]\n\n  @pure def map[U](f: T => U @pure): MS[I, U]\n\n  @pure def remove(i: I): MS[I, T]\n\n  @pure def reverse: MS[I, T]\n\n  @pure def slice(from: I, til: I): MS[I, T]\n\n  @pure def sortWith(lt: (T, T) => B @pure): MS[I, T]\n\n  @pure def tail: MS[I, T]\n\n  @pure def take(size: Z): MS[I, T]\n\n  @pure def takeRight(size: Z): MS[Z, T]\n\n  @pure def zip[T2](other: MS[Z, T2]): MS[Z, (T, T2)]\n\n}\n\n@ext object ISZOpsUtil {\n\n  @pure def parMap[V, U](s: IS[Z, V], f: V => U @pure): IS[Z, U] = $\n\n  def mParMap[V, U](s: IS[Z, V], f: V => U): IS[Z, U] = $\n\n  @pure def parMapCores[V, U](s: IS[Z, V], f: V => U @pure, numOfCores: Z): IS[Z, U] = $\n\n  def mParMapCores[V, U](s: IS[Z, V], f: V => U, numOfCores: Z): IS[Z, U] = $\n\n  @pure def sortWith[T](s: IS[Z, T], lt: (T, T) => B @pure): IS[Z, T] = $\n\n}\n\n@datatype class ISZOps[T](val s: IS[Z, T]) extends ISOps[Z, T] {\n\n  @pure def :+(e: T): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [0, result.size)  result(i) ≡ s(i)\n//                 result(result.size - 1) ≡ e            \"\"\"\n\n    return s :+ e\n  }\n\n  @pure def +:(e: T): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [1, result.size)  result(i) ≡ s(i - 1)\n//                 result(0) ≡ e                              \"\"\"\n\n    return e +: s\n  }\n\n  @pure def ++(other: IS[Z, T]): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + other.size\n//                 ∀i: [0, s.size)  result(i) ≡ s(i)\n//                 ∀i: [0, other.size)  result(s.size + i) ≡ other(i) \"\"\"\n\n    return s ++ other\n  }\n\n  @pure def chunk(size: Z): IS[Z, IS[Z, T]] = {\n//    l\"\"\" requires 0 < size\n//                  size <= s.size\n//         ensures  if (s.size % size ≡ 0) result.size * size ≡ s.size\n//                    else (result.size - 1) * size + s.size % size ≡ s.size\n//                  if (s.size % size ≡ 0) ∀i: [0, result.size)  result(i).size ≡ size\n//                    else ∀i: [0, result.size - 1)  result(i).size ≡ size\n//                  s.size % size ≠ 0 → result(result.size - 1).size ≡ s.size % size\n//                  ∀i: [0, result.size)\n//                    ∀j: [0, result(i).size)\n//                      s(i * result.size + j) ≡ result(i)(j)                          \"\"\"\n\n    var r = IS[Z, IS[Z, T]]()\n    var chunk = IS[Z, T]()\n    for (e <- s) {\n      if (chunk.size == size) {\n        r = r :+ chunk\n        chunk = IS[Z, T]()\n      }\n      chunk = chunk :+ e\n    }\n    if (chunk.nonEmpty) {\n      r = r :+ chunk\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) s(i) ≡ e) \"\"\"\n\n    for (v <- s) {\n      if (v == e) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def drop(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(size + i) \"\"\"\n\n    return laxSlice(size, s.size)\n  }\n\n  @pure def dropRight(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, s.size - size)\n  }\n\n  @pure def exists(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (p(e)) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def filter(p: T => B @pure): IS[Z, T] = {\n\n    var r = IS[Z, T]()\n    for (e <- s) {\n      if (p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def filterNot(p: T => B @pure): IS[Z, T] = {\n\n    var r = IS[Z, T]()\n    for (e <- s) {\n      if (!p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def first: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(0) \"\"\"\n\n    return s(0)\n  }\n\n  @pure def forall(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∀i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (!p(e)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  def mFoldLeft[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  def mFoldRight[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  @pure def insert(i: Z, e: T): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i <= s.size\n//         ensures  result.size ≡ s.size + 1\n//                  ∀j: [0, i) result(j) ≡ s(j)\n//                  result(i) ≡ e\n//                  ∀j: [j, s.size) result(j + 1) ≡ s(j) \"\"\"\n    return (laxSlice(0, i) :+ e) ++ laxSlice(i, s.size)\n  }\n\n  @pure def last: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(s.size - 1) \"\"\"\n\n    return s(s.size - 1)\n  }\n\n  @pure def indexOf(e: T): Z = {\n//    l\"\"\" ensures (0 ≤ result ∧ result < s.size) → s(result) ≡ e\n//                 (result ≡ s.size) ≡ (∀i: [0, s.size) s(i) ≠ e)\n//                 ∃i: [0, s.size) s(i) ≡ e ∧ (∀j: [0, i) s(j) ≠ e) → result ≡ i\n//                 0 ≤ result\n//                 result ≤ s.size                                \"\"\"\n    for (i <- z\"0\" until s.size if e == s(i)) {\n      return i\n    }\n    return s.size\n  }\n\n  @pure def laxSlice(from: Z, til: Z): IS[Z, T] = {\n//    l\"\"\" ensures if (til > from) result.size ≡ NO(til).min(s.size) - NO(0).max(from)\n//                   else result.size ≡ 0\n//                 ∀i: [i, result.size) result(i) ≡ s(NO(0).max(from) + i)               \"\"\"\n\n    if (from >= til || s.isEmpty) {\n      return ISZ()\n    }\n    val start: Z = if (from < 0) 0 else from\n    val until: Z = if (til <= s.size) til else s.size\n    val len = until - start\n    val r = MSZ.create(len, s(0))\n    for (i <- 0 until len) {\n      r(i) = s(start + i)\n    }\n    return r.toIS\n  }\n\n  @pure def map[U](f: T => U @pure): IS[Z, U] = {\n//    l\"\"\" ensures result.size ≡ s.size\n//                 ∀i: [0, result.size)  result(i) ≡ f(s(i)) \"\"\"\n\n    return s.map(f)\n  }\n\n  @pure def parMap[U](f: T => U @pure): IS[Z, U] = {\n    return ISZOpsUtil.parMap(s, f)\n  }\n\n  @pure def mParMap[U](f: T => U): IS[Z, U] = {\n    return ISZOpsUtil.mParMap(s, f)\n  }\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.ISZOps(parMap(f)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.ISZOps(mParMap(f)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.ISZOps(parMap(f)).foldRight(g, init)\n  }\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.ISZOps(mParMap(f)).mFoldRight(g, init)\n  }\n\n  @pure def parMapCores[U](f: T => U @pure, numOfCores: Z): IS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return ISZOpsUtil.parMapCores(s, f, numOfCores)\n    } else {\n      return map(f)\n    }\n  }\n\n  @pure def mParMapCores[U](f: T => U, numOfCores: Z): IS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return ISZOpsUtil.mParMapCores(s, f, numOfCores)\n    } else {\n      return for (e <- s) yield f(e)\n    }\n  }\n\n  @pure def parMapFoldLeftCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(parMapCores(f, numOfCores)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeftCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(mParMapCores(f, numOfCores)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRightCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(parMapCores(f, numOfCores)).foldRight(g, init)\n  }\n\n  def mParMapFoldRightCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(mParMapCores(f, numOfCores)).mFoldRight(g, init)\n  }\n\n  @pure def remove(i: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i < s.size\n//         ensures  result.size ≡ s.size - 1\n//                  ∀j: [0, i)  result(j) ≡ s(j)\n//                  ∀j: [i, result.size)  result(j) ≡ s(j + 1)\n//     \"\"\"\n    return laxSlice(0, i) ++ laxSlice(i + 1, s.size)\n  }\n\n  @pure def reverse: IS[Z, T] = {\n//    l\"\"\" ensures  result.size ≡ s.size\n//                  ∀i: [0, s.size)  result(i) ≡ s(s.size - 1 - i)\n//     \"\"\"\n\n    return for (i <- s.size - 1 to 0 by -1) yield s(i)\n  }\n\n\n  @pure def slice(from: Z, til: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ from\n//                  from < s.size\n//                  0 ≤ til\n//                  til ≤ s.size\n//                  from ≤ til\n//         ensures  result.size ≡ til - from\n//                  ∀i: [0, result.size) result(i) ≡ s(from + i) \"\"\"\n\n    return laxSlice(from, til)\n  }\n\n  @pure def sortWith(lt: (T, T) => B @pure): IS[Z, T] = {\n    return ISZOpsUtil.sortWith(s, lt)\n  }\n\n  @pure def tail: IS[Z, T] = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size - 1\n//                  ∀i: [0, result.size)  result(i) ≡ s(i + 1) \"\"\"\n    return drop(1)\n  }\n\n  @pure def take(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, size)\n  }\n\n  @pure def takeRight(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(s.size - size + i) \"\"\"\n\n    return laxSlice(s.size - size, s.size)\n  }\n\n  @pure def zip[T2](other: IS[Z, T2]): IS[Z, (T, T2)] = {\n//    l\"\"\" requires s.size ≡ other.size\n//         ensures  result ≡ s.size\n//                  ∀i: [0, result.size)  result(i) ≡ ((s(i), other(i))) \"\"\"\n    var i = 0\n    val sz = s.size\n    var r = ISZ[(T, T2)]()\n    while (i < sz) {\n      r = r :+ ((s(i), other(i)))\n      i = i + 1\n    }\n    return r\n  }\n}\n\n\n@ext object MSZOpsUtil {\n\n  @pure def parMap[V, U](s: MS[Z, V], f: V => U @pure): MS[Z, U] = $\n\n  def mParMap[V, U](s: MS[Z, V], f: V => U): MS[Z, U] = $\n\n  @pure def parMapCores[V, U](s: MS[Z, V], f: V => U @pure, numOfCores: Z): MS[Z, U] = $\n\n  def mParMapCores[V, U](s: MS[Z, V], f: V => U, numOfCores: Z): MS[Z, U] = $\n\n  @pure def sortWith[T](s: MS[Z, T], lt: (T, T) => B @pure): MS[Z, T] = $\n\n}\n\n@record class MSZOps[T](val s: MS[Z, T]) extends MSOps[Z, T] {\n\n  @pure def :+(e: T): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [0, result.size)  result(i) ≡ s(i)\n//                 result(result.size - 1) ≡ e            \"\"\"\n\n    return s :+ e\n  }\n\n  @pure def +:(e: T): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [1, result.size)  result(i) ≡ s(i - 1)\n//                 result(0) ≡ e                              \"\"\"\n\n    return e +: s\n  }\n\n  @pure def ++(other: MS[Z, T]): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + other.size\n//                 ∀i: [0, s.size)  result(i) ≡ s(i)\n//                 ∀i: [0, other.size)  result(s.size + i) ≡ other(i) \"\"\"\n\n    return s ++ other\n  }\n\n  @pure def chunk(size: Z): MS[Z, MS[Z, T]] = {\n//    l\"\"\" requires 0 < size\n//                  size <= s.size\n//         ensures  if (s.size % size ≡ 0) result.size * size ≡ s.size\n//                    else (result.size - 1) * size + s.size % size ≡ s.size\n//                  if (s.size % size ≡ 0) ∀i: [0, result.size)  result(i).size ≡ size\n//                    else ∀i: [0, result.size - 1)  result(i).size ≡ size\n//                  s.size % size ≠ 0 → result(result.size - 1).size ≡ s.size % size\n//                  ∀i: [0, result.size)\n//                    ∀j: [0, result(i).size)\n//                      s(i * result.size + j) ≡ result(i)(j)                          \"\"\"\n\n    var r = MS[Z, MS[Z, T]]()\n    var chunk = MS[Z, T]()\n    for (e <- s) {\n      if (chunk.size == size) {\n        r = r :+ chunk\n        chunk = MS[Z, T]()\n      }\n      chunk = chunk :+ e\n    }\n    if (chunk.nonEmpty) {\n      r = r :+ chunk\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) s(i) ≡ e) \"\"\"\n\n    for (v <- s) {\n      if (v == e) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def drop(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(size + i) \"\"\"\n\n    return laxSlice(size, s.size)\n  }\n\n  @pure def dropRight(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, s.size - size)\n  }\n\n  @pure def exists(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (p(e)) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def filter(p: T => B @pure): MS[Z, T] = {\n\n    var r = MS[Z, T]()\n    for (e <- s) {\n      if (p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def filterNot(p: T => B @pure): MS[Z, T] = {\n\n    var r = MS[Z, T]()\n    for (e <- s) {\n      if (!p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def first: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(0) \"\"\"\n\n    return s(0)\n  }\n\n  @pure def forall(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∀i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (!p(e)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R = {\n//    l\"\"\" ensures result ≡ ISOps.foldLeftSpec(s, f, init, s.size - 1) \"\"\"\n\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R = {\n//    l\"\"\" ensures result ≡ ISOps.foldRightSpec(s, f, init, s.size - 1) \"\"\"\n\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  def mFoldLeft[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  def mFoldRight[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  @pure def insert(i: Z, e: T): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i <= s.size\n//         ensures  result.size ≡ s.size + 1\n//                  ∀j: [0, i) result(j) ≡ s(j)\n//                  result(i) ≡ e\n//                  ∀j: [j, s.size) result(j + 1) ≡ s(j) \"\"\"\n    return (laxSlice(0, i) :+ e) ++ laxSlice(i, s.size)\n  }\n\n  @pure def last: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(s.size - 1) \"\"\"\n\n    return s(s.size - 1)\n  }\n\n  @pure def indexOf(e: T): Z = {\n//    l\"\"\" ensures (0 ≤ result ∧ result < s.size) → s(result) ≡ e\n//                 (result ≡ s.size) ≡ (∀i: [0, s.size) s(i) ≠ e)\n//                 ∃i: [0, s.size) s(i) ≡ e ∧ (∀j: [0, i) s(j) ≠ e) → result ≡ i\n//                 0 ≤ result\n//                 result ≤ s.size                                \"\"\"\n    for (i <- z\"0\" until s.size if e == s(i)) {\n      return i\n    }\n    return s.size\n  }\n\n  @pure def laxSlice(from: Z, til: Z): MS[Z, T] = {\n//    l\"\"\" ensures if (til > from) result.size ≡ NO(til).min(s.size) - NO(0).max(from)\n//                   else result.size ≡ 0\n//                 ∀i: [i, result.size) result(i) ≡ s(NO(0).max(from) + i)               \"\"\"\n\n    var r = MS[Z, T]()\n    for (i <- from until til if 0 <= i && i < s.size) {\n      r = r :+ s(i)\n    }\n    return r\n  }\n\n  @pure def map[U](f: T => U @pure): MS[Z, U] = {\n//    l\"\"\" ensures result.size ≡ s.size\n//                 ∀i: [0, result.size)  re
  #729 = Utf8               sult(i) ≡ f(s(i)) \"\"\"\n\n    return s.map(f)\n  }\n\n  @pure def parMap[U](f: T => U @pure): MS[Z, U] = {\n    val r = MSZOpsUtil.parMap(s, f)\n    return r\n  }\n\n  def mParMap[U](f: T => U): MS[Z, U] = {\n    val r = MSZOpsUtil.mParMap(s, f)\n    return r\n  }\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.MSZOps(parMap(f)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.MSZOps(mParMap(f)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.MSZOps(parMap(f)).foldRight(g, init)\n  }\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.MSZOps(mParMap(f)).mFoldRight(g, init)\n  }\n\n  @pure def parMapCores[U](f: T => U @pure, numOfCores: Z): MS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return MSZOpsUtil.parMapCores(s, f, numOfCores)\n    } else {\n      return map(f)\n    }\n  }\n\n  def mParMapCores[U](f: T => U, numOfCores: Z): MS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return MSZOpsUtil.mParMapCores(s, f, numOfCores)\n    } else {\n      return for (e <- s) yield f(e)\n    }\n  }\n\n  @pure def parMapFoldLeftCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(parMapCores(f, numOfCores)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeftCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(mParMapCores(f, numOfCores)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRightCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(parMapCores(f, numOfCores)).foldRight(g, init)\n  }\n\n  def mParMapFoldRightCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(mParMapCores(f, numOfCores)).mFoldRight(g, init)\n  }\n\n  @pure def remove(i: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i < s.size\n//         ensures  result.size ≡ s.size - 1\n//                  ∀j: [0, i)  result(j) ≡ s(j)\n//                  ∀j: [i, result.size)  result(j) ≡ s(j + 1)\n//     \"\"\"\n    return laxSlice(0, i) ++ laxSlice(i + 1, s.size)\n  }\n\n  @pure def reverse: MS[Z, T] = {\n//    l\"\"\" ensures  result.size ≡ s.size\n//                  ∀i: [0, s.size)  result(i) ≡ s(s.size - 1 - i)\n//     \"\"\"\n\n    val r = s\n    var i = 0\n    var j = s.size - 1\n    val half = s.size / 2\n    while (i < half) {\n      val t = r(i)\n      r(i) = r(j)\n      r(j) = t\n      i = i + 1\n      j = j - 1\n    }\n    return r\n  }\n\n\n  @pure def slice(from: Z, til: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ from\n//                  from < s.size\n//                  0 ≤ til\n//                  til ≤ s.size\n//                  from ≤ til\n//         ensures  result.size ≡ til - from\n//                  ∀i: [0, result.size) result(i) ≡ s(from + i) \"\"\"\n\n    return laxSlice(from, til)\n  }\n\n  @pure def sortWith(lt: (T, T) => B @pure): MS[Z, T] = {\n    return MSZOpsUtil.sortWith(s, lt)\n  }\n\n  @pure def tail: MS[Z, T] = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size - 1\n//                  ∀i: [0, result.size)  result(i) ≡ s(i + 1) \"\"\"\n    return drop(1)\n  }\n\n  @pure def take(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, size)\n  }\n\n  @pure def takeRight(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(s.size - size + i) \"\"\"\n\n    return laxSlice(s.size - size, s.size)\n  }\n\n  @pure def zip[T2](other: MS[Z, T2]): MS[Z, (T, T2)] = {\n//    l\"\"\" requires s.size ≡ other.size\n//         ensures  result ≡ s.size\n//                  ∀i: [0, result.size)  result(i) ≡ ((s(i), other(i))) \"\"\"\n    var i = 0\n    val sz = s.size\n    var r = MSZ[(T, T2)]()\n    while (i < sz) {\n      r = r :+ ((s(i), other(i)))\n      i = i + 1\n    }\n    return r\n  }\n}\n\n@sig trait SBOps[I] {\n\n  @pure def toU8: U8\n\n  @pure def toU16: U16\n\n  @pure def toU32: U32\n\n  @pure def toU64: U64\n}\n\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\nobject ISZBOps {\n\n  @pure def fromU8(n: U8): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 8\n//                 result(0) ≡ ((n & u8\"0x01\") ≠ u8\"0x01\") ∧\n//                 result(1) ≡ ((n & u8\"0x02\") ≠ u8\"0x02\") ∧\n//                 result(2) ≡ ((n & u8\"0x04\") ≠ u8\"0x04\") ∧\n//                 result(3) ≡ ((n & u8\"0x08\") ≠ u8\"0x08\") ∧\n//                 result(4) ≡ ((n & u8\"0x10\") ≠ u8\"0x10\") ∧\n//                 result(5) ≡ ((n & u8\"0x20\") ≠ u8\"0x20\") ∧\n//                 result(6) ≡ ((n & u8\"0x40\") ≠ u8\"0x40\") ∧\n//                 result(7) ≡ ((n & u8\"0x80\") ≠ u8\"0x80\")   \"\"\"\n    return IS[Z, B](\n      (n & u8\"0x01\") != u8\"0x01\",\n      (n & u8\"0x02\") != u8\"0x02\",\n      (n & u8\"0x04\") != u8\"0x04\",\n      (n & u8\"0x08\") != u8\"0x08\",\n      (n & u8\"0x10\") != u8\"0x10\",\n      (n & u8\"0x20\") != u8\"0x20\",\n      (n & u8\"0x40\") != u8\"0x40\",\n      (n & u8\"0x80\") != u8\"0x80\"\n    )\n  }\n\n  @pure def fromU16(n: U16): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 16\n//                 result( 0) ≡ ((n & u16\"0x0001\") ≠ u16\"0x0001\") ∧\n//                 result( 1) ≡ ((n & u16\"0x0002\") ≠ u16\"0x0002\") ∧\n//                 result( 2) ≡ ((n & u16\"0x0004\") ≠ u16\"0x0004\") ∧\n//                 result( 3) ≡ ((n & u16\"0x0008\") ≠ u16\"0x0008\") ∧\n//                 result( 4) ≡ ((n & u16\"0x0010\") ≠ u16\"0x0010\") ∧\n//                 result( 5) ≡ ((n & u16\"0x0020\") ≠ u16\"0x0020\") ∧\n//                 result( 6) ≡ ((n & u16\"0x0040\") ≠ u16\"0x0040\") ∧\n//                 result( 7) ≡ ((n & u16\"0x0080\") ≠ u16\"0x0080\") ∧\n//                 result( 8) ≡ ((n & u16\"0x0100\") ≠ u16\"0x0100\") ∧\n//                 result( 9) ≡ ((n & u16\"0x0200\") ≠ u16\"0x0200\") ∧\n//                 result(10) ≡ ((n & u16\"0x0400\") ≠ u16\"0x0400\") ∧\n//                 result(11) ≡ ((n & u16\"0x0800\") ≠ u16\"0x0800\") ∧\n//                 result(12) ≡ ((n & u16\"0x1000\") ≠ u16\"0x1000\") ∧\n//                 result(13) ≡ ((n & u16\"0x2000\") ≠ u16\"0x2000\") ∧\n//                 result(14) ≡ ((n & u16\"0x4000\") ≠ u16\"0x4000\") ∧\n//                 result(15) ≡ ((n & u16\"0x8000\") ≠ u16\"0x8000\")   \"\"\"\n    return IS[Z, B](\n      (n & u16\"0x0001\") != u16\"0x0001\",\n      (n & u16\"0x0002\") != u16\"0x0002\",\n      (n & u16\"0x0004\") != u16\"0x0004\",\n      (n & u16\"0x0008\") != u16\"0x0008\",\n      (n & u16\"0x0010\") != u16\"0x0010\",\n      (n & u16\"0x0020\") != u16\"0x0020\",\n      (n & u16\"0x0040\") != u16\"0x0040\",\n      (n & u16\"0x0080\") != u16\"0x0080\",\n      (n & u16\"0x0100\") != u16\"0x0100\",\n      (n & u16\"0x0200\") != u16\"0x0200\",\n      (n & u16\"0x0400\") != u16\"0x0400\",\n      (n & u16\"0x0800\") != u16\"0x0800\",\n      (n & u16\"0x1000\") != u16\"0x1000\",\n      (n & u16\"0x2000\") != u16\"0x2000\",\n      (n & u16\"0x4000\") != u16\"0x4000\",\n      (n & u16\"0x8000\") != u16\"0x8000\"\n    )\n  }\n\n  @pure def fromU32(s: IS[Z, B], n: U32): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 32\n//                 result( 0) ≡ ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") ∧\n//                 result( 1) ≡ ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") ∧\n//                 result( 2) ≡ ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") ∧\n//                 result( 3) ≡ ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") ∧\n//                 result( 4) ≡ ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") ∧\n//                 result( 5) ≡ ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") ∧\n//                 result( 6) ≡ ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") ∧\n//                 result( 7) ≡ ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") ∧\n//                 result( 8) ≡ ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") ∧\n//                 result( 9) ≡ ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") ∧\n//                 result(10) ≡ ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") ∧\n//                 result(11) ≡ ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") ∧\n//                 result(12) ≡ ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") ∧\n//                 result(13) ≡ ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") ∧\n//                 result(14) ≡ ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") ∧\n//                 result(15) ≡ ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") ∧\n//                 result(16) ≡ ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") ∧\n//                 result(17) ≡ ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") ∧\n//                 result(18) ≡ ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") ∧\n//                 result(19) ≡ ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") ∧\n//                 result(20) ≡ ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") ∧\n//                 result(21) ≡ ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") ∧\n//                 result(22) ≡ ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") ∧\n//                 result(23) ≡ ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") ∧\n//                 result(24) ≡ ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") ∧\n//                 result(25) ≡ ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") ∧\n//                 result(26) ≡ ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") ∧\n//                 result(27) ≡ ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") ∧\n//                 result(28) ≡ ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") ∧\n//                 result(29) ≡ ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") ∧\n//                 result(30) ≡ ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") ∧\n//                 result(31) ≡ ((n & u32\"0x80000000\") ≠ u32\"0x80000000\")   \"\"\"\n\n    return IS[Z, B](\n      (n & u32\"0x00000001\") != u32\"0x00000001\",\n      (n & u32\"0x00000002\") != u32\"0x00000002\",\n      (n & u32\"0x00000004\") != u32\"0x00000004\",\n      (n & u32\"0x00000008\") != u32\"0x00000008\",\n      (n & u32\"0x00000010\") != u32\"0x00000010\",\n      (n & u32\"0x00000020\") != u32\"0x00000020\",\n      (n & u32\"0x00000040\") != u32\"0x00000040\",\n      (n & u32\"0x00000080\") != u32\"0x00000080\",\n      (n & u32\"0x00000100\") != u32\"0x00000100\",\n      (n & u32\"0x00000200\") != u32\"0x00000200\",\n      (n & u32\"0x00000400\") != u32\"0x00000400\",\n      (n & u32\"0x00000800\") != u32\"0x00000800\",\n      (n & u32\"0x00001000\") != u32\"0x00001000\",\n      (n & u32\"0x00002000\") != u32\"0x00002000\",\n      (n & u32\"0x00004000\") != u32\"0x00004000\",\n      (n & u32\"0x00008000\") != u32\"0x00008000\",\n      (n & u32\"0x00010000\") != u32\"0x00010000\",\n      (n & u32\"0x00020000\") != u32\"0x00020000\",\n      (n & u32\"0x00040000\") != u32\"0x00040000\",\n      (n & u32\"0x00080000\") != u32\"0x00080000\",\n      (n & u32\"0x00100000\") != u32\"0x00100000\",\n      (n & u32\"0x00200000\") != u32\"0x00200000\",\n      (n & u32\"0x00400000\") != u32\"0x00400000\",\n      (n & u32\"0x00800000\") != u32\"0x00800000\",\n      (n & u32\"0x01000000\") != u32\"0x01000000\",\n      (n & u32\"0x02000000\") != u32\"0x02000000\",\n      (n & u32\"0x04000000\") != u32\"0x04000000\",\n      (n & u32\"0x08000000\") != u32\"0x08000000\",\n      (n & u32\"0x10000000\") != u32\"0x10000000\",\n      (n & u32\"0x20000000\") != u32\"0x20000000\",\n      (n & u32\"0x40000000\") != u32\"0x40000000\",\n      (n & u32\"0x80000000\") != u32\"0x80000000\"\n    )\n  }\n\n  @pure def fromU64(s: IS[Z, B], n: U64): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 64\n//                 result(  ) ≡ ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") ∧\n//                 result( 1) ≡ ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") ∧\n//                 result( 2) ≡ ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") ∧\n//                 result( 3) ≡ ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") ∧\n//                 result( 4) ≡ ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") ∧\n//                 result( 5) ≡ ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") ∧\n//                 result( 6) ≡ ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") ∧\n//                 result( 7) ≡ ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") ∧\n//                 result( 8) ≡ ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") ∧\n//                 result( 9) ≡ ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") ∧\n//                 result(10) ≡ ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") ∧\n//                 result(11) ≡ ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") ∧\n//                 result(12) ≡ ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") ∧\n//                 result(13) ≡ ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") ∧\n//                 result(14) ≡ ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") ∧\n//                 result(15) ≡ ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") ∧\n//                 result(16) ≡ ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") ∧\n//                 result(17) ≡ ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") ∧\n//                 result(18) ≡ ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") ∧\n//                 result(19) ≡ ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") ∧\n//                 result(20) ≡ ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") ∧\n//                 result(21) ≡ ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") ∧\n//                 result(22) ≡ ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") ∧\n//                 result(23) ≡ ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") ∧\n//                 result(24) ≡ ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") ∧\n//                 result(25) ≡ ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") ∧\n//                 result(26) ≡ ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") ∧\n//                 result(27) ≡ ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") ∧\n//                 result(28) ≡ ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") ∧\n//                 result(29) ≡ ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") ∧\n//                 result(30) ≡ ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") ∧\n//                 result(31) ≡ ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") ∧\n//                 result(32) ≡ ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") ∧\n//                 result(33) ≡ ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") ∧\n//                 result(34) ≡ ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") ∧\n//                 result(35) ≡ ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") ∧\n//                 result(36) ≡ ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") ∧\n//                 result(37) ≡ ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") ∧\n//                 result(38) ≡ ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") ∧\n//                 result(39) ≡ ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") ∧\n//                 result(40) ≡ ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") ∧\n//                 result(41) ≡ ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") ∧\n//                 result(42) ≡ ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") ∧\n//                 result(43) ≡ ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") ∧\n//                 result(44) ≡ ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") ∧\n//                 result(45) ≡ ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") ∧\n//                 result(46) ≡ ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") ∧\n//                 result(47) ≡ ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") ∧\n//                 result(48) ≡ ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") ∧\n//                 result(49) ≡ ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") ∧\n//                 result(50) ≡ ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") ∧\n//                 result(51) ≡ ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") ∧\n//                 result(52) ≡ ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") ∧\n//                 result(53) ≡ ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") ∧\n//                 result(54) ≡ ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") ∧\n//                 result(55) ≡ ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") ∧\n//                 result(56) ≡ ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") ∧\n//                 result(57) ≡ ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") ∧\n//                 result(58) ≡ ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") ∧\n//                 result(59) ≡ ((n & u64\"0x0800000000000000\") ≠ u64\"0x0800000000000000\") ∧\n//                 result(60) ≡ ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") ∧\n//                 result(61) ≡ ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") ∧\n//                 result(62) ≡ ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") ∧\n//                 result(63) ≡ ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\")   \"\"\"\n\n    IS[Z, B](\n      (n & u64\"0x0000000000000001\") != u64\"0x0000000000000001\",\n      (n & u64\"0x0000000000000002\") != u64\"0x0000000000000002\",\n      (n & u64\"0x0000000000000004\") != u64\"0x0000000000000004\",\n      (n & u64\"0x0000000000000008\") != u64\"0x0000000000000008\",\n      (n & u64\"0x0000000000000010\") != u64\"0x0000000000000010\",\n      (n & u64\"0x0000000000000020\") != u64\"0x0000000000000020\",\n      (n & u64\"0x0000000000000040\") != u64\"0x0000000000000040\",\n      (n & u64\"0x0000000000000080\") != u64\"0x0000000000000080\",\n      (n & u64\"0x0000000000000100\") != u64\"0x0000000000000100\",\n      (n & u64\"0x0000000000000200\") != u64\"0x0000000000000200\",\n      (n & u64\"0x0000000000000400\") != u64\"0x0000000000000400\",\n      (n & u64\"0x0000000000000800\") != u64\"0x0000000000000800\",\n      (n & u64\"0x0000000000001000\") != u64\"0x0000000000001000\",\n      (n & u64\"0x0000000000002000\") != u64\"0x0000000000002000\",\n      (n & u64\"0x0000000000004000\") != u64\"0x0000000000004000\",\n      (n & u64\"0x0000000000008000\") != u64\"0x0000000000008000\",\n      (n & u64\"0x0000000000010000\") != u64\"0x0000000000010000\",\n      (n & u64\"0x0000000000020000\") != u64\"0x0000000000020000\",\n      (n & u64\"0x0000000000040000\") != u64\"0x0000000000040000\",\n      (n & u64\"0x0000000000080000\") != u64\"0x0000000000080000\",\n      (n & u64\"0x0000000000100000\") != u64\"0x0000000000100000\",\n      (n & u64\"0x0000000000200000\") != u64\"0x0000000000200000\",\n      (n & u64\"0x0000000000400000\") != u64\"0x0000000000400000\",\n      (n & u64\"0x0000000000800000\") != u64\"0x0000000000800000\",\n      (n & u64\"0x0000000001000000\") != u64\"0x0000000001000000\",\n      (n & u64\"0x0000000002000000\") != u64\"0x0000000002000000\",\n      (n & u64\"0x0000000004000000\") != u64\"0x0000000004000000\",\n      (n & u64\"0x0000000008000000\") != u64\"0x0000000008000000\",\n      (n & u64\"0x0000000010000000\") != u64\"0x0000000010000000\",\n      (n & u64\"0x0000000020000000\") != u64\"0x0000000020000000\",\n      (n & u64\"0x0000000040000000\") != u64\"0x0000000040000000\",\n      (n & u64\"0x0000000080000000\") != u64\"0x0000000080000000\",\n      (n & u64\"0x0000000100000000\") != u64\"0x0000000100000000\",\n      (n & u64\"0x0000000200000000\") != u64\"0x0000000200000000\",\n      (n & u64\"0x0000000400000000\") != u64\"0x0000000400000000\",\n      (n & u64\"0x0000000800000000\") != u64\"0x0000000800000000\",\n      (n & u64\"0x0000001000000000\") != u64\"0x0000001000000000\",\n      (n & u64\"0x0000002000000000\") != u64\"0x0000002000000000\",\n      (n & u64\"0x0000004000000000\") != u64\"0x0000004000000000\",\n      (n & u64\"0x0000008000000000\") != u64\"0x0000008000000000\",\n      (n & u64\"0x0000010000000000\") != u64\"0x0000010000000000\",\n      (n & u64\"0x0000020000000000\") != u64\"0x0000020000000000\",\n      (n & u64\"0x0000040000000000\") != u64\"0x0000040000000000\",\n      (n & u64\"0x0000080000000000\") != u64\"0x0000
  #730 = String             #729          // sult(i) ≡ f(s(i)) \"\"\"\n\n    return s.map(f)\n  }\n\n  @pure def parMap[U](f: T => U @pure): MS[Z, U] = {\n    val r = MSZOpsUtil.parMap(s, f)\n    return r\n  }\n\n  def mParMap[U](f: T => U): MS[Z, U] = {\n    val r = MSZOpsUtil.mParMap(s, f)\n    return r\n  }\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.MSZOps(parMap(f)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.MSZOps(mParMap(f)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.MSZOps(parMap(f)).foldRight(g, init)\n  }\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.MSZOps(mParMap(f)).mFoldRight(g, init)\n  }\n\n  @pure def parMapCores[U](f: T => U @pure, numOfCores: Z): MS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return MSZOpsUtil.parMapCores(s, f, numOfCores)\n    } else {\n      return map(f)\n    }\n  }\n\n  def mParMapCores[U](f: T => U, numOfCores: Z): MS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return MSZOpsUtil.mParMapCores(s, f, numOfCores)\n    } else {\n      return for (e <- s) yield f(e)\n    }\n  }\n\n  @pure def parMapFoldLeftCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(parMapCores(f, numOfCores)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeftCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(mParMapCores(f, numOfCores)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRightCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(parMapCores(f, numOfCores)).foldRight(g, init)\n  }\n\n  def mParMapFoldRightCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(mParMapCores(f, numOfCores)).mFoldRight(g, init)\n  }\n\n  @pure def remove(i: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i < s.size\n//         ensures  result.size ≡ s.size - 1\n//                  ∀j: [0, i)  result(j) ≡ s(j)\n//                  ∀j: [i, result.size)  result(j) ≡ s(j + 1)\n//     \"\"\"\n    return laxSlice(0, i) ++ laxSlice(i + 1, s.size)\n  }\n\n  @pure def reverse: MS[Z, T] = {\n//    l\"\"\" ensures  result.size ≡ s.size\n//                  ∀i: [0, s.size)  result(i) ≡ s(s.size - 1 - i)\n//     \"\"\"\n\n    val r = s\n    var i = 0\n    var j = s.size - 1\n    val half = s.size / 2\n    while (i < half) {\n      val t = r(i)\n      r(i) = r(j)\n      r(j) = t\n      i = i + 1\n      j = j - 1\n    }\n    return r\n  }\n\n\n  @pure def slice(from: Z, til: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ from\n//                  from < s.size\n//                  0 ≤ til\n//                  til ≤ s.size\n//                  from ≤ til\n//         ensures  result.size ≡ til - from\n//                  ∀i: [0, result.size) result(i) ≡ s(from + i) \"\"\"\n\n    return laxSlice(from, til)\n  }\n\n  @pure def sortWith(lt: (T, T) => B @pure): MS[Z, T] = {\n    return MSZOpsUtil.sortWith(s, lt)\n  }\n\n  @pure def tail: MS[Z, T] = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size - 1\n//                  ∀i: [0, result.size)  result(i) ≡ s(i + 1) \"\"\"\n    return drop(1)\n  }\n\n  @pure def take(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, size)\n  }\n\n  @pure def takeRight(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(s.size - size + i) \"\"\"\n\n    return laxSlice(s.size - size, s.size)\n  }\n\n  @pure def zip[T2](other: MS[Z, T2]): MS[Z, (T, T2)] = {\n//    l\"\"\" requires s.size ≡ other.size\n//         ensures  result ≡ s.size\n//                  ∀i: [0, result.size)  result(i) ≡ ((s(i), other(i))) \"\"\"\n    var i = 0\n    val sz = s.size\n    var r = MSZ[(T, T2)]()\n    while (i < sz) {\n      r = r :+ ((s(i), other(i)))\n      i = i + 1\n    }\n    return r\n  }\n}\n\n@sig trait SBOps[I] {\n\n  @pure def toU8: U8\n\n  @pure def toU16: U16\n\n  @pure def toU32: U32\n\n  @pure def toU64: U64\n}\n\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\nobject ISZBOps {\n\n  @pure def fromU8(n: U8): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 8\n//                 result(0) ≡ ((n & u8\"0x01\") ≠ u8\"0x01\") ∧\n//                 result(1) ≡ ((n & u8\"0x02\") ≠ u8\"0x02\") ∧\n//                 result(2) ≡ ((n & u8\"0x04\") ≠ u8\"0x04\") ∧\n//                 result(3) ≡ ((n & u8\"0x08\") ≠ u8\"0x08\") ∧\n//                 result(4) ≡ ((n & u8\"0x10\") ≠ u8\"0x10\") ∧\n//                 result(5) ≡ ((n & u8\"0x20\") ≠ u8\"0x20\") ∧\n//                 result(6) ≡ ((n & u8\"0x40\") ≠ u8\"0x40\") ∧\n//                 result(7) ≡ ((n & u8\"0x80\") ≠ u8\"0x80\")   \"\"\"\n    return IS[Z, B](\n      (n & u8\"0x01\") != u8\"0x01\",\n      (n & u8\"0x02\") != u8\"0x02\",\n      (n & u8\"0x04\") != u8\"0x04\",\n      (n & u8\"0x08\") != u8\"0x08\",\n      (n & u8\"0x10\") != u8\"0x10\",\n      (n & u8\"0x20\") != u8\"0x20\",\n      (n & u8\"0x40\") != u8\"0x40\",\n      (n & u8\"0x80\") != u8\"0x80\"\n    )\n  }\n\n  @pure def fromU16(n: U16): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 16\n//                 result( 0) ≡ ((n & u16\"0x0001\") ≠ u16\"0x0001\") ∧\n//                 result( 1) ≡ ((n & u16\"0x0002\") ≠ u16\"0x0002\") ∧\n//                 result( 2) ≡ ((n & u16\"0x0004\") ≠ u16\"0x0004\") ∧\n//                 result( 3) ≡ ((n & u16\"0x0008\") ≠ u16\"0x0008\") ∧\n//                 result( 4) ≡ ((n & u16\"0x0010\") ≠ u16\"0x0010\") ∧\n//                 result( 5) ≡ ((n & u16\"0x0020\") ≠ u16\"0x0020\") ∧\n//                 result( 6) ≡ ((n & u16\"0x0040\") ≠ u16\"0x0040\") ∧\n//                 result( 7) ≡ ((n & u16\"0x0080\") ≠ u16\"0x0080\") ∧\n//                 result( 8) ≡ ((n & u16\"0x0100\") ≠ u16\"0x0100\") ∧\n//                 result( 9) ≡ ((n & u16\"0x0200\") ≠ u16\"0x0200\") ∧\n//                 result(10) ≡ ((n & u16\"0x0400\") ≠ u16\"0x0400\") ∧\n//                 result(11) ≡ ((n & u16\"0x0800\") ≠ u16\"0x0800\") ∧\n//                 result(12) ≡ ((n & u16\"0x1000\") ≠ u16\"0x1000\") ∧\n//                 result(13) ≡ ((n & u16\"0x2000\") ≠ u16\"0x2000\") ∧\n//                 result(14) ≡ ((n & u16\"0x4000\") ≠ u16\"0x4000\") ∧\n//                 result(15) ≡ ((n & u16\"0x8000\") ≠ u16\"0x8000\")   \"\"\"\n    return IS[Z, B](\n      (n & u16\"0x0001\") != u16\"0x0001\",\n      (n & u16\"0x0002\") != u16\"0x0002\",\n      (n & u16\"0x0004\") != u16\"0x0004\",\n      (n & u16\"0x0008\") != u16\"0x0008\",\n      (n & u16\"0x0010\") != u16\"0x0010\",\n      (n & u16\"0x0020\") != u16\"0x0020\",\n      (n & u16\"0x0040\") != u16\"0x0040\",\n      (n & u16\"0x0080\") != u16\"0x0080\",\n      (n & u16\"0x0100\") != u16\"0x0100\",\n      (n & u16\"0x0200\") != u16\"0x0200\",\n      (n & u16\"0x0400\") != u16\"0x0400\",\n      (n & u16\"0x0800\") != u16\"0x0800\",\n      (n & u16\"0x1000\") != u16\"0x1000\",\n      (n & u16\"0x2000\") != u16\"0x2000\",\n      (n & u16\"0x4000\") != u16\"0x4000\",\n      (n & u16\"0x8000\") != u16\"0x8000\"\n    )\n  }\n\n  @pure def fromU32(s: IS[Z, B], n: U32): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 32\n//                 result( 0) ≡ ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") ∧\n//                 result( 1) ≡ ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") ∧\n//                 result( 2) ≡ ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") ∧\n//                 result( 3) ≡ ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") ∧\n//                 result( 4) ≡ ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") ∧\n//                 result( 5) ≡ ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") ∧\n//                 result( 6) ≡ ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") ∧\n//                 result( 7) ≡ ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") ∧\n//                 result( 8) ≡ ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") ∧\n//                 result( 9) ≡ ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") ∧\n//                 result(10) ≡ ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") ∧\n//                 result(11) ≡ ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") ∧\n//                 result(12) ≡ ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") ∧\n//                 result(13) ≡ ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") ∧\n//                 result(14) ≡ ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") ∧\n//                 result(15) ≡ ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") ∧\n//                 result(16) ≡ ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") ∧\n//                 result(17) ≡ ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") ∧\n//                 result(18) ≡ ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") ∧\n//                 result(19) ≡ ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") ∧\n//                 result(20) ≡ ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") ∧\n//                 result(21) ≡ ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") ∧\n//                 result(22) ≡ ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") ∧\n//                 result(23) ≡ ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") ∧\n//                 result(24) ≡ ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") ∧\n//                 result(25) ≡ ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") ∧\n//                 result(26) ≡ ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") ∧\n//                 result(27) ≡ ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") ∧\n//                 result(28) ≡ ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") ∧\n//                 result(29) ≡ ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") ∧\n//                 result(30) ≡ ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") ∧\n//                 result(31) ≡ ((n & u32\"0x80000000\") ≠ u32\"0x80000000\")   \"\"\"\n\n    return IS[Z, B](\n      (n & u32\"0x00000001\") != u32\"0x00000001\",\n      (n & u32\"0x00000002\") != u32\"0x00000002\",\n      (n & u32\"0x00000004\") != u32\"0x00000004\",\n      (n & u32\"0x00000008\") != u32\"0x00000008\",\n      (n & u32\"0x00000010\") != u32\"0x00000010\",\n      (n & u32\"0x00000020\") != u32\"0x00000020\",\n      (n & u32\"0x00000040\") != u32\"0x00000040\",\n      (n & u32\"0x00000080\") != u32\"0x00000080\",\n      (n & u32\"0x00000100\") != u32\"0x00000100\",\n      (n & u32\"0x00000200\") != u32\"0x00000200\",\n      (n & u32\"0x00000400\") != u32\"0x00000400\",\n      (n & u32\"0x00000800\") != u32\"0x00000800\",\n      (n & u32\"0x00001000\") != u32\"0x00001000\",\n      (n & u32\"0x00002000\") != u32\"0x00002000\",\n      (n & u32\"0x00004000\") != u32\"0x00004000\",\n      (n & u32\"0x00008000\") != u32\"0x00008000\",\n      (n & u32\"0x00010000\") != u32\"0x00010000\",\n      (n & u32\"0x00020000\") != u32\"0x00020000\",\n      (n & u32\"0x00040000\") != u32\"0x00040000\",\n      (n & u32\"0x00080000\") != u32\"0x00080000\",\n      (n & u32\"0x00100000\") != u32\"0x00100000\",\n      (n & u32\"0x00200000\") != u32\"0x00200000\",\n      (n & u32\"0x00400000\") != u32\"0x00400000\",\n      (n & u32\"0x00800000\") != u32\"0x00800000\",\n      (n & u32\"0x01000000\") != u32\"0x01000000\",\n      (n & u32\"0x02000000\") != u32\"0x02000000\",\n      (n & u32\"0x04000000\") != u32\"0x04000000\",\n      (n & u32\"0x08000000\") != u32\"0x08000000\",\n      (n & u32\"0x10000000\") != u32\"0x10000000\",\n      (n & u32\"0x20000000\") != u32\"0x20000000\",\n      (n & u32\"0x40000000\") != u32\"0x40000000\",\n      (n & u32\"0x80000000\") != u32\"0x80000000\"\n    )\n  }\n\n  @pure def fromU64(s: IS[Z, B], n: U64): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 64\n//                 result(  ) ≡ ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") ∧\n//                 result( 1) ≡ ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") ∧\n//                 result( 2) ≡ ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") ∧\n//                 result( 3) ≡ ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") ∧\n//                 result( 4) ≡ ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") ∧\n//                 result( 5) ≡ ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") ∧\n//                 result( 6) ≡ ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") ∧\n//                 result( 7) ≡ ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") ∧\n//                 result( 8) ≡ ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") ∧\n//                 result( 9) ≡ ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") ∧\n//                 result(10) ≡ ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") ∧\n//                 result(11) ≡ ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") ∧\n//                 result(12) ≡ ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") ∧\n//                 result(13) ≡ ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") ∧\n//                 result(14) ≡ ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") ∧\n//                 result(15) ≡ ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") ∧\n//                 result(16) ≡ ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") ∧\n//                 result(17) ≡ ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") ∧\n//                 result(18) ≡ ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") ∧\n//                 result(19) ≡ ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") ∧\n//                 result(20) ≡ ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") ∧\n//                 result(21) ≡ ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") ∧\n//                 result(22) ≡ ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") ∧\n//                 result(23) ≡ ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") ∧\n//                 result(24) ≡ ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") ∧\n//                 result(25) ≡ ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") ∧\n//                 result(26) ≡ ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") ∧\n//                 result(27) ≡ ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") ∧\n//                 result(28) ≡ ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") ∧\n//                 result(29) ≡ ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") ∧\n//                 result(30) ≡ ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") ∧\n//                 result(31) ≡ ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") ∧\n//                 result(32) ≡ ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") ∧\n//                 result(33) ≡ ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") ∧\n//                 result(34) ≡ ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") ∧\n//                 result(35) ≡ ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") ∧\n//                 result(36) ≡ ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") ∧\n//                 result(37) ≡ ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") ∧\n//                 result(38) ≡ ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") ∧\n//                 result(39) ≡ ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") ∧\n//                 result(40) ≡ ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") ∧\n//                 result(41) ≡ ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") ∧\n//                 result(42) ≡ ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") ∧\n//                 result(43) ≡ ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") ∧\n//                 result(44) ≡ ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") ∧\n//                 result(45) ≡ ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") ∧\n//                 result(46) ≡ ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") ∧\n//                 result(47) ≡ ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") ∧\n//                 result(48) ≡ ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") ∧\n//                 result(49) ≡ ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") ∧\n//                 result(50) ≡ ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") ∧\n//                 result(51) ≡ ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") ∧\n//                 result(52) ≡ ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") ∧\n//                 result(53) ≡ ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") ∧\n//                 result(54) ≡ ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") ∧\n//                 result(55) ≡ ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") ∧\n//                 result(56) ≡ ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") ∧\n//                 result(57) ≡ ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") ∧\n//                 result(58) ≡ ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") ∧\n//                 result(59) ≡ ((n & u64\"0x0800000000000000\") ≠ u64\"0x0800000000000000\") ∧\n//                 result(60) ≡ ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") ∧\n//                 result(61) ≡ ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") ∧\n//                 result(62) ≡ ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") ∧\n//                 result(63) ≡ ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\")   \"\"\"\n\n    IS[Z, B](\n      (n & u64\"0x0000000000000001\") != u64\"0x0000000000000001\",\n      (n & u64\"0x0000000000000002\") != u64\"0x0000000000000002\",\n      (n & u64\"0x0000000000000004\") != u64\"0x0000000000000004\",\n      (n & u64\"0x0000000000000008\") != u64\"0x0000000000000008\",\n      (n & u64\"0x0000000000000010\") != u64\"0x0000000000000010\",\n      (n & u64\"0x0000000000000020\") != u64\"0x0000000000000020\",\n      (n & u64\"0x0000000000000040\") != u64\"0x0000000000000040\",\n      (n & u64\"0x0000000000000080\") != u64\"0x0000000000000080\",\n      (n & u64\"0x0000000000000100\") != u64\"0x0000000000000100\",\n      (n & u64\"0x0000000000000200\") != u64\"0x0000000000000200\",\n      (n & u64\"0x0000000000000400\") != u64\"0x0000000000000400\",\n      (n & u64\"0x0000000000000800\") != u64\"0x0000000000000800\",\n      (n & u64\"0x0000000000001000\") != u64\"0x0000000000001000\",\n      (n & u64\"0x0000000000002000\") != u64\"0x0000000000002000\",\n      (n & u64\"0x0000000000004000\") != u64\"0x0000000000004000\",\n      (n & u64\"0x0000000000008000\") != u64\"0x0000000000008000\",\n      (n & u64\"0x0000000000010000\") != u64\"0x0000000000010000\",\n      (n & u64\"0x0000000000020000\") != u64\"0x0000000000020000\",\n      (n & u64\"0x0000000000040000\") != u64\"0x0000000000040000\",\n      (n & u64\"0x0000000000080000\") != u64\"0x0000000000080000\",\n      (n & u64\"0x0000000000100000\") != u64\"0x0000000000100000\",\n      (n & u64\"0x0000000000200000\") != u64\"0x0000000000200000\",\n      (n & u64\"0x0000000000400000\") != u64\"0x0000000000400000\",\n      (n & u64\"0x0000000000800000\") != u64\"0x0000000000800000\",\n      (n & u64\"0x0000000001000000\") != u64\"0x0000000001000000\",\n      (n & u64\"0x0000000002000000\") != u64\"0x0000000002000000\",\n      (n & u64\"0x0000000004000000\") != u64\"0x0000000004000000\",\n      (n & u64\"0x0000000008000000\") != u64\"0x0000000008000000\",\n      (n & u64\"0x0000000010000000\") != u64\"0x0000000010000000\",\n      (n & u64\"0x0000000020000000\") != u64\"0x0000000020000000\",\n      (n & u64\"0x0000000040000000\") != u64\"0x0000000040000000\",\n      (n & u64\"0x0000000080000000\") != u64\"0x0000000080000000\",\n      (n & u64\"0x0000000100000000\") != u64\"0x0000000100000000\",\n      (n & u64\"0x0000000200000000\") != u64\"0x0000000200000000\",\n      (n & u64\"0x0000000400000000\") != u64\"0x0000000400000000\",\n      (n & u64\"0x0000000800000000\") != u64\"0x0000000800000000\",\n      (n & u64\"0x0000001000000000\") != u64\"0x0000001000000000\",\n      (n & u64\"0x0000002000000000\") != u64\"0x0000002000000000\",\n      (n & u64\"0x0000004000000000\") != u64\"0x0000004000000000\",\n      (n & u64\"0x0000008000000000\") != u64\"0x0000008000000000\",\n      (n & u64\"0x0000010000000000\") != u64\"0x0000010000000000\",\n      (n & u64\"0x0000020000000000\") != u64\"0x0000020000000000\",\n      (n & u64\"0x0000040000000000\") != u64\"0x0000040000000000\",\n      (n & u64\"0x0000080000000000\") != u64\"0x0000
  #731 = Utf8               080000000000\",\n      (n & u64\"0x0000100000000000\") != u64\"0x0000100000000000\",\n      (n & u64\"0x0000200000000000\") != u64\"0x0000200000000000\",\n      (n & u64\"0x0000400000000000\") != u64\"0x0000400000000000\",\n      (n & u64\"0x0000800000000000\") != u64\"0x0000800000000000\",\n      (n & u64\"0x0001000000000000\") != u64\"0x0001000000000000\",\n      (n & u64\"0x0002000000000000\") != u64\"0x0002000000000000\",\n      (n & u64\"0x0004000000000000\") != u64\"0x0004000000000000\",\n      (n & u64\"0x0008000000000000\") != u64\"0x0008000000000000\",\n      (n & u64\"0x0010000000000000\") != u64\"0x0010000000000000\",\n      (n & u64\"0x0020000000000000\") != u64\"0x0020000000000000\",\n      (n & u64\"0x0040000000000000\") != u64\"0x0040000000000000\",\n      (n & u64\"0x0080000000000000\") != u64\"0x0080000000000000\",\n      (n & u64\"0x0100000000000000\") != u64\"0x0100000000000000\",\n      (n & u64\"0x0200000000000000\") != u64\"0x0200000000000000\",\n      (n & u64\"0x0400000000000000\") != u64\"0x0400000000000000\",\n      (n & u64\"0x0800000000000000\") != u64\"0x0800000000000000\",\n      (n & u64\"0x1000000000000000\") != u64\"0x1000000000000000\",\n      (n & u64\"0x2000000000000000\") != u64\"0x2000000000000000\",\n      (n & u64\"0x4000000000000000\") != u64\"0x4000000000000000\",\n      (n & u64\"0x8000000000000000\") != u64\"0x8000000000000000\"\n    )\n  }\n}\n\n@datatype class ISZBOps(val s: IS[Z, B]) extends SBOps[Z] {\n\n  @pure def toU8: U8 = {\n//    l\"\"\" requires s.size ≡ 8\n//         ensures  fromU8(result) ≡ s \"\"\"\n\n    var r = u8\"0\"\n    var mask = u8\"1\"\n    for (i <- 0 until 8) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u8\"1\"\n    }\n    return r\n  }\n\n  @pure def toU16: U16 = {\n//    l\"\"\" requires s.size ≡ 16\n//         ensures  fromU16(result) ≡ s \"\"\"\n\n    var r = u16\"0\"\n    var mask = u16\"1\"\n    for (i <- 0 until 16) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u16\"1\"\n    }\n    return r\n  }\n\n  @pure def toU32: U32 = {\n//    l\"\"\" requires s.size ≡ 32\n//         ensures  fromU32(result) ≡ s \"\"\"\n\n    var r = u32\"0\"\n    var mask = u32\"1\"\n    for (i <- 0 until 32) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u32\"1\"\n    }\n    return r\n  }\n\n  @pure def toU64: U64 = {\n//    l\"\"\" requires s.size ≡ 64\n//         ensures  fromU64(result) ≡ s \"\"\"\n\n    var r = u64\"0\"\n    var mask = u64\"1\"\n    for (i <- 0 until 64) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u64\"1\"\n    }\n    return r\n  }\n\n}\n
  #732 = String             #731          // 080000000000\",\n      (n & u64\"0x0000100000000000\") != u64\"0x0000100000000000\",\n      (n & u64\"0x0000200000000000\") != u64\"0x0000200000000000\",\n      (n & u64\"0x0000400000000000\") != u64\"0x0000400000000000\",\n      (n & u64\"0x0000800000000000\") != u64\"0x0000800000000000\",\n      (n & u64\"0x0001000000000000\") != u64\"0x0001000000000000\",\n      (n & u64\"0x0002000000000000\") != u64\"0x0002000000000000\",\n      (n & u64\"0x0004000000000000\") != u64\"0x0004000000000000\",\n      (n & u64\"0x0008000000000000\") != u64\"0x0008000000000000\",\n      (n & u64\"0x0010000000000000\") != u64\"0x0010000000000000\",\n      (n & u64\"0x0020000000000000\") != u64\"0x0020000000000000\",\n      (n & u64\"0x0040000000000000\") != u64\"0x0040000000000000\",\n      (n & u64\"0x0080000000000000\") != u64\"0x0080000000000000\",\n      (n & u64\"0x0100000000000000\") != u64\"0x0100000000000000\",\n      (n & u64\"0x0200000000000000\") != u64\"0x0200000000000000\",\n      (n & u64\"0x0400000000000000\") != u64\"0x0400000000000000\",\n      (n & u64\"0x0800000000000000\") != u64\"0x0800000000000000\",\n      (n & u64\"0x1000000000000000\") != u64\"0x1000000000000000\",\n      (n & u64\"0x2000000000000000\") != u64\"0x2000000000000000\",\n      (n & u64\"0x4000000000000000\") != u64\"0x4000000000000000\",\n      (n & u64\"0x8000000000000000\") != u64\"0x8000000000000000\"\n    )\n  }\n}\n\n@datatype class ISZBOps(val s: IS[Z, B]) extends SBOps[Z] {\n\n  @pure def toU8: U8 = {\n//    l\"\"\" requires s.size ≡ 8\n//         ensures  fromU8(result) ≡ s \"\"\"\n\n    var r = u8\"0\"\n    var mask = u8\"1\"\n    for (i <- 0 until 8) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u8\"1\"\n    }\n    return r\n  }\n\n  @pure def toU16: U16 = {\n//    l\"\"\" requires s.size ≡ 16\n//         ensures  fromU16(result) ≡ s \"\"\"\n\n    var r = u16\"0\"\n    var mask = u16\"1\"\n    for (i <- 0 until 16) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u16\"1\"\n    }\n    return r\n  }\n\n  @pure def toU32: U32 = {\n//    l\"\"\" requires s.size ≡ 32\n//         ensures  fromU32(result) ≡ s \"\"\"\n\n    var r = u32\"0\"\n    var mask = u32\"1\"\n    for (i <- 0 until 32) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u32\"1\"\n    }\n    return r\n  }\n\n  @pure def toU64: U64 = {\n//    l\"\"\" requires s.size ≡ 64\n//         ensures  fromU64(result) ≡ s \"\"\"\n\n    var r = u64\"0\"\n    var mask = u64\"1\"\n    for (i <- 0 until 64) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u64\"1\"\n    }\n    return r\n  }\n\n}\n
  #733 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.U1._\nimport org.sireum.U2._\nimport org.sireum.U3._\nimport org.sireum.U4._\nimport org.sireum.U5._\nimport org.sireum.U6._\nimport org.sireum.U7._\nimport org.sireum.U8._\nimport org.sireum.U9._\nimport org.sireum.U10._\nimport org.sireum.U11._\nimport org.sireum.U12._\nimport org.sireum.U13._\nimport org.sireum.U14._\nimport org.sireum.U15._\nimport org.sireum.U16._\nimport org.sireum.U17._\nimport org.sireum.U18._\nimport org.sireum.U19._\nimport org.sireum.U20._\nimport org.sireum.U21._\nimport org.sireum.U22._\nimport org.sireum.U23._\nimport org.sireum.U24._\nimport org.sireum.U25._\nimport org.sireum.U26._\nimport org.sireum.U27._\nimport org.sireum.U28._\nimport org.sireum.U29._\nimport org.sireum.U30._\nimport org.sireum.U31._\nimport org.sireum.U32._\nimport org.sireum.U33._\nimport org.sireum.U34._\nimport org.sireum.U35._\nimport org.sireum.U36._\nimport org.sireum.U37._\nimport org.sireum.U38._\nimport org.sireum.U39._\nimport org.sireum.U40._\nimport org.sireum.U41._\nimport org.sireum.U42._\nimport org.sireum.U43._\nimport org.sireum.U44._\nimport org.sireum.U45._\nimport org.sireum.U46._\nimport org.sireum.U47._\nimport org.sireum.U48._\nimport org.sireum.U49._\nimport org.sireum.U50._\nimport org.sireum.U51._\nimport org.sireum.U52._\nimport org.sireum.U53._\nimport org.sireum.U54._\nimport org.sireum.U55._\nimport org.sireum.U56._\nimport org.sireum.U57._\nimport org.sireum.U58._\nimport org.sireum.U59._\nimport org.sireum.U60._\nimport org.sireum.U61._\nimport org.sireum.U62._\nimport org.sireum.U63._\nimport org.sireum.U64._\n\n\nobject Bits {\n\n  object Context {\n    def create: Context = {\n      return Context(0, 0, 0)\n    }\n  }\n\n  @record class Context(var offset: Z,\n                        var errorCode: Z,\n                        var errorOffset: Z) {\n    def hasError: B = {\n      return errorCode != 0\n    }\n\n    def signalError(code: Z): Unit = {\n      if (!hasError) {\n        errorCode = code\n        errorOffset = offset\n      }\n    }\n\n    def skip(size: Z, n: Z, errorCode: Z): Unit = {\n      if (offset + n > size) {\n        signalError(errorCode)\n        return\n      }\n      offset = offset + n\n    }\n\n    def updateErrorCode(code: Z): Unit = {\n      errorCode = code\n    }\n  }\n\n  object Reader {\n    val INCOMPLETE_INPUT: Z = 1\n\n    object IS {\n\n      def bleB(input: ISZ[B], context: Context): B = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return F\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return r\n      }\n\n      def beBS(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        bleRaw(input, context, result, size)\n      }\n\n      def leBS(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- size - 1 to 0 by -1) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleRaw(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleU1(input: ISZ[B], context: Context): U1 = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u1\"0\"\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return if (r) u1\"1\" else u1\"0\"\n      }\n\n      def bleU2(input: ISZ[B], context: Context): U2 = {\n        val offset = context.offset\n        if (offset + 2 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u2\"0\"\n        }\n        var r = u2\"0\"\n        var mask = u2\"1\"\n        for (i <- 0 until 1) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u2\"1\"\n        }\n        if (input(offset + 1)) {\n          r = r | mask\n        }\n        context.offset = offset + 2\n        return r\n      }\n\n      def bleU3(input: ISZ[B], context: Context): U3 = {\n        val offset = context.offset\n        if (offset + 3 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u3\"0\"\n        }\n        var r = u3\"0\"\n        var mask = u3\"1\"\n        for (i <- 0 until 2) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u3\"1\"\n        }\n        if (input(offset + 2)) {\n          r = r | mask\n        }\n        context.offset = offset + 3\n        return r\n      }\n\n      def bleU4(input: ISZ[B], context: Context): U4 = {\n        val offset = context.offset\n        if (offset + 4 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u4\"0\"\n        }\n        var r = u4\"0\"\n        var mask = u4\"1\"\n        for (i <- 0 until 3) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u4\"1\"\n        }\n        if (input(offset + 3)) {\n          r = r | mask\n        }\n        context.offset = offset + 4\n        return r\n      }\n\n      def bleU5(input: ISZ[B], context: Context): U5 = {\n        val offset = context.offset\n        if (offset + 5 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u5\"0\"\n        }\n        var r = u5\"0\"\n        var mask = u5\"1\"\n        for (i <- 0 until 4) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u5\"1\"\n        }\n        if (input(offset + 4)) {\n          r = r | mask\n        }\n        context.offset = offset + 5\n        return r\n      }\n\n      def bleU6(input: ISZ[B], context: Context): U6 = {\n        val offset = context.offset\n        if (offset + 6 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u6\"0\"\n        }\n        var r = u6\"0\"\n        var mask = u6\"1\"\n        for (i <- 0 until 5) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u6\"1\"\n        }\n        if (input(offset + 5)) {\n          r = r | mask\n        }\n        context.offset = offset + 6\n        return r\n      }\n\n      def bleU7(input: ISZ[B], context: Context): U7 = {\n        val offset = context.offset\n        if (offset + 7 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u7\"0\"\n        }\n        var r = u7\"0\"\n        var mask = u7\"1\"\n        for (i <- 0 until 6) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u7\"1\"\n        }\n        if (input(offset + 6)) {\n          r = r | mask\n        }\n        context.offset = offset + 7\n        return r\n      }\n\n      def beU8S(input: ISZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        leU8S(input, context, result, size)\n      }\n\n      def beS8S(input: ISZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        leS8S(input, context, result, size)\n      }\n\n      def beU16S(input: ISZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU16(input, context)\n        }\n      }\n\n      def beS16S(input: ISZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS16(input, context)\n        }\n      }\n\n      def beU32S(input: ISZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU32(input, context)\n        }\n      }\n\n      def beS32S(input: ISZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS32(input, context)\n        }\n      }\n\n      def beU64S(input: ISZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU64(input, context)\n        }\n      }\n\n      def beS64S(input: ISZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS64(input, context)\n        }\n      }\n\n      def beF32S(input: ISZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF32(input, context)\n        }\n      }\n\n      def beF64S(input: ISZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF64(input, context)\n        }\n      }\n\n      def leU8S(input: ISZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleU8(input, context)\n        }\n      }\n\n      def leS8S(input: ISZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleS8(input, context)\n        }\n      }\n\n      def leU16S(input: ISZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU16(input, context)\n        }\n      }\n\n      def leS16S(input: ISZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS16(input, context)\n        }\n      }\n\n      def leU32S(input: ISZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU32(input, context)\n        }\n      }\n\n      def leS32S(input: ISZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS32(input, context)\n        }\n      }\n\n      def leU64S(input: ISZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU64(input, context)\n        }\n      }\n\n      def leS64S(input: ISZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS64(input, context)\n        }\n      }\n\n      def leF32S(input: ISZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF32(input, context)\n        }\n      }\n\n      def leF64S(input: ISZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF64(input, context)\n        }\n      }\n\n      def bleU8(input: ISZ[B], context: Context): U8 = {\n        val offset = context.offset\n        if (offset + 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u8\"0\"\n        }\n        var r = u8\"0\"\n        var mask = u8\"1\"\n        for (i <- 0 until 7) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u8\"1\"\n        }\n        if (input(offset + 7)) {\n          r = r | mask\n        }\n        context.offset = offset + 8\n        return r\n      }\n\n      def bleS8(input: ISZ[B], context: Context): S8 = {\n        return conversions.U8.toRawS8(bleU8(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          ret
  #734 = String             #733          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.U1._\nimport org.sireum.U2._\nimport org.sireum.U3._\nimport org.sireum.U4._\nimport org.sireum.U5._\nimport org.sireum.U6._\nimport org.sireum.U7._\nimport org.sireum.U8._\nimport org.sireum.U9._\nimport org.sireum.U10._\nimport org.sireum.U11._\nimport org.sireum.U12._\nimport org.sireum.U13._\nimport org.sireum.U14._\nimport org.sireum.U15._\nimport org.sireum.U16._\nimport org.sireum.U17._\nimport org.sireum.U18._\nimport org.sireum.U19._\nimport org.sireum.U20._\nimport org.sireum.U21._\nimport org.sireum.U22._\nimport org.sireum.U23._\nimport org.sireum.U24._\nimport org.sireum.U25._\nimport org.sireum.U26._\nimport org.sireum.U27._\nimport org.sireum.U28._\nimport org.sireum.U29._\nimport org.sireum.U30._\nimport org.sireum.U31._\nimport org.sireum.U32._\nimport org.sireum.U33._\nimport org.sireum.U34._\nimport org.sireum.U35._\nimport org.sireum.U36._\nimport org.sireum.U37._\nimport org.sireum.U38._\nimport org.sireum.U39._\nimport org.sireum.U40._\nimport org.sireum.U41._\nimport org.sireum.U42._\nimport org.sireum.U43._\nimport org.sireum.U44._\nimport org.sireum.U45._\nimport org.sireum.U46._\nimport org.sireum.U47._\nimport org.sireum.U48._\nimport org.sireum.U49._\nimport org.sireum.U50._\nimport org.sireum.U51._\nimport org.sireum.U52._\nimport org.sireum.U53._\nimport org.sireum.U54._\nimport org.sireum.U55._\nimport org.sireum.U56._\nimport org.sireum.U57._\nimport org.sireum.U58._\nimport org.sireum.U59._\nimport org.sireum.U60._\nimport org.sireum.U61._\nimport org.sireum.U62._\nimport org.sireum.U63._\nimport org.sireum.U64._\n\n\nobject Bits {\n\n  object Context {\n    def create: Context = {\n      return Context(0, 0, 0)\n    }\n  }\n\n  @record class Context(var offset: Z,\n                        var errorCode: Z,\n                        var errorOffset: Z) {\n    def hasError: B = {\n      return errorCode != 0\n    }\n\n    def signalError(code: Z): Unit = {\n      if (!hasError) {\n        errorCode = code\n        errorOffset = offset\n      }\n    }\n\n    def skip(size: Z, n: Z, errorCode: Z): Unit = {\n      if (offset + n > size) {\n        signalError(errorCode)\n        return\n      }\n      offset = offset + n\n    }\n\n    def updateErrorCode(code: Z): Unit = {\n      errorCode = code\n    }\n  }\n\n  object Reader {\n    val INCOMPLETE_INPUT: Z = 1\n\n    object IS {\n\n      def bleB(input: ISZ[B], context: Context): B = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return F\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return r\n      }\n\n      def beBS(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        bleRaw(input, context, result, size)\n      }\n\n      def leBS(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- size - 1 to 0 by -1) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleRaw(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleU1(input: ISZ[B], context: Context): U1 = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u1\"0\"\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return if (r) u1\"1\" else u1\"0\"\n      }\n\n      def bleU2(input: ISZ[B], context: Context): U2 = {\n        val offset = context.offset\n        if (offset + 2 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u2\"0\"\n        }\n        var r = u2\"0\"\n        var mask = u2\"1\"\n        for (i <- 0 until 1) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u2\"1\"\n        }\n        if (input(offset + 1)) {\n          r = r | mask\n        }\n        context.offset = offset + 2\n        return r\n      }\n\n      def bleU3(input: ISZ[B], context: Context): U3 = {\n        val offset = context.offset\n        if (offset + 3 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u3\"0\"\n        }\n        var r = u3\"0\"\n        var mask = u3\"1\"\n        for (i <- 0 until 2) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u3\"1\"\n        }\n        if (input(offset + 2)) {\n          r = r | mask\n        }\n        context.offset = offset + 3\n        return r\n      }\n\n      def bleU4(input: ISZ[B], context: Context): U4 = {\n        val offset = context.offset\n        if (offset + 4 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u4\"0\"\n        }\n        var r = u4\"0\"\n        var mask = u4\"1\"\n        for (i <- 0 until 3) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u4\"1\"\n        }\n        if (input(offset + 3)) {\n          r = r | mask\n        }\n        context.offset = offset + 4\n        return r\n      }\n\n      def bleU5(input: ISZ[B], context: Context): U5 = {\n        val offset = context.offset\n        if (offset + 5 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u5\"0\"\n        }\n        var r = u5\"0\"\n        var mask = u5\"1\"\n        for (i <- 0 until 4) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u5\"1\"\n        }\n        if (input(offset + 4)) {\n          r = r | mask\n        }\n        context.offset = offset + 5\n        return r\n      }\n\n      def bleU6(input: ISZ[B], context: Context): U6 = {\n        val offset = context.offset\n        if (offset + 6 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u6\"0\"\n        }\n        var r = u6\"0\"\n        var mask = u6\"1\"\n        for (i <- 0 until 5) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u6\"1\"\n        }\n        if (input(offset + 5)) {\n          r = r | mask\n        }\n        context.offset = offset + 6\n        return r\n      }\n\n      def bleU7(input: ISZ[B], context: Context): U7 = {\n        val offset = context.offset\n        if (offset + 7 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u7\"0\"\n        }\n        var r = u7\"0\"\n        var mask = u7\"1\"\n        for (i <- 0 until 6) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u7\"1\"\n        }\n        if (input(offset + 6)) {\n          r = r | mask\n        }\n        context.offset = offset + 7\n        return r\n      }\n\n      def beU8S(input: ISZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        leU8S(input, context, result, size)\n      }\n\n      def beS8S(input: ISZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        leS8S(input, context, result, size)\n      }\n\n      def beU16S(input: ISZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU16(input, context)\n        }\n      }\n\n      def beS16S(input: ISZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS16(input, context)\n        }\n      }\n\n      def beU32S(input: ISZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU32(input, context)\n        }\n      }\n\n      def beS32S(input: ISZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS32(input, context)\n        }\n      }\n\n      def beU64S(input: ISZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU64(input, context)\n        }\n      }\n\n      def beS64S(input: ISZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS64(input, context)\n        }\n      }\n\n      def beF32S(input: ISZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF32(input, context)\n        }\n      }\n\n      def beF64S(input: ISZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF64(input, context)\n        }\n      }\n\n      def leU8S(input: ISZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleU8(input, context)\n        }\n      }\n\n      def leS8S(input: ISZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleS8(input, context)\n        }\n      }\n\n      def leU16S(input: ISZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU16(input, context)\n        }\n      }\n\n      def leS16S(input: ISZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS16(input, context)\n        }\n      }\n\n      def leU32S(input: ISZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU32(input, context)\n        }\n      }\n\n      def leS32S(input: ISZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS32(input, context)\n        }\n      }\n\n      def leU64S(input: ISZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU64(input, context)\n        }\n      }\n\n      def leS64S(input: ISZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS64(input, context)\n        }\n      }\n\n      def leF32S(input: ISZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF32(input, context)\n        }\n      }\n\n      def leF64S(input: ISZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF64(input, context)\n        }\n      }\n\n      def bleU8(input: ISZ[B], context: Context): U8 = {\n        val offset = context.offset\n        if (offset + 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u8\"0\"\n        }\n        var r = u8\"0\"\n        var mask = u8\"1\"\n        for (i <- 0 until 7) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u8\"1\"\n        }\n        if (input(offset + 7)) {\n          r = r | mask\n        }\n        context.offset = offset + 8\n        return r\n      }\n\n      def bleS8(input: ISZ[B], context: Context): S8 = {\n        return conversions.U8.toRawS8(bleU8(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          ret
  #735 = Utf8               urn u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      */\n\n      def beU9(input: ISZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def beU10(input: ISZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def beU11(input: ISZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def beU12(input: ISZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def beU13(input: ISZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def beU14(input: ISZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def beU15(input: ISZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def beU16(input: ISZ[B], context: Context): U16 = {\n        val r = (conversions.U8.toU16(bleU8(input, context)) << u16\"8\") |\n          conversions.U8.toU16(bleU8(input, context))\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def beS16(input: ISZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(beU16(input, context))\n      }\n\n      def beU17(input: ISZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def beU18(input: ISZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def beU19(input: ISZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def beU20(input: ISZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def beU21(input: ISZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def beU22(input: ISZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def beU23(input: ISZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def beU24(input: ISZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def beU25(input: ISZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def beU26(input: ISZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def beU27(input: ISZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def beU28(input: ISZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def beU29(input: ISZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def beU30(input: ISZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def beU31(input: ISZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def beU32(input: ISZ[B], context: Context): U32 = {\n        val r = (conversions.U8.toU32(bleU8(input, context)) << u32\"24\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          conversions.U8.toU32(bleU8(input, context))\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def beS32(input: ISZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(beU32(input, context))\n      }\n\n      def beU33(input: ISZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def beU34(input: ISZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def beU35(input: ISZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def beU36(input: ISZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def beU37(input: ISZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def beU38(input: ISZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def beU39(input: ISZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def beU40(input: ISZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def beU41(input: ISZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def beU42(input: ISZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def beU43(input: ISZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n
  #736 = String             #735          // urn u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      */\n\n      def beU9(input: ISZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def beU10(input: ISZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def beU11(input: ISZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def beU12(input: ISZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def beU13(input: ISZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def beU14(input: ISZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def beU15(input: ISZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def beU16(input: ISZ[B], context: Context): U16 = {\n        val r = (conversions.U8.toU16(bleU8(input, context)) << u16\"8\") |\n          conversions.U8.toU16(bleU8(input, context))\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def beS16(input: ISZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(beU16(input, context))\n      }\n\n      def beU17(input: ISZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def beU18(input: ISZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def beU19(input: ISZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def beU20(input: ISZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def beU21(input: ISZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def beU22(input: ISZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def beU23(input: ISZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def beU24(input: ISZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def beU25(input: ISZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def beU26(input: ISZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def beU27(input: ISZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def beU28(input: ISZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def beU29(input: ISZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def beU30(input: ISZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def beU31(input: ISZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def beU32(input: ISZ[B], context: Context): U32 = {\n        val r = (conversions.U8.toU32(bleU8(input, context)) << u32\"24\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          conversions.U8.toU32(bleU8(input, context))\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def beS32(input: ISZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(beU32(input, context))\n      }\n\n      def beU33(input: ISZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def beU34(input: ISZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def beU35(input: ISZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def beU36(input: ISZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def beU37(input: ISZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def beU38(input: ISZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def beU39(input: ISZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def beU40(input: ISZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def beU41(input: ISZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def beU42(input: ISZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def beU43(input: ISZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n
  #737 = Utf8               r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def beU44(input: ISZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def beU45(input: ISZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def beU46(input: ISZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def beU47(input: ISZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def beU48(input: ISZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def beU49(input: ISZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def beU50(input: ISZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def beU51(input: ISZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def beU52(input: ISZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def beU53(input: ISZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def beU54(input: ISZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def beU55(input: ISZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def beU56(input: ISZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def beU57(input: ISZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def beU58(input: ISZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def beU59(input: ISZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def beU60(input: ISZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def beU61(input: ISZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def beU62(input: ISZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def beU63(input: ISZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def beU64(input: ISZ[B], context: Context): U64 = {\n        val r = (conversions.U8.toU64(bleU8(input, context)) << u64\"56\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          conversions.U8.toU64(bleU8(input, context))\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def beS64(input: ISZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(beU64(input, context))\n      }\n\n      def beF32(input: ISZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(beU32(input, context))\n      }\n\n      def beF64(input: ISZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(beU64(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n
  #738 = String             #737          // r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def beU44(input: ISZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def beU45(input: ISZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def beU46(input: ISZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def beU47(input: ISZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def beU48(input: ISZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def beU49(input: ISZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def beU50(input: ISZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def beU51(input: ISZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def beU52(input: ISZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def beU53(input: ISZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def beU54(input: ISZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def beU55(input: ISZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def beU56(input: ISZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def beU57(input: ISZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def beU58(input: ISZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def beU59(input: ISZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def beU60(input: ISZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def beU61(input: ISZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def beU62(input: ISZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def beU63(input: ISZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def beU64(input: ISZ[B], context: Context): U64 = {\n        val r = (conversions.U8.toU64(bleU8(input, context)) << u64\"56\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          conversions.U8.toU64(bleU8(input, context))\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def beS64(input: ISZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(beU64(input, context))\n      }\n\n      def beF32(input: ISZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(beU32(input, context))\n      }\n\n      def beF64(input: ISZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(beU64(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n
  #739 = Utf8                         |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n       */\n\n      def leU9(input: ISZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def leU10(input: ISZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def leU11(input: ISZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def leU12(input: ISZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def leU13(input: ISZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def leU14(input: ISZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def leU15(input: ISZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def leU16(input: ISZ[B], context: Context): U16 = {\n        val r = conversions.U8.toU16(bleU8(input, context)) |\n          (conversions.U8.toU16(bleU8(input, context)) << u16\"8\")\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def leS16(input: ISZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(leU16(input, context))\n      }\n\n      def leU17(input: ISZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def leU18(input: ISZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def leU19(input: ISZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def leU20(input: ISZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def leU21(input: ISZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def leU22(input: ISZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def leU23(input: ISZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def leU24(input: ISZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def leU25(input: ISZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def leU26(input: ISZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def leU27(input: ISZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def leU28(input: ISZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def leU29(input: ISZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def leU30(input: ISZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def leU31(input: ISZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def leU32(input: ISZ[B], context: Context): U32 = {\n        val r = conversions.U8.toU32(bleU8(input, context)) |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"24\")\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def leS32(input: ISZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(leU32(input, context))\n      }\n\n      def leU33(input: ISZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def leU34(input: ISZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def leU35(input: ISZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def leU36(input: ISZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def leU37(input: ISZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def leU38(input: ISZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def leU39(input: ISZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | (conversions.U64.toU39
  #740 = String             #739          //           |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n       */\n\n      def leU9(input: ISZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def leU10(input: ISZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def leU11(input: ISZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def leU12(input: ISZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def leU13(input: ISZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def leU14(input: ISZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def leU15(input: ISZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def leU16(input: ISZ[B], context: Context): U16 = {\n        val r = conversions.U8.toU16(bleU8(input, context)) |\n          (conversions.U8.toU16(bleU8(input, context)) << u16\"8\")\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def leS16(input: ISZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(leU16(input, context))\n      }\n\n      def leU17(input: ISZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def leU18(input: ISZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def leU19(input: ISZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def leU20(input: ISZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def leU21(input: ISZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def leU22(input: ISZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def leU23(input: ISZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def leU24(input: ISZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def leU25(input: ISZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def leU26(input: ISZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def leU27(input: ISZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def leU28(input: ISZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def leU29(input: ISZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def leU30(input: ISZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def leU31(input: ISZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def leU32(input: ISZ[B], context: Context): U32 = {\n        val r = conversions.U8.toU32(bleU8(input, context)) |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"24\")\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def leS32(input: ISZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(leU32(input, context))\n      }\n\n      def leU33(input: ISZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def leU34(input: ISZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def leU35(input: ISZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def leU36(input: ISZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def leU37(input: ISZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def leU38(input: ISZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def leU39(input: ISZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | (conversions.U64.toU39
  #741 = Utf8               (conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def leU40(input: ISZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def leU41(input: ISZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def leU42(input: ISZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def leU43(input: ISZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def leU44(input: ISZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def leU45(input: ISZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def leU46(input: ISZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def leU47(input: ISZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def leU48(input: ISZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def leU49(input: ISZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def leU50(input: ISZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def leU51(input: ISZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def leU52(input: ISZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def leU53(input: ISZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def leU54(input: ISZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def leU55(input: ISZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def leU56(input: ISZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def leU57(input: ISZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def leU58(input: ISZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def leU59(input: ISZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def leU60(input: ISZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def leU61(input: ISZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def leU62(input: ISZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def leU63(input: ISZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n
  #742 = String             #741          // (conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def leU40(input: ISZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def leU41(input: ISZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def leU42(input: ISZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def leU43(input: ISZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def leU44(input: ISZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def leU45(input: ISZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def leU46(input: ISZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def leU47(input: ISZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def leU48(input: ISZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def leU49(input: ISZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def leU50(input: ISZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def leU51(input: ISZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def leU52(input: ISZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def leU53(input: ISZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def leU54(input: ISZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def leU55(input: ISZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def leU56(input: ISZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def leU57(input: ISZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def leU58(input: ISZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def leU59(input: ISZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def leU60(input: ISZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def leU61(input: ISZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def leU62(input: ISZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def leU63(input: ISZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n
  #743 = Utf8                   def leU64(input: ISZ[B], context: Context): U64 = {\n        val r = conversions.U8.toU64(bleU8(input, context)) |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"56\")\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def leS64(input: ISZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(leU64(input, context))\n      }\n\n      def leF32(input: ISZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(leU32(input, context))\n      }\n\n      def leF64(input: ISZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(leU64(input, context))\n      }\n    }\n\n    object MS {\n\n      def bleB(input: MSZ[B], context: Context): B = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return F\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return r\n      }\n\n      def beBS(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        bleRaw(input, context, result, size)\n      }\n\n      def leBS(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- size - 1 to 0 by -1) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleRaw(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleU1(input: MSZ[B], context: Context): U1 = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u1\"0\"\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return if (r) u1\"1\" else u1\"0\"\n      }\n\n      def bleU2(input: MSZ[B], context: Context): U2 = {\n        val offset = context.offset\n        if (offset + 2 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u2\"0\"\n        }\n        var r = u2\"0\"\n        var mask = u2\"1\"\n        for (i <- 0 until 1) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u2\"1\"\n        }\n        if (input(offset + 1)) {\n          r = r | mask\n        }\n        context.offset = offset + 2\n        return r\n      }\n\n      def bleU3(input: MSZ[B], context: Context): U3 = {\n        val offset = context.offset\n        if (offset + 3 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u3\"0\"\n        }\n        var r = u3\"0\"\n        var mask = u3\"1\"\n        for (i <- 0 until 2) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u3\"1\"\n        }\n        if (input(offset + 2)) {\n          r = r | mask\n        }\n        context.offset = offset + 3\n        return r\n      }\n\n      def bleU4(input: MSZ[B], context: Context): U4 = {\n        val offset = context.offset\n        if (offset + 4 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u4\"0\"\n        }\n        var r = u4\"0\"\n        var mask = u4\"1\"\n        for (i <- 0 until 3) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u4\"1\"\n        }\n        if (input(offset + 3)) {\n          r = r | mask\n        }\n        context.offset = offset + 4\n        return r\n      }\n\n      def bleU5(input: MSZ[B], context: Context): U5 = {\n        val offset = context.offset\n        if (offset + 5 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u5\"0\"\n        }\n        var r = u5\"0\"\n        var mask = u5\"1\"\n        for (i <- 0 until 4) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u5\"1\"\n        }\n        if (input(offset + 4)) {\n          r = r | mask\n        }\n        context.offset = offset + 5\n        return r\n      }\n\n      def bleU6(input: MSZ[B], context: Context): U6 = {\n        val offset = context.offset\n        if (offset + 6 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u6\"0\"\n        }\n        var r = u6\"0\"\n        var mask = u6\"1\"\n        for (i <- 0 until 5) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u6\"1\"\n        }\n        if (input(offset + 5)) {\n          r = r | mask\n        }\n        context.offset = offset + 6\n        return r\n      }\n\n      def bleU7(input: MSZ[B], context: Context): U7 = {\n        val offset = context.offset\n        if (offset + 7 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u7\"0\"\n        }\n        var r = u7\"0\"\n        var mask = u7\"1\"\n        for (i <- 0 until 6) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u7\"1\"\n        }\n        if (input(offset + 6)) {\n          r = r | mask\n        }\n        context.offset = offset + 7\n        return r\n      }\n\n      def beU8S(input: MSZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        leU8S(input, context, result, size)\n      }\n\n      def beS8S(input: MSZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        leS8S(input, context, result, size)\n      }\n\n      def beU16S(input: MSZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU16(input, context)\n        }\n      }\n\n      def beS16S(input: MSZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS16(input, context)\n        }\n      }\n\n      def beU32S(input: MSZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU32(input, context)\n        }\n      }\n\n      def beS32S(input: MSZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS32(input, context)\n        }\n      }\n\n      def beU64S(input: MSZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU64(input, context)\n        }\n      }\n\n      def beS64S(input: MSZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS64(input, context)\n        }\n      }\n\n      def beF32S(input: MSZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF32(input, context)\n        }\n      }\n\n      def beF64S(input: MSZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF64(input, context)\n        }\n      }\n\n      def leU8S(input: MSZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleU8(input, context)\n        }\n      }\n\n      def leS8S(input: MSZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleS8(input, context)\n        }\n      }\n\n      def leU16S(input: MSZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU16(input, context)\n        }\n      }\n\n      def leS16S(input: MSZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS16(input, context)\n        }\n      }\n\n      def leU32S(input: MSZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU32(input, context)\n        }\n      }\n\n      def leS32S(input: MSZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS32(input, context)\n        }\n      }\n\n      def leU64S(input: MSZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU64(input, context)\n        }\n      }\n\n      def leS64S(input: MSZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS64(input, context)\n        }\n      }\n\n      def leF32S(input: MSZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF32(input, context)\n        }\n      }\n\n      def leF64S(input: MSZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF64(input, context)\n        }\n      }\n\n      def bleU8(input: MSZ[B], context: Context): U8 = {\n        val offset = context.offset\n        if (offset + 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u8\"0\"\n        }\n        var r = u8\"0\"\n        var mask = u8\"1\"\n        for (i <- 0 until 7) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u8\"1\"\n        }\n        if (input(offset + 7)) {\n          r = r | mask\n        }\n        context.offset = offset + 8\n        return r\n      }\n\n      def bleS8(input: MSZ[B], context: Context): S8 = {\n        return conversions.U8.toRawS8(bleU8(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      */\n\n      def beU9(i
  #744 = String             #743          //     def leU64(input: ISZ[B], context: Context): U64 = {\n        val r = conversions.U8.toU64(bleU8(input, context)) |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"56\")\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def leS64(input: ISZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(leU64(input, context))\n      }\n\n      def leF32(input: ISZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(leU32(input, context))\n      }\n\n      def leF64(input: ISZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(leU64(input, context))\n      }\n    }\n\n    object MS {\n\n      def bleB(input: MSZ[B], context: Context): B = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return F\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return r\n      }\n\n      def beBS(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        bleRaw(input, context, result, size)\n      }\n\n      def leBS(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- size - 1 to 0 by -1) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleRaw(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleU1(input: MSZ[B], context: Context): U1 = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u1\"0\"\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return if (r) u1\"1\" else u1\"0\"\n      }\n\n      def bleU2(input: MSZ[B], context: Context): U2 = {\n        val offset = context.offset\n        if (offset + 2 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u2\"0\"\n        }\n        var r = u2\"0\"\n        var mask = u2\"1\"\n        for (i <- 0 until 1) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u2\"1\"\n        }\n        if (input(offset + 1)) {\n          r = r | mask\n        }\n        context.offset = offset + 2\n        return r\n      }\n\n      def bleU3(input: MSZ[B], context: Context): U3 = {\n        val offset = context.offset\n        if (offset + 3 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u3\"0\"\n        }\n        var r = u3\"0\"\n        var mask = u3\"1\"\n        for (i <- 0 until 2) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u3\"1\"\n        }\n        if (input(offset + 2)) {\n          r = r | mask\n        }\n        context.offset = offset + 3\n        return r\n      }\n\n      def bleU4(input: MSZ[B], context: Context): U4 = {\n        val offset = context.offset\n        if (offset + 4 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u4\"0\"\n        }\n        var r = u4\"0\"\n        var mask = u4\"1\"\n        for (i <- 0 until 3) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u4\"1\"\n        }\n        if (input(offset + 3)) {\n          r = r | mask\n        }\n        context.offset = offset + 4\n        return r\n      }\n\n      def bleU5(input: MSZ[B], context: Context): U5 = {\n        val offset = context.offset\n        if (offset + 5 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u5\"0\"\n        }\n        var r = u5\"0\"\n        var mask = u5\"1\"\n        for (i <- 0 until 4) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u5\"1\"\n        }\n        if (input(offset + 4)) {\n          r = r | mask\n        }\n        context.offset = offset + 5\n        return r\n      }\n\n      def bleU6(input: MSZ[B], context: Context): U6 = {\n        val offset = context.offset\n        if (offset + 6 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u6\"0\"\n        }\n        var r = u6\"0\"\n        var mask = u6\"1\"\n        for (i <- 0 until 5) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u6\"1\"\n        }\n        if (input(offset + 5)) {\n          r = r | mask\n        }\n        context.offset = offset + 6\n        return r\n      }\n\n      def bleU7(input: MSZ[B], context: Context): U7 = {\n        val offset = context.offset\n        if (offset + 7 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u7\"0\"\n        }\n        var r = u7\"0\"\n        var mask = u7\"1\"\n        for (i <- 0 until 6) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u7\"1\"\n        }\n        if (input(offset + 6)) {\n          r = r | mask\n        }\n        context.offset = offset + 7\n        return r\n      }\n\n      def beU8S(input: MSZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        leU8S(input, context, result, size)\n      }\n\n      def beS8S(input: MSZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        leS8S(input, context, result, size)\n      }\n\n      def beU16S(input: MSZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU16(input, context)\n        }\n      }\n\n      def beS16S(input: MSZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS16(input, context)\n        }\n      }\n\n      def beU32S(input: MSZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU32(input, context)\n        }\n      }\n\n      def beS32S(input: MSZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS32(input, context)\n        }\n      }\n\n      def beU64S(input: MSZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU64(input, context)\n        }\n      }\n\n      def beS64S(input: MSZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS64(input, context)\n        }\n      }\n\n      def beF32S(input: MSZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF32(input, context)\n        }\n      }\n\n      def beF64S(input: MSZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF64(input, context)\n        }\n      }\n\n      def leU8S(input: MSZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleU8(input, context)\n        }\n      }\n\n      def leS8S(input: MSZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleS8(input, context)\n        }\n      }\n\n      def leU16S(input: MSZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU16(input, context)\n        }\n      }\n\n      def leS16S(input: MSZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS16(input, context)\n        }\n      }\n\n      def leU32S(input: MSZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU32(input, context)\n        }\n      }\n\n      def leS32S(input: MSZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS32(input, context)\n        }\n      }\n\n      def leU64S(input: MSZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU64(input, context)\n        }\n      }\n\n      def leS64S(input: MSZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS64(input, context)\n        }\n      }\n\n      def leF32S(input: MSZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF32(input, context)\n        }\n      }\n\n      def leF64S(input: MSZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF64(input, context)\n        }\n      }\n\n      def bleU8(input: MSZ[B], context: Context): U8 = {\n        val offset = context.offset\n        if (offset + 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u8\"0\"\n        }\n        var r = u8\"0\"\n        var mask = u8\"1\"\n        for (i <- 0 until 7) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u8\"1\"\n        }\n        if (input(offset + 7)) {\n          r = r | mask\n        }\n        context.offset = offset + 8\n        return r\n      }\n\n      def bleS8(input: MSZ[B], context: Context): S8 = {\n        return conversions.U8.toRawS8(bleU8(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      */\n\n      def beU9(i
  #745 = Utf8               nput: MSZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def beU10(input: MSZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def beU11(input: MSZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def beU12(input: MSZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def beU13(input: MSZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def beU14(input: MSZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def beU15(input: MSZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def beU16(input: MSZ[B], context: Context): U16 = {\n        val r = (conversions.U8.toU16(bleU8(input, context)) << u16\"8\") |\n          conversions.U8.toU16(bleU8(input, context))\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def beS16(input: MSZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(beU16(input, context))\n      }\n\n      def beU17(input: MSZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def beU18(input: MSZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def beU19(input: MSZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def beU20(input: MSZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def beU21(input: MSZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def beU22(input: MSZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def beU23(input: MSZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def beU24(input: MSZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def beU25(input: MSZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def beU26(input: MSZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def beU27(input: MSZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def beU28(input: MSZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def beU29(input: MSZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def beU30(input: MSZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def beU31(input: MSZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def beU32(input: MSZ[B], context: Context): U32 = {\n        val r = (conversions.U8.toU32(bleU8(input, context)) << u32\"24\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          conversions.U8.toU32(bleU8(input, context))\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def beS32(input: MSZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(beU32(input, context))\n      }\n\n      def beU33(input: MSZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def beU34(input: MSZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def beU35(input: MSZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def beU36(input: MSZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def beU37(input: MSZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def beU38(input: MSZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def beU39(input: MSZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def beU40(input: MSZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def beU41(input: MSZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def beU42(input: MSZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def beU43(input: MSZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def beU44(input: MSZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def beU45(input: MSZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def beU46(input: MSZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, contex
  #746 = String             #745          // nput: MSZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def beU10(input: MSZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def beU11(input: MSZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def beU12(input: MSZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def beU13(input: MSZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def beU14(input: MSZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def beU15(input: MSZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def beU16(input: MSZ[B], context: Context): U16 = {\n        val r = (conversions.U8.toU16(bleU8(input, context)) << u16\"8\") |\n          conversions.U8.toU16(bleU8(input, context))\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def beS16(input: MSZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(beU16(input, context))\n      }\n\n      def beU17(input: MSZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def beU18(input: MSZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def beU19(input: MSZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def beU20(input: MSZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def beU21(input: MSZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def beU22(input: MSZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def beU23(input: MSZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def beU24(input: MSZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def beU25(input: MSZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def beU26(input: MSZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def beU27(input: MSZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def beU28(input: MSZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def beU29(input: MSZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def beU30(input: MSZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def beU31(input: MSZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def beU32(input: MSZ[B], context: Context): U32 = {\n        val r = (conversions.U8.toU32(bleU8(input, context)) << u32\"24\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          conversions.U8.toU32(bleU8(input, context))\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def beS32(input: MSZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(beU32(input, context))\n      }\n\n      def beU33(input: MSZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def beU34(input: MSZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def beU35(input: MSZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def beU36(input: MSZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def beU37(input: MSZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def beU38(input: MSZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def beU39(input: MSZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def beU40(input: MSZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def beU41(input: MSZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def beU42(input: MSZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def beU43(input: MSZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def beU44(input: MSZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def beU45(input: MSZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def beU46(input: MSZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, contex
  #747 = Utf8               t))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def beU47(input: MSZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def beU48(input: MSZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def beU49(input: MSZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def beU50(input: MSZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def beU51(input: MSZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def beU52(input: MSZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def beU53(input: MSZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def beU54(input: MSZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def beU55(input: MSZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def beU56(input: MSZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def beU57(input: MSZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def beU58(input: MSZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def beU59(input: MSZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def beU60(input: MSZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def beU61(input: MSZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def beU62(input: MSZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def beU63(input: MSZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def beU64(input: MSZ[B], context: Context): U64 = {\n        val r = (conversions.U8.toU64(bleU8(input, context)) << u64\"56\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          conversions.U8.toU64(bleU8(input, context))\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def beS64(input: MSZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(beU64(input, context))\n      }\n\n      def beF32(input: MSZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(beU32(input, context))\n      }\n\n      def beF64(input: MSZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(beU64(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        ret
  #748 = String             #747          // t))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def beU47(input: MSZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def beU48(input: MSZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def beU49(input: MSZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def beU50(input: MSZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def beU51(input: MSZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def beU52(input: MSZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def beU53(input: MSZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def beU54(input: MSZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def beU55(input: MSZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def beU56(input: MSZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def beU57(input: MSZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def beU58(input: MSZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def beU59(input: MSZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def beU60(input: MSZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def beU61(input: MSZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def beU62(input: MSZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def beU63(input: MSZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def beU64(input: MSZ[B], context: Context): U64 = {\n        val r = (conversions.U8.toU64(bleU8(input, context)) << u64\"56\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          conversions.U8.toU64(bleU8(input, context))\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def beS64(input: MSZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(beU64(input, context))\n      }\n\n      def beF32(input: MSZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(beU32(input, context))\n      }\n\n      def beF64(input: MSZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(beU64(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        ret
  #749 = Utf8               urn r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n       */\n\n      def leU9(input: MSZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def leU10(input: MSZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def leU11(input: MSZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def leU12(input: MSZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def leU13(input: MSZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def leU14(input: MSZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def leU15(input: MSZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def leU16(input: MSZ[B], context: Context): U16 = {\n        val r = conversions.U8.toU16(bleU8(input, context)) |\n          (conversions.U8.toU16(bleU8(input, context)) << u16\"8\")\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def leS16(input: MSZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(leU16(input, context))\n      }\n\n      def leU17(input: MSZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def leU18(input: MSZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def leU19(input: MSZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def leU20(input: MSZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def leU21(input: MSZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def leU22(input: MSZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def leU23(input: MSZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def leU24(input: MSZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def leU25(input: MSZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def leU26(input: MSZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def leU27(input: MSZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def leU28(input: MSZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def leU29(input: MSZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def leU30(input: MSZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def leU31(input: MSZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def leU32(input: MSZ[B], context: Context): U32 = {\n        val r = conversions.U8.toU32(bleU8(input, context)) |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"24\")\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def leS32(input: MSZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(leU32(input, context))\n      }\n\n      def leU33(input: MSZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def leU34(input: MSZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def leU35(input: MSZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def leU36(input: MSZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def leU37(input: MSZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def leU38(input: MSZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def leU39(input: MSZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def leU40(input: MSZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def leU41(input: MSZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def leU42(input: MSZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def leU43(input: MSZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(inp
  #750 = String             #749          // urn r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n       */\n\n      def leU9(input: MSZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def leU10(input: MSZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def leU11(input: MSZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def leU12(input: MSZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def leU13(input: MSZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def leU14(input: MSZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def leU15(input: MSZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def leU16(input: MSZ[B], context: Context): U16 = {\n        val r = conversions.U8.toU16(bleU8(input, context)) |\n          (conversions.U8.toU16(bleU8(input, context)) << u16\"8\")\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def leS16(input: MSZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(leU16(input, context))\n      }\n\n      def leU17(input: MSZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def leU18(input: MSZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def leU19(input: MSZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def leU20(input: MSZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def leU21(input: MSZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def leU22(input: MSZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def leU23(input: MSZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def leU24(input: MSZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def leU25(input: MSZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def leU26(input: MSZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def leU27(input: MSZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def leU28(input: MSZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def leU29(input: MSZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def leU30(input: MSZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def leU31(input: MSZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def leU32(input: MSZ[B], context: Context): U32 = {\n        val r = conversions.U8.toU32(bleU8(input, context)) |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"24\")\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def leS32(input: MSZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(leU32(input, context))\n      }\n\n      def leU33(input: MSZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def leU34(input: MSZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def leU35(input: MSZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def leU36(input: MSZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def leU37(input: MSZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def leU38(input: MSZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def leU39(input: MSZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def leU40(input: MSZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def leU41(input: MSZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def leU42(input: MSZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def leU43(input: MSZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(inp
  #751 = Utf8               ut, context)))\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def leU44(input: MSZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def leU45(input: MSZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def leU46(input: MSZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def leU47(input: MSZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def leU48(input: MSZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def leU49(input: MSZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def leU50(input: MSZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def leU51(input: MSZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def leU52(input: MSZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def leU53(input: MSZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def leU54(input: MSZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def leU55(input: MSZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def leU56(input: MSZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def leU57(input: MSZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def leU58(input: MSZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def leU59(input: MSZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def leU60(input: MSZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def leU61(input: MSZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def leU62(input: MSZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def leU63(input: MSZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def leU64(input: MSZ[B], context: Context): U64 = {\n        val r = conversions.U8.toU64(bleU8(input, context)) |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"56\")\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def leS64(input: MSZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(leU64(input, context))\n      }\n\n      def leF32(input: MSZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(leU32(input, context))\n      }\n\n      def leF64(input: MSZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(leU64(input, context))\n      }\n    }  }\n\n  object Writer {\n    val INSUFFICIENT_BUFFER_SIZE: Z = 1\n\n    def resultIS(output: ISZ[B], context: Context): ISZ[B] = {\n      return ops.ISZOps(output).slice(0, context.offset)\n    }\n\n    def resultMS(output: MSZ[B], context: Context): MSZ[B] = {\n      return ops.MSZOps(output).slice(0, context.offset)\n    }\n\n    def bleB(output: MSZ[B], context: Context, v: B): Unit = {\n      val offset = context.offset\n      if (offset + 1 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      output(offset) = v\n      context.offset = offset + 1\n    }\n\n    def beBS(output: MSZ[B], context: Context, v: MSZ[B]): Unit = {\n      bleRaw(output, context, v, v.size)\n    }\n\n    def leBS(output: MSZ[B], context: Context, v: MSZ[B]): Unit = {\n      bleRaw(output, context, v, v.size)\n    }\n\n    def bleRaw(output: MSZ[B], context: Context, v: MSZ[B], size: Z): Unit = {\n      val offset = context.offset\n      if (offset + size > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleB(output, context, v(i))\n      }\n    }\n\n    def bleU1(output: MSZ[B], context: Context, v: U1): Unit = {\n      val offset = context.offset\n      if (offset + 1 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      output(offset) = v == u1\"1\"\n      contex
  #752 = String             #751          // ut, context)))\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def leU44(input: MSZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def leU45(input: MSZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def leU46(input: MSZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def leU47(input: MSZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def leU48(input: MSZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def leU49(input: MSZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def leU50(input: MSZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def leU51(input: MSZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def leU52(input: MSZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def leU53(input: MSZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def leU54(input: MSZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def leU55(input: MSZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def leU56(input: MSZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def leU57(input: MSZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def leU58(input: MSZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def leU59(input: MSZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def leU60(input: MSZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def leU61(input: MSZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def leU62(input: MSZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def leU63(input: MSZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def leU64(input: MSZ[B], context: Context): U64 = {\n        val r = conversions.U8.toU64(bleU8(input, context)) |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"56\")\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def leS64(input: MSZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(leU64(input, context))\n      }\n\n      def leF32(input: MSZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(leU32(input, context))\n      }\n\n      def leF64(input: MSZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(leU64(input, context))\n      }\n    }  }\n\n  object Writer {\n    val INSUFFICIENT_BUFFER_SIZE: Z = 1\n\n    def resultIS(output: ISZ[B], context: Context): ISZ[B] = {\n      return ops.ISZOps(output).slice(0, context.offset)\n    }\n\n    def resultMS(output: MSZ[B], context: Context): MSZ[B] = {\n      return ops.MSZOps(output).slice(0, context.offset)\n    }\n\n    def bleB(output: MSZ[B], context: Context, v: B): Unit = {\n      val offset = context.offset\n      if (offset + 1 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      output(offset) = v\n      context.offset = offset + 1\n    }\n\n    def beBS(output: MSZ[B], context: Context, v: MSZ[B]): Unit = {\n      bleRaw(output, context, v, v.size)\n    }\n\n    def leBS(output: MSZ[B], context: Context, v: MSZ[B]): Unit = {\n      bleRaw(output, context, v, v.size)\n    }\n\n    def bleRaw(output: MSZ[B], context: Context, v: MSZ[B], size: Z): Unit = {\n      val offset = context.offset\n      if (offset + size > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleB(output, context, v(i))\n      }\n    }\n\n    def bleU1(output: MSZ[B], context: Context, v: U1): Unit = {\n      val offset = context.offset\n      if (offset + 1 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      output(offset) = v == u1\"1\"\n      contex
  #753 = Utf8               t.offset = offset + 1\n    }\n\n    def bleU2(output: MSZ[B], context: Context, v: U2): Unit = {\n      val offset = context.offset\n      if (offset + 2 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u2\"1\"\n      for (i <- 0 until 1) {\n        if ((v & mask) != u2\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u2\"1\"\n      }\n      if ((v & mask) != u2\"0\") {\n        output(offset + 1) = T\n      } else {\n        output(offset + 1) = F\n      }\n      context.offset = offset + 2\n    }\n\n    def bleU3(output: MSZ[B], context: Context, v: U3): Unit = {\n      val offset = context.offset\n      if (offset + 3 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u3\"1\"\n      for (i <- 0 until 2) {\n        if ((v & mask) != u3\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u3\"1\"\n      }\n      if ((v & mask) != u3\"0\") {\n        output(offset + 2) = T\n      } else {\n        output(offset + 2) = F\n      }\n      context.offset = offset + 3\n    }\n\n    def bleU4(output: MSZ[B], context: Context, v: U4): Unit = {\n      val offset = context.offset\n      if (offset + 4 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u4\"1\"\n      for (i <- 0 until 3) {\n        if ((v & mask) != u4\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u4\"1\"\n      }\n      if ((v & mask) != u4\"0\") {\n        output(offset + 3) = T\n      } else {\n        output(offset + 3) = F\n      }\n      context.offset = offset + 4\n    }\n\n    def bleU5(output: MSZ[B], context: Context, v: U5): Unit = {\n      val offset = context.offset\n      if (offset + 5 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u5\"1\"\n      for (i <- 0 until 4) {\n        if ((v & mask) != u5\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u5\"1\"\n      }\n      if ((v & mask) != u5\"0\") {\n        output(offset + 4) = T\n      } else {\n        output(offset + 4) = F\n      }\n      context.offset = offset + 5\n    }\n\n    def bleU6(output: MSZ[B], context: Context, v: U6): Unit = {\n      val offset = context.offset\n      if (offset + 6 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u6\"1\"\n      for (i <- 0 until 5) {\n        if ((v & mask) != u6\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u6\"1\"\n      }\n      if ((v & mask) != u6\"0\") {\n        output(offset + 5) = T\n      } else {\n        output(offset + 5) = F\n      }\n      context.offset = offset + 6\n    }\n\n    def bleU7(output: MSZ[B], context: Context, v: U7): Unit = {\n      val offset = context.offset\n      if (offset + 7 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u7\"1\"\n      for (i <- 0 until 6) {\n        if ((v & mask) != u7\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u7\"1\"\n      }\n      if ((v & mask) != u7\"0\") {\n        output(offset + 6) = T\n      } else {\n        output(offset + 6) = F\n      }\n      context.offset = offset + 7\n    }\n\n    def bleU8(output: MSZ[B], context: Context, v: U8): Unit = {\n      val offset = context.offset\n      if (offset + 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u8\"1\"\n      for (i <- 0 until 7) {\n        if ((v & mask) != u8\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u8\"1\"\n      }\n      if ((v & mask) != u8\"0\") {\n        output(offset + 7) = T\n      } else {\n        output(offset + 7) = F\n      }\n      context.offset = offset + 8\n    }\n\n    def bleS8(output: MSZ[B], context: Context, v: S8): Unit = {\n      bleU8(output, context, conversions.S8.toRawU8(v))\n    }\n\n    def beU8S(output: MSZ[B], context: Context, v: MSZ[U8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleU8(output, context, v(i))\n      }\n    }\n\n    def beS8S(output: MSZ[B], context: Context, v: MSZ[S8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleS8(output, context, v(i))\n      }\n    }\n\n    def beU16S(output: MSZ[B], context: Context, v: MSZ[U16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU16(output, context, v(i))\n      }\n    }\n\n    def beS16S(output: MSZ[B], context: Context, v: MSZ[S16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS16(output, context, v(i))\n      }\n    }\n\n    def beU32S(output: MSZ[B], context: Context, v: MSZ[U32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU32(output, context, v(i))\n      }\n    }\n\n    def beS32S(output: MSZ[B], context: Context, v: MSZ[S32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS32(output, context, v(i))\n      }\n    }\n\n    def beU64S(output: MSZ[B], context: Context, v: MSZ[U64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU64(output, context, v(i))\n      }\n    }\n\n    def beS64S(output: MSZ[B], context: Context, v: MSZ[S64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS64(output, context, v(i))\n      }\n    }\n\n    def beF32S(output: MSZ[B], context: Context, v: MSZ[F32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beF32(output, context, v(i))\n      }\n    }\n\n    def beF64S(output: MSZ[B], context: Context, v: MSZ[F64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beF64(output, context, v(i))\n      }\n    }\n\n    def leU8S(output: MSZ[B], context: Context, v: MSZ[U8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleU8(output, context, v(i))\n      }\n    }\n\n    def leS8S(output: MSZ[B], context: Context, v: MSZ[S8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleS8(output, context, v(i))\n      }\n    }\n\n    def leU16S(output: MSZ[B], context: Context, v: MSZ[U16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU16(output, context, v(i))\n      }\n    }\n\n    def leS16S(output: MSZ[B], context: Context, v: MSZ[S16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS16(output, context, v(i))\n      }\n    }\n\n    def leU32S(output: MSZ[B], context: Context, v: MSZ[U32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU32(output, context, v(i))\n      }\n    }\n\n    def leS32S(output: MSZ[B], context: Context, v: MSZ[S32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS32(output, context, v(i))\n      }\n    }\n\n    def leU64S(output: MSZ[B], context: Context, v: MSZ[U64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU64(output, context, v(i))\n      }\n    }\n\n    def leS64S(output: MSZ[B], context: Context, v: MSZ[S64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS64(output, context, v(i))\n      }\n    }\n\n    def leF32S(output: MSZ[B], context: Context, v: MSZ[F32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leF32(output, context, v(i))\n      }\n    }\n\n    def leF64S(output: MSZ[B], context: Context, v: MSZ[F64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leF64(output, context, v(i))\n      }\n    }\n\n    // Slang script gen:\n    /*\n    for (i <- 9 to 15) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 8}(output, context, conversions.U8.toU${i - 16}(conversions.U16.toU8(conversions.U$i.toU16(v >> u$i\"8\"))))\n            |  bleU8(output, context, conversions.U16.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 17 to 24) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 16}(output, context, conversions.U8.toU${i - 16}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"16\"))))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 25 to 31) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 24}(output, context, conversions.U8.toU${i - 24}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"24\"))))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 33 to 40) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 32}(output, context, conversions.U8.toU${i - 32}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"32\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 41 to 48) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 40}(output, context, conversions.U8.toU${i - 40}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"40\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 49 to 56) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 48}(output, context, conversions.U8.toU${i - 48}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"48\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 57 to 63) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 56}(output, context, conversions.U8.toU${i - 56}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"56\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"48\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n    */\n    def beU9(output: MSZ[B], context: Context, v: U9): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U16.toU8(conversions.U9.toU16(v >> u9\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U9.toU16(v & u9\"0xFF\")))\n    }\n\n    def beU10(output: MSZ[B], context: Context, v: U10): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U16.toU8(conversions.U10.toU16(v >> u10\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U10.toU16(v & u10\"0xFF\")))\n    }\n\n    def beU11(output: MSZ[B], context: Context, v: U11): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U16.toU8(conversions.U11.toU16(v >> u11\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U11.toU16(v & u11\"0xFF\")))\n    }\n\n    def beU12(output: MSZ[B], context: Context, v: U12): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U16.toU8(conversions.U12.toU16(v >> u12\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U12.toU16(v & u12\"0xFF\")))\n    }\n\n    def beU13(output: MSZ[B], context: Context, v: U13): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U16.toU8(conversions.U13.toU16(v >> u13\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U13.toU16(v & u13\"0xFF\")))\n    }\n\n    def beU14(output: MSZ[B], context: Context, v: U14): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U16.toU8(conversions.U14.toU16(v >> u14\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U14.toU16(v & u14\"0xFF\")))\n    }\n\n    def beU15(output: MSZ[B], context: Context, v: U15): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U16.toU8(conversions.U15.toU16(v >> u15\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U15.toU16(v & u15\"0xFF\")))\n    }\n\n    def beU16(output: MSZ[B], context: Context, v: U16): Unit = {\n      bleU8(output, context, conversions.U16.toU8(v >> u16\"8\"))\n      bleU8(output, context, conversions.U16.toU8(v & u16\"0xFF\"))\n    }\n\n    def beS16(output: MSZ[B], context: Context, v: S16): Unit = {\n      beU16(output, context, conversions.S16.toRawU16(v))\n    }\n\n    def beU17(output: MSZ[B], context: Context, v: U17): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U17.toU32(v >> u17\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32((v >> u17\"8\") & u17\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32(v & u17\"0xFF\")))\n    }\n\n    def beU18(output: MSZ[B], context: Context, v: U18): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U18.toU32(v >> u18\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU
  #754 = String             #753          // t.offset = offset + 1\n    }\n\n    def bleU2(output: MSZ[B], context: Context, v: U2): Unit = {\n      val offset = context.offset\n      if (offset + 2 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u2\"1\"\n      for (i <- 0 until 1) {\n        if ((v & mask) != u2\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u2\"1\"\n      }\n      if ((v & mask) != u2\"0\") {\n        output(offset + 1) = T\n      } else {\n        output(offset + 1) = F\n      }\n      context.offset = offset + 2\n    }\n\n    def bleU3(output: MSZ[B], context: Context, v: U3): Unit = {\n      val offset = context.offset\n      if (offset + 3 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u3\"1\"\n      for (i <- 0 until 2) {\n        if ((v & mask) != u3\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u3\"1\"\n      }\n      if ((v & mask) != u3\"0\") {\n        output(offset + 2) = T\n      } else {\n        output(offset + 2) = F\n      }\n      context.offset = offset + 3\n    }\n\n    def bleU4(output: MSZ[B], context: Context, v: U4): Unit = {\n      val offset = context.offset\n      if (offset + 4 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u4\"1\"\n      for (i <- 0 until 3) {\n        if ((v & mask) != u4\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u4\"1\"\n      }\n      if ((v & mask) != u4\"0\") {\n        output(offset + 3) = T\n      } else {\n        output(offset + 3) = F\n      }\n      context.offset = offset + 4\n    }\n\n    def bleU5(output: MSZ[B], context: Context, v: U5): Unit = {\n      val offset = context.offset\n      if (offset + 5 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u5\"1\"\n      for (i <- 0 until 4) {\n        if ((v & mask) != u5\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u5\"1\"\n      }\n      if ((v & mask) != u5\"0\") {\n        output(offset + 4) = T\n      } else {\n        output(offset + 4) = F\n      }\n      context.offset = offset + 5\n    }\n\n    def bleU6(output: MSZ[B], context: Context, v: U6): Unit = {\n      val offset = context.offset\n      if (offset + 6 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u6\"1\"\n      for (i <- 0 until 5) {\n        if ((v & mask) != u6\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u6\"1\"\n      }\n      if ((v & mask) != u6\"0\") {\n        output(offset + 5) = T\n      } else {\n        output(offset + 5) = F\n      }\n      context.offset = offset + 6\n    }\n\n    def bleU7(output: MSZ[B], context: Context, v: U7): Unit = {\n      val offset = context.offset\n      if (offset + 7 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u7\"1\"\n      for (i <- 0 until 6) {\n        if ((v & mask) != u7\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u7\"1\"\n      }\n      if ((v & mask) != u7\"0\") {\n        output(offset + 6) = T\n      } else {\n        output(offset + 6) = F\n      }\n      context.offset = offset + 7\n    }\n\n    def bleU8(output: MSZ[B], context: Context, v: U8): Unit = {\n      val offset = context.offset\n      if (offset + 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u8\"1\"\n      for (i <- 0 until 7) {\n        if ((v & mask) != u8\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u8\"1\"\n      }\n      if ((v & mask) != u8\"0\") {\n        output(offset + 7) = T\n      } else {\n        output(offset + 7) = F\n      }\n      context.offset = offset + 8\n    }\n\n    def bleS8(output: MSZ[B], context: Context, v: S8): Unit = {\n      bleU8(output, context, conversions.S8.toRawU8(v))\n    }\n\n    def beU8S(output: MSZ[B], context: Context, v: MSZ[U8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleU8(output, context, v(i))\n      }\n    }\n\n    def beS8S(output: MSZ[B], context: Context, v: MSZ[S8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleS8(output, context, v(i))\n      }\n    }\n\n    def beU16S(output: MSZ[B], context: Context, v: MSZ[U16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU16(output, context, v(i))\n      }\n    }\n\n    def beS16S(output: MSZ[B], context: Context, v: MSZ[S16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS16(output, context, v(i))\n      }\n    }\n\n    def beU32S(output: MSZ[B], context: Context, v: MSZ[U32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU32(output, context, v(i))\n      }\n    }\n\n    def beS32S(output: MSZ[B], context: Context, v: MSZ[S32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS32(output, context, v(i))\n      }\n    }\n\n    def beU64S(output: MSZ[B], context: Context, v: MSZ[U64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU64(output, context, v(i))\n      }\n    }\n\n    def beS64S(output: MSZ[B], context: Context, v: MSZ[S64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS64(output, context, v(i))\n      }\n    }\n\n    def beF32S(output: MSZ[B], context: Context, v: MSZ[F32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beF32(output, context, v(i))\n      }\n    }\n\n    def beF64S(output: MSZ[B], context: Context, v: MSZ[F64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beF64(output, context, v(i))\n      }\n    }\n\n    def leU8S(output: MSZ[B], context: Context, v: MSZ[U8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleU8(output, context, v(i))\n      }\n    }\n\n    def leS8S(output: MSZ[B], context: Context, v: MSZ[S8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleS8(output, context, v(i))\n      }\n    }\n\n    def leU16S(output: MSZ[B], context: Context, v: MSZ[U16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU16(output, context, v(i))\n      }\n    }\n\n    def leS16S(output: MSZ[B], context: Context, v: MSZ[S16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS16(output, context, v(i))\n      }\n    }\n\n    def leU32S(output: MSZ[B], context: Context, v: MSZ[U32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU32(output, context, v(i))\n      }\n    }\n\n    def leS32S(output: MSZ[B], context: Context, v: MSZ[S32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS32(output, context, v(i))\n      }\n    }\n\n    def leU64S(output: MSZ[B], context: Context, v: MSZ[U64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU64(output, context, v(i))\n      }\n    }\n\n    def leS64S(output: MSZ[B], context: Context, v: MSZ[S64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS64(output, context, v(i))\n      }\n    }\n\n    def leF32S(output: MSZ[B], context: Context, v: MSZ[F32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leF32(output, context, v(i))\n      }\n    }\n\n    def leF64S(output: MSZ[B], context: Context, v: MSZ[F64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leF64(output, context, v(i))\n      }\n    }\n\n    // Slang script gen:\n    /*\n    for (i <- 9 to 15) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 8}(output, context, conversions.U8.toU${i - 16}(conversions.U16.toU8(conversions.U$i.toU16(v >> u$i\"8\"))))\n            |  bleU8(output, context, conversions.U16.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 17 to 24) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 16}(output, context, conversions.U8.toU${i - 16}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"16\"))))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 25 to 31) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 24}(output, context, conversions.U8.toU${i - 24}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"24\"))))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 33 to 40) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 32}(output, context, conversions.U8.toU${i - 32}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"32\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 41 to 48) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 40}(output, context, conversions.U8.toU${i - 40}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"40\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 49 to 56) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 48}(output, context, conversions.U8.toU${i - 48}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"48\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 57 to 63) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 56}(output, context, conversions.U8.toU${i - 56}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"56\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"48\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n    */\n    def beU9(output: MSZ[B], context: Context, v: U9): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U16.toU8(conversions.U9.toU16(v >> u9\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U9.toU16(v & u9\"0xFF\")))\n    }\n\n    def beU10(output: MSZ[B], context: Context, v: U10): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U16.toU8(conversions.U10.toU16(v >> u10\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U10.toU16(v & u10\"0xFF\")))\n    }\n\n    def beU11(output: MSZ[B], context: Context, v: U11): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U16.toU8(conversions.U11.toU16(v >> u11\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U11.toU16(v & u11\"0xFF\")))\n    }\n\n    def beU12(output: MSZ[B], context: Context, v: U12): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U16.toU8(conversions.U12.toU16(v >> u12\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U12.toU16(v & u12\"0xFF\")))\n    }\n\n    def beU13(output: MSZ[B], context: Context, v: U13): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U16.toU8(conversions.U13.toU16(v >> u13\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U13.toU16(v & u13\"0xFF\")))\n    }\n\n    def beU14(output: MSZ[B], context: Context, v: U14): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U16.toU8(conversions.U14.toU16(v >> u14\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U14.toU16(v & u14\"0xFF\")))\n    }\n\n    def beU15(output: MSZ[B], context: Context, v: U15): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U16.toU8(conversions.U15.toU16(v >> u15\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U15.toU16(v & u15\"0xFF\")))\n    }\n\n    def beU16(output: MSZ[B], context: Context, v: U16): Unit = {\n      bleU8(output, context, conversions.U16.toU8(v >> u16\"8\"))\n      bleU8(output, context, conversions.U16.toU8(v & u16\"0xFF\"))\n    }\n\n    def beS16(output: MSZ[B], context: Context, v: S16): Unit = {\n      beU16(output, context, conversions.S16.toRawU16(v))\n    }\n\n    def beU17(output: MSZ[B], context: Context, v: U17): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U17.toU32(v >> u17\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32((v >> u17\"8\") & u17\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32(v & u17\"0xFF\")))\n    }\n\n    def beU18(output: MSZ[B], context: Context, v: U18): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U18.toU32(v >> u18\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU
  #755 = Utf8               32((v >> u18\"8\") & u18\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32(v & u18\"0xFF\")))\n    }\n\n    def beU19(output: MSZ[B], context: Context, v: U19): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U19.toU32(v >> u19\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32((v >> u19\"8\") & u19\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32(v & u19\"0xFF\")))\n    }\n\n    def beU20(output: MSZ[B], context: Context, v: U20): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U20.toU32(v >> u20\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32((v >> u20\"8\") & u20\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32(v & u20\"0xFF\")))\n    }\n\n    def beU21(output: MSZ[B], context: Context, v: U21): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U21.toU32(v >> u21\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32((v >> u21\"8\") & u21\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32(v & u21\"0xFF\")))\n    }\n\n    def beU22(output: MSZ[B], context: Context, v: U22): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U22.toU32(v >> u22\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32((v >> u22\"8\") & u22\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32(v & u22\"0xFF\")))\n    }\n\n    def beU23(output: MSZ[B], context: Context, v: U23): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U23.toU32(v >> u23\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32((v >> u23\"8\") & u23\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32(v & u23\"0xFF\")))\n    }\n\n    def beU24(output: MSZ[B], context: Context, v: U24): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v >> u24\"16\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32((v >> u24\"8\") & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v & u24\"0xFF\")))\n    }\n\n    def beU25(output: MSZ[B], context: Context, v: U25): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U25.toU32(v >> u25\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"16\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"8\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32(v & u25\"0xFF\")))\n    }\n\n    def beU26(output: MSZ[B], context: Context, v: U26): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U26.toU32(v >> u26\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"16\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"8\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32(v & u26\"0xFF\")))\n    }\n\n    def beU27(output: MSZ[B], context: Context, v: U27): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U27.toU32(v >> u27\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"16\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"8\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32(v & u27\"0xFF\")))\n    }\n\n    def beU28(output: MSZ[B], context: Context, v: U28): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U28.toU32(v >> u28\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"16\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"8\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32(v & u28\"0xFF\")))\n    }\n\n    def beU29(output: MSZ[B], context: Context, v: U29): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U29.toU32(v >> u29\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"16\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"8\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32(v & u29\"0xFF\")))\n    }\n\n    def beU30(output: MSZ[B], context: Context, v: U30): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U30.toU32(v >> u30\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"16\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"8\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32(v & u30\"0xFF\")))\n    }\n\n    def beU31(output: MSZ[B], context: Context, v: U31): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U31.toU32(v >> u31\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"16\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"8\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32(v & u31\"0xFF\")))\n    }\n\n    def beU32(output: MSZ[B], context: Context, v: U32): Unit = {\n      bleU8(output, context, conversions.U32.toU8(v >> u32\"24\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"16\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"8\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8(v & u32\"0xFF\"))\n    }\n\n    def beS32(output: MSZ[B], context: Context, v: S32): Unit = {\n      beU32(output, context, conversions.S32.toRawU32(v))\n    }\n\n    def beU33(output: MSZ[B], context: Context, v: U33): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U33.toU64(v >> u33\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"24\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"16\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"8\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64(v & u33\"0xFF\")))\n    }\n\n    def beU34(output: MSZ[B], context: Context, v: U34): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U34.toU64(v >> u34\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"24\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"16\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"8\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64(v & u34\"0xFF\")))\n    }\n\n    def beU35(output: MSZ[B], context: Context, v: U35): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U35.toU64(v >> u35\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"24\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"16\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"8\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64(v & u35\"0xFF\")))\n    }\n\n    def beU36(output: MSZ[B], context: Context, v: U36): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U36.toU64(v >> u36\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"24\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"16\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"8\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64(v & u36\"0xFF\")))\n    }\n\n    def beU37(output: MSZ[B], context: Context, v: U37): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U37.toU64(v >> u37\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"24\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"16\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"8\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64(v & u37\"0xFF\")))\n    }\n\n    def beU38(output: MSZ[B], context: Context, v: U38): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U38.toU64(v >> u38\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"24\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"16\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"8\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64(v & u38\"0xFF\")))\n    }\n\n    def beU39(output: MSZ[B], context: Context, v: U39): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U39.toU64(v >> u39\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"24\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"16\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"8\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64(v & u39\"0xFF\")))\n    }\n\n    def beU40(output: MSZ[B], context: Context, v: U40): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v >> u40\"32\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"24\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"16\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"8\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v & u40\"0xFF\")))\n    }\n\n    def beU41(output: MSZ[B], context: Context, v: U41): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U41.toU64(v >> u41\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"32\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"24\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"16\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"8\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64(v & u41\"0xFF\")))\n    }\n\n    def beU42(output: MSZ[B], context: Context, v: U42): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U42.toU64(v >> u42\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"32\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"24\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"16\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"8\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64(v & u42\"0xFF\")))\n    }\n\n    def beU43(output: MSZ[B], context: Context, v: U43): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U43.toU64(v >> u43\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"32\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"24\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"16\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"8\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64(v & u43\"0xFF\")))\n    }\n\n    def beU44(output: MSZ[B], context: Context, v: U44): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U44.toU64(v >> u44\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"32\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"24\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"16\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"8\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64(v & u44\"0xFF\")))\n    }\n\n    def beU45(output: MSZ[B], context: Context, v: U45): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U45.toU64(v >> u45\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"32\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"24\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"16\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"8\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64(v & u45\"0xFF\")))\n    }\n\n    def beU46(output: MSZ[B], context: Context, v: U46): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U46.toU64(v >> u46\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"32\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"24\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"16\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"8\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64(v & u46\"0xFF\")))\n    }\n\n    def beU47(output: MSZ[B], context: Context, v: U47): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U47.toU64(v >> u47\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"32\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"24\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"16\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"8\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64(v & u47\"0xFF\")))\n    }\n\n    def beU48(output: MSZ[B], context: Context, v: U48): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v >> u48\"40\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"32\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"24\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"16\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"8\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v & u48\"0xFF\")))\n    }\n\n    def beU49(output: MSZ[B], context: Context, v: U49): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U49.toU64(v >> u49\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"40\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"32\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"24\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"16\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"8\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64(v & u49\"0xFF\")))\n    }\n\n    def beU50(output: MSZ[B], context: Context, v: U50): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U50.toU64(v >> u50\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"40\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"32\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"24\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"16\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"8\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64(v & u50\"0xFF\")))\n    }\n\n    def beU51(output: MSZ[B], context: Context, v: U51): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U51.toU64(v >> u51\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"40\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"32\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"24\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"16\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"8\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64(v & u51\"0xFF\")))\n    }\n\n    def beU52(output: MSZ[B], context: Context, v: U52): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U52.toU64(v >> u52\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"40\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"32\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"24\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"16\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"8\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64(v & u52\"0xFF\")))\n    }\n\n    def beU53(output: MSZ[B], context: Context, v: U53): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U53.toU64(v >> u53\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"40\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"32\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"24\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"16\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"8\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(convers
  #756 = String             #755          // 32((v >> u18\"8\") & u18\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32(v & u18\"0xFF\")))\n    }\n\n    def beU19(output: MSZ[B], context: Context, v: U19): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U19.toU32(v >> u19\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32((v >> u19\"8\") & u19\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32(v & u19\"0xFF\")))\n    }\n\n    def beU20(output: MSZ[B], context: Context, v: U20): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U20.toU32(v >> u20\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32((v >> u20\"8\") & u20\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32(v & u20\"0xFF\")))\n    }\n\n    def beU21(output: MSZ[B], context: Context, v: U21): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U21.toU32(v >> u21\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32((v >> u21\"8\") & u21\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32(v & u21\"0xFF\")))\n    }\n\n    def beU22(output: MSZ[B], context: Context, v: U22): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U22.toU32(v >> u22\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32((v >> u22\"8\") & u22\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32(v & u22\"0xFF\")))\n    }\n\n    def beU23(output: MSZ[B], context: Context, v: U23): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U23.toU32(v >> u23\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32((v >> u23\"8\") & u23\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32(v & u23\"0xFF\")))\n    }\n\n    def beU24(output: MSZ[B], context: Context, v: U24): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v >> u24\"16\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32((v >> u24\"8\") & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v & u24\"0xFF\")))\n    }\n\n    def beU25(output: MSZ[B], context: Context, v: U25): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U25.toU32(v >> u25\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"16\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"8\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32(v & u25\"0xFF\")))\n    }\n\n    def beU26(output: MSZ[B], context: Context, v: U26): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U26.toU32(v >> u26\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"16\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"8\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32(v & u26\"0xFF\")))\n    }\n\n    def beU27(output: MSZ[B], context: Context, v: U27): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U27.toU32(v >> u27\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"16\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"8\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32(v & u27\"0xFF\")))\n    }\n\n    def beU28(output: MSZ[B], context: Context, v: U28): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U28.toU32(v >> u28\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"16\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"8\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32(v & u28\"0xFF\")))\n    }\n\n    def beU29(output: MSZ[B], context: Context, v: U29): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U29.toU32(v >> u29\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"16\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"8\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32(v & u29\"0xFF\")))\n    }\n\n    def beU30(output: MSZ[B], context: Context, v: U30): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U30.toU32(v >> u30\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"16\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"8\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32(v & u30\"0xFF\")))\n    }\n\n    def beU31(output: MSZ[B], context: Context, v: U31): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U31.toU32(v >> u31\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"16\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"8\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32(v & u31\"0xFF\")))\n    }\n\n    def beU32(output: MSZ[B], context: Context, v: U32): Unit = {\n      bleU8(output, context, conversions.U32.toU8(v >> u32\"24\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"16\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"8\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8(v & u32\"0xFF\"))\n    }\n\n    def beS32(output: MSZ[B], context: Context, v: S32): Unit = {\n      beU32(output, context, conversions.S32.toRawU32(v))\n    }\n\n    def beU33(output: MSZ[B], context: Context, v: U33): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U33.toU64(v >> u33\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"24\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"16\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"8\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64(v & u33\"0xFF\")))\n    }\n\n    def beU34(output: MSZ[B], context: Context, v: U34): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U34.toU64(v >> u34\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"24\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"16\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"8\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64(v & u34\"0xFF\")))\n    }\n\n    def beU35(output: MSZ[B], context: Context, v: U35): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U35.toU64(v >> u35\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"24\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"16\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"8\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64(v & u35\"0xFF\")))\n    }\n\n    def beU36(output: MSZ[B], context: Context, v: U36): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U36.toU64(v >> u36\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"24\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"16\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"8\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64(v & u36\"0xFF\")))\n    }\n\n    def beU37(output: MSZ[B], context: Context, v: U37): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U37.toU64(v >> u37\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"24\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"16\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"8\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64(v & u37\"0xFF\")))\n    }\n\n    def beU38(output: MSZ[B], context: Context, v: U38): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U38.toU64(v >> u38\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"24\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"16\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"8\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64(v & u38\"0xFF\")))\n    }\n\n    def beU39(output: MSZ[B], context: Context, v: U39): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U39.toU64(v >> u39\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"24\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"16\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"8\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64(v & u39\"0xFF\")))\n    }\n\n    def beU40(output: MSZ[B], context: Context, v: U40): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v >> u40\"32\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"24\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"16\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"8\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v & u40\"0xFF\")))\n    }\n\n    def beU41(output: MSZ[B], context: Context, v: U41): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U41.toU64(v >> u41\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"32\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"24\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"16\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"8\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64(v & u41\"0xFF\")))\n    }\n\n    def beU42(output: MSZ[B], context: Context, v: U42): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U42.toU64(v >> u42\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"32\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"24\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"16\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"8\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64(v & u42\"0xFF\")))\n    }\n\n    def beU43(output: MSZ[B], context: Context, v: U43): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U43.toU64(v >> u43\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"32\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"24\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"16\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"8\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64(v & u43\"0xFF\")))\n    }\n\n    def beU44(output: MSZ[B], context: Context, v: U44): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U44.toU64(v >> u44\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"32\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"24\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"16\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"8\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64(v & u44\"0xFF\")))\n    }\n\n    def beU45(output: MSZ[B], context: Context, v: U45): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U45.toU64(v >> u45\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"32\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"24\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"16\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"8\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64(v & u45\"0xFF\")))\n    }\n\n    def beU46(output: MSZ[B], context: Context, v: U46): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U46.toU64(v >> u46\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"32\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"24\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"16\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"8\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64(v & u46\"0xFF\")))\n    }\n\n    def beU47(output: MSZ[B], context: Context, v: U47): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U47.toU64(v >> u47\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"32\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"24\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"16\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"8\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64(v & u47\"0xFF\")))\n    }\n\n    def beU48(output: MSZ[B], context: Context, v: U48): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v >> u48\"40\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"32\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"24\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"16\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"8\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v & u48\"0xFF\")))\n    }\n\n    def beU49(output: MSZ[B], context: Context, v: U49): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U49.toU64(v >> u49\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"40\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"32\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"24\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"16\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"8\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64(v & u49\"0xFF\")))\n    }\n\n    def beU50(output: MSZ[B], context: Context, v: U50): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U50.toU64(v >> u50\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"40\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"32\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"24\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"16\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"8\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64(v & u50\"0xFF\")))\n    }\n\n    def beU51(output: MSZ[B], context: Context, v: U51): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U51.toU64(v >> u51\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"40\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"32\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"24\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"16\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"8\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64(v & u51\"0xFF\")))\n    }\n\n    def beU52(output: MSZ[B], context: Context, v: U52): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U52.toU64(v >> u52\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"40\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"32\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"24\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"16\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"8\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64(v & u52\"0xFF\")))\n    }\n\n    def beU53(output: MSZ[B], context: Context, v: U53): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U53.toU64(v >> u53\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"40\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"32\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"24\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"16\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"8\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(convers
  #757 = Utf8               ions.U53.toU64(v & u53\"0xFF\")))\n    }\n\n    def beU54(output: MSZ[B], context: Context, v: U54): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U54.toU64(v >> u54\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"40\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"32\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"24\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"16\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"8\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64(v & u54\"0xFF\")))\n    }\n\n    def beU55(output: MSZ[B], context: Context, v: U55): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U55.toU64(v >> u55\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"40\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"32\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"24\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"16\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"8\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64(v & u55\"0xFF\")))\n    }\n\n    def beU56(output: MSZ[B], context: Context, v: U56): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v >> u56\"48\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"40\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"32\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"24\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"16\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"8\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v & u56\"0xFF\")))\n    }\n\n    def beU57(output: MSZ[B], context: Context, v: U57): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U57.toU64(v >> u57\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"48\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"40\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"32\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"24\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"16\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"8\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64(v & u57\"0xFF\")))\n    }\n\n    def beU58(output: MSZ[B], context: Context, v: U58): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U58.toU64(v >> u58\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"48\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"40\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"32\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"24\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"16\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"8\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64(v & u58\"0xFF\")))\n    }\n\n    def beU59(output: MSZ[B], context: Context, v: U59): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U59.toU64(v >> u59\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"48\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"40\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"32\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"24\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"16\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"8\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64(v & u59\"0xFF\")))\n    }\n\n    def beU60(output: MSZ[B], context: Context, v: U60): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U60.toU64(v >> u60\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"48\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"40\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"32\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"24\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"16\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"8\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64(v & u60\"0xFF\")))\n    }\n\n    def beU61(output: MSZ[B], context: Context, v: U61): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U61.toU64(v >> u61\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"48\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"40\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"32\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"24\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"16\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"8\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64(v & u61\"0xFF\")))\n    }\n\n    def beU62(output: MSZ[B], context: Context, v: U62): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U62.toU64(v >> u62\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"48\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"40\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"32\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"24\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"16\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"8\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64(v & u62\"0xFF\")))\n    }\n\n    def beU63(output: MSZ[B], context: Context, v: U63): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U63.toU64(v >> u63\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"48\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"40\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"32\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"24\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"16\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"8\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64(v & u63\"0xFF\")))\n    }\n\n    def beU64(output: MSZ[B], context: Context, v: U64): Unit = {\n      bleU8(output, context, conversions.U64.toU8(v >> u64\"56\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"48\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"40\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"32\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"24\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"16\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"8\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8(v & u64\"0xFF\"))\n    }\n\n    def beS64(output: MSZ[B], context: Context, v: S64): Unit = {\n      beU64(output, context, conversions.S64.toRawU64(v))\n    }\n\n    def beF32(output: MSZ[B], context: Context, v: F32): Unit = {\n      beU32(output, context, conversions.F32.toRawU32(v))\n    }\n\n    def beF64(output: MSZ[B], context: Context, v: F64): Unit = {\n      beU64(output, context, conversions.F64.toRawU64(v))\n    }\n\n    // Slang script gen:\n    /*\n    for (i <- 9 to 15) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U16.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU${i - 8}(output, context, conversions.U8.toU${i - 16}(conversions.U16.toU8(conversions.U$i.toU16(v >> u$i\"8\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 17 to 24) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU${i - 16}(output, context, conversions.U8.toU${i - 16}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"16\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 25 to 31) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU${i - 24}(output, context, conversions.U8.toU${i - 24}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"24\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 33 to 40) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU${i - 32}(output, context, conversions.U8.toU${i - 32}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"32\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 41 to 48) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU${i - 40}(output, context, conversions.U8.toU${i - 40}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"40\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 49 to 56) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU${i - 48}(output, context, conversions.U8.toU${i - 48}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"48\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 57 to 63) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"48\") & u$i\"0xFF\")))\n            |  bleU${i - 56}(output, context, conversions.U8.toU${i - 56}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"56\"))))\n            |}\n            |\"\"\".render)\n    }\n     */\n    def leU9(output: MSZ[B], context: Context, v: U9): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U9.toU16(v & u9\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U16.toU8(conversions.U9.toU16(v >> u9\"8\"))))\n    }\n\n    def leU10(output: MSZ[B], context: Context, v: U10): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U10.toU16(v & u10\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U16.toU8(conversions.U10.toU16(v >> u10\"8\"))))\n    }\n\n    def leU11(output: MSZ[B], context: Context, v: U11): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U11.toU16(v & u11\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U16.toU8(conversions.U11.toU16(v >> u11\"8\"))))\n    }\n\n    def leU12(output: MSZ[B], context: Context, v: U12): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U12.toU16(v & u12\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U16.toU8(conversions.U12.toU16(v >> u12\"8\"))))\n    }\n\n    def leU13(output: MSZ[B], context: Context, v: U13): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U13.toU16(v & u13\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U16.toU8(conversions.U13.toU16(v >> u13\"8\"))))\n    }\n\n    def leU14(output: MSZ[B], context: Context, v: U14): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U14.toU16(v & u14\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U16.toU8(conversions.U14.toU16(v >> u14\"8\"))))\n    }\n\n    def leU15(output: MSZ[B], context: Context, v: U15): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U15.toU16(v & u15\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U16.toU8(conversions.U15.toU16(v >> u15\"8\"))))\n    }\n\n    def leU16(output: MSZ[B], context: Context, v: U16): Unit = {\n      bleU8(output, context, conversions.U16.toU8(v & u16\"0xFF\"))\n      bleU8(output, context, conversions.U16.toU8(v >> u16\"8\"))\n    }\n\n    def leS16(output: MSZ[B], context: Context, v: S16): Unit = {\n      leU16(output, context, conversions.S16.toRawU16(v))\n    }\n\n    def leU17(output: MSZ[B], context: Context, v: U17): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32(v & u17\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32((v >> u17\"8\") & u17\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U17.toU32(v >> u17\"16\"))))\n    }\n\n    def leU18(output: MSZ[B], context: Context, v: U18): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32(v & u18\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32((v >> u18\"8\") & u18\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U18.toU32(v >> u18\"16\"))))\n    }\n\n    def leU19(output: MSZ[B], context: Context, v: U19): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32(v & u19\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32((v >> u19\"8\") & u19\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U19.toU32(v >> u19\"16\"))))\n    }\n\n    def leU20(output: MSZ[B], context: Context, v: U20): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32(v & u20\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32((v >> u20\"8\") & u20\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U20.toU32(v >> u20\"16\"))))\n    }\n\n    def leU21(output: MSZ[B], context: Context, v: U21): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32(v & u21\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32((v >> u21\"8\") & u21\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U21.toU32(v >> u21\"16\"))))\n    }\n\n    def leU22(output: MSZ[B], context: Context, v: U22): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32(v & u22\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32((v >> u22\"8\") & u22\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U22.toU32(v >> u22\"16\"))))\n    }\n\n    def leU23(output: MSZ[B], context: Context, v: U23): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32(v & u23\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32((v >> u23\"8\") & u23\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U23.toU32(v >> u23\"16\"))))\n    }\n\n    def leU24(output: MSZ[B], context: Context, v: U24): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32((v >> u24\"8\") & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v >> u24\"16\")))\n    }\n\n    def leU25(output: MSZ[B], context: Context, v: U25): Unit = {\n      bleU8(output, context, conv
  #758 = String             #757          // ions.U53.toU64(v & u53\"0xFF\")))\n    }\n\n    def beU54(output: MSZ[B], context: Context, v: U54): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U54.toU64(v >> u54\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"40\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"32\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"24\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"16\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"8\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64(v & u54\"0xFF\")))\n    }\n\n    def beU55(output: MSZ[B], context: Context, v: U55): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U55.toU64(v >> u55\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"40\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"32\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"24\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"16\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"8\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64(v & u55\"0xFF\")))\n    }\n\n    def beU56(output: MSZ[B], context: Context, v: U56): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v >> u56\"48\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"40\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"32\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"24\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"16\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"8\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v & u56\"0xFF\")))\n    }\n\n    def beU57(output: MSZ[B], context: Context, v: U57): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U57.toU64(v >> u57\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"48\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"40\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"32\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"24\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"16\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"8\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64(v & u57\"0xFF\")))\n    }\n\n    def beU58(output: MSZ[B], context: Context, v: U58): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U58.toU64(v >> u58\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"48\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"40\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"32\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"24\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"16\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"8\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64(v & u58\"0xFF\")))\n    }\n\n    def beU59(output: MSZ[B], context: Context, v: U59): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U59.toU64(v >> u59\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"48\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"40\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"32\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"24\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"16\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"8\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64(v & u59\"0xFF\")))\n    }\n\n    def beU60(output: MSZ[B], context: Context, v: U60): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U60.toU64(v >> u60\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"48\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"40\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"32\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"24\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"16\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"8\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64(v & u60\"0xFF\")))\n    }\n\n    def beU61(output: MSZ[B], context: Context, v: U61): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U61.toU64(v >> u61\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"48\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"40\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"32\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"24\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"16\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"8\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64(v & u61\"0xFF\")))\n    }\n\n    def beU62(output: MSZ[B], context: Context, v: U62): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U62.toU64(v >> u62\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"48\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"40\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"32\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"24\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"16\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"8\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64(v & u62\"0xFF\")))\n    }\n\n    def beU63(output: MSZ[B], context: Context, v: U63): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U63.toU64(v >> u63\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"48\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"40\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"32\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"24\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"16\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"8\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64(v & u63\"0xFF\")))\n    }\n\n    def beU64(output: MSZ[B], context: Context, v: U64): Unit = {\n      bleU8(output, context, conversions.U64.toU8(v >> u64\"56\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"48\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"40\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"32\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"24\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"16\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"8\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8(v & u64\"0xFF\"))\n    }\n\n    def beS64(output: MSZ[B], context: Context, v: S64): Unit = {\n      beU64(output, context, conversions.S64.toRawU64(v))\n    }\n\n    def beF32(output: MSZ[B], context: Context, v: F32): Unit = {\n      beU32(output, context, conversions.F32.toRawU32(v))\n    }\n\n    def beF64(output: MSZ[B], context: Context, v: F64): Unit = {\n      beU64(output, context, conversions.F64.toRawU64(v))\n    }\n\n    // Slang script gen:\n    /*\n    for (i <- 9 to 15) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U16.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU${i - 8}(output, context, conversions.U8.toU${i - 16}(conversions.U16.toU8(conversions.U$i.toU16(v >> u$i\"8\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 17 to 24) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU${i - 16}(output, context, conversions.U8.toU${i - 16}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"16\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 25 to 31) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU${i - 24}(output, context, conversions.U8.toU${i - 24}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"24\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 33 to 40) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU${i - 32}(output, context, conversions.U8.toU${i - 32}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"32\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 41 to 48) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU${i - 40}(output, context, conversions.U8.toU${i - 40}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"40\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 49 to 56) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU${i - 48}(output, context, conversions.U8.toU${i - 48}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"48\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 57 to 63) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"48\") & u$i\"0xFF\")))\n            |  bleU${i - 56}(output, context, conversions.U8.toU${i - 56}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"56\"))))\n            |}\n            |\"\"\".render)\n    }\n     */\n    def leU9(output: MSZ[B], context: Context, v: U9): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U9.toU16(v & u9\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U16.toU8(conversions.U9.toU16(v >> u9\"8\"))))\n    }\n\n    def leU10(output: MSZ[B], context: Context, v: U10): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U10.toU16(v & u10\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U16.toU8(conversions.U10.toU16(v >> u10\"8\"))))\n    }\n\n    def leU11(output: MSZ[B], context: Context, v: U11): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U11.toU16(v & u11\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U16.toU8(conversions.U11.toU16(v >> u11\"8\"))))\n    }\n\n    def leU12(output: MSZ[B], context: Context, v: U12): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U12.toU16(v & u12\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U16.toU8(conversions.U12.toU16(v >> u12\"8\"))))\n    }\n\n    def leU13(output: MSZ[B], context: Context, v: U13): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U13.toU16(v & u13\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U16.toU8(conversions.U13.toU16(v >> u13\"8\"))))\n    }\n\n    def leU14(output: MSZ[B], context: Context, v: U14): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U14.toU16(v & u14\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U16.toU8(conversions.U14.toU16(v >> u14\"8\"))))\n    }\n\n    def leU15(output: MSZ[B], context: Context, v: U15): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U15.toU16(v & u15\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U16.toU8(conversions.U15.toU16(v >> u15\"8\"))))\n    }\n\n    def leU16(output: MSZ[B], context: Context, v: U16): Unit = {\n      bleU8(output, context, conversions.U16.toU8(v & u16\"0xFF\"))\n      bleU8(output, context, conversions.U16.toU8(v >> u16\"8\"))\n    }\n\n    def leS16(output: MSZ[B], context: Context, v: S16): Unit = {\n      leU16(output, context, conversions.S16.toRawU16(v))\n    }\n\n    def leU17(output: MSZ[B], context: Context, v: U17): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32(v & u17\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32((v >> u17\"8\") & u17\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U17.toU32(v >> u17\"16\"))))\n    }\n\n    def leU18(output: MSZ[B], context: Context, v: U18): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32(v & u18\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32((v >> u18\"8\") & u18\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U18.toU32(v >> u18\"16\"))))\n    }\n\n    def leU19(output: MSZ[B], context: Context, v: U19): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32(v & u19\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32((v >> u19\"8\") & u19\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U19.toU32(v >> u19\"16\"))))\n    }\n\n    def leU20(output: MSZ[B], context: Context, v: U20): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32(v & u20\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32((v >> u20\"8\") & u20\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U20.toU32(v >> u20\"16\"))))\n    }\n\n    def leU21(output: MSZ[B], context: Context, v: U21): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32(v & u21\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32((v >> u21\"8\") & u21\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U21.toU32(v >> u21\"16\"))))\n    }\n\n    def leU22(output: MSZ[B], context: Context, v: U22): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32(v & u22\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32((v >> u22\"8\") & u22\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U22.toU32(v >> u22\"16\"))))\n    }\n\n    def leU23(output: MSZ[B], context: Context, v: U23): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32(v & u23\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32((v >> u23\"8\") & u23\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U23.toU32(v >> u23\"16\"))))\n    }\n\n    def leU24(output: MSZ[B], context: Context, v: U24): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32((v >> u24\"8\") & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v >> u24\"16\")))\n    }\n\n    def leU25(output: MSZ[B], context: Context, v: U25): Unit = {\n      bleU8(output, context, conv
  #759 = Utf8               ersions.U32.toU8(conversions.U25.toU32(v & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"8\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"16\") & u25\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U25.toU32(v >> u25\"24\"))))\n    }\n\n    def leU26(output: MSZ[B], context: Context, v: U26): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32(v & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"8\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"16\") & u26\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U26.toU32(v >> u26\"24\"))))\n    }\n\n    def leU27(output: MSZ[B], context: Context, v: U27): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32(v & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"8\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"16\") & u27\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U27.toU32(v >> u27\"24\"))))\n    }\n\n    def leU28(output: MSZ[B], context: Context, v: U28): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32(v & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"8\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"16\") & u28\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U28.toU32(v >> u28\"24\"))))\n    }\n\n    def leU29(output: MSZ[B], context: Context, v: U29): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32(v & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"8\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"16\") & u29\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U29.toU32(v >> u29\"24\"))))\n    }\n\n    def leU30(output: MSZ[B], context: Context, v: U30): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32(v & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"8\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"16\") & u30\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U30.toU32(v >> u30\"24\"))))\n    }\n\n    def leU31(output: MSZ[B], context: Context, v: U31): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32(v & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"8\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"16\") & u31\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U31.toU32(v >> u31\"24\"))))\n    }\n\n    def leU32(output: MSZ[B], context: Context, v: U32): Unit = {\n      bleU8(output, context, conversions.U32.toU8(v & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"8\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"16\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8(v >> u32\"24\"))\n    }\n\n    def leS32(output: MSZ[B], context: Context, v: S32): Unit = {\n      leU32(output, context, conversions.S32.toRawU32(v))\n    }\n\n    def leU33(output: MSZ[B], context: Context, v: U33): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64(v & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"8\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"16\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"24\") & u33\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U33.toU64(v >> u33\"32\"))))\n    }\n\n    def leU34(output: MSZ[B], context: Context, v: U34): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64(v & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"8\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"16\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"24\") & u34\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U34.toU64(v >> u34\"32\"))))\n    }\n\n    def leU35(output: MSZ[B], context: Context, v: U35): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64(v & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"8\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"16\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"24\") & u35\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U35.toU64(v >> u35\"32\"))))\n    }\n\n    def leU36(output: MSZ[B], context: Context, v: U36): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64(v & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"8\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"16\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"24\") & u36\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U36.toU64(v >> u36\"32\"))))\n    }\n\n    def leU37(output: MSZ[B], context: Context, v: U37): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64(v & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"8\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"16\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"24\") & u37\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U37.toU64(v >> u37\"32\"))))\n    }\n\n    def leU38(output: MSZ[B], context: Context, v: U38): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64(v & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"8\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"16\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"24\") & u38\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U38.toU64(v >> u38\"32\"))))\n    }\n\n    def leU39(output: MSZ[B], context: Context, v: U39): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64(v & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"8\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"16\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"24\") & u39\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U39.toU64(v >> u39\"32\"))))\n    }\n\n    def leU40(output: MSZ[B], context: Context, v: U40): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"8\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"16\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"24\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v >> u40\"32\")))\n    }\n\n    def leU41(output: MSZ[B], context: Context, v: U41): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64(v & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"8\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"16\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"24\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"32\") & u41\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U41.toU64(v >> u41\"40\"))))\n    }\n\n    def leU42(output: MSZ[B], context: Context, v: U42): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64(v & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"8\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"16\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"24\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"32\") & u42\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U42.toU64(v >> u42\"40\"))))\n    }\n\n    def leU43(output: MSZ[B], context: Context, v: U43): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64(v & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"8\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"16\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"24\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"32\") & u43\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U43.toU64(v >> u43\"40\"))))\n    }\n\n    def leU44(output: MSZ[B], context: Context, v: U44): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64(v & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"8\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"16\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"24\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"32\") & u44\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U44.toU64(v >> u44\"40\"))))\n    }\n\n    def leU45(output: MSZ[B], context: Context, v: U45): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64(v & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"8\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"16\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"24\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"32\") & u45\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U45.toU64(v >> u45\"40\"))))\n    }\n\n    def leU46(output: MSZ[B], context: Context, v: U46): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64(v & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"8\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"16\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"24\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"32\") & u46\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U46.toU64(v >> u46\"40\"))))\n    }\n\n    def leU47(output: MSZ[B], context: Context, v: U47): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64(v & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"8\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"16\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"24\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"32\") & u47\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U47.toU64(v >> u47\"40\"))))\n    }\n\n    def leU48(output: MSZ[B], context: Context, v: U48): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"8\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"16\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"24\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"32\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v >> u48\"40\")))\n    }\n\n    def leU49(output: MSZ[B], context: Context, v: U49): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64(v & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"8\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"16\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"24\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"32\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"40\") & u49\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U49.toU64(v >> u49\"48\"))))\n    }\n\n    def leU50(output: MSZ[B], context: Context, v: U50): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64(v & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"8\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"16\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"24\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"32\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"40\") & u50\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U50.toU64(v >> u50\"48\"))))\n    }\n\n    def leU51(output: MSZ[B], context: Context, v: U51): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64(v & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"8\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"16\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"24\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"32\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"40\") & u51\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U51.toU64(v >> u51\"48\"))))\n    }\n\n    def leU52(output: MSZ[B], context: Context, v: U52): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64(v & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"8\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"16\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"24\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"32\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"40\") & u52\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U52.toU64(v >> u52\"48\"))))\n    }\n\n    def leU53(output: MSZ[B], context: Context, v: U53): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64(v & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"8\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"16\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"24\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"32\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"40\") & u53\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U53.toU64(v >> u53\"48\"))))\n    }\n\n    def leU54(output: MSZ[B], context: Context, v: U54): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64(v & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"8\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"16\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"24\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"32\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"40\") & u54\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U54.toU64(v >> u54\"48\"))))\n    }\n\n    def leU55(output: MSZ[B], context: Context, v: U55): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64(v & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"8\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"16\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"24\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"32\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"40\") & u55\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U55.toU64(v >> u55\"48\"))))\n    }\n\n    def leU56(output: MSZ[B], context: Context, v: U56): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"8\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"16\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"24\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"32\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"40\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v >> u56\"48\")))\n    }\n\n    def leU57(output: MSZ[B], context: Context, v: U57): Unit = {\n      bleU8(ou
  #760 = String             #759          // ersions.U32.toU8(conversions.U25.toU32(v & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"8\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"16\") & u25\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U25.toU32(v >> u25\"24\"))))\n    }\n\n    def leU26(output: MSZ[B], context: Context, v: U26): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32(v & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"8\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"16\") & u26\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U26.toU32(v >> u26\"24\"))))\n    }\n\n    def leU27(output: MSZ[B], context: Context, v: U27): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32(v & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"8\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"16\") & u27\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U27.toU32(v >> u27\"24\"))))\n    }\n\n    def leU28(output: MSZ[B], context: Context, v: U28): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32(v & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"8\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"16\") & u28\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U28.toU32(v >> u28\"24\"))))\n    }\n\n    def leU29(output: MSZ[B], context: Context, v: U29): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32(v & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"8\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"16\") & u29\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U29.toU32(v >> u29\"24\"))))\n    }\n\n    def leU30(output: MSZ[B], context: Context, v: U30): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32(v & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"8\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"16\") & u30\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U30.toU32(v >> u30\"24\"))))\n    }\n\n    def leU31(output: MSZ[B], context: Context, v: U31): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32(v & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"8\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"16\") & u31\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U31.toU32(v >> u31\"24\"))))\n    }\n\n    def leU32(output: MSZ[B], context: Context, v: U32): Unit = {\n      bleU8(output, context, conversions.U32.toU8(v & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"8\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"16\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8(v >> u32\"24\"))\n    }\n\n    def leS32(output: MSZ[B], context: Context, v: S32): Unit = {\n      leU32(output, context, conversions.S32.toRawU32(v))\n    }\n\n    def leU33(output: MSZ[B], context: Context, v: U33): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64(v & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"8\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"16\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"24\") & u33\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U33.toU64(v >> u33\"32\"))))\n    }\n\n    def leU34(output: MSZ[B], context: Context, v: U34): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64(v & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"8\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"16\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"24\") & u34\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U34.toU64(v >> u34\"32\"))))\n    }\n\n    def leU35(output: MSZ[B], context: Context, v: U35): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64(v & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"8\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"16\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"24\") & u35\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U35.toU64(v >> u35\"32\"))))\n    }\n\n    def leU36(output: MSZ[B], context: Context, v: U36): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64(v & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"8\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"16\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"24\") & u36\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U36.toU64(v >> u36\"32\"))))\n    }\n\n    def leU37(output: MSZ[B], context: Context, v: U37): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64(v & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"8\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"16\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"24\") & u37\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U37.toU64(v >> u37\"32\"))))\n    }\n\n    def leU38(output: MSZ[B], context: Context, v: U38): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64(v & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"8\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"16\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"24\") & u38\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U38.toU64(v >> u38\"32\"))))\n    }\n\n    def leU39(output: MSZ[B], context: Context, v: U39): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64(v & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"8\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"16\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"24\") & u39\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U39.toU64(v >> u39\"32\"))))\n    }\n\n    def leU40(output: MSZ[B], context: Context, v: U40): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"8\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"16\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"24\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v >> u40\"32\")))\n    }\n\n    def leU41(output: MSZ[B], context: Context, v: U41): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64(v & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"8\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"16\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"24\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"32\") & u41\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U41.toU64(v >> u41\"40\"))))\n    }\n\n    def leU42(output: MSZ[B], context: Context, v: U42): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64(v & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"8\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"16\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"24\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"32\") & u42\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U42.toU64(v >> u42\"40\"))))\n    }\n\n    def leU43(output: MSZ[B], context: Context, v: U43): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64(v & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"8\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"16\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"24\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"32\") & u43\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U43.toU64(v >> u43\"40\"))))\n    }\n\n    def leU44(output: MSZ[B], context: Context, v: U44): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64(v & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"8\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"16\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"24\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"32\") & u44\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U44.toU64(v >> u44\"40\"))))\n    }\n\n    def leU45(output: MSZ[B], context: Context, v: U45): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64(v & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"8\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"16\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"24\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"32\") & u45\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U45.toU64(v >> u45\"40\"))))\n    }\n\n    def leU46(output: MSZ[B], context: Context, v: U46): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64(v & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"8\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"16\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"24\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"32\") & u46\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U46.toU64(v >> u46\"40\"))))\n    }\n\n    def leU47(output: MSZ[B], context: Context, v: U47): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64(v & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"8\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"16\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"24\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"32\") & u47\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U47.toU64(v >> u47\"40\"))))\n    }\n\n    def leU48(output: MSZ[B], context: Context, v: U48): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"8\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"16\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"24\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"32\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v >> u48\"40\")))\n    }\n\n    def leU49(output: MSZ[B], context: Context, v: U49): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64(v & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"8\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"16\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"24\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"32\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"40\") & u49\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U49.toU64(v >> u49\"48\"))))\n    }\n\n    def leU50(output: MSZ[B], context: Context, v: U50): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64(v & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"8\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"16\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"24\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"32\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"40\") & u50\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U50.toU64(v >> u50\"48\"))))\n    }\n\n    def leU51(output: MSZ[B], context: Context, v: U51): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64(v & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"8\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"16\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"24\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"32\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"40\") & u51\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U51.toU64(v >> u51\"48\"))))\n    }\n\n    def leU52(output: MSZ[B], context: Context, v: U52): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64(v & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"8\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"16\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"24\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"32\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"40\") & u52\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U52.toU64(v >> u52\"48\"))))\n    }\n\n    def leU53(output: MSZ[B], context: Context, v: U53): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64(v & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"8\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"16\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"24\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"32\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"40\") & u53\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U53.toU64(v >> u53\"48\"))))\n    }\n\n    def leU54(output: MSZ[B], context: Context, v: U54): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64(v & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"8\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"16\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"24\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"32\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"40\") & u54\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U54.toU64(v >> u54\"48\"))))\n    }\n\n    def leU55(output: MSZ[B], context: Context, v: U55): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64(v & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"8\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"16\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"24\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"32\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"40\") & u55\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U55.toU64(v >> u55\"48\"))))\n    }\n\n    def leU56(output: MSZ[B], context: Context, v: U56): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"8\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"16\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"24\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"32\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"40\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v >> u56\"48\")))\n    }\n\n    def leU57(output: MSZ[B], context: Context, v: U57): Unit = {\n      bleU8(ou
  #761 = Utf8               tput, context, conversions.U64.toU8(conversions.U57.toU64(v & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"8\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"16\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"24\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"32\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"40\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"48\") & u57\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U57.toU64(v >> u57\"56\"))))\n    }\n\n    def leU58(output: MSZ[B], context: Context, v: U58): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64(v & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"8\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"16\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"24\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"32\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"40\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"48\") & u58\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U58.toU64(v >> u58\"56\"))))\n    }\n\n    def leU59(output: MSZ[B], context: Context, v: U59): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64(v & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"8\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"16\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"24\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"32\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"40\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"48\") & u59\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U59.toU64(v >> u59\"56\"))))\n    }\n\n    def leU60(output: MSZ[B], context: Context, v: U60): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64(v & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"8\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"16\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"24\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"32\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"40\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"48\") & u60\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U60.toU64(v >> u60\"56\"))))\n    }\n\n    def leU61(output: MSZ[B], context: Context, v: U61): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64(v & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"8\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"16\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"24\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"32\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"40\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"48\") & u61\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U61.toU64(v >> u61\"56\"))))\n    }\n\n    def leU62(output: MSZ[B], context: Context, v: U62): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64(v & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"8\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"16\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"24\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"32\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"40\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"48\") & u62\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U62.toU64(v >> u62\"56\"))))\n    }\n\n    def leU63(output: MSZ[B], context: Context, v: U63): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64(v & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"8\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"16\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"24\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"32\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"40\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"48\") & u63\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U63.toU64(v >> u63\"56\"))))\n    }\n\n    def leU64(output: MSZ[B], context: Context, v: U64): Unit = {\n      bleU8(output, context, conversions.U64.toU8(v & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"8\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"16\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"24\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"32\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"40\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"48\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8(v >> u64\"56\"))\n    }\n\n    def leS64(output: MSZ[B], context: Context, v: S64): Unit = {\n      leU64(output, context, conversions.S64.toRawU64(v))\n    }\n\n    def leF32(output: MSZ[B], context: Context, v: F32): Unit = {\n      leU32(output, context, conversions.F32.toRawU32(v))\n    }\n\n    def leF64(output: MSZ[B], context: Context, v: F64): Unit = {\n      leU64(output, context, conversions.F64.toRawU64(v))\n    }\n  }\n\n  def hex2u8(n: U8): Option[U8] = {\n    if (u8\"48\" <= n && n <= u8\"57\") { // \'0\' .. \'9\'\n      return Some(n - u8\"48\")\n    }\n    if (u8\"65\" <= n && n <= u8\"70\") { // \'A\' .. \'F\'\n      return Some(n - u8\"55\")\n    }\n    if (u8\"97\" <= n && n <= u8\"102\") { // \'a\' .. \'f\'\n      return Some(n - u8\"87\")\n    }\n    return None()\n  }\n\n  def fromHexString(s: String): ISZ[B] = {\n    assert(s.size % 2 == 0)\n    val ms = MSZ.create(s.size * 4, F)\n    var i = 0\n    val sz = s.size\n    val u8s = conversions.String.toU8is(s)\n    val ctx = Bits.Context.create\n    while (i < sz) {\n      val b1Opt = hex2u8(u8s(i))\n      i = i + 1\n      val b2Opt = hex2u8(u8s(i))\n      i = i + 1\n      (b1Opt, b2Opt) match {\n        case (Some(b1), Some(b2)) =>\n          val b = b1 << u8\"4\" | b2\n          Bits.Writer.bleU8(ms, ctx, b)\n        case (_, _) =>\n          halt(s\"Invalid hex input string at offset: ${i - (if (b1Opt.isEmpty) 2 else 1)}\")\n      }\n    }\n    assert(ctx.errorCode == 0)\n    return Bits.Writer.resultMS(ms, ctx).toIS\n  }\n}\n
  #762 = String             #761          // tput, context, conversions.U64.toU8(conversions.U57.toU64(v & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"8\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"16\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"24\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"32\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"40\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"48\") & u57\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U57.toU64(v >> u57\"56\"))))\n    }\n\n    def leU58(output: MSZ[B], context: Context, v: U58): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64(v & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"8\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"16\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"24\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"32\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"40\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"48\") & u58\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U58.toU64(v >> u58\"56\"))))\n    }\n\n    def leU59(output: MSZ[B], context: Context, v: U59): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64(v & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"8\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"16\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"24\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"32\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"40\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"48\") & u59\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U59.toU64(v >> u59\"56\"))))\n    }\n\n    def leU60(output: MSZ[B], context: Context, v: U60): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64(v & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"8\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"16\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"24\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"32\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"40\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"48\") & u60\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U60.toU64(v >> u60\"56\"))))\n    }\n\n    def leU61(output: MSZ[B], context: Context, v: U61): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64(v & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"8\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"16\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"24\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"32\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"40\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"48\") & u61\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U61.toU64(v >> u61\"56\"))))\n    }\n\n    def leU62(output: MSZ[B], context: Context, v: U62): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64(v & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"8\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"16\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"24\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"32\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"40\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"48\") & u62\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U62.toU64(v >> u62\"56\"))))\n    }\n\n    def leU63(output: MSZ[B], context: Context, v: U63): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64(v & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"8\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"16\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"24\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"32\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"40\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"48\") & u63\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U63.toU64(v >> u63\"56\"))))\n    }\n\n    def leU64(output: MSZ[B], context: Context, v: U64): Unit = {\n      bleU8(output, context, conversions.U64.toU8(v & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"8\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"16\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"24\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"32\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"40\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"48\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8(v >> u64\"56\"))\n    }\n\n    def leS64(output: MSZ[B], context: Context, v: S64): Unit = {\n      leU64(output, context, conversions.S64.toRawU64(v))\n    }\n\n    def leF32(output: MSZ[B], context: Context, v: F32): Unit = {\n      leU32(output, context, conversions.F32.toRawU32(v))\n    }\n\n    def leF64(output: MSZ[B], context: Context, v: F64): Unit = {\n      leU64(output, context, conversions.F64.toRawU64(v))\n    }\n  }\n\n  def hex2u8(n: U8): Option[U8] = {\n    if (u8\"48\" <= n && n <= u8\"57\") { // \'0\' .. \'9\'\n      return Some(n - u8\"48\")\n    }\n    if (u8\"65\" <= n && n <= u8\"70\") { // \'A\' .. \'F\'\n      return Some(n - u8\"55\")\n    }\n    if (u8\"97\" <= n && n <= u8\"102\") { // \'a\' .. \'f\'\n      return Some(n - u8\"87\")\n    }\n    return None()\n  }\n\n  def fromHexString(s: String): ISZ[B] = {\n    assert(s.size % 2 == 0)\n    val ms = MSZ.create(s.size * 4, F)\n    var i = 0\n    val sz = s.size\n    val u8s = conversions.String.toU8is(s)\n    val ctx = Bits.Context.create\n    while (i < sz) {\n      val b1Opt = hex2u8(u8s(i))\n      i = i + 1\n      val b2Opt = hex2u8(u8s(i))\n      i = i + 1\n      (b1Opt, b2Opt) match {\n        case (Some(b1), Some(b2)) =>\n          val b = b1 << u8\"4\" | b2\n          Bits.Writer.bleU8(ms, ctx, b)\n        case (_, _) =>\n          halt(s\"Invalid hex input string at offset: ${i - (if (b1Opt.isEmpty) 2 else 1)}\")\n      }\n    }\n    assert(ctx.errorCode == 0)\n    return Bits.Writer.resultMS(ms, ctx).toIS\n  }\n}\n
  #763 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.justification.Premise\n\nobject Map {\n\n  @strictpure def empty[K, T]: Map[K, T] = Map[K, T](ISZ())\n\n  @strictpure def of[K, T]: Map[K, T] = Map.empty\n\n  @strictpure def ++[K, T, I](s: IS[I, (K, T)]): Map[K, T] = Map.empty[K, T] ++ s\n\n  @strictpure def entriesOf[K, T](m: Map[K, T]): ISZ[(K, T)] = m.entries\n\n  object Entries {\n\n    @strictpure def uniqueKeys[K, T](entries: ISZ[(K, T)]): B =\n      ∀(entries.indices)(i => ∀(entries.indices)(j => (i != j) ->: (entries(i)._1 != entries(j)._1)))\n\n    @strictpure def contain[K, T](entries: ISZ[(K, T)], kv: (K, T)): B = ∃(entries.indices)(j => kv == entries(j))\n\n    @strictpure def containKey[K, T](entries: ISZ[(K, T)], key: K): B = ∃(entries.indices)(j => key == entries(j)._1)\n\n    @strictpure def containValue[K, T](entries: ISZ[(K, T)], value: T): B = ∃(entries.indices)(j => value == entries(j)._2)\n\n    @strictpure def keyIndexOfFrom[K, T](entries: ISZ[(K, T)], key: K, from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)._1 == key) from\n      else keyIndexOfFrom(entries, key, from + 1)\n\n    @strictpure def valueIndexOfFrom[K, T](entries: ISZ[(K, T)], value: T, from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)._2 == value) from\n      else valueIndexOfFrom(entries, value, from + 1)\n\n    @strictpure def indexOfFrom[K, T](entries: ISZ[(K, T)], kv: (K, T), from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)== kv) from\n      else indexOfFrom(entries, kv, from + 1)\n\n  }\n\n}\n\n@datatype class Map[K, T](val entries: ISZ[(K, T)]) {\n\n  @spec def uniqueKeys = Invariant(Map.Entries.uniqueKeys(entries))\n\n  @pure def keys: ISZ[K] = {\n    Contract(\n      Ensures(\n        SeqUtil.IS.pair1Eq(entries, Res),\n        SeqUtil.IS.unique(Res),\n      )\n    )\n    var r = ISZ[K]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(r, i),\n        0 <= i,\n        i <= entries.size,\n        i == r.size,\n        ∀(0 until i)(j => r(j) == entries(j)._1)\n      )\n      r = r :+ entries(i)._1\n      i = i + 1\n    }\n    return r\n  }\n\n  @pure def values: ISZ[T] = {\n    Contract(Ensures(SeqUtil.IS.pair2Eq(entries, Res)))\n    var r = ISZ[T]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(r, i),\n        0 <= i,\n        i <= entries.size,\n        i == r.size,\n        ∀(0 until i)(j => r(j) == entries(j)._2)\n      )\n      r = r :+ entries(i)._2\n      i = i + 1\n    }\n    return r\n  }\n\n  @strictpure def keySet: Set[K] = Set.empty[K] ++ keys\n\n  @strictpure def valueSet: Set[T] =  Set.empty[T] ++ values\n\n  @pure def +(p: (K, T)): Map[K, T] = {\n    Contract(\n      Ensures(\n        Map.entriesOf(Res).size == entries.size | Map.entriesOf(Res).size == entries.size + 1,\n        Map.Entries.contain(Map.entriesOf(Res), p),\n        ∀(Map.entriesOf(Res).indices)(j =>\n          (Map.entriesOf(Res)(j) != p) ->: Map.Entries.contain(entries, Map.entriesOf(Res)(j))),\n        ∀(entries.indices)(j =>\n          (entries(j)._1 != p._1) ->: Map.Entries.contain(Map.entriesOf(Res), entries(j))),\n      )\n    )\n    val (key, value) = p\n    val index = indexOf(key)\n    val newEntries: ISZ[(K, T)] = if (index < 0) {\n      val r = entries :+ ((key, value))\n      Deduce(\n        //@formatter:off\n        1 #> (r(r.size - 1) == p)                                                           by Premise,\n        2 #> Map.Entries.contain(r, p)                                                      by Premise,\n        3 #> Map.Entries.uniqueKeys(r)                                                      by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != p) ->: Map.Entries.contain(entries, r(j)))          by Premise,\n        5 #> ∀(entries.indices)(j => Map.Entries.contain(r, entries(j)))                    by Premise,\n        //@formatter:on\n      )\n      r\n    } else {\n      val r = entries(index ~> p)\n      Deduce(\n        //@formatter:off\n        1 #> (r(index) == p)                                                                by Premise,\n        2 #> Map.Entries.contain(r, p)                                                      by Premise,\n        3 #> Map.Entries.uniqueKeys(r)                                                      by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != p) ->: Map.Entries.contain(entries, r(j)))          by Premise,\n        5 #> ∀(entries.indices)(j => (index != j) ->: Map.Entries.contain(r, entries(j)))   by Premise,\n        //@formatter:on\n      )\n      r\n    }\n    return Map(newEntries)\n  }\n\n  @pure def ++[I](kvs: IS[I, (K, T)]): Map[K, T] = {\n    var r = this\n    for (kv <- kvs) {\n      r = r + kv\n    }\n    return r\n  }\n\n  @pure def get(key: K): Option[T] = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(∃(entries.indices)(j => (key == entries(j)._1) & (Res == Some(entries(j)._2))))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == None[T]())\n      )\n    )\n    val index = indexOf(key)\n    val r: Option[T] = if (index < 0) None[T]() else Some(entries(index)._2)\n    return r\n  }\n\n  @pure def getOrElse(key: K, default: => T): T = {\n    val index = indexOf(key)\n    return if (index < 0) default else entries(index)._2\n  }\n\n  @pure def getOrElseEager(key: K, default: T): T = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(Map.Entries.containValue(entries, Res))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == default)\n      )\n    )\n    val index = indexOf(key)\n    return if (index < 0) default else entries(index)._2\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(∃(entries.indices)(j => Res == Some(entries(j))))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == None[(K, T)]())\n      )\n    )\n    val index = indexOf(key)\n    val r: Option[(K, T)] = if (index < 0) None[(K, T)]() else Some(entries(index))\n    return r\n  }\n\n  @pure def indexOf(key: K): Z = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(\n          0 <= Res[Z],\n          Res[Z] < entries.size,\n          entries(Res[Z])._1 == key\n        )\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res[Z] == -1)\n      )\n    )\n    var index: Z = -1\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(index, i),\n        0 <= i,\n        i <= entries.size,\n        (index != -1) ->: (0 <= index & index < entries.size & entries(index)._1 == key),\n        (index == -1) ->: ∀(0 until i)(j => key != entries(j)._1)\n      )\n      if (entries(i)._1 == key) {\n        index = i\n        i = entries.size - 1\n      }\n      i = i + 1\n    }\n    return index\n  }\n\n  @pure def --[I](keys: IS[I, K]): Map[K, T] = {\n    var deletedMappings = ISZ[(K, T)]()\n    for (key <- keys) {\n      get(key) match {\n        case Some(value) => deletedMappings = deletedMappings :+ ((key, value))\n        case _ =>\n      }\n    }\n    if (deletedMappings.nonEmpty) {\n      return Map(entries -- deletedMappings)\n    } else {\n      return this\n    }\n  }\n\n  @pure def -(p: (K, T)): Map[K, T] = {\n    Contract(\n      Ensures(\n        Map.entriesOf(Res).size == entries.size | Map.entriesOf(Res).size == entries.size - 1,\n        ∀(Map.entriesOf(Res).indices)(j =>\n          Map.entriesOf(Res)(j) != p & Map.Entries.contain(entries, Map.entriesOf(Res)(j))),\n        ∀(entries.indices)(j =>\n          (entries(j) != p) ->: Map.Entries.contain(Map.entriesOf(Res), entries(j))),\n      )\n    )\n    var newEntries = ISZ[(K, T)]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(i, newEntries),\n        0 <= i,\n        i <= entries.size,\n        ∀(newEntries.indices)(j => ∀(i until entries.size)(k => newEntries(j)._1 != entries(k)._1)),\n        ∀(newEntries.indices)(j => newEntries(j) != p & Map.Entries.contain(entries, newEntries(j))),\n        ∃(0 until i)(j => p == entries(j)) ->: (newEntries.size == i - 1),\n        ∀(0 until i)(j => p != entries(j)) ->: (newEntries.size == i),\n        ∀(0 until i)(j => (p != entries(j)) ->: Map.Entries.contain(newEntries, entries(j))),\n        Map.Entries.uniqueKeys(newEntries),\n      )\n      val kv = entries(i)\n      if (kv != p) {\n        newEntries = newEntries :+ kv\n        Deduce(\n          1 #> ∀(0 to i)(j => (p != entries(j)) ->: Map.Entries.contain(newEntries, entries(j)))  by Premise\n        )\n      }\n      i = i + 1\n    }\n    val r = Map(newEntries)\n    return r\n  }\n\n  @pure def contains(key: K): B = {\n    Contract(Ensures(Res == Map.Entries.containKey(entries, key)))\n    return indexOf(key) >= 0\n  }\n\n  @pure def isEmpty: B = {\n    Contract(Ensures(Res == (entries.size == 0)))\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    Contract(Ensures(Res != (entries.size == 0)))\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    Contract(Ensures(Res == entries.size))\n    return entries.size\n  }\n\n  @pure override def string: String = {\n    val r = st\"\"\"{\n    |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n    |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return entries.size\n  }\n\n  @pure def isEqual(other: Map[K, T]): B = {\n    Contract(\n      Case(\n        \"Equal\",\n        Requires(\n          entries.size == other.entries.size,\n          ∀(entries.indices)(j => Map.Entries.contain(other.entries, entries(j))),\n        ),\n        Ensures(Res[B])\n      ),\n      Case(\n        \"Inequal-diff-key\",\n        Requires(\n          entries.size == other.entries.size,\n          ∃(entries.indices)(j => !Map.Entries.containKey(other.entries, entries(j)._1)),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-diff-value\",\n        Requires(\n          entries.size == other.entries.size,\n          ∃(entries.indices)(j => ∀(other.entries.indices)(k => entries(j) != other.entries(k))),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-size\",\n        Requires(entries.size != other.entries.size),\n        Ensures(!Res[B])\n      )\n    )\n    val sz = size\n    var r = T\n    if (sz != other.size) {\n      r = F\n    } else {\n      var i: Z = 0\n      while (r & i < sz) {\n        Invariant(\n          Modifies(i, r),\n          0 <= i,\n          i <= sz,\n          r ->: ∀(0 until i)(j => Map.Entries.contain(other.entries, entries(j))),\n          !r ->: ∃(entries.indices)(j =>\n            !Map.Entries.containKey(other.entries, entries(j)._1) |\n              !Map.Entries.contain(other.entries, entries(j)))\n        )\n        val (key, v) = entries(i)\n        val v2Opt = other.get(key)\n        v2Opt match {\n          case Some(v2) =>\n            if (v2 != v) {\n              r = F\n            }\n          case _ =>\n            r = F\n        }\n        i = i + 1\n      }\n    }\n    return r\n  }\n}\n
  #764 = String             #763          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.justification.Premise\n\nobject Map {\n\n  @strictpure def empty[K, T]: Map[K, T] = Map[K, T](ISZ())\n\n  @strictpure def of[K, T]: Map[K, T] = Map.empty\n\n  @strictpure def ++[K, T, I](s: IS[I, (K, T)]): Map[K, T] = Map.empty[K, T] ++ s\n\n  @strictpure def entriesOf[K, T](m: Map[K, T]): ISZ[(K, T)] = m.entries\n\n  object Entries {\n\n    @strictpure def uniqueKeys[K, T](entries: ISZ[(K, T)]): B =\n      ∀(entries.indices)(i => ∀(entries.indices)(j => (i != j) ->: (entries(i)._1 != entries(j)._1)))\n\n    @strictpure def contain[K, T](entries: ISZ[(K, T)], kv: (K, T)): B = ∃(entries.indices)(j => kv == entries(j))\n\n    @strictpure def containKey[K, T](entries: ISZ[(K, T)], key: K): B = ∃(entries.indices)(j => key == entries(j)._1)\n\n    @strictpure def containValue[K, T](entries: ISZ[(K, T)], value: T): B = ∃(entries.indices)(j => value == entries(j)._2)\n\n    @strictpure def keyIndexOfFrom[K, T](entries: ISZ[(K, T)], key: K, from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)._1 == key) from\n      else keyIndexOfFrom(entries, key, from + 1)\n\n    @strictpure def valueIndexOfFrom[K, T](entries: ISZ[(K, T)], value: T, from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)._2 == value) from\n      else valueIndexOfFrom(entries, value, from + 1)\n\n    @strictpure def indexOfFrom[K, T](entries: ISZ[(K, T)], kv: (K, T), from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)== kv) from\n      else indexOfFrom(entries, kv, from + 1)\n\n  }\n\n}\n\n@datatype class Map[K, T](val entries: ISZ[(K, T)]) {\n\n  @spec def uniqueKeys = Invariant(Map.Entries.uniqueKeys(entries))\n\n  @pure def keys: ISZ[K] = {\n    Contract(\n      Ensures(\n        SeqUtil.IS.pair1Eq(entries, Res),\n        SeqUtil.IS.unique(Res),\n      )\n    )\n    var r = ISZ[K]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(r, i),\n        0 <= i,\n        i <= entries.size,\n        i == r.size,\n        ∀(0 until i)(j => r(j) == entries(j)._1)\n      )\n      r = r :+ entries(i)._1\n      i = i + 1\n    }\n    return r\n  }\n\n  @pure def values: ISZ[T] = {\n    Contract(Ensures(SeqUtil.IS.pair2Eq(entries, Res)))\n    var r = ISZ[T]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(r, i),\n        0 <= i,\n        i <= entries.size,\n        i == r.size,\n        ∀(0 until i)(j => r(j) == entries(j)._2)\n      )\n      r = r :+ entries(i)._2\n      i = i + 1\n    }\n    return r\n  }\n\n  @strictpure def keySet: Set[K] = Set.empty[K] ++ keys\n\n  @strictpure def valueSet: Set[T] =  Set.empty[T] ++ values\n\n  @pure def +(p: (K, T)): Map[K, T] = {\n    Contract(\n      Ensures(\n        Map.entriesOf(Res).size == entries.size | Map.entriesOf(Res).size == entries.size + 1,\n        Map.Entries.contain(Map.entriesOf(Res), p),\n        ∀(Map.entriesOf(Res).indices)(j =>\n          (Map.entriesOf(Res)(j) != p) ->: Map.Entries.contain(entries, Map.entriesOf(Res)(j))),\n        ∀(entries.indices)(j =>\n          (entries(j)._1 != p._1) ->: Map.Entries.contain(Map.entriesOf(Res), entries(j))),\n      )\n    )\n    val (key, value) = p\n    val index = indexOf(key)\n    val newEntries: ISZ[(K, T)] = if (index < 0) {\n      val r = entries :+ ((key, value))\n      Deduce(\n        //@formatter:off\n        1 #> (r(r.size - 1) == p)                                                           by Premise,\n        2 #> Map.Entries.contain(r, p)                                                      by Premise,\n        3 #> Map.Entries.uniqueKeys(r)                                                      by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != p) ->: Map.Entries.contain(entries, r(j)))          by Premise,\n        5 #> ∀(entries.indices)(j => Map.Entries.contain(r, entries(j)))                    by Premise,\n        //@formatter:on\n      )\n      r\n    } else {\n      val r = entries(index ~> p)\n      Deduce(\n        //@formatter:off\n        1 #> (r(index) == p)                                                                by Premise,\n        2 #> Map.Entries.contain(r, p)                                                      by Premise,\n        3 #> Map.Entries.uniqueKeys(r)                                                      by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != p) ->: Map.Entries.contain(entries, r(j)))          by Premise,\n        5 #> ∀(entries.indices)(j => (index != j) ->: Map.Entries.contain(r, entries(j)))   by Premise,\n        //@formatter:on\n      )\n      r\n    }\n    return Map(newEntries)\n  }\n\n  @pure def ++[I](kvs: IS[I, (K, T)]): Map[K, T] = {\n    var r = this\n    for (kv <- kvs) {\n      r = r + kv\n    }\n    return r\n  }\n\n  @pure def get(key: K): Option[T] = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(∃(entries.indices)(j => (key == entries(j)._1) & (Res == Some(entries(j)._2))))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == None[T]())\n      )\n    )\n    val index = indexOf(key)\n    val r: Option[T] = if (index < 0) None[T]() else Some(entries(index)._2)\n    return r\n  }\n\n  @pure def getOrElse(key: K, default: => T): T = {\n    val index = indexOf(key)\n    return if (index < 0) default else entries(index)._2\n  }\n\n  @pure def getOrElseEager(key: K, default: T): T = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(Map.Entries.containValue(entries, Res))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == default)\n      )\n    )\n    val index = indexOf(key)\n    return if (index < 0) default else entries(index)._2\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(∃(entries.indices)(j => Res == Some(entries(j))))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == None[(K, T)]())\n      )\n    )\n    val index = indexOf(key)\n    val r: Option[(K, T)] = if (index < 0) None[(K, T)]() else Some(entries(index))\n    return r\n  }\n\n  @pure def indexOf(key: K): Z = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(\n          0 <= Res[Z],\n          Res[Z] < entries.size,\n          entries(Res[Z])._1 == key\n        )\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res[Z] == -1)\n      )\n    )\n    var index: Z = -1\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(index, i),\n        0 <= i,\n        i <= entries.size,\n        (index != -1) ->: (0 <= index & index < entries.size & entries(index)._1 == key),\n        (index == -1) ->: ∀(0 until i)(j => key != entries(j)._1)\n      )\n      if (entries(i)._1 == key) {\n        index = i\n        i = entries.size - 1\n      }\n      i = i + 1\n    }\n    return index\n  }\n\n  @pure def --[I](keys: IS[I, K]): Map[K, T] = {\n    var deletedMappings = ISZ[(K, T)]()\n    for (key <- keys) {\n      get(key) match {\n        case Some(value) => deletedMappings = deletedMappings :+ ((key, value))\n        case _ =>\n      }\n    }\n    if (deletedMappings.nonEmpty) {\n      return Map(entries -- deletedMappings)\n    } else {\n      return this\n    }\n  }\n\n  @pure def -(p: (K, T)): Map[K, T] = {\n    Contract(\n      Ensures(\n        Map.entriesOf(Res).size == entries.size | Map.entriesOf(Res).size == entries.size - 1,\n        ∀(Map.entriesOf(Res).indices)(j =>\n          Map.entriesOf(Res)(j) != p & Map.Entries.contain(entries, Map.entriesOf(Res)(j))),\n        ∀(entries.indices)(j =>\n          (entries(j) != p) ->: Map.Entries.contain(Map.entriesOf(Res), entries(j))),\n      )\n    )\n    var newEntries = ISZ[(K, T)]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(i, newEntries),\n        0 <= i,\n        i <= entries.size,\n        ∀(newEntries.indices)(j => ∀(i until entries.size)(k => newEntries(j)._1 != entries(k)._1)),\n        ∀(newEntries.indices)(j => newEntries(j) != p & Map.Entries.contain(entries, newEntries(j))),\n        ∃(0 until i)(j => p == entries(j)) ->: (newEntries.size == i - 1),\n        ∀(0 until i)(j => p != entries(j)) ->: (newEntries.size == i),\n        ∀(0 until i)(j => (p != entries(j)) ->: Map.Entries.contain(newEntries, entries(j))),\n        Map.Entries.uniqueKeys(newEntries),\n      )\n      val kv = entries(i)\n      if (kv != p) {\n        newEntries = newEntries :+ kv\n        Deduce(\n          1 #> ∀(0 to i)(j => (p != entries(j)) ->: Map.Entries.contain(newEntries, entries(j)))  by Premise\n        )\n      }\n      i = i + 1\n    }\n    val r = Map(newEntries)\n    return r\n  }\n\n  @pure def contains(key: K): B = {\n    Contract(Ensures(Res == Map.Entries.containKey(entries, key)))\n    return indexOf(key) >= 0\n  }\n\n  @pure def isEmpty: B = {\n    Contract(Ensures(Res == (entries.size == 0)))\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    Contract(Ensures(Res != (entries.size == 0)))\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    Contract(Ensures(Res == entries.size))\n    return entries.size\n  }\n\n  @pure override def string: String = {\n    val r = st\"\"\"{\n    |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n    |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return entries.size\n  }\n\n  @pure def isEqual(other: Map[K, T]): B = {\n    Contract(\n      Case(\n        \"Equal\",\n        Requires(\n          entries.size == other.entries.size,\n          ∀(entries.indices)(j => Map.Entries.contain(other.entries, entries(j))),\n        ),\n        Ensures(Res[B])\n      ),\n      Case(\n        \"Inequal-diff-key\",\n        Requires(\n          entries.size == other.entries.size,\n          ∃(entries.indices)(j => !Map.Entries.containKey(other.entries, entries(j)._1)),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-diff-value\",\n        Requires(\n          entries.size == other.entries.size,\n          ∃(entries.indices)(j => ∀(other.entries.indices)(k => entries(j) != other.entries(k))),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-size\",\n        Requires(entries.size != other.entries.size),\n        Ensures(!Res[B])\n      )\n    )\n    val sz = size\n    var r = T\n    if (sz != other.size) {\n      r = F\n    } else {\n      var i: Z = 0\n      while (r & i < sz) {\n        Invariant(\n          Modifies(i, r),\n          0 <= i,\n          i <= sz,\n          r ->: ∀(0 until i)(j => Map.Entries.contain(other.entries, entries(j))),\n          !r ->: ∃(entries.indices)(j =>\n            !Map.Entries.containKey(other.entries, entries(j)._1) |\n              !Map.Entries.contain(other.entries, entries(j)))\n        )\n        val (key, v) = entries(i)\n        val v2Opt = other.get(key)\n        v2Opt match {\n          case Some(v2) =>\n            if (v2 != v) {\n              r = F\n            }\n          case _ =>\n            r = F\n        }\n        i = i + 1\n      }\n    }\n    return r\n  }\n}\n
  #765 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject HashSBag {\n\n  @pure def empty[T]: HashSBag[T] = {\n    return HashSBag(HashSMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSBag[T] = {\n    return HashSBag(HashSMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSBag[T] = {\n    return HashSBag.empty[T] ++ s\n  }\n\n}\n\n@datatype class HashSBag[T](val map: HashSMap[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): HashSBag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def +#(p: (T, Z)): HashSBag[T] = {\n    return addN(p._1, p._2)\n  }\n\n  @pure def addN(e: T, n: Z): HashSBag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def ++[I](es: IS[I, T]): HashSBag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSBag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](s: IS[I, T]): HashSBag[T] = {\n    var r = this\n    for (e <- s) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def -#(p: (T, Z)): HashSBag[T] = {\n    return removeN(p._1, p._2)\n  }\n\n  @pure def removeN(e: T, n: Z): HashSBag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def \\(other: HashSBag[T]): HashSBag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: HashSBag[T]): HashSBag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSBag[T]): HashSBag[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSBag[T]): HashSBag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSBag[T]): HashSBag[T] = {\n    var r = HashSBag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r.addN(e._1, n)\n      } else {\n        r = r.addN(e._1, m)\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
  #766 = String             #765          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject HashSBag {\n\n  @pure def empty[T]: HashSBag[T] = {\n    return HashSBag(HashSMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSBag[T] = {\n    return HashSBag(HashSMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSBag[T] = {\n    return HashSBag.empty[T] ++ s\n  }\n\n}\n\n@datatype class HashSBag[T](val map: HashSMap[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): HashSBag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def +#(p: (T, Z)): HashSBag[T] = {\n    return addN(p._1, p._2)\n  }\n\n  @pure def addN(e: T, n: Z): HashSBag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def ++[I](es: IS[I, T]): HashSBag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSBag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](s: IS[I, T]): HashSBag[T] = {\n    var r = this\n    for (e <- s) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def -#(p: (T, Z)): HashSBag[T] = {\n    return removeN(p._1, p._2)\n  }\n\n  @pure def removeN(e: T, n: Z): HashSBag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def \\(other: HashSBag[T]): HashSBag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: HashSBag[T]): HashSBag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSBag[T]): HashSBag[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSBag[T]): HashSBag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSBag[T]): HashSBag[T] = {\n    var r = HashSBag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r.addN(e._1, n)\n      } else {\n        r = r.addN(e._1, m)\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
  #767 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject OsProto {\n\n  @sig trait Path\n\n  object Proc {\n    @sig trait Result {\n      def ok: B = {\n        return exitCode == 0\n      }\n      def out: String\n      def err: String\n      def exitCode: Z\n    }\n  }\n\n  @sig trait Proc {\n\n    @pure def commands(cs: ISZ[String]): Proc\n\n    @pure def at(dir: Path): Proc\n\n    @pure def env(m: ISZ[(String, String)]): Proc\n\n    @pure def input(content: String): Proc\n\n    @pure def timeout(millis: Z): Proc\n\n    @pure def dontInheritEnv: Proc\n\n    @pure def redirectErr: Proc\n\n    @pure def bufferErr: Proc\n\n    @pure def console: Proc\n\n    @pure def echoEnv: Proc\n\n    @pure def echo: Proc\n\n    @pure def standard: Proc\n\n    @pure def script: Proc\n\n    @pure def outLineAction(f: String => B): Proc\n\n    @pure def errLineAction(f: String => B): Proc\n\n    def run(): Proc.Result\n\n    def runCheck(): Proc.Result\n  }\n\n}\n
  #768 = String             #767          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject OsProto {\n\n  @sig trait Path\n\n  object Proc {\n    @sig trait Result {\n      def ok: B = {\n        return exitCode == 0\n      }\n      def out: String\n      def err: String\n      def exitCode: Z\n    }\n  }\n\n  @sig trait Proc {\n\n    @pure def commands(cs: ISZ[String]): Proc\n\n    @pure def at(dir: Path): Proc\n\n    @pure def env(m: ISZ[(String, String)]): Proc\n\n    @pure def input(content: String): Proc\n\n    @pure def timeout(millis: Z): Proc\n\n    @pure def dontInheritEnv: Proc\n\n    @pure def redirectErr: Proc\n\n    @pure def bufferErr: Proc\n\n    @pure def console: Proc\n\n    @pure def echoEnv: Proc\n\n    @pure def echo: Proc\n\n    @pure def standard: Proc\n\n    @pure def script: Proc\n\n    @pure def outLineAction(f: String => B): Proc\n\n    @pure def errLineAction(f: String => B): Proc\n\n    def run(): Proc.Result\n\n    def runCheck(): Proc.Result\n  }\n\n}\n
  #769 = Utf8               // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.justification.Premise\n\nobject Set {\n\n  @strictpure def empty[T]: Set[T] = Set[T](ISZ())\n\n  @strictpure def ++[I, T](s: IS[I, T]): Set[T] = empty[T] ++ s\n\n  @strictpure def elementsOf[T](s: Set[T]): ISZ[T] = s.elements\n\n  object Elements {\n\n    @strictpure def unique[T](elements: ISZ[T]): B =\n      ∀(elements.indices)(i => ∀(elements.indices)(j => (i != j) ->: (elements(i) != elements(j))))\n\n    @strictpure def contain[T](elements: ISZ[T], e: T): B = ∃(elements.indices)(j => e == elements(j))\n\n    @strictpure def indexOfFrom[T](elements: ISZ[T], e: T, from: Z): Z =\n      if (from < 0 | from >= elements.size) -1\n      else if (elements(from)== e) from\n      else indexOfFrom(elements, e, from + 1)\n\n  }\n}\n\n@datatype class Set[T](val elements: ISZ[T]) {\n\n  @spec def uniqueElements = Invariant(Set.Elements.unique(elements))\n\n  @pure def +(e: T): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size == elements.size | Set.elementsOf(Res).size == elements.size + 1,\n        Set.Elements.contain(Set.elementsOf(Res), e),\n        ∀(Set.elementsOf(Res).indices)(j =>\n          (Set.elementsOf(Res)(j) != e) ->: Set.Elements.contain(elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          (elements(j) != e) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j)))\n      )\n    )\n    val index = indexOf(e)\n    val newElements: ISZ[T] = if (index < 0) {\n      val r = elements :+ e\n      Deduce(\n        //@formatter:off\n        1 #> (r(r.size - 1) == e)                                                           by Premise,\n        2 #> Set.Elements.contain(r, e)                                                     by Premise,\n        3 #> SeqUtil.IS.unique(r)                                                           by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != e) ->: Set.Elements.contain(elements, r(j)))        by Premise,\n        5 #> ∀(elements.indices)(j => Set.Elements.contain(r, elements(j)))                 by Premise,\n        //@formatter:on\n      )\n      r\n    } else {\n      val r = elements(index ~> e)\n      Deduce(\n        //@formatter:off\n        1 #> (r(index) == e)                                                                by Premise,\n        2 #> Set.Elements.contain(r, e)                                                     by Premise,\n        3 #> SeqUtil.IS.unique(r)                                                           by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != e) ->: Set.Elements.contain(elements, r(j)))        by Premise,\n        5 #> ∀(elements.indices)(j => Set.Elements.contain(r, elements(j)))                 by Premise,\n        //@formatter:on\n      )\n      r\n    }\n    return Set(newElements)\n  }\n\n  @pure def ++[I](is: IS[I, T]): Set[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size == elements.size | Set.elementsOf(Res).size == elements.size - 1,\n        ∀(Set.elementsOf(Res).indices)(j => Set.elementsOf(Res)(j) != e & Set.Elements.contain(elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => (elements(j) != e) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(newElements.indices)(j => newElements(j) != e & Set.Elements.contain(elements, newElements(j))),\n        ∃(0 until i)(j => e == elements(j)) ->: (newElements.size == i - 1),\n        ∀(0 until i)(j => e != elements(j)) ->: (newElements.size == i),\n        ∀(0 until i)(j => (e != elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val kv = elements(i)\n      if (kv != e) {\n        newElements = newElements :+ kv\n      }\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def --[I](is: IS[I, T]): Set[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    Contract(Ensures(Res == Set.Elements.contain(elements, e)))\n    return indexOf(e) >= 0\n  }\n\n  @pure def union(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size >= elements.size,\n        Set.elementsOf(Res).size <= elements.size + other.elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) |\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => elements(j) == Set.elementsOf(Res)(j)),\n        ∀(other.elements.indices)(j => Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = elements\n    var i: Z = 0\n    while (i < other.elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= other.elements.size,\n        newElements.size >= elements.size,\n        newElements.size <= elements.size + i,\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j)) |\n          Set.Elements.contain(other.elements, newElements(j))),\n        ∀(elements.indices)(j => elements(j) == newElements(j)),\n        ∀(elements.size until newElements.size)(j =>\n          ∀(i until other.elements.size)(k => newElements(j) != other.elements(k))),\n        ∀(0 until i)(j => Set.Elements.contain(newElements, other.elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val e = other.elements(i)\n      if (!contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          1 #> ∀(0 to i)(j => Set.Elements.contain(newElements, other.elements(j)))         by Premise,\n        )\n      } else {\n        Deduce(\n          1 #> ∀(0 to i)(j => Set.Elements.contain(newElements, other.elements(j)))         by Premise,\n        )\n      }\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def ∪(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size >= elements.size,\n        Set.elementsOf(Res).size <= elements.size + other.elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) |\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => elements(j) == Set.elementsOf(Res)(j)),\n        ∀(other.elements.indices)(j => Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    return union(other)\n  }\n\n  @pure def intersect(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j =>\n          Set.Elements.contain(elements, other.elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        newElements.size <= i,\n        ∀(newElements.indices)(j => Set.Elements.contain(other.elements, newElements(j))),\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j))),\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(0 until i)(j => Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements)\n      )\n      val e = elements(i)\n      if (other.contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          //@formatter:off\n          1 #> ∀(0 to i)(j => Set.Elements.contain(other.elements, elements(j)) ->:\n            Set.Elements.contain(newElements, elements(j)))                                 by Premise,\n          2 #> Set.Elements.unique(newElements)                                             by Premise\n          //@formatter:on\n        )\n      }\n\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def ∩(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j =>\n          Set.Elements.contain(elements, other.elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    return intersect(other)\n  }\n\n  @pure def \\(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            !Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          !Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j => !Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        newElements.size <= i,\n        ∀(newElements.indices)(j => !Set.Elements.contain(other.elements, newElements(j))),\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j))),\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(0 until i)(j => !Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val e = elements(i)\n      if (!other.contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          //@formatter:off\n          1 #> ∀(0 to i)(j => !Set.Elements.contain(other.elements, elements(j)) ->:\n            Set.Elements.contain(newElements, elements(j)))                                 by Premise,\n          2 #> Set.Elements.unique(newElements)                                             by Premise\n          //@formatter:on\n        )\n      }\n\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def isEqual(other: Set[T]): B = {\n    Contract(\n      Case(\n        \"Equal\",\n        Requires(\n          elements. size == other.elements.size,\n          ∀(elements.indices)(j => Set.Elements.contain(other.elements, elements(j))),\n        ),\n        Ensures(Res[B])\n      ),\n      Case(\n        \"Inequal-diff\",\n        Requires(\n          elements.size == other.elements.size,\n          ∃(elements.indices)(j => !Set.Elements.contain(other.elements, elements(j))),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-size\",\n        Requires(elements.size != other.elements.size),\n        Ensures(!Res[B])\n      )\n    )\n    val sz = size\n    if (sz != other.size) {\n      return F\n    } else {\n      var i: Z = 0\n      var r = T\n      while (r & i < sz) {\n        Invariant(\n          Modifies(i, r),\n          0 <= i,\n          i <= sz,\n          r ->: ∀(0 until i)(j => Set.Elements.contain(other.elements, elements(j))),\n          !r ->: ∃(elements.indices)(j => !Set.Elements.contain(other.elements, elements(j)))\n        )\n        if (!other.contains(elements(i))) {\n          r = F\n        }\n        i = i + 1\n      }\n\n      return r\n    }\n  }\n\n  @pure override def hash: Z = {\n    return elements.hash\n  }\n\n  @pure def isEmpty: B = {\n    Contract(Ensures(Res == (elements.size == 0)))\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    Contract(Ensures(Res == (elements.size != 0)))\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    Contract(Ensures(Res == elements.size))\n    return elements.size\n  }\n\n  @pure def indexOf(e: T): Z = {\n    Contract(\n      Case(\n        \"In\",\n        Requires(Set.Elements.contain(elements, e)),\n        Ensures(\n          0 <= Res[Z],\n          Res[Z] < elements.size,\n          elements(Res[Z]) == e\n        )\n      ),\n      Case(\n        \"Not-in\",\n        Requires(!Set.Elements.contain(elements, e)),\n        Ensures(Res[Z] == -1)\n      )\n    )\n    var index: Z = -1\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(index, i),\n        0 <= i,\n        i <= elements.size,\n        (index != -1) ->: (0 <= index & index < elements.size & elements(index) == e),\n        (index == -1) ->: ∀(0 until i)(j => e != elements(j))\n      )\n      if (elements(i) == e) {\n        index = i\n        i = elements.size - 1\n      }\n      i = i + 1\n    }\n    return index\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
  #770 = String             #769          // // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.justification.Premise\n\nobject Set {\n\n  @strictpure def empty[T]: Set[T] = Set[T](ISZ())\n\n  @strictpure def ++[I, T](s: IS[I, T]): Set[T] = empty[T] ++ s\n\n  @strictpure def elementsOf[T](s: Set[T]): ISZ[T] = s.elements\n\n  object Elements {\n\n    @strictpure def unique[T](elements: ISZ[T]): B =\n      ∀(elements.indices)(i => ∀(elements.indices)(j => (i != j) ->: (elements(i) != elements(j))))\n\n    @strictpure def contain[T](elements: ISZ[T], e: T): B = ∃(elements.indices)(j => e == elements(j))\n\n    @strictpure def indexOfFrom[T](elements: ISZ[T], e: T, from: Z): Z =\n      if (from < 0 | from >= elements.size) -1\n      else if (elements(from)== e) from\n      else indexOfFrom(elements, e, from + 1)\n\n  }\n}\n\n@datatype class Set[T](val elements: ISZ[T]) {\n\n  @spec def uniqueElements = Invariant(Set.Elements.unique(elements))\n\n  @pure def +(e: T): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size == elements.size | Set.elementsOf(Res).size == elements.size + 1,\n        Set.Elements.contain(Set.elementsOf(Res), e),\n        ∀(Set.elementsOf(Res).indices)(j =>\n          (Set.elementsOf(Res)(j) != e) ->: Set.Elements.contain(elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          (elements(j) != e) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j)))\n      )\n    )\n    val index = indexOf(e)\n    val newElements: ISZ[T] = if (index < 0) {\n      val r = elements :+ e\n      Deduce(\n        //@formatter:off\n        1 #> (r(r.size - 1) == e)                                                           by Premise,\n        2 #> Set.Elements.contain(r, e)                                                     by Premise,\n        3 #> SeqUtil.IS.unique(r)                                                           by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != e) ->: Set.Elements.contain(elements, r(j)))        by Premise,\n        5 #> ∀(elements.indices)(j => Set.Elements.contain(r, elements(j)))                 by Premise,\n        //@formatter:on\n      )\n      r\n    } else {\n      val r = elements(index ~> e)\n      Deduce(\n        //@formatter:off\n        1 #> (r(index) == e)                                                                by Premise,\n        2 #> Set.Elements.contain(r, e)                                                     by Premise,\n        3 #> SeqUtil.IS.unique(r)                                                           by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != e) ->: Set.Elements.contain(elements, r(j)))        by Premise,\n        5 #> ∀(elements.indices)(j => Set.Elements.contain(r, elements(j)))                 by Premise,\n        //@formatter:on\n      )\n      r\n    }\n    return Set(newElements)\n  }\n\n  @pure def ++[I](is: IS[I, T]): Set[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size == elements.size | Set.elementsOf(Res).size == elements.size - 1,\n        ∀(Set.elementsOf(Res).indices)(j => Set.elementsOf(Res)(j) != e & Set.Elements.contain(elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => (elements(j) != e) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(newElements.indices)(j => newElements(j) != e & Set.Elements.contain(elements, newElements(j))),\n        ∃(0 until i)(j => e == elements(j)) ->: (newElements.size == i - 1),\n        ∀(0 until i)(j => e != elements(j)) ->: (newElements.size == i),\n        ∀(0 until i)(j => (e != elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val kv = elements(i)\n      if (kv != e) {\n        newElements = newElements :+ kv\n      }\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def --[I](is: IS[I, T]): Set[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    Contract(Ensures(Res == Set.Elements.contain(elements, e)))\n    return indexOf(e) >= 0\n  }\n\n  @pure def union(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size >= elements.size,\n        Set.elementsOf(Res).size <= elements.size + other.elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) |\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => elements(j) == Set.elementsOf(Res)(j)),\n        ∀(other.elements.indices)(j => Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = elements\n    var i: Z = 0\n    while (i < other.elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= other.elements.size,\n        newElements.size >= elements.size,\n        newElements.size <= elements.size + i,\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j)) |\n          Set.Elements.contain(other.elements, newElements(j))),\n        ∀(elements.indices)(j => elements(j) == newElements(j)),\n        ∀(elements.size until newElements.size)(j =>\n          ∀(i until other.elements.size)(k => newElements(j) != other.elements(k))),\n        ∀(0 until i)(j => Set.Elements.contain(newElements, other.elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val e = other.elements(i)\n      if (!contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          1 #> ∀(0 to i)(j => Set.Elements.contain(newElements, other.elements(j)))         by Premise,\n        )\n      } else {\n        Deduce(\n          1 #> ∀(0 to i)(j => Set.Elements.contain(newElements, other.elements(j)))         by Premise,\n        )\n      }\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def ∪(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size >= elements.size,\n        Set.elementsOf(Res).size <= elements.size + other.elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) |\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => elements(j) == Set.elementsOf(Res)(j)),\n        ∀(other.elements.indices)(j => Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    return union(other)\n  }\n\n  @pure def intersect(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j =>\n          Set.Elements.contain(elements, other.elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        newElements.size <= i,\n        ∀(newElements.indices)(j => Set.Elements.contain(other.elements, newElements(j))),\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j))),\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(0 until i)(j => Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements)\n      )\n      val e = elements(i)\n      if (other.contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          //@formatter:off\n          1 #> ∀(0 to i)(j => Set.Elements.contain(other.elements, elements(j)) ->:\n            Set.Elements.contain(newElements, elements(j)))                                 by Premise,\n          2 #> Set.Elements.unique(newElements)                                             by Premise\n          //@formatter:on\n        )\n      }\n\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def ∩(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j =>\n          Set.Elements.contain(elements, other.elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    return intersect(other)\n  }\n\n  @pure def \\(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            !Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          !Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j => !Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        newElements.size <= i,\n        ∀(newElements.indices)(j => !Set.Elements.contain(other.elements, newElements(j))),\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j))),\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(0 until i)(j => !Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val e = elements(i)\n      if (!other.contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          //@formatter:off\n          1 #> ∀(0 to i)(j => !Set.Elements.contain(other.elements, elements(j)) ->:\n            Set.Elements.contain(newElements, elements(j)))                                 by Premise,\n          2 #> Set.Elements.unique(newElements)                                             by Premise\n          //@formatter:on\n        )\n      }\n\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def isEqual(other: Set[T]): B = {\n    Contract(\n      Case(\n        \"Equal\",\n        Requires(\n          elements. size == other.elements.size,\n          ∀(elements.indices)(j => Set.Elements.contain(other.elements, elements(j))),\n        ),\n        Ensures(Res[B])\n      ),\n      Case(\n        \"Inequal-diff\",\n        Requires(\n          elements.size == other.elements.size,\n          ∃(elements.indices)(j => !Set.Elements.contain(other.elements, elements(j))),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-size\",\n        Requires(elements.size != other.elements.size),\n        Ensures(!Res[B])\n      )\n    )\n    val sz = size\n    if (sz != other.size) {\n      return F\n    } else {\n      var i: Z = 0\n      var r = T\n      while (r & i < sz) {\n        Invariant(\n          Modifies(i, r),\n          0 <= i,\n          i <= sz,\n          r ->: ∀(0 until i)(j => Set.Elements.contain(other.elements, elements(j))),\n          !r ->: ∃(elements.indices)(j => !Set.Elements.contain(other.elements, elements(j)))\n        )\n        if (!other.contains(elements(i))) {\n          r = F\n        }\n        i = i + 1\n      }\n\n      return r\n    }\n  }\n\n  @pure override def hash: Z = {\n    return elements.hash\n  }\n\n  @pure def isEmpty: B = {\n    Contract(Ensures(Res == (elements.size == 0)))\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    Contract(Ensures(Res == (elements.size != 0)))\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    Contract(Ensures(Res == elements.size))\n    return elements.size\n  }\n\n  @pure def indexOf(e: T): Z = {\n    Contract(\n      Case(\n        \"In\",\n        Requires(Set.Elements.contain(elements, e)),\n        Ensures(\n          0 <= Res[Z],\n          Res[Z] < elements.size,\n          elements(Res[Z]) == e\n        )\n      ),\n      Case(\n        \"Not-in\",\n        Requires(!Set.Elements.contain(elements, e)),\n        Ensures(Res[Z] == -1)\n      )\n    )\n    var index: Z = -1\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(index, i),\n        0 <= i,\n        i <= elements.size,\n        (index != -1) ->: (0 <= index & index < elements.size & elements(index) == e),\n        (index == -1) ->: ∀(0 until i)(j => e != elements(j))\n      )\n      if (elements(i) == e) {\n        index = i\n        i = elements.size - 1\n      }\n      i = i + 1\n    }\n    return index\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
  #771 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject ContractUtil {\n\n  @strictpure def modPos(n: Z, m: Z): Z = if (n < m) n else n - m\n\n  @strictpure def modNeg(n: Z, m: Z): Z = if (n < 0) n + m else n\n\n  @strictpure def isEqualExcept[I, T](s1: IS[I, T], s2: IS[I, T], i: I): B =\n    s1.size == s2.size & All(s1.indices)(j => (j != i) ->: (s1(j) == s2(j)))\n\n  @strictpure def isEqualExcept2[I, T](s1: IS[I, T], s2: IS[I, T], i1: I, i2: I): B =\n    s1.size == s2.size & All(s1.indices)(j => ((j != i1) & (j != i2)) ->: (s1(j) == s2(j)))\n\n  @strictpure def msEqualExcept[I, T](s1: MS[I, T], s2: MS[I, T], i: I): B =\n    s1.size == s2.size & All(s1.indices)(j => (j != i) ->: (s1(j) == s2(j)))\n\n  @strictpure def msEqualExcept2[I, T](s1: MS[I, T], s2: MS[I, T], i1: I, i2: I): B =\n    s1.size == s2.size & All(s1.indices)(j => ((j != i1) & (j != i2)) ->: (s1(j) == s2(j)))\n\n  @strictpure def isAllIS[I, T](s: IS[I, T], e: T): B = All(s.indices)(i => s(i) == e)\n\n  @strictpure def isAllMS[I, T](s: MS[I, T], e: T): B = All(s.indices)(i => s(i) == e)\n}\n
  #772 = String             #771          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject ContractUtil {\n\n  @strictpure def modPos(n: Z, m: Z): Z = if (n < m) n else n - m\n\n  @strictpure def modNeg(n: Z, m: Z): Z = if (n < 0) n + m else n\n\n  @strictpure def isEqualExcept[I, T](s1: IS[I, T], s2: IS[I, T], i: I): B =\n    s1.size == s2.size & All(s1.indices)(j => (j != i) ->: (s1(j) == s2(j)))\n\n  @strictpure def isEqualExcept2[I, T](s1: IS[I, T], s2: IS[I, T], i1: I, i2: I): B =\n    s1.size == s2.size & All(s1.indices)(j => ((j != i1) & (j != i2)) ->: (s1(j) == s2(j)))\n\n  @strictpure def msEqualExcept[I, T](s1: MS[I, T], s2: MS[I, T], i: I): B =\n    s1.size == s2.size & All(s1.indices)(j => (j != i) ->: (s1(j) == s2(j)))\n\n  @strictpure def msEqualExcept2[I, T](s1: MS[I, T], s2: MS[I, T], i1: I, i2: I): B =\n    s1.size == s2.size & All(s1.indices)(j => ((j != i1) & (j != i2)) ->: (s1(j) == s2(j)))\n\n  @strictpure def isAllIS[I, T](s: IS[I, T], e: T): B = All(s.indices)(i => s(i) == e)\n\n  @strictpure def isAllMS[I, T](s: MS[I, T], e: T): B = All(s.indices)(i => s(i) == e)\n}\n
  #773 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Poset {\n\n  type Index = Z\n\n  object Internal {\n\n    val emptySet: HashSSet[Poset.Index] = HashSSet.empty\n\n    @pure def addNode[T](poset: Poset[T], node: T): (Poset[T], Index) = {\n      poset.nodes.get(node) match {\n        case Some(n) => return (poset, n)\n        case _ =>\n          val n = poset.nodes.size\n          return (\n            poset(\n              nodes = poset.nodes + node ~> n,\n              nodesInverse = poset.nodesInverse :+ node,\n              parents = poset.parents + n ~> emptySet,\n              children = poset.children + n ~> emptySet\n            ),\n            n\n          )\n      }\n    }\n\n    @pure def addNodes[T](poset: Poset[T], nodes: ISZ[T]): (Poset[T], ISZ[Index]) = {\n      var r = poset\n      val s = ZS.create(nodes.size, 0)\n      var i = 0\n      for (nd <- nodes) {\n        val p = addNode(r, nd)\n        r = p._1\n        s(i) = p._2\n        i = i + 1\n      }\n      return (r, s.toIS)\n    }\n\n    @pure def addParents[T](poset: Poset[T], n: Index, ns: ISZ[Index]): Poset[T] = {\n      var changed = F\n      val newParents: HashSMap[Index, HashSSet[Index]] = {\n        val s = poset.parents.get(n).get\n        val newS = s ++ ns\n        if (newS.size != s.size) {\n          changed = T\n          poset.parents + n ~> newS\n        } else {\n          poset.parents\n        }\n      }\n      var newChildren: HashSMap[Index, HashSSet[Index]] = poset.children\n      for (c <- ns) {\n        newChildren = {\n          val s = newChildren.get(c).get\n          val newS = s + n\n          if (newS.size != s.size) {\n            changed = T\n            newChildren + c ~> newS\n          } else {\n            newChildren\n          }\n        }\n      }\n      return if (changed) poset(parents = newParents, children = newChildren) else poset\n    }\n\n    @pure def removeParent[T](poset: Poset[T], n: Index, parent: Index): Poset[T] = {\n      poset.parents.get(n) match {\n        case Some(s) =>\n          return poset(\n            parents = poset.parents + n ~> (s - parent),\n            children = poset.children + parent ~> (poset.children.get(parent).get - n)\n          )\n        case _ => return poset\n      }\n    }\n\n    @pure def addChildren[T](poset: Poset[T], n: Index, ns: ISZ[Index]): Poset[T] = {\n      var changed = F\n      val newChildren: HashSMap[Index, HashSSet[Index]] = {\n        val s = poset.children.get(n).get\n        val newS = s ++ ns\n        if (newS.size != s.size) {\n          changed = T\n          poset.children + n ~> newS\n        } else {\n          poset.children\n        }\n      }\n      var newParents: HashSMap[Index, HashSSet[Index]] = poset.parents\n      for (c <- ns) {\n        newParents = {\n          val s = newParents.get(c).get\n          val newS = s + n\n          if (newS.size != s.size) {\n            changed = T\n            newParents + c ~> newS\n          } else {\n            newParents\n          }\n        }\n      }\n      return if (changed) poset(parents = newParents, children = newChildren) else poset\n    }\n\n    @pure def childrenOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      poset.children.get(n) match {\n        case Some(s) => return s\n        case _ => return emptySet\n      }\n    }\n\n    @pure def parentsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      poset.parents.get(n) match {\n        case Some(s) => return s\n        case _ => return emptySet\n      }\n    }\n\n    @pure def ancestorsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      return ancestorsCache[T](poset, n, HashSMap.empty)._1\n    }\n\n    @pure def ancestorsCache[T](\n      poset: Poset[T],\n      n: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): (HashSSet[Index], HashSMap[Index, HashSSet[Index]]) = {\n      var mAcc = acc\n      var r = emptySet\n      for (nParent <- parentsOf(poset, n).elements) {\n        mAcc = ancestorsRec(poset, nParent, mAcc)\n        r = (r + nParent) ∪ mAcc.get(nParent).getOrElse(emptySet)\n      }\n      return (r, mAcc)\n    }\n\n    @pure def ancestorsRec[T](\n      poset: Poset[T],\n      m: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): HashSMap[Index, HashSSet[Index]] = {\n      if (acc.contains(m)) {\n        return acc\n      }\n      val p = ancestorsCache(poset, m, acc + m ~> emptySet)\n      val mAncestors = p._1\n      val mAcc = p._2\n      return mAcc + m ~> mAncestors\n    }\n\n    @pure def lub[T](poset: Poset[T], ns: ISZ[Index]): Option[Index] = {\n      ns.size match {\n        case z\"0\" => return None()\n        case z\"1\" => return Some(ns(0))\n        case _ =>\n      }\n      if ((HashSSet ++ ns).size == 1) {\n        return Some(ns(0))\n      }\n      val p0 = ancestorsCache[T](poset, ns(0), HashSMap.empty)\n      var commons = p0._1 + ns(0)\n      var acc = p0._2\n      for (i <- z\"1\" until ns.size) {\n        val p = ancestorsCache(poset, ns(i), acc)\n        acc = p._2\n        commons = commons ∩ (p._1 + ns(i))\n      }\n      if (commons.isEmpty) {\n        return None()\n      }\n      for (b1 <- commons.elements) {\n        for (b2 <- commons.elements if b1 != b2) {\n          if (ancestorsCache(poset, b1, acc)._1.contains(b2)) {\n            commons = commons - b2\n          }\n        }\n      }\n      if (commons.size == 1) {\n        return Some(commons.elements(0))\n      } else {\n        return None()\n      }\n    }\n\n    @pure def descendantsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      return descendantsCache[T](poset, n, HashSMap.empty)._1\n    }\n\n    @pure def descendantsCache[T](\n      poset: Poset[T],\n      n: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): (HashSSet[Index], HashSMap[Index, HashSSet[Index]]) = {\n      var mAcc = acc\n      var r = emptySet\n      for (nChild <- childrenOf(poset, n).elements) {\n        mAcc = descendantsRec(poset, nChild, mAcc)\n        r = (r + nChild) ∪ mAcc.get(nChild).getOrElse(emptySet)\n      }\n      return (r, mAcc)\n    }\n\n    @pure def descendantsRec[T](\n      poset: Poset[T],\n      m: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): HashSMap[Index, HashSSet[Index]] = {\n      if (acc.contains(m)) {\n        return acc\n      }\n      val p = descendantsCache(poset, m, acc + m ~> emptySet)\n      val mDescendants = p._1\n      val mAcc = p._2\n      return mAcc + m ~> mDescendants\n    }\n\n    @pure def glb[T](poset: Poset[T], ns: ISZ[Index]): Option[Index] = {\n      ns.size match {\n        case z\"0\" => return None()\n        case z\"1\" => return Some(ns(0))\n        case _ =>\n      }\n      if ((HashSSet.empty[Index] ++ ns).size == 1) {\n        return Some(ns(0))\n      }\n      val p0 = descendantsCache[T](poset, ns(0), HashSMap.empty)\n      var commons = p0._1 + ns(0)\n      var acc = p0._2\n      for (i <- z\"1\" until ns.size) {\n        val p = descendantsCache(poset, ns(i), acc)\n        acc = p._2\n        commons = commons ∩ (p._1 + ns(i))\n      }\n      if (commons.isEmpty) {\n        return None()\n      }\n      for (b1 <- commons.elements) {\n        for (b2 <- commons.elements if b1 != b2) {\n          if (descendantsCache(poset, b1, acc)._1.contains(b2)) {\n            commons = commons - b2\n          }\n        }\n      }\n      if (commons.size == 1) {\n        return Some(commons.elements(0))\n      } else {\n        return None()\n      }\n    }\n  }\n\n  def empty[T]: Poset[T] = {\n    return Poset[T](HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty)\n  }\n}\n\nimport Poset._\n\n@datatype class Poset[T](\n  val nodes: HashSMap[T, Poset.Index],\n  val nodesInverse: IS[Poset.Index, T],\n  val parents: HashSMap[Poset.Index, HashSSet[Poset.Index]],\n  val children: HashSMap[Poset.Index, HashSSet[Poset.Index]]\n) {\n\n  val emptySet: HashSSet[T] = HashSSet.empty\n\n  @pure def size: Z = {\n    return nodes.size\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: Poset[T]): B = {\n    if (nodesInverse != other.nodesInverse) {\n      return F\n    }\n    for (node <- nodes.keys) {\n      val n = nodes.get(node).get\n      val m = other.nodes.get(node).get\n      val nParents = HashSSet ++ parents.get(n).get.elements.map[T](np => nodesInverse(np))\n      val mParents = HashSSet ++ other.parents.get(m).get.elements.map[T](mp => other.nodesInverse(mp))\n      if (nParents != mParents) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def addNode(node: T): Poset[T] = {\n    return Poset.Internal.addNode(this, node)._1\n  }\n\n  @pure def rootNodes: ISZ[T] = {\n    return for (e <- parents.entries if e._2.isEmpty) yield nodesInverse(e._1)\n  }\n\n  @pure def addParents(node: T, nds: ISZ[T]): Poset[T] = {\n    var r = this\n    val n: Index = {\n      val p = Poset.Internal.addNode(r, node)\n      r = p._1\n      p._2\n    }\n    val ns: ISZ[Index] = {\n      val p = Poset.Internal.addNodes(r, nds)\n      r = p._1\n      p._2\n    }\n    return Poset.Internal.addParents(r, n, ns)\n  }\n\n  @pure def removeParent(node: T, parent: T): Poset[T] = {\n    (nodes.get(node), nodes.get(parent)) match {\n      case (Some(n), Some(p)) => return Poset.Internal.removeParent(this, n, p)\n      case _ => return this\n    }\n  }\n\n  @pure def removeChild(n: T, child: T): Poset[T] = {\n    return removeParent(child, n)\n  }\n\n  @pure def addChildren(node: T, nds: ISZ[T]): Poset[T] = {\n    var r = this\n    val n: Index = {\n      val p = Poset.Internal.addNode(r, node)\n      r = p._1\n      p._2\n    }\n    val ns: ISZ[Index] = {\n      val p = Poset.Internal.addNodes(r, nds)\n      r = p._1\n      p._2\n    }\n    return Poset.Internal.addChildren(r, n, ns)\n  }\n\n  @pure def childrenOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.childrenOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def isChildOf(node1: T, node2: T): B = {\n    (nodes.get(node1), nodes.get(node2)) match {\n      case (Some(n1), Some(n2)) => return Poset.Internal.childrenOf(this, n1).contains(n2)\n      case _ => return F\n    }\n  }\n\n  @pure def parentsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.parentsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def isParentOf(node1: T, node2: T): B = {\n    return isChildOf(node2, node1)\n  }\n\n  @pure def ancestorsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.ancestorsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def lub(nds: ISZ[T]): Option[T] = {\n    val ns: ISZ[Index] = for (node <- nds; n <- nodes.get(node).toIS) yield n\n    return Poset.Internal.lub(this, ns).map(n => nodesInverse(n))\n  }\n\n  @pure def descendantsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.descendantsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def glb(nds: ISZ[T]): Option[T] = {\n    val ns: ISZ[Index] = for (node <- nds; n <- nodes.get(node).toIS) yield n\n    return Poset.Internal.glb(this, ns).map(n => nodesInverse(n))\n  }\n\n  @pure def toST(f: T => ST): ST = {\n    val nodes: ISZ[ST] = for (e <- this.nodes.entries) yield st\"n${e._2} ${f(e._1)}\"\n    val edges: ISZ[ST] = for (entry <- parents.entries; parent <- entry._2.elements) yield st\"n${entry._1} -> n$parent\"\n    val r =\n      st\"\"\"digraph G {\n      |  rankdir=\"BT\"\n      |\n      |  ${(nodes, \"\\n\")}\n      |\n      |  ${(edges, \"\\n\")}\n      |}\"\"\"\n    return r\n  }\n\n  @pure override def string: String = {\n    return toST(node => st\"\"\"[label=\"$node\"]\"\"\").render\n  }\n}\n
  #774 = String             #773          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Poset {\n\n  type Index = Z\n\n  object Internal {\n\n    val emptySet: HashSSet[Poset.Index] = HashSSet.empty\n\n    @pure def addNode[T](poset: Poset[T], node: T): (Poset[T], Index) = {\n      poset.nodes.get(node) match {\n        case Some(n) => return (poset, n)\n        case _ =>\n          val n = poset.nodes.size\n          return (\n            poset(\n              nodes = poset.nodes + node ~> n,\n              nodesInverse = poset.nodesInverse :+ node,\n              parents = poset.parents + n ~> emptySet,\n              children = poset.children + n ~> emptySet\n            ),\n            n\n          )\n      }\n    }\n\n    @pure def addNodes[T](poset: Poset[T], nodes: ISZ[T]): (Poset[T], ISZ[Index]) = {\n      var r = poset\n      val s = ZS.create(nodes.size, 0)\n      var i = 0\n      for (nd <- nodes) {\n        val p = addNode(r, nd)\n        r = p._1\n        s(i) = p._2\n        i = i + 1\n      }\n      return (r, s.toIS)\n    }\n\n    @pure def addParents[T](poset: Poset[T], n: Index, ns: ISZ[Index]): Poset[T] = {\n      var changed = F\n      val newParents: HashSMap[Index, HashSSet[Index]] = {\n        val s = poset.parents.get(n).get\n        val newS = s ++ ns\n        if (newS.size != s.size) {\n          changed = T\n          poset.parents + n ~> newS\n        } else {\n          poset.parents\n        }\n      }\n      var newChildren: HashSMap[Index, HashSSet[Index]] = poset.children\n      for (c <- ns) {\n        newChildren = {\n          val s = newChildren.get(c).get\n          val newS = s + n\n          if (newS.size != s.size) {\n            changed = T\n            newChildren + c ~> newS\n          } else {\n            newChildren\n          }\n        }\n      }\n      return if (changed) poset(parents = newParents, children = newChildren) else poset\n    }\n\n    @pure def removeParent[T](poset: Poset[T], n: Index, parent: Index): Poset[T] = {\n      poset.parents.get(n) match {\n        case Some(s) =>\n          return poset(\n            parents = poset.parents + n ~> (s - parent),\n            children = poset.children + parent ~> (poset.children.get(parent).get - n)\n          )\n        case _ => return poset\n      }\n    }\n\n    @pure def addChildren[T](poset: Poset[T], n: Index, ns: ISZ[Index]): Poset[T] = {\n      var changed = F\n      val newChildren: HashSMap[Index, HashSSet[Index]] = {\n        val s = poset.children.get(n).get\n        val newS = s ++ ns\n        if (newS.size != s.size) {\n          changed = T\n          poset.children + n ~> newS\n        } else {\n          poset.children\n        }\n      }\n      var newParents: HashSMap[Index, HashSSet[Index]] = poset.parents\n      for (c <- ns) {\n        newParents = {\n          val s = newParents.get(c).get\n          val newS = s + n\n          if (newS.size != s.size) {\n            changed = T\n            newParents + c ~> newS\n          } else {\n            newParents\n          }\n        }\n      }\n      return if (changed) poset(parents = newParents, children = newChildren) else poset\n    }\n\n    @pure def childrenOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      poset.children.get(n) match {\n        case Some(s) => return s\n        case _ => return emptySet\n      }\n    }\n\n    @pure def parentsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      poset.parents.get(n) match {\n        case Some(s) => return s\n        case _ => return emptySet\n      }\n    }\n\n    @pure def ancestorsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      return ancestorsCache[T](poset, n, HashSMap.empty)._1\n    }\n\n    @pure def ancestorsCache[T](\n      poset: Poset[T],\n      n: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): (HashSSet[Index], HashSMap[Index, HashSSet[Index]]) = {\n      var mAcc = acc\n      var r = emptySet\n      for (nParent <- parentsOf(poset, n).elements) {\n        mAcc = ancestorsRec(poset, nParent, mAcc)\n        r = (r + nParent) ∪ mAcc.get(nParent).getOrElse(emptySet)\n      }\n      return (r, mAcc)\n    }\n\n    @pure def ancestorsRec[T](\n      poset: Poset[T],\n      m: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): HashSMap[Index, HashSSet[Index]] = {\n      if (acc.contains(m)) {\n        return acc\n      }\n      val p = ancestorsCache(poset, m, acc + m ~> emptySet)\n      val mAncestors = p._1\n      val mAcc = p._2\n      return mAcc + m ~> mAncestors\n    }\n\n    @pure def lub[T](poset: Poset[T], ns: ISZ[Index]): Option[Index] = {\n      ns.size match {\n        case z\"0\" => return None()\n        case z\"1\" => return Some(ns(0))\n        case _ =>\n      }\n      if ((HashSSet ++ ns).size == 1) {\n        return Some(ns(0))\n      }\n      val p0 = ancestorsCache[T](poset, ns(0), HashSMap.empty)\n      var commons = p0._1 + ns(0)\n      var acc = p0._2\n      for (i <- z\"1\" until ns.size) {\n        val p = ancestorsCache(poset, ns(i), acc)\n        acc = p._2\n        commons = commons ∩ (p._1 + ns(i))\n      }\n      if (commons.isEmpty) {\n        return None()\n      }\n      for (b1 <- commons.elements) {\n        for (b2 <- commons.elements if b1 != b2) {\n          if (ancestorsCache(poset, b1, acc)._1.contains(b2)) {\n            commons = commons - b2\n          }\n        }\n      }\n      if (commons.size == 1) {\n        return Some(commons.elements(0))\n      } else {\n        return None()\n      }\n    }\n\n    @pure def descendantsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      return descendantsCache[T](poset, n, HashSMap.empty)._1\n    }\n\n    @pure def descendantsCache[T](\n      poset: Poset[T],\n      n: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): (HashSSet[Index], HashSMap[Index, HashSSet[Index]]) = {\n      var mAcc = acc\n      var r = emptySet\n      for (nChild <- childrenOf(poset, n).elements) {\n        mAcc = descendantsRec(poset, nChild, mAcc)\n        r = (r + nChild) ∪ mAcc.get(nChild).getOrElse(emptySet)\n      }\n      return (r, mAcc)\n    }\n\n    @pure def descendantsRec[T](\n      poset: Poset[T],\n      m: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): HashSMap[Index, HashSSet[Index]] = {\n      if (acc.contains(m)) {\n        return acc\n      }\n      val p = descendantsCache(poset, m, acc + m ~> emptySet)\n      val mDescendants = p._1\n      val mAcc = p._2\n      return mAcc + m ~> mDescendants\n    }\n\n    @pure def glb[T](poset: Poset[T], ns: ISZ[Index]): Option[Index] = {\n      ns.size match {\n        case z\"0\" => return None()\n        case z\"1\" => return Some(ns(0))\n        case _ =>\n      }\n      if ((HashSSet.empty[Index] ++ ns).size == 1) {\n        return Some(ns(0))\n      }\n      val p0 = descendantsCache[T](poset, ns(0), HashSMap.empty)\n      var commons = p0._1 + ns(0)\n      var acc = p0._2\n      for (i <- z\"1\" until ns.size) {\n        val p = descendantsCache(poset, ns(i), acc)\n        acc = p._2\n        commons = commons ∩ (p._1 + ns(i))\n      }\n      if (commons.isEmpty) {\n        return None()\n      }\n      for (b1 <- commons.elements) {\n        for (b2 <- commons.elements if b1 != b2) {\n          if (descendantsCache(poset, b1, acc)._1.contains(b2)) {\n            commons = commons - b2\n          }\n        }\n      }\n      if (commons.size == 1) {\n        return Some(commons.elements(0))\n      } else {\n        return None()\n      }\n    }\n  }\n\n  def empty[T]: Poset[T] = {\n    return Poset[T](HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty)\n  }\n}\n\nimport Poset._\n\n@datatype class Poset[T](\n  val nodes: HashSMap[T, Poset.Index],\n  val nodesInverse: IS[Poset.Index, T],\n  val parents: HashSMap[Poset.Index, HashSSet[Poset.Index]],\n  val children: HashSMap[Poset.Index, HashSSet[Poset.Index]]\n) {\n\n  val emptySet: HashSSet[T] = HashSSet.empty\n\n  @pure def size: Z = {\n    return nodes.size\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: Poset[T]): B = {\n    if (nodesInverse != other.nodesInverse) {\n      return F\n    }\n    for (node <- nodes.keys) {\n      val n = nodes.get(node).get\n      val m = other.nodes.get(node).get\n      val nParents = HashSSet ++ parents.get(n).get.elements.map[T](np => nodesInverse(np))\n      val mParents = HashSSet ++ other.parents.get(m).get.elements.map[T](mp => other.nodesInverse(mp))\n      if (nParents != mParents) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def addNode(node: T): Poset[T] = {\n    return Poset.Internal.addNode(this, node)._1\n  }\n\n  @pure def rootNodes: ISZ[T] = {\n    return for (e <- parents.entries if e._2.isEmpty) yield nodesInverse(e._1)\n  }\n\n  @pure def addParents(node: T, nds: ISZ[T]): Poset[T] = {\n    var r = this\n    val n: Index = {\n      val p = Poset.Internal.addNode(r, node)\n      r = p._1\n      p._2\n    }\n    val ns: ISZ[Index] = {\n      val p = Poset.Internal.addNodes(r, nds)\n      r = p._1\n      p._2\n    }\n    return Poset.Internal.addParents(r, n, ns)\n  }\n\n  @pure def removeParent(node: T, parent: T): Poset[T] = {\n    (nodes.get(node), nodes.get(parent)) match {\n      case (Some(n), Some(p)) => return Poset.Internal.removeParent(this, n, p)\n      case _ => return this\n    }\n  }\n\n  @pure def removeChild(n: T, child: T): Poset[T] = {\n    return removeParent(child, n)\n  }\n\n  @pure def addChildren(node: T, nds: ISZ[T]): Poset[T] = {\n    var r = this\n    val n: Index = {\n      val p = Poset.Internal.addNode(r, node)\n      r = p._1\n      p._2\n    }\n    val ns: ISZ[Index] = {\n      val p = Poset.Internal.addNodes(r, nds)\n      r = p._1\n      p._2\n    }\n    return Poset.Internal.addChildren(r, n, ns)\n  }\n\n  @pure def childrenOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.childrenOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def isChildOf(node1: T, node2: T): B = {\n    (nodes.get(node1), nodes.get(node2)) match {\n      case (Some(n1), Some(n2)) => return Poset.Internal.childrenOf(this, n1).contains(n2)\n      case _ => return F\n    }\n  }\n\n  @pure def parentsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.parentsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def isParentOf(node1: T, node2: T): B = {\n    return isChildOf(node2, node1)\n  }\n\n  @pure def ancestorsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.ancestorsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def lub(nds: ISZ[T]): Option[T] = {\n    val ns: ISZ[Index] = for (node <- nds; n <- nodes.get(node).toIS) yield n\n    return Poset.Internal.lub(this, ns).map(n => nodesInverse(n))\n  }\n\n  @pure def descendantsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.descendantsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def glb(nds: ISZ[T]): Option[T] = {\n    val ns: ISZ[Index] = for (node <- nds; n <- nodes.get(node).toIS) yield n\n    return Poset.Internal.glb(this, ns).map(n => nodesInverse(n))\n  }\n\n  @pure def toST(f: T => ST): ST = {\n    val nodes: ISZ[ST] = for (e <- this.nodes.entries) yield st\"n${e._2} ${f(e._1)}\"\n    val edges: ISZ[ST] = for (entry <- parents.entries; parent <- entry._2.elements) yield st\"n${entry._1} -> n$parent\"\n    val r =\n      st\"\"\"digraph G {\n      |  rankdir=\"BT\"\n      |\n      |  ${(nodes, \"\\n\")}\n      |\n      |  ${(edges, \"\\n\")}\n      |}\"\"\"\n    return r\n  }\n\n  @pure override def string: String = {\n    return toST(node => st\"\"\"[label=\"$node\"]\"\"\").render\n  }\n}\n
  #775 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n@ext object Asm {\n  def eraseNonNative(path: Os.Path): Unit = $\n  def rewriteReleaseFence(path: Os.Path): Unit = $\n  def rewriteSetSecurityManager(path: Os.Path): Unit = $\n}\n
  #776 = String             #775          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n@ext object Asm {\n  def eraseNonNative(path: Os.Path): Unit = $\n  def rewriteReleaseFence(path: Os.Path): Unit = $\n  def rewriteSetSecurityManager(path: Os.Path): Unit = $\n}\n
  #777 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.project\n\nimport org.sireum._\nimport org.sireum.project.PublishInfo._\n\nobject ProjectUtil {\n\n  val sharedSuffix: String = \"shared\"\n  val jvmSuffix: String = \"jvm\"\n  val jsSuffix: String = \"js\"\n\n  val bsd2License: License = License(\n    name = \"BSD 2-Clause\",\n    url = \"https://github.com/sireum/kekinian/blob/master/license.txt\",\n    distribution = \"repo\"\n  )\n  val bsd2: ISZ[License] = ISZ(bsd2License)\n\n  val robby: Developer = Developer(id = \"robby-phd\", name = \"Robby\")\n  val johnHatcliff: Developer = Developer(id = \"John-Hatcliff\", name = \"John Hatcliff\")\n  val jasonBelt: Developer = Developer(id = \"jasonbelt\", name = \"Jason Belt\")\n  val thari: Developer = Developer(id = \"thari\", name = \"Hariharan Thiagarajan\")\n  val matthewWeis: Developer = Developer(id = \"matthewweis\", name = \"Matthew Weis\")\n\n  @strictpure def id(baseId: String): ISZ[String] = ISZ(baseId)\n\n  @strictpure def sharedId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$sharedSuffix\")\n\n  @strictpure def jvmId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$jvmSuffix\")\n\n  @strictpure def jsId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$jsSuffix\")\n\n  @strictpure def sharedJvmId(baseId: String): ISZ[String] = sharedId(baseId) ++ jvmId(baseId)\n\n  @strictpure def sharedJsId(baseId: String): ISZ[String] = sharedId(baseId) ++ jsId(baseId)\n\n  def dirs(base: Os.Path, segss: ISZ[ISZ[String]]): ISZ[String] = {\n    var r = ISZ[String]()\n    for (segs <- segss) {\n      r = r :+ st\"${(segs, Os.fileSep)}\".render\n    }\n    return r\n  }\n\n  def mavenSourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(\n      ISZ(\"src\", \"main\", \"java\"),\n      ISZ(\"src\", \"main\", \"scala\")))\n  }\n\n  def mavenTestSourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(\n      ISZ(\"src\", \"test\", \"java\"),\n      ISZ(\"src\", \"test\", \"scala\")))\n  }\n\n  def mavenResourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(ISZ(\"src\", \"main\", \"resources\")))\n  }\n\n  def mavenTestResourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(ISZ(\"src\", \"test\", \"resources\")))\n  }\n\n  @pure def moduleSharedPub(id: String,\n                            baseDir: Os.Path,\n                            sharedDeps: ISZ[String],\n                            sharedIvyDeps: ISZ[String],\n                            pubOpt: Option[PublishInfo]): Module = {\n    val sharedDir = baseDir / sharedSuffix\n    val shared = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$sharedSuffix\"),\n      deps = sharedDeps,\n      targets = Module.allTargets,\n      ivyDeps = sharedIvyDeps,\n      sources = mavenSourceDirs(sharedDir),\n      resources = mavenResourceDirs(sharedDir),\n      testSources = mavenTestSourceDirs(sharedDir),\n      testResources = mavenTestResourceDirs(sharedDir),\n      publishInfoOpt = pubOpt\n    )\n    return shared\n  }\n\n  @strictpure def moduleShared(id: String,\n                               baseDir: Os.Path,\n                               sharedDeps: ISZ[String],\n                               sharedIvyDeps: ISZ[String]): Module =\n    moduleSharedPub(\n      id = id,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleJvmPub(id: String,\n                         baseDir: Os.Path,\n                         jvmDeps: ISZ[String],\n                         jvmIvyDeps: ISZ[String],\n                         pubOpt: Option[PublishInfo]): Module = {\n    val jvmDir = baseDir / jvmSuffix\n    val jvm = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$jvmSuffix\"),\n      deps = jvmDeps,\n      targets = ISZ(Target.Jvm),\n      ivyDeps = jvmIvyDeps,\n      sources = mavenSourceDirs(jvmDir),\n      resources = mavenResourceDirs(jvmDir),\n      testSources = mavenTestSourceDirs(jvmDir),\n      testResources = mavenTestResourceDirs(jvmDir),\n      publishInfoOpt = pubOpt\n    )\n    return jvm\n  }\n\n  @strictpure def moduleJvm(id: String,\n                            baseDir: Os.Path,\n                            jvmDeps: ISZ[String],\n                            jvmIvyDeps: ISZ[String]): Module =\n    moduleJvmPub(id, baseDir, jvmDeps, jvmIvyDeps, None())\n\n  @pure def moduleJsPub(id: String,\n                        baseDir: Os.Path,\n                        jsDeps: ISZ[String],\n                        jsIvyDeps: ISZ[String],\n                        pubOpt: Option[PublishInfo]): Module = {\n    val jsDir = baseDir / jsSuffix\n    val js = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$jsSuffix\"),\n      deps = jsDeps,\n      targets = ISZ(Target.Js),\n      ivyDeps = jsIvyDeps,\n      sources = mavenSourceDirs(jsDir),\n      resources = mavenResourceDirs(jsDir),\n      testSources = mavenTestSourceDirs(jsDir),\n      testResources = mavenTestResourceDirs(jsDir),\n      publishInfoOpt = pubOpt\n    )\n    return js\n  }\n\n  @strictpure def moduleJs(id: String,\n                           baseDir: Os.Path,\n                           jsDeps: ISZ[String],\n                           jsIvyDeps: ISZ[String]): Module =\n    moduleJsPub(\n      id = id,\n      baseDir = baseDir,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleSharedJvmPub(baseId: String,\n                               baseDir: Os.Path,\n                               sharedDeps: ISZ[String],\n                               sharedIvyDeps: ISZ[String],\n                               jvmDeps: ISZ[String],\n                               jvmIvyDeps: ISZ[String],\n                               pubOpt: Option[PublishInfo]): (Module, Module) = {\n    val shared = moduleSharedPub(s\"$baseId-$sharedSuffix\", baseDir, sharedDeps, sharedIvyDeps, pubOpt)\n    val jvm = moduleJvmPub(baseId, baseDir, jvmDeps :+ shared.id, jvmIvyDeps, pubOpt)\n    return (shared, jvm)\n  }\n\n  @strictpure def moduleSharedJvm(baseId: String,\n                                  baseDir: Os.Path,\n                                  sharedDeps: ISZ[String],\n                                  sharedIvyDeps: ISZ[String],\n                                  jvmDeps: ISZ[String],\n                                  jvmIvyDeps: ISZ[String]): (Module, Module) =\n    moduleSharedJvmPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jvmDeps = jvmDeps,\n      jvmIvyDeps = jvmIvyDeps,\n      pubOpt = None()\n    )\n\n\n  @pure def moduleSharedJsPub(baseId: String,\n                              baseDir: Os.Path,\n                              sharedDeps: ISZ[String],\n                              sharedIvyDeps: ISZ[String],\n                              jsDeps: ISZ[String],\n                              jsIvyDeps: ISZ[String],\n                              pubOpt: Option[PublishInfo]): (Module, Module) = {\n    val shared = moduleSharedPub(s\"$baseId-$sharedSuffix\", baseDir, sharedDeps, sharedIvyDeps, pubOpt)\n    val js = moduleJsPub(baseId, baseDir, jsDeps :+ shared.id, jsIvyDeps, pubOpt)\n    return (shared, js)\n  }\n\n  @strictpure def moduleSharedJs(baseId: String,\n                                 baseDir: Os.Path,\n                                 sharedDeps: ISZ[String],\n                                 sharedIvyDeps: ISZ[String],\n                                 jsDeps: ISZ[String],\n                                 jsIvyDeps: ISZ[String]): (Module, Module) =\n    moduleSharedJsPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleSharedJvmJsPub(baseId: String,\n                                 baseDir: Os.Path,\n                                 sharedDeps: ISZ[String],\n                                 sharedIvyDeps: ISZ[String],\n                                 jvmDeps: ISZ[String],\n                                 jvmIvyDeps: ISZ[String],\n                                 jsDeps: ISZ[String],\n                                 jsIvyDeps: ISZ[String],\n                                 pubOpt: Option[PublishInfo]): (Module, Module, Module) = {\n    val (shared, js) = moduleSharedJsPub(baseId, baseDir, sharedDeps, sharedIvyDeps, jsDeps, jsIvyDeps, pubOpt)\n    val jvm = moduleJvmPub(baseId, baseDir, jvmDeps :+ shared.id, jvmIvyDeps, pubOpt)\n    return (shared, jvm, js(id = s\"$baseId-$jsSuffix\"))\n  }\n\n  @strictpure def moduleSharedJvmJs(baseId: String,\n                                    baseDir: Os.Path,\n                                    sharedDeps: ISZ[String],\n                                    sharedIvyDeps: ISZ[String],\n                                    jvmDeps: ISZ[String],\n                                    jvmIvyDeps: ISZ[String],\n                                    jsDeps: ISZ[String],\n                                    jsIvyDeps: ISZ[String]): (Module, Module, Module) =\n    moduleSharedJvmJsPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jvmDeps = jvmDeps,\n      jvmIvyDeps = jvmIvyDeps,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @strictpure def pub(desc: String,\n                      url: String,\n                      licenses: ISZ[PublishInfo.License],\n                      devs: ISZ[PublishInfo.Developer]): Option[PublishInfo] =\n    Some(\n      PublishInfo(\n        description = desc,\n        url = url,\n        licenses = licenses,\n        developers = devs\n      )\n    )\n\n  @pure def toDot(p: Project): String = {\n    @pure def node2st(name: String): ST = {\n      p.modules.get(name) match {\n        case Some(m) =>\n          val targets = HashSet.empty[Target.Type] ++ m.targets\n          if (targets.contains(Target.Jvm) && targets.contains(Target.Js)) {\n            return st\"\"\"[shape = \"rect\", label=\"$name\"]\"\"\"\n          } else if (targets.contains(Target.Jvm)) {\n            return st\"\"\"[shape = \"trapezium\", label=\"$name\"]\"\"\"\n          } else {\n            return st\"\"\"[shape = \"invtrapezium\", label=\"$name\"]\"\"\"\n          }\n        case _ => return st\"\"\"[shape = \"octagon\", label=\"$name\"]\"\"\"\n      }\n    }\n\n    return p.poset.toST(node2st _).render\n  }\n\n  def projectCli(args: ISZ[String], project: Project): Unit = {\n\n    def usage(): Unit = {\n      println(\"Usage: [ json ]\")\n    }\n\n    var isDot = T\n\n    args match {\n      case ISZ(string\"json\") => isDot = F\n      case ISZ(string\"-h\") =>\n        usage()\n        Os.exit(0)\n      case ISZ() =>\n      case _ =>\n        usage()\n        Os.exit(-1)\n    }\n\n    if (isDot) {\n      println(toDot(project))\n    } else {\n      println(JSON.fromProject(project, T))\n    }\n  }\n\n  @pure def projectJsonLine(text: String): Option[String] = {\n    val prefix = \"{  \\\"type\\\" : \\\"Project\\\"\"\n    for (line <- ops.StringOps(text).split((c: C) => c === \'\\n\')) {\n      var first = 0\n      var last = line.size - 1\n      val lineCis = conversions.String.toCis(line)\n      while (first < line.size && lineCis(first) != \'{\') {\n        first = first + 1\n      }\n      while (last >= 0 && lineCis(last) != \'}\') {\n        last = last - 1\n      }\n      val slicedLine: String =\n        if (first == 0 && last == line.size) line\n        else conversions.String.fromCis(ops.ISZOps(lineCis).slice(first, last + 1))\n      if (ops.StringOps(slicedLine).startsWith(prefix)) {\n        return Some(line)\n      }\n    }\n    return None()\n  }\n\n  def loadFromBaseDirs(baseDirs: ISZ[Os.Path]): Option[Project] = {\n    var r = Project.empty\n    for (baseDir <- baseDirs) {\n      val pJsonFile = baseDir / \"project.json\"\n      val cmdFile = baseDir / \"bin\" / \"project.cmd\"\n      var loaded = F\n      if (pJsonFile.exists && cmdFile.exists && cmdFile.lastModified < pJsonFile.lastModified) {\n        load(pJsonFile) match {\n          case Some(prj) =>\n            println(s\"Loading from $pJsonFile ...\")\n            r = r ++ prj\n            loaded = T\n          case _ =>\n        }\n      }\n      if (!loaded) {\n        println(s\"Loading from $cmdFile ...\")\n        val pr = proc\"$cmdFile json\".redirectErr.run()\n        if (pr.ok) {\n          projectJsonLine(pr.out) match {\n            case Some(line) => JSON.toProject(line) match {\n              case Either.Left(prj) =>\n                r = r ++ prj\n                loaded = T\n                store(pJsonFile, prj)\n                println(s\"Wrote $pJsonFile\")\n              case _ =>\n            }\n            case _ =>\n          }\n        } else {\n          eprintln(s\"Failed to load from $cmdFile\")\n          println(pr.out)\n          eprintln(pr.err)\n        }\n      }\n      if (!loaded) {\n        return None()\n      }\n    }\n    return Some(r)\n  }\n\n  def load(path: Os.Path): Option[Project] = {\n    if (!path.isFile) {\n      return None()\n    }\n    val parser = org.sireum.project.JSON.Parser(path.read)\n    val p = parser.parseProject()\n    if (parser.errorOpt.nonEmpty) {\n      return None()\n    }\n    var r = Project.empty(mavenRepoUrls = p.mavenRepoUrls)\n    for (m <- p.modules.values) {\n      r = r + m\n    }\n    return Some(r)\n  }\n\n  def store(path: Os.Path, prj: Project): Unit = {\n    path.writeOver(org.sireum.project.JSON.fromProject(prj(poset = Poset.empty), F))\n  }\n\n  @strictpure def pathSep(base: Os.Path, sub: String): Os.Path =\n    if (ops.StringOps(sub).startsWith(Os.fileSep)) Os.path(s\"$base$sub\")\n    else base / sub\n\n  @strictpure def moduleBasePath(m: Module): Os.Path = m.subPathOpt match {\n    case Some(sp) => pathSep(Os.path(m.basePath), sp)\n    case _ => Os.path(m.basePath)\n  }\n\n  @strictpure def moduleSources(m: Module): ISZ[Os.Path] =\n    for (p <- for (source <- m.sources) yield pathSep(moduleBasePath(m), source) if p.exists) yield p\n\n  @strictpure def moduleResources(m: Module): ISZ[Os.Path] =\n    for (p <- for (resource <- m.resources) yield pathSep(moduleBasePath(m), resource) if p.exists) yield p\n\n  @strictpure def moduleTestSources(m: Module): ISZ[Os.Path] =\n    for (p <- for (testSource <- m.testSources) yield pathSep(moduleBasePath(m), testSource) if p.exists) yield p\n\n  @strictpure def moduleTestResources(m: Module): ISZ[Os.Path] =\n    for (p <- for (testResource <- m.testResources) yield pathSep(moduleBasePath(m), testResource) if p.exists) yield p\n}\n
  #778 = String             #777          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.project\n\nimport org.sireum._\nimport org.sireum.project.PublishInfo._\n\nobject ProjectUtil {\n\n  val sharedSuffix: String = \"shared\"\n  val jvmSuffix: String = \"jvm\"\n  val jsSuffix: String = \"js\"\n\n  val bsd2License: License = License(\n    name = \"BSD 2-Clause\",\n    url = \"https://github.com/sireum/kekinian/blob/master/license.txt\",\n    distribution = \"repo\"\n  )\n  val bsd2: ISZ[License] = ISZ(bsd2License)\n\n  val robby: Developer = Developer(id = \"robby-phd\", name = \"Robby\")\n  val johnHatcliff: Developer = Developer(id = \"John-Hatcliff\", name = \"John Hatcliff\")\n  val jasonBelt: Developer = Developer(id = \"jasonbelt\", name = \"Jason Belt\")\n  val thari: Developer = Developer(id = \"thari\", name = \"Hariharan Thiagarajan\")\n  val matthewWeis: Developer = Developer(id = \"matthewweis\", name = \"Matthew Weis\")\n\n  @strictpure def id(baseId: String): ISZ[String] = ISZ(baseId)\n\n  @strictpure def sharedId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$sharedSuffix\")\n\n  @strictpure def jvmId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$jvmSuffix\")\n\n  @strictpure def jsId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$jsSuffix\")\n\n  @strictpure def sharedJvmId(baseId: String): ISZ[String] = sharedId(baseId) ++ jvmId(baseId)\n\n  @strictpure def sharedJsId(baseId: String): ISZ[String] = sharedId(baseId) ++ jsId(baseId)\n\n  def dirs(base: Os.Path, segss: ISZ[ISZ[String]]): ISZ[String] = {\n    var r = ISZ[String]()\n    for (segs <- segss) {\n      r = r :+ st\"${(segs, Os.fileSep)}\".render\n    }\n    return r\n  }\n\n  def mavenSourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(\n      ISZ(\"src\", \"main\", \"java\"),\n      ISZ(\"src\", \"main\", \"scala\")))\n  }\n\n  def mavenTestSourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(\n      ISZ(\"src\", \"test\", \"java\"),\n      ISZ(\"src\", \"test\", \"scala\")))\n  }\n\n  def mavenResourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(ISZ(\"src\", \"main\", \"resources\")))\n  }\n\n  def mavenTestResourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(ISZ(\"src\", \"test\", \"resources\")))\n  }\n\n  @pure def moduleSharedPub(id: String,\n                            baseDir: Os.Path,\n                            sharedDeps: ISZ[String],\n                            sharedIvyDeps: ISZ[String],\n                            pubOpt: Option[PublishInfo]): Module = {\n    val sharedDir = baseDir / sharedSuffix\n    val shared = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$sharedSuffix\"),\n      deps = sharedDeps,\n      targets = Module.allTargets,\n      ivyDeps = sharedIvyDeps,\n      sources = mavenSourceDirs(sharedDir),\n      resources = mavenResourceDirs(sharedDir),\n      testSources = mavenTestSourceDirs(sharedDir),\n      testResources = mavenTestResourceDirs(sharedDir),\n      publishInfoOpt = pubOpt\n    )\n    return shared\n  }\n\n  @strictpure def moduleShared(id: String,\n                               baseDir: Os.Path,\n                               sharedDeps: ISZ[String],\n                               sharedIvyDeps: ISZ[String]): Module =\n    moduleSharedPub(\n      id = id,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleJvmPub(id: String,\n                         baseDir: Os.Path,\n                         jvmDeps: ISZ[String],\n                         jvmIvyDeps: ISZ[String],\n                         pubOpt: Option[PublishInfo]): Module = {\n    val jvmDir = baseDir / jvmSuffix\n    val jvm = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$jvmSuffix\"),\n      deps = jvmDeps,\n      targets = ISZ(Target.Jvm),\n      ivyDeps = jvmIvyDeps,\n      sources = mavenSourceDirs(jvmDir),\n      resources = mavenResourceDirs(jvmDir),\n      testSources = mavenTestSourceDirs(jvmDir),\n      testResources = mavenTestResourceDirs(jvmDir),\n      publishInfoOpt = pubOpt\n    )\n    return jvm\n  }\n\n  @strictpure def moduleJvm(id: String,\n                            baseDir: Os.Path,\n                            jvmDeps: ISZ[String],\n                            jvmIvyDeps: ISZ[String]): Module =\n    moduleJvmPub(id, baseDir, jvmDeps, jvmIvyDeps, None())\n\n  @pure def moduleJsPub(id: String,\n                        baseDir: Os.Path,\n                        jsDeps: ISZ[String],\n                        jsIvyDeps: ISZ[String],\n                        pubOpt: Option[PublishInfo]): Module = {\n    val jsDir = baseDir / jsSuffix\n    val js = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$jsSuffix\"),\n      deps = jsDeps,\n      targets = ISZ(Target.Js),\n      ivyDeps = jsIvyDeps,\n      sources = mavenSourceDirs(jsDir),\n      resources = mavenResourceDirs(jsDir),\n      testSources = mavenTestSourceDirs(jsDir),\n      testResources = mavenTestResourceDirs(jsDir),\n      publishInfoOpt = pubOpt\n    )\n    return js\n  }\n\n  @strictpure def moduleJs(id: String,\n                           baseDir: Os.Path,\n                           jsDeps: ISZ[String],\n                           jsIvyDeps: ISZ[String]): Module =\n    moduleJsPub(\n      id = id,\n      baseDir = baseDir,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleSharedJvmPub(baseId: String,\n                               baseDir: Os.Path,\n                               sharedDeps: ISZ[String],\n                               sharedIvyDeps: ISZ[String],\n                               jvmDeps: ISZ[String],\n                               jvmIvyDeps: ISZ[String],\n                               pubOpt: Option[PublishInfo]): (Module, Module) = {\n    val shared = moduleSharedPub(s\"$baseId-$sharedSuffix\", baseDir, sharedDeps, sharedIvyDeps, pubOpt)\n    val jvm = moduleJvmPub(baseId, baseDir, jvmDeps :+ shared.id, jvmIvyDeps, pubOpt)\n    return (shared, jvm)\n  }\n\n  @strictpure def moduleSharedJvm(baseId: String,\n                                  baseDir: Os.Path,\n                                  sharedDeps: ISZ[String],\n                                  sharedIvyDeps: ISZ[String],\n                                  jvmDeps: ISZ[String],\n                                  jvmIvyDeps: ISZ[String]): (Module, Module) =\n    moduleSharedJvmPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jvmDeps = jvmDeps,\n      jvmIvyDeps = jvmIvyDeps,\n      pubOpt = None()\n    )\n\n\n  @pure def moduleSharedJsPub(baseId: String,\n                              baseDir: Os.Path,\n                              sharedDeps: ISZ[String],\n                              sharedIvyDeps: ISZ[String],\n                              jsDeps: ISZ[String],\n                              jsIvyDeps: ISZ[String],\n                              pubOpt: Option[PublishInfo]): (Module, Module) = {\n    val shared = moduleSharedPub(s\"$baseId-$sharedSuffix\", baseDir, sharedDeps, sharedIvyDeps, pubOpt)\n    val js = moduleJsPub(baseId, baseDir, jsDeps :+ shared.id, jsIvyDeps, pubOpt)\n    return (shared, js)\n  }\n\n  @strictpure def moduleSharedJs(baseId: String,\n                                 baseDir: Os.Path,\n                                 sharedDeps: ISZ[String],\n                                 sharedIvyDeps: ISZ[String],\n                                 jsDeps: ISZ[String],\n                                 jsIvyDeps: ISZ[String]): (Module, Module) =\n    moduleSharedJsPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleSharedJvmJsPub(baseId: String,\n                                 baseDir: Os.Path,\n                                 sharedDeps: ISZ[String],\n                                 sharedIvyDeps: ISZ[String],\n                                 jvmDeps: ISZ[String],\n                                 jvmIvyDeps: ISZ[String],\n                                 jsDeps: ISZ[String],\n                                 jsIvyDeps: ISZ[String],\n                                 pubOpt: Option[PublishInfo]): (Module, Module, Module) = {\n    val (shared, js) = moduleSharedJsPub(baseId, baseDir, sharedDeps, sharedIvyDeps, jsDeps, jsIvyDeps, pubOpt)\n    val jvm = moduleJvmPub(baseId, baseDir, jvmDeps :+ shared.id, jvmIvyDeps, pubOpt)\n    return (shared, jvm, js(id = s\"$baseId-$jsSuffix\"))\n  }\n\n  @strictpure def moduleSharedJvmJs(baseId: String,\n                                    baseDir: Os.Path,\n                                    sharedDeps: ISZ[String],\n                                    sharedIvyDeps: ISZ[String],\n                                    jvmDeps: ISZ[String],\n                                    jvmIvyDeps: ISZ[String],\n                                    jsDeps: ISZ[String],\n                                    jsIvyDeps: ISZ[String]): (Module, Module, Module) =\n    moduleSharedJvmJsPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jvmDeps = jvmDeps,\n      jvmIvyDeps = jvmIvyDeps,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @strictpure def pub(desc: String,\n                      url: String,\n                      licenses: ISZ[PublishInfo.License],\n                      devs: ISZ[PublishInfo.Developer]): Option[PublishInfo] =\n    Some(\n      PublishInfo(\n        description = desc,\n        url = url,\n        licenses = licenses,\n        developers = devs\n      )\n    )\n\n  @pure def toDot(p: Project): String = {\n    @pure def node2st(name: String): ST = {\n      p.modules.get(name) match {\n        case Some(m) =>\n          val targets = HashSet.empty[Target.Type] ++ m.targets\n          if (targets.contains(Target.Jvm) && targets.contains(Target.Js)) {\n            return st\"\"\"[shape = \"rect\", label=\"$name\"]\"\"\"\n          } else if (targets.contains(Target.Jvm)) {\n            return st\"\"\"[shape = \"trapezium\", label=\"$name\"]\"\"\"\n          } else {\n            return st\"\"\"[shape = \"invtrapezium\", label=\"$name\"]\"\"\"\n          }\n        case _ => return st\"\"\"[shape = \"octagon\", label=\"$name\"]\"\"\"\n      }\n    }\n\n    return p.poset.toST(node2st _).render\n  }\n\n  def projectCli(args: ISZ[String], project: Project): Unit = {\n\n    def usage(): Unit = {\n      println(\"Usage: [ json ]\")\n    }\n\n    var isDot = T\n\n    args match {\n      case ISZ(string\"json\") => isDot = F\n      case ISZ(string\"-h\") =>\n        usage()\n        Os.exit(0)\n      case ISZ() =>\n      case _ =>\n        usage()\n        Os.exit(-1)\n    }\n\n    if (isDot) {\n      println(toDot(project))\n    } else {\n      println(JSON.fromProject(project, T))\n    }\n  }\n\n  @pure def projectJsonLine(text: String): Option[String] = {\n    val prefix = \"{  \\\"type\\\" : \\\"Project\\\"\"\n    for (line <- ops.StringOps(text).split((c: C) => c === \'\\n\')) {\n      var first = 0\n      var last = line.size - 1\n      val lineCis = conversions.String.toCis(line)\n      while (first < line.size && lineCis(first) != \'{\') {\n        first = first + 1\n      }\n      while (last >= 0 && lineCis(last) != \'}\') {\n        last = last - 1\n      }\n      val slicedLine: String =\n        if (first == 0 && last == line.size) line\n        else conversions.String.fromCis(ops.ISZOps(lineCis).slice(first, last + 1))\n      if (ops.StringOps(slicedLine).startsWith(prefix)) {\n        return Some(line)\n      }\n    }\n    return None()\n  }\n\n  def loadFromBaseDirs(baseDirs: ISZ[Os.Path]): Option[Project] = {\n    var r = Project.empty\n    for (baseDir <- baseDirs) {\n      val pJsonFile = baseDir / \"project.json\"\n      val cmdFile = baseDir / \"bin\" / \"project.cmd\"\n      var loaded = F\n      if (pJsonFile.exists && cmdFile.exists && cmdFile.lastModified < pJsonFile.lastModified) {\n        load(pJsonFile) match {\n          case Some(prj) =>\n            println(s\"Loading from $pJsonFile ...\")\n            r = r ++ prj\n            loaded = T\n          case _ =>\n        }\n      }\n      if (!loaded) {\n        println(s\"Loading from $cmdFile ...\")\n        val pr = proc\"$cmdFile json\".redirectErr.run()\n        if (pr.ok) {\n          projectJsonLine(pr.out) match {\n            case Some(line) => JSON.toProject(line) match {\n              case Either.Left(prj) =>\n                r = r ++ prj\n                loaded = T\n                store(pJsonFile, prj)\n                println(s\"Wrote $pJsonFile\")\n              case _ =>\n            }\n            case _ =>\n          }\n        } else {\n          eprintln(s\"Failed to load from $cmdFile\")\n          println(pr.out)\n          eprintln(pr.err)\n        }\n      }\n      if (!loaded) {\n        return None()\n      }\n    }\n    return Some(r)\n  }\n\n  def load(path: Os.Path): Option[Project] = {\n    if (!path.isFile) {\n      return None()\n    }\n    val parser = org.sireum.project.JSON.Parser(path.read)\n    val p = parser.parseProject()\n    if (parser.errorOpt.nonEmpty) {\n      return None()\n    }\n    var r = Project.empty(mavenRepoUrls = p.mavenRepoUrls)\n    for (m <- p.modules.values) {\n      r = r + m\n    }\n    return Some(r)\n  }\n\n  def store(path: Os.Path, prj: Project): Unit = {\n    path.writeOver(org.sireum.project.JSON.fromProject(prj(poset = Poset.empty), F))\n  }\n\n  @strictpure def pathSep(base: Os.Path, sub: String): Os.Path =\n    if (ops.StringOps(sub).startsWith(Os.fileSep)) Os.path(s\"$base$sub\")\n    else base / sub\n\n  @strictpure def moduleBasePath(m: Module): Os.Path = m.subPathOpt match {\n    case Some(sp) => pathSep(Os.path(m.basePath), sp)\n    case _ => Os.path(m.basePath)\n  }\n\n  @strictpure def moduleSources(m: Module): ISZ[Os.Path] =\n    for (p <- for (source <- m.sources) yield pathSep(moduleBasePath(m), source) if p.exists) yield p\n\n  @strictpure def moduleResources(m: Module): ISZ[Os.Path] =\n    for (p <- for (resource <- m.resources) yield pathSep(moduleBasePath(m), resource) if p.exists) yield p\n\n  @strictpure def moduleTestSources(m: Module): ISZ[Os.Path] =\n    for (p <- for (testSource <- m.testSources) yield pathSep(moduleBasePath(m), testSource) if p.exists) yield p\n\n  @strictpure def moduleTestResources(m: Module): ISZ[Os.Path] =\n    for (p <- for (testResource <- m.testResources) yield pathSep(moduleBasePath(m), testResource) if p.exists) yield p\n}\n
  #779 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.project\n\nimport org.sireum._\n\nobject DependencyManager {\n  @datatype class Lib(val name: String,\n                      val org: String,\n                      val module: String,\n                      val version: String,\n                      val main: String,\n                      val sourcesOpt: Option[String],\n                      val javadocOpt: Option[String])\n\n  val javaKey: String = \"org.sireum.version.zulu\"\n  val jbrKey: String = \"org.sireum.version.jbr\"\n  val scalacPluginKey: String = \"org.sireum::scalac-plugin:\"\n  val scalaKey: String = \"org.scala-lang:scala-library:\"\n  val scalaJsKey: String = \"org.scala-js:::scalajs-compiler:\"\n  val scalaTestKey: String = \"org.scalatest::scalatest::\"\n  val macrosKey: String = \"org.sireum.kekinian::macros:\"\n  val testKey: String = \"org.sireum.kekinian::test:\"\n  val libraryKey: String = \"org.sireum.kekinian::library:\"\n  val librarySharedKey: String = \"org.sireum.kekinian::library-shared:\"\n\n  val jarSuffix: String = \".jar\"\n  val sourceJarSuffix: String = \"-sources.jar\"\n  val docJarSuffix: String = \"-javadoc.jar\"\n\n  val ignoredLibraryNames: HashSet[String] = HashSet ++ ISZ[String](\n    \"org.scala-lang.scala-library\", \"org.scala-lang.scala-reflect\", \"org.scala-lang.scala-compiler\"\n  )\n\n  @pure def buildClassifiers(withSource: B, withDoc: B): ISZ[CoursierClassifier.Type] = {\n    var classifiers = ISZ[CoursierClassifier.Type](CoursierClassifier.Default)\n    if (withSource) {\n      classifiers = classifiers :+ CoursierClassifier.Sources\n    }\n    if (withDoc) {\n      classifiers = classifiers :+ CoursierClassifier.Javadoc\n    }\n    return classifiers\n  }\n\n  @strictpure def libName(cif: CoursierFileInfo): String = s\"${cif.org}.${cif.module}\"\n}\n\nimport DependencyManager._\n\n@record class DependencyManager(val project: Project,\n                                val versions: HashSMap[String, String],\n                                val isJs: B,\n                                val withSource: B,\n                                val withDoc: B,\n                                val javaHome: Os.Path,\n                                val scalaHome: Os.Path,\n                                val sireumHome: Os.Path,\n                                val cacheOpt: Option[Os.Path]) {\n\n  val sireumJar: Os.Path = sireumHome / \"bin\" / \"sireum.jar\"\n\n  val _scalacPlugin: Os.Path = sireumHome / \"lib\" / s\"scalac-plugin-${versions.get(scalacPluginKey).get}.jar\"\n\n  def scalacPlugin: Os.Path = {\n    if (_scalacPlugin.exists) {\n      return _scalacPlugin\n    }\n    val version = versions.get(scalacPluginKey).get\n    val url = s\"https://github.com/sireum/scalac-plugin/releases/download/$version/scalac-plugin-$version.jar\"\n    val cacheDir: Os.Path = Os.env(\"SIREUM_CACHE\") match {\n      case Some(v) => Os.path(v)\n      case _ => Os.home / \"Downloads\" / \"sireum\"\n    }\n    cacheDir.mkdirAll()\n    _scalacPlugin.up.mkdirAll()\n    val pluginCache = cacheDir / _scalacPlugin.name\n    if (!pluginCache.exists) {\n      println(s\"Please wait while downloading Slang scalac plugin $version ...\")\n      pluginCache.downloadFrom(url)\n      println()\n    }\n    pluginCache.copyOverTo(_scalacPlugin)\n    return _scalacPlugin\n  }\n\n  val javaVersion: String = versions.get(DependencyManager.javaKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Java version (key: ${DependencyManager.javaKey})\")\n  }\n\n  val scalaVersion: String = versions.get(DependencyManager.scalaKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Scala version (key: ${DependencyManager.scalaKey})\")\n  }\n\n  val scalaMajorVersion: String = {\n    val verOps = ops.StringOps(scalaVersion)\n    val i = verOps.indexOf(\'.\')\n    val j = verOps.indexOfFrom(\'.\', i + 1)\n    verOps.substring(0, j)\n  }\n\n  val scalaJsVersion: String = versions.get(DependencyManager.scalaJsKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Scala.js version (key: ${DependencyManager.scalaJsKey})\")\n  }\n\n  val sjsSuffix: String = {\n    val verOps = ops.StringOps(scalaJsVersion)\n    val i = verOps.indexOf(\'.\')\n    s\"_sjs${verOps.substring(0, i)}\"\n  }\n\n  val scalaTestVersion: String = versions.get(DependencyManager.scalaTestKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find ScalaTest version (key: ${DependencyManager.scalaTestKey})\")\n  }\n\n  val ivyDeps: HashSMap[String, String] = {\n    var r = HashSMap.empty[String, String]\n    for (m <- project.modules.values) {\n      for (ivyDep <- m.ivyDeps) {\n        val v = getVersion(ivyDep)\n        val ivyDepOps = ops.StringOps(ivyDep)\n        if (isJs && ivyDepOps.endsWith(\"::\")) {\n          val dep = s\"${ivyDepOps.substring(0, ivyDep.size - 2)}$sjsSuffix:\"\n          r = r + ivyDep ~> s\"$dep$v\"\n        } else {\n          r = r + ivyDep ~> s\"$ivyDep$v\"\n        }\n      }\n    }\n    r\n  }\n\n  var _libMap: HashSMap[String, Lib] = HashSMap.empty\n\n  def libMap: HashSMap[String, Lib] = {\n    if (_libMap.isEmpty) {\n      var r = HashSMap.empty[String, Lib]\n      for (cif <- fetchClassifiers(ivyDeps.values, buildClassifiers(withSource, withDoc))) {\n        val name = libName(cif)\n        val p = cif.path\n        val pNameOps = ops.StringOps(p.string)\n        if (!ignoredLibraryNames.contains(name)) {\n          var lib: Lib = r.get(name) match {\n            case Some(l) => l\n            case _ => Lib(name, cif.org, cif.module, cif.version, \"\", None(), None())\n          }\n          if (pNameOps.endsWith(sourceJarSuffix)) {\n            lib = lib(sourcesOpt = Some(p.string))\n          } else if (pNameOps.endsWith(docJarSuffix)) {\n            lib = lib(javadocOpt = Some(p.string))\n          } else if (pNameOps.endsWith(jarSuffix)) {\n            lib = lib(main = p.string)\n          } else {\n            halt(s\"Expecting a file with .jar extension but found \'$p\'\")\n          }\n          r = r + name ~> lib\n        }\n      }\n      _libMap = r\n    }\n    return _libMap\n  }\n\n  var tLibMap: HashMap[String, ISZ[Lib]] = HashMap.empty\n\n  var dLibMap: HashMap[String, ISZ[Lib]] = HashMap.empty\n\n  @pure def getVersion(ivyDep: String): String = {\n    versions.get(ivyDep) match {\n      case Some(v) => return v\n      case _ => halt(s\"Could not find version information for \'$ivyDep\' in $versions\")\n    }\n  }\n\n  @pure def getModule(id: String): Module = {\n    project.modules.get(id) match {\n      case Some(m) => return m\n      case _ => halt(s\"Could not find module with ID \'$id\'\")\n    }\n  }\n\n  @memoize def computeTransitiveDeps(m: Module): ISZ[String] = {\n    var r = HashSSet.empty[String]\n    for (mDep <- m.deps) {\n      r = r + mDep ++ computeTransitiveDeps(getModule(mDep))\n    }\n    return r.elements\n  }\n\n  @memoize def computeTransitiveIvyDeps(m: Module): ISZ[String] = {\n    var r = HashSSet.empty[String]\n    for (mid <- m.deps) {\n      r = r ++ computeTransitiveIvyDeps(project.modules.get(mid).get)\n    }\n    for (id <- m.ivyDeps) {\n      r = r + ivyDeps.get(id).get\n    }\n    return r.elements\n  }\n\n  def fetchTransitiveLibs(m: Module): ISZ[Lib] = {\n    tLibMap.get(m.id) match {\n      case Some(libs) => return libs\n      case _ =>\n    }\n    val r: ISZ[Lib] =\n      for (cif <- fetch(computeTransitiveIvyDeps(m)) if !ignoredLibraryNames.contains(libName(cif))) yield libMap.get(libName(cif)).get\n    tLibMap = tLibMap + m.id ~> r\n    return r\n  }\n\n  def fetchDiffLibs(m: Module): ISZ[Lib] = {\n    dLibMap.get(m.id) match {\n      case Some(libs) => return libs\n      case _ =>\n    }\n    var s = HashSSet ++ fetchTransitiveLibs(m)\n    for (mDep <- m.deps) {\n      s = s -- fetchTransitiveLibs(getModule(mDep))\n    }\n    val r = s.elements\n    dLibMap = dLibMap + m.id ~> r\n    return r\n  }\n\n  def fetch(ivyDeps: ISZ[String]): ISZ[CoursierFileInfo] = {\n    return fetchClassifiers(ivyDeps, ISZ(CoursierClassifier.Default))\n  }\n\n  def fetchClassifiers(ivyDeps: ISZ[String], classifiers: ISZ[CoursierClassifier.Type]): ISZ[CoursierFileInfo] = {\n    val oldScalaVersion = Coursier.scalaVersion\n    val oldCacheOpt = Coursier.cacheOpt\n    val oldRepoUrls = Coursier.mavenRepoUrls\n    Coursier.addMavenRepositories(project.mavenRepoUrls)\n    Coursier.setCache(cacheOpt)\n    val r = Coursier.fetchClassifiers(ivyDeps, classifiers)\n    Coursier.setScalaVersion(oldScalaVersion)\n    Coursier.setCache(oldCacheOpt)\n    Coursier.setMavenRepositories(oldRepoUrls)\n    return r\n  }\n}\n\n
  #780 = String             #779          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.project\n\nimport org.sireum._\n\nobject DependencyManager {\n  @datatype class Lib(val name: String,\n                      val org: String,\n                      val module: String,\n                      val version: String,\n                      val main: String,\n                      val sourcesOpt: Option[String],\n                      val javadocOpt: Option[String])\n\n  val javaKey: String = \"org.sireum.version.zulu\"\n  val jbrKey: String = \"org.sireum.version.jbr\"\n  val scalacPluginKey: String = \"org.sireum::scalac-plugin:\"\n  val scalaKey: String = \"org.scala-lang:scala-library:\"\n  val scalaJsKey: String = \"org.scala-js:::scalajs-compiler:\"\n  val scalaTestKey: String = \"org.scalatest::scalatest::\"\n  val macrosKey: String = \"org.sireum.kekinian::macros:\"\n  val testKey: String = \"org.sireum.kekinian::test:\"\n  val libraryKey: String = \"org.sireum.kekinian::library:\"\n  val librarySharedKey: String = \"org.sireum.kekinian::library-shared:\"\n\n  val jarSuffix: String = \".jar\"\n  val sourceJarSuffix: String = \"-sources.jar\"\n  val docJarSuffix: String = \"-javadoc.jar\"\n\n  val ignoredLibraryNames: HashSet[String] = HashSet ++ ISZ[String](\n    \"org.scala-lang.scala-library\", \"org.scala-lang.scala-reflect\", \"org.scala-lang.scala-compiler\"\n  )\n\n  @pure def buildClassifiers(withSource: B, withDoc: B): ISZ[CoursierClassifier.Type] = {\n    var classifiers = ISZ[CoursierClassifier.Type](CoursierClassifier.Default)\n    if (withSource) {\n      classifiers = classifiers :+ CoursierClassifier.Sources\n    }\n    if (withDoc) {\n      classifiers = classifiers :+ CoursierClassifier.Javadoc\n    }\n    return classifiers\n  }\n\n  @strictpure def libName(cif: CoursierFileInfo): String = s\"${cif.org}.${cif.module}\"\n}\n\nimport DependencyManager._\n\n@record class DependencyManager(val project: Project,\n                                val versions: HashSMap[String, String],\n                                val isJs: B,\n                                val withSource: B,\n                                val withDoc: B,\n                                val javaHome: Os.Path,\n                                val scalaHome: Os.Path,\n                                val sireumHome: Os.Path,\n                                val cacheOpt: Option[Os.Path]) {\n\n  val sireumJar: Os.Path = sireumHome / \"bin\" / \"sireum.jar\"\n\n  val _scalacPlugin: Os.Path = sireumHome / \"lib\" / s\"scalac-plugin-${versions.get(scalacPluginKey).get}.jar\"\n\n  def scalacPlugin: Os.Path = {\n    if (_scalacPlugin.exists) {\n      return _scalacPlugin\n    }\n    val version = versions.get(scalacPluginKey).get\n    val url = s\"https://github.com/sireum/scalac-plugin/releases/download/$version/scalac-plugin-$version.jar\"\n    val cacheDir: Os.Path = Os.env(\"SIREUM_CACHE\") match {\n      case Some(v) => Os.path(v)\n      case _ => Os.home / \"Downloads\" / \"sireum\"\n    }\n    cacheDir.mkdirAll()\n    _scalacPlugin.up.mkdirAll()\n    val pluginCache = cacheDir / _scalacPlugin.name\n    if (!pluginCache.exists) {\n      println(s\"Please wait while downloading Slang scalac plugin $version ...\")\n      pluginCache.downloadFrom(url)\n      println()\n    }\n    pluginCache.copyOverTo(_scalacPlugin)\n    return _scalacPlugin\n  }\n\n  val javaVersion: String = versions.get(DependencyManager.javaKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Java version (key: ${DependencyManager.javaKey})\")\n  }\n\n  val scalaVersion: String = versions.get(DependencyManager.scalaKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Scala version (key: ${DependencyManager.scalaKey})\")\n  }\n\n  val scalaMajorVersion: String = {\n    val verOps = ops.StringOps(scalaVersion)\n    val i = verOps.indexOf(\'.\')\n    val j = verOps.indexOfFrom(\'.\', i + 1)\n    verOps.substring(0, j)\n  }\n\n  val scalaJsVersion: String = versions.get(DependencyManager.scalaJsKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Scala.js version (key: ${DependencyManager.scalaJsKey})\")\n  }\n\n  val sjsSuffix: String = {\n    val verOps = ops.StringOps(scalaJsVersion)\n    val i = verOps.indexOf(\'.\')\n    s\"_sjs${verOps.substring(0, i)}\"\n  }\n\n  val scalaTestVersion: String = versions.get(DependencyManager.scalaTestKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find ScalaTest version (key: ${DependencyManager.scalaTestKey})\")\n  }\n\n  val ivyDeps: HashSMap[String, String] = {\n    var r = HashSMap.empty[String, String]\n    for (m <- project.modules.values) {\n      for (ivyDep <- m.ivyDeps) {\n        val v = getVersion(ivyDep)\n        val ivyDepOps = ops.StringOps(ivyDep)\n        if (isJs && ivyDepOps.endsWith(\"::\")) {\n          val dep = s\"${ivyDepOps.substring(0, ivyDep.size - 2)}$sjsSuffix:\"\n          r = r + ivyDep ~> s\"$dep$v\"\n        } else {\n          r = r + ivyDep ~> s\"$ivyDep$v\"\n        }\n      }\n    }\n    r\n  }\n\n  var _libMap: HashSMap[String, Lib] = HashSMap.empty\n\n  def libMap: HashSMap[String, Lib] = {\n    if (_libMap.isEmpty) {\n      var r = HashSMap.empty[String, Lib]\n      for (cif <- fetchClassifiers(ivyDeps.values, buildClassifiers(withSource, withDoc))) {\n        val name = libName(cif)\n        val p = cif.path\n        val pNameOps = ops.StringOps(p.string)\n        if (!ignoredLibraryNames.contains(name)) {\n          var lib: Lib = r.get(name) match {\n            case Some(l) => l\n            case _ => Lib(name, cif.org, cif.module, cif.version, \"\", None(), None())\n          }\n          if (pNameOps.endsWith(sourceJarSuffix)) {\n            lib = lib(sourcesOpt = Some(p.string))\n          } else if (pNameOps.endsWith(docJarSuffix)) {\n            lib = lib(javadocOpt = Some(p.string))\n          } else if (pNameOps.endsWith(jarSuffix)) {\n            lib = lib(main = p.string)\n          } else {\n            halt(s\"Expecting a file with .jar extension but found \'$p\'\")\n          }\n          r = r + name ~> lib\n        }\n      }\n      _libMap = r\n    }\n    return _libMap\n  }\n\n  var tLibMap: HashMap[String, ISZ[Lib]] = HashMap.empty\n\n  var dLibMap: HashMap[String, ISZ[Lib]] = HashMap.empty\n\n  @pure def getVersion(ivyDep: String): String = {\n    versions.get(ivyDep) match {\n      case Some(v) => return v\n      case _ => halt(s\"Could not find version information for \'$ivyDep\' in $versions\")\n    }\n  }\n\n  @pure def getModule(id: String): Module = {\n    project.modules.get(id) match {\n      case Some(m) => return m\n      case _ => halt(s\"Could not find module with ID \'$id\'\")\n    }\n  }\n\n  @memoize def computeTransitiveDeps(m: Module): ISZ[String] = {\n    var r = HashSSet.empty[String]\n    for (mDep <- m.deps) {\n      r = r + mDep ++ computeTransitiveDeps(getModule(mDep))\n    }\n    return r.elements\n  }\n\n  @memoize def computeTransitiveIvyDeps(m: Module): ISZ[String] = {\n    var r = HashSSet.empty[String]\n    for (mid <- m.deps) {\n      r = r ++ computeTransitiveIvyDeps(project.modules.get(mid).get)\n    }\n    for (id <- m.ivyDeps) {\n      r = r + ivyDeps.get(id).get\n    }\n    return r.elements\n  }\n\n  def fetchTransitiveLibs(m: Module): ISZ[Lib] = {\n    tLibMap.get(m.id) match {\n      case Some(libs) => return libs\n      case _ =>\n    }\n    val r: ISZ[Lib] =\n      for (cif <- fetch(computeTransitiveIvyDeps(m)) if !ignoredLibraryNames.contains(libName(cif))) yield libMap.get(libName(cif)).get\n    tLibMap = tLibMap + m.id ~> r\n    return r\n  }\n\n  def fetchDiffLibs(m: Module): ISZ[Lib] = {\n    dLibMap.get(m.id) match {\n      case Some(libs) => return libs\n      case _ =>\n    }\n    var s = HashSSet ++ fetchTransitiveLibs(m)\n    for (mDep <- m.deps) {\n      s = s -- fetchTransitiveLibs(getModule(mDep))\n    }\n    val r = s.elements\n    dLibMap = dLibMap + m.id ~> r\n    return r\n  }\n\n  def fetch(ivyDeps: ISZ[String]): ISZ[CoursierFileInfo] = {\n    return fetchClassifiers(ivyDeps, ISZ(CoursierClassifier.Default))\n  }\n\n  def fetchClassifiers(ivyDeps: ISZ[String], classifiers: ISZ[CoursierClassifier.Type]): ISZ[CoursierFileInfo] = {\n    val oldScalaVersion = Coursier.scalaVersion\n    val oldCacheOpt = Coursier.cacheOpt\n    val oldRepoUrls = Coursier.mavenRepoUrls\n    Coursier.addMavenRepositories(project.mavenRepoUrls)\n    Coursier.setCache(cacheOpt)\n    val r = Coursier.fetchClassifiers(ivyDeps, classifiers)\n    Coursier.setScalaVersion(oldScalaVersion)\n    Coursier.setCache(oldCacheOpt)\n    Coursier.setMavenRepositories(oldRepoUrls)\n    return r\n  }\n}\n\n
  #781 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject GitHub {\n\n  @datatype trait Credential\n\n  @datatype class Repository(connection: Option[Credential],\n                             owner: String,\n                             name: String) {\n    def latestRelease: Release = {\n      return Ext.latestRelease(this)\n    }\n\n    def releases: Jen[Release] = {\n      return Ext.releases(this)\n    }\n  }\n\n  @datatype class Release(repo: Repository,\n                          id: Z,\n                          name: String,\n                          publishedTime: Z,\n                          isDraft: B,\n                          isPrerelease: B,\n                          tagName: String,\n                          commit: String,\n                          tarUrl: String,\n                          zipUrl: String) {\n    def assets: Jen[Asset] = {\n      return Ext.assets(this)\n    }\n  }\n\n  @datatype class Asset(release: Release,\n                        id: Z,\n                        name: String,\n                        label: String,\n                        state: String,\n                        size: Z,\n                        contentType: String,\n                        url: String,\n                        downloadCount: Z) {\n\n  }\n\n  @strictpure def repo(owner: String, repo: String): Repository = Repository(None(), owner, repo)\n\n  @ext(\"GitHub_Ext\") object Ext {\n\n    def latestRelease(repo: Repository): Release = $\n\n    def releases(repo: Repository): Jen[Release] = $\n\n    def assets(release: Release): Jen[Asset] = $\n  }\n}\n\n
  #782 = String             #781          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject GitHub {\n\n  @datatype trait Credential\n\n  @datatype class Repository(connection: Option[Credential],\n                             owner: String,\n                             name: String) {\n    def latestRelease: Release = {\n      return Ext.latestRelease(this)\n    }\n\n    def releases: Jen[Release] = {\n      return Ext.releases(this)\n    }\n  }\n\n  @datatype class Release(repo: Repository,\n                          id: Z,\n                          name: String,\n                          publishedTime: Z,\n                          isDraft: B,\n                          isPrerelease: B,\n                          tagName: String,\n                          commit: String,\n                          tarUrl: String,\n                          zipUrl: String) {\n    def assets: Jen[Asset] = {\n      return Ext.assets(this)\n    }\n  }\n\n  @datatype class Asset(release: Release,\n                        id: Z,\n                        name: String,\n                        label: String,\n                        state: String,\n                        size: Z,\n                        contentType: String,\n                        url: String,\n                        downloadCount: Z) {\n\n  }\n\n  @strictpure def repo(owner: String, repo: String): Repository = Repository(None(), owner, repo)\n\n  @ext(\"GitHub_Ext\") object Ext {\n\n    def latestRelease(repo: Repository): Release = $\n\n    def releases(repo: Repository): Jen[Release] = $\n\n    def assets(release: Release): Jen[Asset] = $\n  }\n}\n\n
  #783 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject Os {\n\n  @pure def cliArgs: ISZ[String] = {\n    return Ext.cliArgs\n  }\n\n  @memoize def cwd: Path = {\n    return Path.Impl(Ext.cwd)\n  }\n\n  def exit(code: Z): Unit = {\n    Ext.exit(code)\n  }\n\n  def env(name: String): Option[String] = {\n    return Ext.env(name)\n  }\n\n  def envs: Map[String, String] = {\n    return Ext.envs\n  }\n\n  @pure def fileSep: String = {\n    return Ext.fileSep\n  }\n\n  @pure def uriToPath(uri: String): Os.Path = {\n    return Path.Impl(Ext.fromUri(uri))\n  }\n\n  @memoize def home: Path = {\n    return Path.Impl(Ext.home)\n  }\n\n  @pure def isLinux: B = {\n    return kind == Kind.Linux\n  }\n\n  @pure def isMac: B = {\n    return kind == Kind.Mac\n  }\n\n  @pure def isWin: B = {\n    return kind == Kind.Win\n  }\n\n  @pure def pathSep: String = {\n    return Ext.pathSep\n  }\n\n  @pure def lineSep: String = {\n    return Ext.lineSep\n  }\n\n  @pure def pathSepChar: C = {\n    return Ext.pathSepChar\n  }\n\n  @pure def kind: Kind.Type = {\n    return Ext.os\n  }\n\n  @pure def readIndexableCFrom(url: String): Indexable.Pos[C] = {\n    return Ext.readIndexableCUrl(url)\n  }\n\n  @pure def path(value: String): Path = {\n    if (isWin) {\n      val sOps = ops.StringOps(value)\n      val cygPrefix: String = \"/cygdrive/\"\n      if (sOps.startsWith(cygPrefix)) {\n        return Path.Impl(\n          ops.StringOps(s\"${sOps.substring(cygPrefix.size, cygPrefix.size + 1)}:${sOps.substring(cygPrefix.size + 1, value.size)}\").replaceAllChars(\'/\', \'\\\\\'))\n\n      } else if (sOps.startsWith(\"/\") && env(\"OSTYPE\") == Some(\"msys\")) {\n        return Path.Impl(ops.StringOps(s\"${sOps.substring(1, 2)}:${sOps.substring(2, value.size)}\").\n          replaceAllChars(\'/\', \'\\\\\'))\n      }\n    }\n    return Path.Impl(Ext.norm(value))\n  }\n\n  @pure def proc(commands: ISZ[String]): Proc = {\n    return Proc(commands, cwd, Map.empty, T, None(), F, F, F, F, F, 0, F, F, None(), None())\n  }\n\n  @pure def procs(commands: String): Proc = {\n    val cmds: ISZ[String] = for (cmd <- ops.StringOps(commands).split((c: C) => c == \' \')) yield\n      ops.StringOps(cmd).replaceAllChars(\'␣\', \' \')\n    return proc(cmds)\n  }\n\n  @memoize def roots: ISZ[Path] = {\n    return for (root <- Ext.roots) yield Path.Impl(root)\n  }\n\n  def slashDir: Os.Path = {\n    return Os.path(Ext.slashDir)\n  }\n\n  def temp(): Path = {\n    val r = tempFix(\"\", \"\")\n    return r\n  }\n\n  def tempFix(prefix: String, suffix: String): Path = {\n    val r = Ext.temp(prefix, suffix)\n    return Path.Impl(r)\n  }\n\n  def tempDir(): Path = {\n    val r = tempDirFix(\"\")\n    return r\n  }\n\n  def tempDirFix(prefix: String): Path = {\n    val r = Ext.tempDir(prefix)\n    return Path.Impl(r)\n  }\n\n\n  @enum object Kind {\n    \'Mac\n    \'Linux\n    \'LinuxArm\n    \'Win\n    \'Unsupported\n  }\n\n  object Path {\n\n    @enum object Kind {\n      \'Dir\n      \'File\n      \'SymLink\n      \'Other\n    }\n\n    @enum object WriteMode {\n      \'Regular\n      \'Over\n      \'Append\n    }\n\n    @datatype class Impl(val value: String) extends Path {\n      override def string: String = {\n        return value\n      }\n    }\n\n    @sig trait Jen[T] extends org.sireum.Jen[T] {\n      def path: Path\n      override def string: String = {\n        return s\"Jen($path)\"\n      }\n    }\n\n    @msig trait MJen[T] extends org.sireum.MJen[T] {\n      def path: Path\n      override def string: String = {\n        return s\"MJen($path)\"\n      }\n    }\n\n    def overlay(isMove: B, path: Os.Path, target: Os.Path, includeDir: B, followLink: B,\n                pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      var r = HashSMap.empty[Os.Path, Os.Path]\n      val files = ops.ISZOps(walk(path, includeDir, T, pred)).reverse\n      for (p <- files) {\n        val t = target / path.relativize(p).string\n        p.kind match {\n          case Kind.Dir =>\n            t.mkdirAll()\n            if (isMove) {\n              p.remove()\n            }\n            if (report) {\n              r = r + p ~> t\n            }\n          case Kind.File =>\n            t.up.mkdirAll()\n            if (isMove) {\n              p.moveOverTo(t)\n            } else {\n              p.copyOverTo(t)\n            }\n            if (report) {\n              r = r + p ~> t\n            }\n          case Kind.SymLink if isMove =>\n            p.remove()\n          case _ =>\n        }\n      }\n      return r\n    }\n\n    def walk(path: Os.Path, includeDir: B, followLink: B, pred: Os.Path => B @pure): ISZ[Os.Path] = {\n      var rSet = HashSSet.empty[Os.Path]\n      var rIS = ISZ[Os.Path]()\n      def add(p: Os.Path): Unit = {\n        val pCanon = p.canon\n        if (followLink) {\n          rSet = rSet + pCanon\n        } else {\n          rIS = rIS :+ pCanon\n        }\n      }\n      def rec(p: Os.Path): Unit = {\n        if (!followLink && rSet.contains(p.canon)) {\n          return\n        }\n        p.kind match {\n          case Os.Path.Kind.Dir =>\n            if (includeDir && pred(p)) {\n              add(p)\n            }\n            for (p2 <- p.list) {\n              rec(p2)\n            }\n          case Os.Path.Kind.File if pred(p) => add(p)\n          case Os.Path.Kind.SymLink if followLink =>\n            if (pred(p)) {\n              add(p)\n            }\n            val tOpt = p.readSymLink\n            tOpt match {\n              case Some(t) => rec(t)\n              case _ =>\n            }\n          case _ =>\n        }\n      }\n      rec(path)\n      return if (followLink) rSet.map.keys else rIS\n    }\n\n  }\n\n  object Proc {\n\n    @sig sealed trait Result extends OsProto.Proc.Result\n\n    object Result {\n\n      @datatype class Normal(val exitCode: Z, val out: String, val err: String) extends Result\n\n      @datatype class Exception(val err: String) extends Result {\n        def out: String = {\n          return \"\"\n        }\n        def exitCode: Z = {\n          return -100\n        }\n      }\n\n      @datatype class Timeout(val out: String, val err: String) extends Result {\n        def exitCode: Z = {\n          return -101\n        }\n      }\n\n    }\n  }\n\n  @datatype class Proc(val cmds: ISZ[String],\n                       val wd: Path,\n                       val envMap: Map[String, String],\n                       val shouldAddEnv: B,\n                       val in: Option[String],\n                       val isErrAsOut: B,\n                       val shouldOutputConsole: B,\n                       val isErrBuffered: B,\n                       val shouldPrintEnv: B,\n                       val shouldPrintCommands: B,\n                       val timeoutInMillis: Z,\n                       val shouldUseStandardLib: B,\n                       val isScript: B,\n                       val outLineActionOpt: Option[String => B],\n                       val errLineActionOpt: Option[String => B]) extends OsProto.Proc {\n\n    @pure def commands(cs: ISZ[String]): Proc = {\n      val thisL = this\n      return thisL(cmds = cmds ++ cs)\n    }\n\n    @pure def at(dir: OsProto.Path): Proc = {\n      val thisL = this\n      return thisL(wd = Os.Path.Impl(dir.string))\n    }\n\n    @pure def env(m: ISZ[(String, String)]): Proc = {\n      val thisL = this\n      return thisL(envMap = this.envMap ++ m)\n    }\n\n    @pure def input(content: String): Proc = {\n      val thisL = this\n      return thisL(in = Some(content))\n    }\n\n    @pure def timeout(millis: Z): Proc = {\n      val thisL = this\n      return thisL(timeoutInMillis = millis)\n    }\n\n    @pure def dontInheritEnv: Proc = {\n      val thisL = this\n      return thisL(shouldAddEnv = F)\n    }\n\n    @pure def redirectErr: Proc = {\n      val thisL = this\n      return thisL(isErrAsOut = T)\n    }\n\n    @pure def bufferErr: Proc = {\n      val thisL = this\n      return thisL(isErrBuffered = T)\n    }\n\n    @pure def console: Proc = {\n      val thisL = this\n      return thisL(shouldOutputConsole = T)\n    }\n\n    @pure def echoEnv: Proc = {\n      val thisL = this\n      return thisL(shouldPrintEnv = T)\n    }\n\n    @pure def echo: Proc = {\n      val thisL = this\n      return thisL(shouldPrintCommands = T)\n    }\n\n    @pure def standard: Proc = {\n      val thisL = this\n      return thisL(shouldUseStandardLib = T)\n    }\n\n    @pure def script: Proc = {\n      val thisL = this\n      return thisL(isScript = T)\n    }\n\n    @pure def outLineAction(f: String => B): Proc = {\n      val thisL = this\n      return thisL(outLineActionOpt = Some(f))\n    }\n\n    @pure def errLineAction(f: String => B): Proc = {\n      val thisL = this\n      return thisL(errLineActionOpt = Some(f))\n    }\n\n    def run(): Proc.Result = {\n      val r = Ext.proc(this)\n      return r\n    }\n\n    def runCheck(): Proc.Result = {\n      val r = run()\n      if (!r.ok) {\n        eprintln(\n          st\"\"\"Error encountered when running: ${(cmds, \" \")}, exit code: ${r.exitCode}\n              |${r.err}\"\"\".render)\n        Os.exit(-1)\n      }\n      return r\n    }\n  }\n\n  @sig sealed trait Path extends OsProto.Path {\n\n    @pure def value: String\n\n    @strictpure def procString: String = ops.StringOps(value).replaceAllChars(\' \', \'␣\')\n\n    @pure def /(name: String): Path = {\n      return Path.Impl(s\"$value$fileSep$name\")\n    }\n\n    @pure def /+(names: ISZ[String]): Path = {\n      return Path.Impl(st\"$value$fileSep${(names, fileSep)}\".render)\n    }\n\n    def call(args: ISZ[String]): Os.Proc = {\n      return Os.proc(((if (Os.isWin) ISZ[String](\"cmd\", \"/c\") else ISZ[String](\"sh\")) :+ string) ++ args)\n    }\n\n    def canon: Path = {\n      val p = Ext.canon(value)\n      return if (p == value) this else Path.Impl(p)\n    }\n\n    def abs: Path = {\n      val p = Ext.abs(value)\n      return if (p == value) this else Path.Impl(p)\n    }\n\n    def chmod(mask: String): Unit = {\n      Ext.chmod(value, mask, F)\n    }\n\n    def chmodAll(mask: String): Unit = {\n      Ext.chmod(value, mask, T)\n    }\n\n    def copyTo(target: Path): Unit = {\n      Ext.copy(value, target.value, F)\n    }\n\n    def copyOverTo(target: Path): Unit = {\n      Ext.copy(value, target.value, T)\n    }\n\n    def downloadFrom(url: String): B = {\n      return Ext.download(value, url)\n    }\n\n    def exists: B = {\n      return Ext.exists(value)\n    }\n\n    @pure def ext: String = {\n      val nameOps = ops.StringOps(name)\n      val i = nameOps.lastIndexOf(\'.\')\n      return if (i >= 0) nameOps.substring(i + 1, name.size) else \"\"\n    }\n\n    def isAbs: B = {\n      return Ext.isAbs(value)\n    }\n\n    def isDir: B = {\n      return Ext.isDir(value)\n    }\n\n    def isFile: B = {\n      return Ext.isFile(value)\n    }\n\n    def isSymLink: B = {\n      return Ext.isSymLink(value)\n    }\n\n    def kind: Path.Kind.Type = {\n      return Ext.kind(value)\n    }\n\n    def lastModified: Z = {\n      return Ext.lastModified(value)\n    }\n\n    def length: Z = {\n      return Ext.length(value)\n    }\n\n    def list: ISZ[Path] = {\n      return for (filename <- Ext.list(value)) yield this / filename\n    }\n\n    def mergeFrom(sources: ISZ[Os.Path]): Unit = {\n      Ext.mergeFrom(value, for (p <- sources) yield p.value)\n    }\n\n    def md5: String = {\n      return Ext.md5(value)\n    }\n\n    def moveTo(target: Path): Unit = {\n      Ext.move(value, target.value, F)\n    }\n\n    def moveOverTo(target: Path): Unit = {\n      Ext.move(value, target.value, T)\n    }\n\n    def mkdir(): Unit = {\n      Ext.mkdir(value, F)\n    }\n\n    def mkdirAll(): Unit = {\n      Ext.mkdir(value, T)\n    }\n\n    def mklink(target: Path): Unit = {\n      Ext.mklink(value, target.value)\n    }\n\n    @pure def name: String = {\n      return Ext.name(value)\n    }\n\n    def overlayCopy(target: Os.Path, includeDir: B, followLink: B,\n                    pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      return Path.overlay(F, this, target, includeDir, followLink, pred, report)\n    }\n\n    def overlayMove(target: Os.Path, includeDir: B, followLink: B,\n                    pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      return Path.overlay(T, this, target, includeDir, followLink, pred, report)\n    }\n\n    def properties: Map[String, String] = {\n      return Ext.properties(value)\n    }\n\n    def readSymLink: Option[Path] = {\n      val r = Ext.readSymLink(value)\n      return r.map(o => Path.Impl(o))\n    }\n\n    @pure def relativize(other: Path): Path = {\n      return Path.Impl(Ext.relativize(value, other.value))\n    }\n\n    def read: String = {\n      return Ext.read(value)\n    }\n\n    def readLines: ISZ[String] = {\n      return Ext.readLineStream(value).toISZ\n    }\n\n    def readLineStream: Jen[String] = {\n      return Ext.readLineStream(value)\n    }\n\n    def readLineMStream: MJen[String] = {\n      return Ext.readLineMStream(value)\n    }\n\n    def readU8s: ISZ[U8] = {\n      return Ext.readU8s(value)\n    }\n\n    def readU8ms: MSZ[U8] = {\n      return Ext.readU8ms(value)\n    }\n\n    def readU8Stream: Jen[U8] = {\n      return Ext.readU8Stream(value)\n    }\n\n    def readU8MStream: MJen[U8] = {\n      return Ext.readU8MStream(value)\n    }\n\n    def readCStream: Jen[C] = {\n      return Ext.readCStream(value)\n    }\n\n    def readIndexableC: Indexable.Pos[C] = {\n      return Ext.readIndexableCPath(value)\n    }\n\n    def readCMStream: MJen[C] = {\n      return Ext.readCMStream(value)\n    }\n\n    def remove(): Unit = {\n      Ext.remove(value)\n    }\n\n    def removeAll(): Unit = {\n      Ext.removeAll(value)\n    }\n\n    def removeOnExit(): Unit = {\n      Ext.removeOnExit(value)\n    }\n\n    def sha1: String = {\n      return Ext.sha1(value)\n    }\n\n    def size: Z = {\n      return Ext.size(value)\n    }\n\n    def slash(args: ISZ[String]): Unit = {\n      val nativ = this / \".com\"\n      if (nativ.exists && this.lastModified < nativ.lastModified) {\n        Os.proc(string +: args).console.runCheck()\n      } else {\n        nativ.removeAll()\n        proc(string +: args).script.console.runCheck()\n      }\n    }\n\n    def toUri: String = {\n      return Ext.toUri(value)\n    }\n\n    def write(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOver(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppend(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Append)\n    }\n\n    def writeLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Regular)\n    }\n\n    def writeU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Over)\n    }\n\n    def writeOverU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Append)\n    }\n\n    def writeAppendU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Append)\n    }\n\n    def writeU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Regular)\n    }\n\n    def writeU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Over)\n    }\n\n    def writeOverU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Append)\n    }\n\n    def writeAppendU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Append)\n    }\n\n    def writeU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Append)\n    }\n\n    def zipTo(target: Os.Path): Unit = {\n      Ext.zip(value, target.value)\n    }\n\n    def unzipTo(target: Os.Path): Unit = {\n      Ext.unzip(value, target.value)\n    }\n\n    @pure def up: Path = {\n      return Path.Impl(Ext.parent(value))\n    }\n  }\n\n  @ext(\"Os_Ext\") object Ext {\n\n    @pure def cliArgs: ISZ[String] = $\n\n    @pure def cwd: String = $\n\n    @pure def fileSep: String = $\n\n    @pure def home: String = $\n\n    @pure def lineSep: String = $\n\n    @pure def pathSep: String = $\n\n    @pure def pathSepChar: C = $\n\n    @pure def os: Kind.Type = $\n\n    def roots: ISZ[String] = $\n\n    def abs(path: String): String = $\n\n    def canon(path: String): String = $\n\n    def chm
  #784 = String             #783          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject Os {\n\n  @pure def cliArgs: ISZ[String] = {\n    return Ext.cliArgs\n  }\n\n  @memoize def cwd: Path = {\n    return Path.Impl(Ext.cwd)\n  }\n\n  def exit(code: Z): Unit = {\n    Ext.exit(code)\n  }\n\n  def env(name: String): Option[String] = {\n    return Ext.env(name)\n  }\n\n  def envs: Map[String, String] = {\n    return Ext.envs\n  }\n\n  @pure def fileSep: String = {\n    return Ext.fileSep\n  }\n\n  @pure def uriToPath(uri: String): Os.Path = {\n    return Path.Impl(Ext.fromUri(uri))\n  }\n\n  @memoize def home: Path = {\n    return Path.Impl(Ext.home)\n  }\n\n  @pure def isLinux: B = {\n    return kind == Kind.Linux\n  }\n\n  @pure def isMac: B = {\n    return kind == Kind.Mac\n  }\n\n  @pure def isWin: B = {\n    return kind == Kind.Win\n  }\n\n  @pure def pathSep: String = {\n    return Ext.pathSep\n  }\n\n  @pure def lineSep: String = {\n    return Ext.lineSep\n  }\n\n  @pure def pathSepChar: C = {\n    return Ext.pathSepChar\n  }\n\n  @pure def kind: Kind.Type = {\n    return Ext.os\n  }\n\n  @pure def readIndexableCFrom(url: String): Indexable.Pos[C] = {\n    return Ext.readIndexableCUrl(url)\n  }\n\n  @pure def path(value: String): Path = {\n    if (isWin) {\n      val sOps = ops.StringOps(value)\n      val cygPrefix: String = \"/cygdrive/\"\n      if (sOps.startsWith(cygPrefix)) {\n        return Path.Impl(\n          ops.StringOps(s\"${sOps.substring(cygPrefix.size, cygPrefix.size + 1)}:${sOps.substring(cygPrefix.size + 1, value.size)}\").replaceAllChars(\'/\', \'\\\\\'))\n\n      } else if (sOps.startsWith(\"/\") && env(\"OSTYPE\") == Some(\"msys\")) {\n        return Path.Impl(ops.StringOps(s\"${sOps.substring(1, 2)}:${sOps.substring(2, value.size)}\").\n          replaceAllChars(\'/\', \'\\\\\'))\n      }\n    }\n    return Path.Impl(Ext.norm(value))\n  }\n\n  @pure def proc(commands: ISZ[String]): Proc = {\n    return Proc(commands, cwd, Map.empty, T, None(), F, F, F, F, F, 0, F, F, None(), None())\n  }\n\n  @pure def procs(commands: String): Proc = {\n    val cmds: ISZ[String] = for (cmd <- ops.StringOps(commands).split((c: C) => c == \' \')) yield\n      ops.StringOps(cmd).replaceAllChars(\'␣\', \' \')\n    return proc(cmds)\n  }\n\n  @memoize def roots: ISZ[Path] = {\n    return for (root <- Ext.roots) yield Path.Impl(root)\n  }\n\n  def slashDir: Os.Path = {\n    return Os.path(Ext.slashDir)\n  }\n\n  def temp(): Path = {\n    val r = tempFix(\"\", \"\")\n    return r\n  }\n\n  def tempFix(prefix: String, suffix: String): Path = {\n    val r = Ext.temp(prefix, suffix)\n    return Path.Impl(r)\n  }\n\n  def tempDir(): Path = {\n    val r = tempDirFix(\"\")\n    return r\n  }\n\n  def tempDirFix(prefix: String): Path = {\n    val r = Ext.tempDir(prefix)\n    return Path.Impl(r)\n  }\n\n\n  @enum object Kind {\n    \'Mac\n    \'Linux\n    \'LinuxArm\n    \'Win\n    \'Unsupported\n  }\n\n  object Path {\n\n    @enum object Kind {\n      \'Dir\n      \'File\n      \'SymLink\n      \'Other\n    }\n\n    @enum object WriteMode {\n      \'Regular\n      \'Over\n      \'Append\n    }\n\n    @datatype class Impl(val value: String) extends Path {\n      override def string: String = {\n        return value\n      }\n    }\n\n    @sig trait Jen[T] extends org.sireum.Jen[T] {\n      def path: Path\n      override def string: String = {\n        return s\"Jen($path)\"\n      }\n    }\n\n    @msig trait MJen[T] extends org.sireum.MJen[T] {\n      def path: Path\n      override def string: String = {\n        return s\"MJen($path)\"\n      }\n    }\n\n    def overlay(isMove: B, path: Os.Path, target: Os.Path, includeDir: B, followLink: B,\n                pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      var r = HashSMap.empty[Os.Path, Os.Path]\n      val files = ops.ISZOps(walk(path, includeDir, T, pred)).reverse\n      for (p <- files) {\n        val t = target / path.relativize(p).string\n        p.kind match {\n          case Kind.Dir =>\n            t.mkdirAll()\n            if (isMove) {\n              p.remove()\n            }\n            if (report) {\n              r = r + p ~> t\n            }\n          case Kind.File =>\n            t.up.mkdirAll()\n            if (isMove) {\n              p.moveOverTo(t)\n            } else {\n              p.copyOverTo(t)\n            }\n            if (report) {\n              r = r + p ~> t\n            }\n          case Kind.SymLink if isMove =>\n            p.remove()\n          case _ =>\n        }\n      }\n      return r\n    }\n\n    def walk(path: Os.Path, includeDir: B, followLink: B, pred: Os.Path => B @pure): ISZ[Os.Path] = {\n      var rSet = HashSSet.empty[Os.Path]\n      var rIS = ISZ[Os.Path]()\n      def add(p: Os.Path): Unit = {\n        val pCanon = p.canon\n        if (followLink) {\n          rSet = rSet + pCanon\n        } else {\n          rIS = rIS :+ pCanon\n        }\n      }\n      def rec(p: Os.Path): Unit = {\n        if (!followLink && rSet.contains(p.canon)) {\n          return\n        }\n        p.kind match {\n          case Os.Path.Kind.Dir =>\n            if (includeDir && pred(p)) {\n              add(p)\n            }\n            for (p2 <- p.list) {\n              rec(p2)\n            }\n          case Os.Path.Kind.File if pred(p) => add(p)\n          case Os.Path.Kind.SymLink if followLink =>\n            if (pred(p)) {\n              add(p)\n            }\n            val tOpt = p.readSymLink\n            tOpt match {\n              case Some(t) => rec(t)\n              case _ =>\n            }\n          case _ =>\n        }\n      }\n      rec(path)\n      return if (followLink) rSet.map.keys else rIS\n    }\n\n  }\n\n  object Proc {\n\n    @sig sealed trait Result extends OsProto.Proc.Result\n\n    object Result {\n\n      @datatype class Normal(val exitCode: Z, val out: String, val err: String) extends Result\n\n      @datatype class Exception(val err: String) extends Result {\n        def out: String = {\n          return \"\"\n        }\n        def exitCode: Z = {\n          return -100\n        }\n      }\n\n      @datatype class Timeout(val out: String, val err: String) extends Result {\n        def exitCode: Z = {\n          return -101\n        }\n      }\n\n    }\n  }\n\n  @datatype class Proc(val cmds: ISZ[String],\n                       val wd: Path,\n                       val envMap: Map[String, String],\n                       val shouldAddEnv: B,\n                       val in: Option[String],\n                       val isErrAsOut: B,\n                       val shouldOutputConsole: B,\n                       val isErrBuffered: B,\n                       val shouldPrintEnv: B,\n                       val shouldPrintCommands: B,\n                       val timeoutInMillis: Z,\n                       val shouldUseStandardLib: B,\n                       val isScript: B,\n                       val outLineActionOpt: Option[String => B],\n                       val errLineActionOpt: Option[String => B]) extends OsProto.Proc {\n\n    @pure def commands(cs: ISZ[String]): Proc = {\n      val thisL = this\n      return thisL(cmds = cmds ++ cs)\n    }\n\n    @pure def at(dir: OsProto.Path): Proc = {\n      val thisL = this\n      return thisL(wd = Os.Path.Impl(dir.string))\n    }\n\n    @pure def env(m: ISZ[(String, String)]): Proc = {\n      val thisL = this\n      return thisL(envMap = this.envMap ++ m)\n    }\n\n    @pure def input(content: String): Proc = {\n      val thisL = this\n      return thisL(in = Some(content))\n    }\n\n    @pure def timeout(millis: Z): Proc = {\n      val thisL = this\n      return thisL(timeoutInMillis = millis)\n    }\n\n    @pure def dontInheritEnv: Proc = {\n      val thisL = this\n      return thisL(shouldAddEnv = F)\n    }\n\n    @pure def redirectErr: Proc = {\n      val thisL = this\n      return thisL(isErrAsOut = T)\n    }\n\n    @pure def bufferErr: Proc = {\n      val thisL = this\n      return thisL(isErrBuffered = T)\n    }\n\n    @pure def console: Proc = {\n      val thisL = this\n      return thisL(shouldOutputConsole = T)\n    }\n\n    @pure def echoEnv: Proc = {\n      val thisL = this\n      return thisL(shouldPrintEnv = T)\n    }\n\n    @pure def echo: Proc = {\n      val thisL = this\n      return thisL(shouldPrintCommands = T)\n    }\n\n    @pure def standard: Proc = {\n      val thisL = this\n      return thisL(shouldUseStandardLib = T)\n    }\n\n    @pure def script: Proc = {\n      val thisL = this\n      return thisL(isScript = T)\n    }\n\n    @pure def outLineAction(f: String => B): Proc = {\n      val thisL = this\n      return thisL(outLineActionOpt = Some(f))\n    }\n\n    @pure def errLineAction(f: String => B): Proc = {\n      val thisL = this\n      return thisL(errLineActionOpt = Some(f))\n    }\n\n    def run(): Proc.Result = {\n      val r = Ext.proc(this)\n      return r\n    }\n\n    def runCheck(): Proc.Result = {\n      val r = run()\n      if (!r.ok) {\n        eprintln(\n          st\"\"\"Error encountered when running: ${(cmds, \" \")}, exit code: ${r.exitCode}\n              |${r.err}\"\"\".render)\n        Os.exit(-1)\n      }\n      return r\n    }\n  }\n\n  @sig sealed trait Path extends OsProto.Path {\n\n    @pure def value: String\n\n    @strictpure def procString: String = ops.StringOps(value).replaceAllChars(\' \', \'␣\')\n\n    @pure def /(name: String): Path = {\n      return Path.Impl(s\"$value$fileSep$name\")\n    }\n\n    @pure def /+(names: ISZ[String]): Path = {\n      return Path.Impl(st\"$value$fileSep${(names, fileSep)}\".render)\n    }\n\n    def call(args: ISZ[String]): Os.Proc = {\n      return Os.proc(((if (Os.isWin) ISZ[String](\"cmd\", \"/c\") else ISZ[String](\"sh\")) :+ string) ++ args)\n    }\n\n    def canon: Path = {\n      val p = Ext.canon(value)\n      return if (p == value) this else Path.Impl(p)\n    }\n\n    def abs: Path = {\n      val p = Ext.abs(value)\n      return if (p == value) this else Path.Impl(p)\n    }\n\n    def chmod(mask: String): Unit = {\n      Ext.chmod(value, mask, F)\n    }\n\n    def chmodAll(mask: String): Unit = {\n      Ext.chmod(value, mask, T)\n    }\n\n    def copyTo(target: Path): Unit = {\n      Ext.copy(value, target.value, F)\n    }\n\n    def copyOverTo(target: Path): Unit = {\n      Ext.copy(value, target.value, T)\n    }\n\n    def downloadFrom(url: String): B = {\n      return Ext.download(value, url)\n    }\n\n    def exists: B = {\n      return Ext.exists(value)\n    }\n\n    @pure def ext: String = {\n      val nameOps = ops.StringOps(name)\n      val i = nameOps.lastIndexOf(\'.\')\n      return if (i >= 0) nameOps.substring(i + 1, name.size) else \"\"\n    }\n\n    def isAbs: B = {\n      return Ext.isAbs(value)\n    }\n\n    def isDir: B = {\n      return Ext.isDir(value)\n    }\n\n    def isFile: B = {\n      return Ext.isFile(value)\n    }\n\n    def isSymLink: B = {\n      return Ext.isSymLink(value)\n    }\n\n    def kind: Path.Kind.Type = {\n      return Ext.kind(value)\n    }\n\n    def lastModified: Z = {\n      return Ext.lastModified(value)\n    }\n\n    def length: Z = {\n      return Ext.length(value)\n    }\n\n    def list: ISZ[Path] = {\n      return for (filename <- Ext.list(value)) yield this / filename\n    }\n\n    def mergeFrom(sources: ISZ[Os.Path]): Unit = {\n      Ext.mergeFrom(value, for (p <- sources) yield p.value)\n    }\n\n    def md5: String = {\n      return Ext.md5(value)\n    }\n\n    def moveTo(target: Path): Unit = {\n      Ext.move(value, target.value, F)\n    }\n\n    def moveOverTo(target: Path): Unit = {\n      Ext.move(value, target.value, T)\n    }\n\n    def mkdir(): Unit = {\n      Ext.mkdir(value, F)\n    }\n\n    def mkdirAll(): Unit = {\n      Ext.mkdir(value, T)\n    }\n\n    def mklink(target: Path): Unit = {\n      Ext.mklink(value, target.value)\n    }\n\n    @pure def name: String = {\n      return Ext.name(value)\n    }\n\n    def overlayCopy(target: Os.Path, includeDir: B, followLink: B,\n                    pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      return Path.overlay(F, this, target, includeDir, followLink, pred, report)\n    }\n\n    def overlayMove(target: Os.Path, includeDir: B, followLink: B,\n                    pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      return Path.overlay(T, this, target, includeDir, followLink, pred, report)\n    }\n\n    def properties: Map[String, String] = {\n      return Ext.properties(value)\n    }\n\n    def readSymLink: Option[Path] = {\n      val r = Ext.readSymLink(value)\n      return r.map(o => Path.Impl(o))\n    }\n\n    @pure def relativize(other: Path): Path = {\n      return Path.Impl(Ext.relativize(value, other.value))\n    }\n\n    def read: String = {\n      return Ext.read(value)\n    }\n\n    def readLines: ISZ[String] = {\n      return Ext.readLineStream(value).toISZ\n    }\n\n    def readLineStream: Jen[String] = {\n      return Ext.readLineStream(value)\n    }\n\n    def readLineMStream: MJen[String] = {\n      return Ext.readLineMStream(value)\n    }\n\n    def readU8s: ISZ[U8] = {\n      return Ext.readU8s(value)\n    }\n\n    def readU8ms: MSZ[U8] = {\n      return Ext.readU8ms(value)\n    }\n\n    def readU8Stream: Jen[U8] = {\n      return Ext.readU8Stream(value)\n    }\n\n    def readU8MStream: MJen[U8] = {\n      return Ext.readU8MStream(value)\n    }\n\n    def readCStream: Jen[C] = {\n      return Ext.readCStream(value)\n    }\n\n    def readIndexableC: Indexable.Pos[C] = {\n      return Ext.readIndexableCPath(value)\n    }\n\n    def readCMStream: MJen[C] = {\n      return Ext.readCMStream(value)\n    }\n\n    def remove(): Unit = {\n      Ext.remove(value)\n    }\n\n    def removeAll(): Unit = {\n      Ext.removeAll(value)\n    }\n\n    def removeOnExit(): Unit = {\n      Ext.removeOnExit(value)\n    }\n\n    def sha1: String = {\n      return Ext.sha1(value)\n    }\n\n    def size: Z = {\n      return Ext.size(value)\n    }\n\n    def slash(args: ISZ[String]): Unit = {\n      val nativ = this / \".com\"\n      if (nativ.exists && this.lastModified < nativ.lastModified) {\n        Os.proc(string +: args).console.runCheck()\n      } else {\n        nativ.removeAll()\n        proc(string +: args).script.console.runCheck()\n      }\n    }\n\n    def toUri: String = {\n      return Ext.toUri(value)\n    }\n\n    def write(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOver(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppend(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Append)\n    }\n\n    def writeLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Regular)\n    }\n\n    def writeU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Over)\n    }\n\n    def writeOverU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Append)\n    }\n\n    def writeAppendU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Append)\n    }\n\n    def writeU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Regular)\n    }\n\n    def writeU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Over)\n    }\n\n    def writeOverU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Append)\n    }\n\n    def writeAppendU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Append)\n    }\n\n    def writeU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Append)\n    }\n\n    def zipTo(target: Os.Path): Unit = {\n      Ext.zip(value, target.value)\n    }\n\n    def unzipTo(target: Os.Path): Unit = {\n      Ext.unzip(value, target.value)\n    }\n\n    @pure def up: Path = {\n      return Path.Impl(Ext.parent(value))\n    }\n  }\n\n  @ext(\"Os_Ext\") object Ext {\n\n    @pure def cliArgs: ISZ[String] = $\n\n    @pure def cwd: String = $\n\n    @pure def fileSep: String = $\n\n    @pure def home: String = $\n\n    @pure def lineSep: String = $\n\n    @pure def pathSep: String = $\n\n    @pure def pathSepChar: C = $\n\n    @pure def os: Kind.Type = $\n\n    def roots: ISZ[String] = $\n\n    def abs(path: String): String = $\n\n    def canon(path: String): String = $\n\n    def chm
  #785 = Utf8               od(path: String, mask: String, all: B): Unit = $\n\n    def copy(path: String, target: String, over: B): Unit = $\n\n    def download(path: String, url: String): B = $\n\n    def env(name: String): Option[String] = $\n\n    def envs: Map[String, String] = $\n\n    def exists(path: String): B = $\n\n    def exit(code: Z): Unit = $\n\n    def fromUri(uri: String): String = $\n\n    @pure def isAbs(path: String): B = $\n\n    def isDir(path: String): B = $\n\n    def isFile(path: String): B = $\n\n    def isSymLink(path: String): B = $\n\n    def kind(path: String): Path.Kind.Type = $\n\n    def lastModified(path: String): Z = $\n\n    def length(path: String): Z = $\n\n    def list(path: String): ISZ[String] = $\n\n    def mergeFrom(path: String, sources: ISZ[String]): Unit = $\n\n    def md5(path: String): String = $\n\n    def move(path: String, target: String, over: B): Unit = $\n\n    def mkdir(path: String, all: B): Unit = $\n\n    def mklink(path: String, target: String): Unit = $\n\n    @pure def name(path: String): String = $\n\n    @pure def norm(path: String): String = $\n\n    def properties(path: String): Map[String, String] = $\n\n    def readSymLink(path: String): Option[String] = $\n\n    @pure def relativize(path: String, other: String): String = $\n\n    def read(path: String): String = $\n\n    def readU8s(path: String): ISZ[U8] = $\n\n    def readU8ms(path: String): MSZ[U8] = $\n\n    def readLineStream(path: String): Path.Jen[String] = $\n\n    def readU8Stream(path: String): Path.Jen[U8] = $\n\n    def readCStream(path: String): Path.Jen[C] = $\n\n    def readIndexableCPath(path: String): Indexable.Pos[C] = $\n\n    def readIndexableCUrl(url: String): Indexable.Pos[C] = $\n\n    def readLineMStream(path: String): Path.MJen[String] = $\n\n    def readCMStream(path: String): Path.MJen[C] = $\n\n    def readU8MStream(path: String): Path.MJen[U8] = $\n\n    def remove(path: String): Unit = $\n\n    def removeAll(path: String): Unit = $\n\n    def removeOnExit(path: String): Unit = $\n\n    def sha1(path: String): String = $\n\n    def slashDir: String = $\n\n    def size(path: String): Z = $\n\n    def temp(prefix: String, suffix: String): String = $\n\n    def tempDir(prefix: String): String = $\n\n    def toUri(path: String): String = $\n\n    def write(path: String, content: String, mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8s(path: String, u8s: ISZ[U8], offset: Z, len: Z, mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8ms(path: String, u8s: MSZ[U8], offset: Z, len: Z, mode: Path.WriteMode.Type): Unit = $\n\n    def writeLineStream(path: String, lines: Jen[String], mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8Stream(path: String, u8s: Jen[U8], mode: Path.WriteMode.Type): Unit = $\n\n    def writeCStream(path: String, cs: Jen[C], mode: Path.WriteMode.Type): Unit = $\n\n    def writeLineMStream(path: String, lines: MJen[String], mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8MStream(path: String, u8s: MJen[U8], mode: Path.WriteMode.Type): Unit = $\n\n    def writeCMStream(path: String, cs: MJen[C], mode: Path.WriteMode.Type): Unit = $\n\n    def zip(path: String, target: String): Unit = $\n\n    def unzip(path: String, target: String): Unit = $\n\n    @pure def parent(path: String): String = $\n\n    def proc(e: Proc): Proc.Result = $\n\n  }\n\n}\n\n
  #786 = String             #785          // od(path: String, mask: String, all: B): Unit = $\n\n    def copy(path: String, target: String, over: B): Unit = $\n\n    def download(path: String, url: String): B = $\n\n    def env(name: String): Option[String] = $\n\n    def envs: Map[String, String] = $\n\n    def exists(path: String): B = $\n\n    def exit(code: Z): Unit = $\n\n    def fromUri(uri: String): String = $\n\n    @pure def isAbs(path: String): B = $\n\n    def isDir(path: String): B = $\n\n    def isFile(path: String): B = $\n\n    def isSymLink(path: String): B = $\n\n    def kind(path: String): Path.Kind.Type = $\n\n    def lastModified(path: String): Z = $\n\n    def length(path: String): Z = $\n\n    def list(path: String): ISZ[String] = $\n\n    def mergeFrom(path: String, sources: ISZ[String]): Unit = $\n\n    def md5(path: String): String = $\n\n    def move(path: String, target: String, over: B): Unit = $\n\n    def mkdir(path: String, all: B): Unit = $\n\n    def mklink(path: String, target: String): Unit = $\n\n    @pure def name(path: String): String = $\n\n    @pure def norm(path: String): String = $\n\n    def properties(path: String): Map[String, String] = $\n\n    def readSymLink(path: String): Option[String] = $\n\n    @pure def relativize(path: String, other: String): String = $\n\n    def read(path: String): String = $\n\n    def readU8s(path: String): ISZ[U8] = $\n\n    def readU8ms(path: String): MSZ[U8] = $\n\n    def readLineStream(path: String): Path.Jen[String] = $\n\n    def readU8Stream(path: String): Path.Jen[U8] = $\n\n    def readCStream(path: String): Path.Jen[C] = $\n\n    def readIndexableCPath(path: String): Indexable.Pos[C] = $\n\n    def readIndexableCUrl(url: String): Indexable.Pos[C] = $\n\n    def readLineMStream(path: String): Path.MJen[String] = $\n\n    def readCMStream(path: String): Path.MJen[C] = $\n\n    def readU8MStream(path: String): Path.MJen[U8] = $\n\n    def remove(path: String): Unit = $\n\n    def removeAll(path: String): Unit = $\n\n    def removeOnExit(path: String): Unit = $\n\n    def sha1(path: String): String = $\n\n    def slashDir: String = $\n\n    def size(path: String): Z = $\n\n    def temp(prefix: String, suffix: String): String = $\n\n    def tempDir(prefix: String): String = $\n\n    def toUri(path: String): String = $\n\n    def write(path: String, content: String, mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8s(path: String, u8s: ISZ[U8], offset: Z, len: Z, mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8ms(path: String, u8s: MSZ[U8], offset: Z, len: Z, mode: Path.WriteMode.Type): Unit = $\n\n    def writeLineStream(path: String, lines: Jen[String], mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8Stream(path: String, u8s: Jen[U8], mode: Path.WriteMode.Type): Unit = $\n\n    def writeCStream(path: String, cs: Jen[C], mode: Path.WriteMode.Type): Unit = $\n\n    def writeLineMStream(path: String, lines: MJen[String], mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8MStream(path: String, u8s: MJen[U8], mode: Path.WriteMode.Type): Unit = $\n\n    def writeCMStream(path: String, cs: MJen[C], mode: Path.WriteMode.Type): Unit = $\n\n    def zip(path: String, target: String): Unit = $\n\n    def unzip(path: String, target: String): Unit = $\n\n    @pure def parent(path: String): String = $\n\n    def proc(e: Proc): Proc.Result = $\n\n  }\n\n}\n\n
  #787 = Utf8               // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n\n@enum object CoursierClassifier {\n  \'Default\n  \'Javadoc\n  \'Sources\n  \'Tests\n}\n\n@datatype class CoursierFileInfo(val org: String,\n                                 val module: String,\n                                 val version: String,\n                                 val path: Os.Path)\n\n@ext object Coursier {\n\n  def cacheOpt: Option[Os.Path] = $\n\n  def scalaVersion: String = $\n\n  def setScalaVersion(version: String): Unit = $\n\n  def setCache(pathOpt: Option[Os.Path]): Unit = $\n\n  def addMavenRepositories(urls: ISZ[String]): Unit = $\n\n  def setMavenRepositories(urls: ISZ[String]): Unit = $\n\n  def mavenRepoUrls: ISZ[String] = $\n\n  def fetch(deps: ISZ[String]): ISZ[CoursierFileInfo] = $\n\n  def fetchClassifiers(deps: ISZ[String], cls: ISZ[CoursierClassifier.Type]): ISZ[CoursierFileInfo] = $\n\n  def isRuntimePublishedLocally(version: String): B = $\n}\n
  #788 = String             #787          // // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n\n@enum object CoursierClassifier {\n  \'Default\n  \'Javadoc\n  \'Sources\n  \'Tests\n}\n\n@datatype class CoursierFileInfo(val org: String,\n                                 val module: String,\n                                 val version: String,\n                                 val path: Os.Path)\n\n@ext object Coursier {\n\n  def cacheOpt: Option[Os.Path] = $\n\n  def scalaVersion: String = $\n\n  def setScalaVersion(version: String): Unit = $\n\n  def setCache(pathOpt: Option[Os.Path]): Unit = $\n\n  def addMavenRepositories(urls: ISZ[String]): Unit = $\n\n  def setMavenRepositories(urls: ISZ[String]): Unit = $\n\n  def mavenRepoUrls: ISZ[String] = $\n\n  def fetch(deps: ISZ[String]): ISZ[CoursierFileInfo] = $\n\n  def fetchClassifiers(deps: ISZ[String], cls: ISZ[CoursierClassifier.Type]): ISZ[CoursierFileInfo] = $\n\n  def isRuntimePublishedLocally(version: String): B = $\n}\n
  #789 = Utf8               p
  #790 = Utf8               org/sireum/Some$
  #791 = Class              #790          // org/sireum/Some$
  #792 = Utf8               Lorg/sireum/Some$;
  #793 = NameAndType        #21:#792      // MODULE$:Lorg/sireum/Some$;
  #794 = Fieldref           #791.#793     // org/sireum/Some$.MODULE$:Lorg/sireum/Some$;
  #795 = Utf8               org/sireum/String
  #796 = Class              #795          // org/sireum/String
  #797 = Utf8               org/sireum/String$
  #798 = Class              #797          // org/sireum/String$
  #799 = Utf8               Lorg/sireum/String$;
  #800 = NameAndType        #21:#799      // MODULE$:Lorg/sireum/String$;
  #801 = Fieldref           #798.#800     // org/sireum/String$.MODULE$:Lorg/sireum/String$;
  #802 = Utf8               _1
  #803 = Utf8               ()Ljava/lang/Object;
  #804 = NameAndType        #802:#803     // _1:()Ljava/lang/Object;
  #805 = Methodref          #44.#804      // scala/Tuple2._1:()Ljava/lang/Object;
  #806 = Utf8               scala/collection/IterableOnceOps
  #807 = Class              #806          // scala/collection/IterableOnceOps
  #808 = Utf8               /
  #809 = String             #808          // /
  #810 = Utf8               mkString
  #811 = Utf8               (Ljava/lang/String;)Ljava/lang/String;
  #812 = NameAndType        #810:#811     // mkString:(Ljava/lang/String;)Ljava/lang/String;
  #813 = InterfaceMethodref #807.#812     // scala/collection/IterableOnceOps.mkString:(Ljava/lang/String;)Ljava/lang/String;
  #814 = NameAndType        #70:#811      // apply:(Ljava/lang/String;)Ljava/lang/String;
  #815 = Methodref          #798.#814     // org/sireum/String$.apply:(Ljava/lang/String;)Ljava/lang/String;
  #816 = Utf8               (Ljava/lang/String;)V
  #817 = NameAndType        #25:#816      // "<init>":(Ljava/lang/String;)V
  #818 = Methodref          #796.#817     // org/sireum/String."<init>":(Ljava/lang/String;)V
  #819 = Utf8               (Ljava/lang/Object;)Lorg/sireum/Some;
  #820 = NameAndType        #70:#819      // apply:(Ljava/lang/Object;)Lorg/sireum/Some;
  #821 = Methodref          #791.#820     // org/sireum/Some$.apply:(Ljava/lang/Object;)Lorg/sireum/Some;
  #822 = Utf8               _2
  #823 = NameAndType        #822:#803     // _2:()Ljava/lang/Object;
  #824 = Methodref          #44.#823      // scala/Tuple2._2:()Ljava/lang/Object;
  #825 = Utf8               Lscala/Tuple2;
  #826 = Methodref          #4.#26        // java/lang/Object."<init>":()V
  #827 = Utf8               $deserializeLambda$
  #828 = Utf8               (Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
  #829 = Utf8               scala/runtime/LambdaDeserialize
  #830 = Class              #829          // scala/runtime/LambdaDeserialize
  #831 = Utf8               bootstrap
  #832 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/CallSite;
  #833 = NameAndType        #831:#832     // bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/CallSite;
  #834 = Methodref          #830.#833     // scala/runtime/LambdaDeserialize.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/CallSite;
  #835 = MethodHandle       6:#834        // REF_invokeStatic scala/runtime/LambdaDeserialize.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/CallSite;
  #836 = Utf8               lambdaDeserialize
  #837 = NameAndType        #836:#828     // lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
  #838 = InvokeDynamic      #2:#837       // #2:lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
  #839 = Utf8               Code
  #840 = Utf8               LineNumberTable
  #841 = Utf8               LocalVariableTable
  #842 = Utf8               Signature
  #843 = Utf8               MethodParameters
  #844 = Utf8               InnerClasses
  #845 = Utf8               SourceFile
  #846 = Utf8               BootstrapMethods
  #847 = Utf8               ScalaInlineInfo
  #848 = Utf8               Scala
{
  public static final org.sireum.Library_Ext$ MODULE$;
    descriptor: Lorg/sireum/Library_Ext$;
    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL

  public static {};
    descriptor: ()V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=0, args_size=0
         0: new           #2                  // class org/sireum/Library_Ext$
         3: dup
         4: invokespecial #27                 // Method "<init>":()V
         7: putstatic     #29                 // Field MODULE$:Lorg/sireum/Library_Ext$;
        10: return
      LineNumberTable:
        line 30: 0

  public scala.collection.Map<scala.collection.immutable.Vector<java.lang.String>, java.lang.String> sharedMap();
    descriptor: ()Lscala/collection/Map;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=13, locals=1, args_size=1
         0: getstatic     #37                 // Field scala/collection/immutable/ListMap$.MODULE$:Lscala/collection/immutable/ListMap$;
         3: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
         6: bipush        57
         8: anewarray     #44                 // class scala/Tuple2
        11: dup
        12: iconst_0
        13: new           #44                 // class scala/Tuple2
        16: dup
        17: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
        20: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
        23: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
        26: iconst_3
        27: anewarray     #55                 // class java/lang/String
        30: dup
        31: iconst_0
        32: ldc           #57                 // String org
        34: aastore
        35: dup
        36: iconst_1
        37: ldc           #59                 // String sireum
        39: aastore
        40: dup
        41: iconst_2
        42: ldc           #61                 // String HashBag.scala
        44: aastore
        45: checkcast     #63                 // class "[Ljava/lang/Object;"
        48: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
        51: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
        54: invokestatic  #77                 // Method f0$1:()Ljava/lang/String;
        57: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
        60: aastore
        61: dup
        62: iconst_1
        63: new           #44                 // class scala/Tuple2
        66: dup
        67: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
        70: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
        73: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
        76: iconst_3
        77: anewarray     #55                 // class java/lang/String
        80: dup
        81: iconst_0
        82: ldc           #57                 // String org
        84: aastore
        85: dup
        86: iconst_1
        87: ldc           #59                 // String sireum
        89: aastore
        90: dup
        91: iconst_2
        92: ldc           #82                 // String Indexable.scala
        94: aastore
        95: checkcast     #63                 // class "[Ljava/lang/Object;"
        98: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       101: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       104: invokestatic  #85                 // Method f0$2:()Ljava/lang/String;
       107: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       110: aastore
       111: dup
       112: iconst_2
       113: new           #44                 // class scala/Tuple2
       116: dup
       117: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       120: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       123: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       126: iconst_3
       127: anewarray     #55                 // class java/lang/String
       130: dup
       131: iconst_0
       132: ldc           #57                 // String org
       134: aastore
       135: dup
       136: iconst_1
       137: ldc           #59                 // String sireum
       139: aastore
       140: dup
       141: iconst_2
       142: ldc           #87                 // String Either.scala
       144: aastore
       145: checkcast     #63                 // class "[Ljava/lang/Object;"
       148: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       151: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       154: invokestatic  #90                 // Method f0$3:()Ljava/lang/String;
       157: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       160: aastore
       161: dup
       162: iconst_3
       163: new           #44                 // class scala/Tuple2
       166: dup
       167: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       170: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       173: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       176: iconst_4
       177: anewarray     #55                 // class java/lang/String
       180: dup
       181: iconst_0
       182: ldc           #57                 // String org
       184: aastore
       185: dup
       186: iconst_1
       187: ldc           #59                 // String sireum
       189: aastore
       190: dup
       191: iconst_2
       192: ldc           #92                 // String crypto
       194: aastore
       195: dup
       196: iconst_3
       197: ldc           #94                 // String SHA3.scala
       199: aastore
       200: checkcast     #63                 // class "[Ljava/lang/Object;"
       203: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       206: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       209: invokestatic  #97                 // Method f0$4:()Ljava/lang/String;
       212: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       215: aastore
       216: dup
       217: iconst_4
       218: new           #44                 // class scala/Tuple2
       221: dup
       222: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       225: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       228: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       231: iconst_3
       232: anewarray     #55                 // class java/lang/String
       235: dup
       236: iconst_0
       237: ldc           #57                 // String org
       239: aastore
       240: dup
       241: iconst_1
       242: ldc           #59                 // String sireum
       244: aastore
       245: dup
       246: iconst_2
       247: ldc           #99                 // String Hash.scala
       249: aastore
       250: checkcast     #63                 // class "[Ljava/lang/Object;"
       253: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       256: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       259: invokestatic  #102                // Method f0$5:()Ljava/lang/String;
       262: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       265: aastore
       266: dup
       267: iconst_5
       268: new           #44                 // class scala/Tuple2
       271: dup
       272: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       275: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       278: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       281: iconst_3
       282: anewarray     #55                 // class java/lang/String
       285: dup
       286: iconst_0
       287: ldc           #57                 // String org
       289: aastore
       290: dup
       291: iconst_1
       292: ldc           #59                 // String sireum
       294: aastore
       295: dup
       296: iconst_2
       297: ldc           #104                // String CircularQueue.scala
       299: aastore
       300: checkcast     #63                 // class "[Ljava/lang/Object;"
       303: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       306: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       309: invokestatic  #107                // Method f0$6:()Ljava/lang/String;
       312: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       315: aastore
       316: dup
       317: bipush        6
       319: new           #44                 // class scala/Tuple2
       322: dup
       323: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       326: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       329: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       332: iconst_3
       333: anewarray     #55                 // class java/lang/String
       336: dup
       337: iconst_0
       338: ldc           #57                 // String org
       340: aastore
       341: dup
       342: iconst_1
       343: ldc           #59                 // String sireum
       345: aastore
       346: dup
       347: iconst_2
       348: ldc           #109                // String Library.scala
       350: aastore
       351: checkcast     #63                 // class "[Ljava/lang/Object;"
       354: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       357: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       360: invokestatic  #112                // Method f0$7:()Ljava/lang/String;
       363: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       366: aastore
       367: dup
       368: bipush        7
       370: new           #44                 // class scala/Tuple2
       373: dup
       374: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       377: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       380: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       383: iconst_3
       384: anewarray     #55                 // class java/lang/String
       387: dup
       388: iconst_0
       389: ldc           #57                 // String org
       391: aastore
       392: dup
       393: iconst_1
       394: ldc           #59                 // String sireum
       396: aastore
       397: dup
       398: iconst_2
       399: ldc           #114                // String UnionFind.scala
       401: aastore
       402: checkcast     #63                 // class "[Ljava/lang/Object;"
       405: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       408: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       411: invokestatic  #117                // Method f0$8:()Ljava/lang/String;
       414: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       417: aastore
       418: dup
       419: bipush        8
       421: new           #44                 // class scala/Tuple2
       424: dup
       425: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       428: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       431: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       434: iconst_4
       435: anewarray     #55                 // class java/lang/String
       438: dup
       439: iconst_0
       440: ldc           #57                 // String org
       442: aastore
       443: dup
       444: iconst_1
       445: ldc           #59                 // String sireum
       447: aastore
       448: dup
       449: iconst_2
       450: ldc           #119                // String extension
       452: aastore
       453: dup
       454: iconst_3
       455: ldc           #121                // String Time.scala
       457: aastore
       458: checkcast     #63                 // class "[Ljava/lang/Object;"
       461: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       464: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       467: invokestatic  #124                // Method f0$9:()Ljava/lang/String;
       470: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       473: aastore
       474: dup
       475: bipush        9
       477: new           #44                 // class scala/Tuple2
       480: dup
       481: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       484: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       487: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       490: iconst_4
       491: anewarray     #55                 // class java/lang/String
       494: dup
       495: iconst_0
       496: ldc           #57                 // String org
       498: aastore
       499: dup
       500: iconst_1
       501: ldc           #59                 // String sireum
       503: aastore
       504: dup
       505: iconst_2
       506: ldc           #119                // String extension
       508: aastore
       509: dup
       510: iconst_3
       511: ldc           #126                // String Console.scala
       513: aastore
       514: checkcast     #63                 // class "[Ljava/lang/Object;"
       517: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       520: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       523: invokestatic  #129                // Method f0$10:()Ljava/lang/String;
       526: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       529: aastore
       530: dup
       531: bipush        10
       533: new           #44                 // class scala/Tuple2
       536: dup
       537: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       540: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       543: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       546: iconst_4
       547: anewarray     #55                 // class java/lang/String
       550: dup
       551: iconst_0
       552: ldc           #57                 // String org
       554: aastore
       555: dup
       556: iconst_1
       557: ldc           #59                 // String sireum
       559: aastore
       560: dup
       561: iconst_2
       562: ldc           #119                // String extension
       564: aastore
       565: dup
       566: iconst_3
       567: ldc           #131                // String Debug.scala
       569: aastore
       570: checkcast     #63                 // class "[Ljava/lang/Object;"
       573: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       576: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       579: invokestatic  #134                // Method f0$11:()Ljava/lang/String;
       582: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       585: aastore
       586: dup
       587: bipush        11
       589: new           #44                 // class scala/Tuple2
       592: dup
       593: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       596: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       599: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       602: iconst_4
       603: anewarray     #55                 // class java/lang/String
       606: dup
       607: iconst_0
       608: ldc           #57                 // String org
       610: aastore
       611: dup
       612: iconst_1
       613: ldc           #59                 // String sireum
       615: aastore
       616: dup
       617: iconst_2
       618: ldc           #119                // String extension
       620: aastore
       621: dup
       622: iconst_3
       623: ldc           #136                // String Cancel.scala
       625: aastore
       626: checkcast     #63                 // class "[Ljava/lang/Object;"
       629: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       632: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       635: invokestatic  #139                // Method f0$12:()Ljava/lang/String;
       638: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       641: aastore
       642: dup
       643: bipush        12
       645: new           #44                 // class scala/Tuple2
       648: dup
       649: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       652: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       655: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       658: iconst_3
       659: anewarray     #55                 // class java/lang/String
       662: dup
       663: iconst_0
       664: ldc           #57                 // String org
       666: aastore
       667: dup
       668: iconst_1
       669: ldc           #59                 // String sireum
       671: aastore
       672: dup
       673: iconst_2
       674: ldc           #141                // String BitsRangeTypes.scala
       676: aastore
       677: checkcast     #63                 // class "[Ljava/lang/Object;"
       680: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       683: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       686: invokestatic  #144                // Method f0$13:()Ljava/lang/String;
       689: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       692: aastore
       693: dup
       694: bipush        13
       696: new           #44                 // class scala/Tuple2
       699: dup
       700: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       703: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       706: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       709: iconst_3
       710: anewarray     #55                 // class java/lang/String
       713: dup
       714: iconst_0
       715: ldc           #57                 // String org
       717: aastore
       718: dup
       719: iconst_1
       720: ldc           #59                 // String sireum
       722: aastore
       723: dup
       724: iconst_2
       725: ldc           #146                // String Stack.scala
       727: aastore
       728: checkcast     #63                 // class "[Ljava/lang/Object;"
       731: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       734: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       737: invokestatic  #149                // Method f0$14:()Ljava/lang/String;
       740: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       743: aastore
       744: dup
       745: bipush        14
       747: new           #44                 // class scala/Tuple2
       750: dup
       751: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       754: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       757: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       760: iconst_3
       761: anewarray     #55                 // class java/lang/String
       764: dup
       765: iconst_0
       766: ldc           #57                 // String org
       768: aastore
       769: dup
       770: iconst_1
       771: ldc           #59                 // String sireum
       773: aastore
       774: dup
       775: iconst_2
       776: ldc           #151                // String Option.scala
       778: aastore
       779: checkcast     #63                 // class "[Ljava/lang/Object;"
       782: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       785: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       788: invokestatic  #154                // Method f0$15:()Ljava/lang/String;
       791: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       794: aastore
       795: dup
       796: bipush        15
       798: new           #44                 // class scala/Tuple2
       801: dup
       802: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       805: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       808: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       811: iconst_4
       812: anewarray     #55                 // class java/lang/String
       815: dup
       816: iconst_0
       817: ldc           #57                 // String org
       819: aastore
       820: dup
       821: iconst_1
       822: ldc           #59                 // String sireum
       824: aastore
       825: dup
       826: iconst_2
       827: ldc           #156                // String conversions
       829: aastore
       830: dup
       831: iconst_3
       832: ldc           #158                // String Collection.scala
       834: aastore
       835: checkcast     #63                 // class "[Ljava/lang/Object;"
       838: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       841: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       844: invokestatic  #161                // Method f0$16:()Ljava/lang/String;
       847: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       850: aastore
       851: dup
       852: bipush        16
       854: new           #44                 // class scala/Tuple2
       857: dup
       858: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       861: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       864: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       867: iconst_4
       868: anewarray     #55                 // class java/lang/String
       871: dup
       872: iconst_0
       873: ldc           #57                 // String org
       875: aastore
       876: dup
       877: iconst_1
       878: ldc           #59                 // String sireum
       880: aastore
       881: dup
       882: iconst_2
       883: ldc           #156                // String conversions
       885: aastore
       886: dup
       887: iconst_3
       888: ldc           #163                // String conversions.scala
       890: aastore
       891: checkcast     #63                 // class "[Ljava/lang/Object;"
       894: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       897: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       900: new           #165                // class java/lang/StringBuilder
       903: dup
       904: ldc           #166                // int 0
       906: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
       909: invokestatic  #172                // Method f0$17:()Ljava/lang/String;
       912: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       915: invokestatic  #179                // Method f1$1:()Ljava/lang/String;
       918: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       921: invokestatic  #182                // Method f2$1:()Ljava/lang/String;
       924: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       927: invokestatic  #185                // Method f3$1:()Ljava/lang/String;
       930: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       933: invokestatic  #188                // Method f4$1:()Ljava/lang/String;
       936: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       939: invokestatic  #191                // Method f5$1:()Ljava/lang/String;
       942: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       945: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
       948: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       951: aastore
       952: dup
       953: bipush        17
       955: new           #44                 // class scala/Tuple2
       958: dup
       959: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       962: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       965: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       968: iconst_3
       969: anewarray     #55                 // class java/lang/String
       972: dup
       973: iconst_0
       974: ldc           #57                 // String org
       976: aastore
       977: dup
       978: iconst_1
       979: ldc           #59                 // String sireum
       981: aastore
       982: dup
       983: iconst_2
       984: ldc           #196                // String HashMap.scala
       986: aastore
       987: checkcast     #63                 // class "[Ljava/lang/Object;"
       990: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       993: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       996: invokestatic  #199                // Method f0$18:()Ljava/lang/String;
       999: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1002: aastore
      1003: dup
      1004: bipush        18
      1006: new           #44                 // class scala/Tuple2
      1009: dup
      1010: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1013: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1016: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1019: iconst_3
      1020: anewarray     #55                 // class java/lang/String
      1023: dup
      1024: iconst_0
      1025: ldc           #57                 // String org
      1027: aastore
      1028: dup
      1029: iconst_1
      1030: ldc           #59                 // String sireum
      1032: aastore
      1033: dup
      1034: iconst_2
      1035: ldc           #201                // String Jen.scala
      1037: aastore
      1038: checkcast     #63                 // class "[Ljava/lang/Object;"
      1041: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1044: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1047: invokestatic  #204                // Method f0$19:()Ljava/lang/String;
      1050: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1053: aastore
      1054: dup
      1055: bipush        19
      1057: new           #44                 // class scala/Tuple2
      1060: dup
      1061: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1064: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1067: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1070: iconst_3
      1071: anewarray     #55                 // class java/lang/String
      1074: dup
      1075: iconst_0
      1076: ldc           #57                 // String org
      1078: aastore
      1079: dup
      1080: iconst_1
      1081: ldc           #59                 // String sireum
      1083: aastore
      1084: dup
      1085: iconst_2
      1086: ldc           #206                // String MOption.scala
      1088: aastore
      1089: checkcast     #63                 // class "[Ljava/lang/Object;"
      1092: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1095: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1098: invokestatic  #209                // Method f0$20:()Ljava/lang/String;
      1101: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1104: aastore
      1105: dup
      1106: bipush        20
      1108: new           #44                 // class scala/Tuple2
      1111: dup
      1112: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1115: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1118: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1121: iconst_3
      1122: anewarray     #55                 // class java/lang/String
      1125: dup
      1126: iconst_0
      1127: ldc           #57                 // String org
      1129: aastore
      1130: dup
      1131: iconst_1
      1132: ldc           #59                 // String sireum
      1134: aastore
      1135: dup
      1136: iconst_2
      1137: ldc           #211                // String HashSet.scala
      1139: aastore
      1140: checkcast     #63                 // class "[Ljava/lang/Object;"
      1143: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1146: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1149: invokestatic  #214                // Method f0$21:()Ljava/lang/String;
      1152: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1155: aastore
      1156: dup
      1157: bipush        21
      1159: new           #44                 // class scala/Tuple2
      1162: dup
      1163: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1166: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1169: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1172: iconst_3
      1173: anewarray     #55                 // class java/lang/String
      1176: dup
      1177: iconst_0
      1178: ldc           #57                 // String org
      1180: aastore
      1181: dup
      1182: iconst_1
      1183: ldc           #59                 // String sireum
      1185: aastore
      1186: dup
      1187: iconst_2
      1188: ldc           #216                // String BuiltInTypes.slang
      1190: aastore
      1191: checkcast     #63                 // class "[Ljava/lang/Object;"
      1194: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1197: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1200: invokestatic  #219                // Method f0$22:()Ljava/lang/String;
      1203: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1206: aastore
      1207: dup
      1208: bipush        22
      1210: new           #44                 // class scala/Tuple2
      1213: dup
      1214: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1217: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1220: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1223: iconst_4
      1224: anewarray     #55                 // class java/lang/String
      1227: dup
      1228: iconst_0
      1229: ldc           #57                 // String org
      1231: aastore
      1232: dup
      1233: iconst_1
      1234: ldc           #59                 // String sireum
      1236: aastore
      1237: dup
      1238: iconst_2
      1239: ldc           #221                // String message
      1241: aastore
      1242: dup
      1243: iconst_3
      1244: ldc           #223                // String Message.scala
      1246: aastore
      1247: checkcast     #63                 // class "[Ljava/lang/Object;"
      1250: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1253: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1256: invokestatic  #226                // Method f0$23:()Ljava/lang/String;
      1259: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1262: aastore
      1263: dup
      1264: bipush        23
      1266: new           #44                 // class scala/Tuple2
      1269: dup
      1270: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1273: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1276: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1279: iconst_4
      1280: anewarray     #55                 // class java/lang/String
      1283: dup
      1284: iconst_0
      1285: ldc           #57                 // String org
      1287: aastore
      1288: dup
      1289: iconst_1
      1290: ldc           #59                 // String sireum
      1292: aastore
      1293: dup
      1294: iconst_2
      1295: ldc           #221                // String message
      1297: aastore
      1298: dup
      1299: iconst_3
      1300: ldc           #228                // String Reporter.scala
      1302: aastore
      1303: checkcast     #63                 // class "[Ljava/lang/Object;"
      1306: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1309: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1312: invokestatic  #231                // Method f0$24:()Ljava/lang/String;
      1315: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1318: aastore
      1319: dup
      1320: bipush        24
      1322: new           #44                 // class scala/Tuple2
      1325: dup
      1326: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1329: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1332: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1335: iconst_3
      1336: anewarray     #55                 // class java/lang/String
      1339: dup
      1340: iconst_0
      1341: ldc           #57                 // String org
      1343: aastore
      1344: dup
      1345: iconst_1
      1346: ldc           #59                 // String sireum
      1348: aastore
      1349: dup
      1350: iconst_2
      1351: ldc           #233                // String ObjPrinter.scala
      1353: aastore
      1354: checkcast     #63                 // class "[Ljava/lang/Object;"
      1357: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1360: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1363: invokestatic  #236                // Method f0$25:()Ljava/lang/String;
      1366: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1369: aastore
      1370: dup
      1371: bipush        25
      1373: new           #44                 // class scala/Tuple2
      1376: dup
      1377: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1380: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1383: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1386: iconst_4
      1387: anewarray     #55                 // class java/lang/String
      1390: dup
      1391: iconst_0
      1392: ldc           #57                 // String org
      1394: aastore
      1395: dup
      1396: iconst_1
      1397: ldc           #59                 // String sireum
      1399: aastore
      1400: dup
      1401: iconst_2
      1402: ldc           #238                // String cli
      1404: aastore
      1405: dup
      1406: iconst_3
      1407: ldc           #240                // String JSON.scala
      1409: aastore
      1410: checkcast     #63                 // class "[Ljava/lang/Object;"
      1413: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1416: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1419: new           #165                // class java/lang/StringBuilder
      1422: dup
      1423: ldc           #166                // int 0
      1425: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
      1428: invokestatic  #243                // Method f0$26:()Ljava/lang/String;
      1431: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1434: invokestatic  #246                // Method f1$2:()Ljava/lang/String;
      1437: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1440: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      1443: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1446: aastore
      1447: dup
      1448: bipush        26
      1450: new           #44                 // class scala/Tuple2
      1453: dup
      1454: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1457: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1460: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1463: iconst_4
      1464: anewarray     #55                 // class java/lang/String
      1467: dup
      1468: iconst_0
      1469: ldc           #57                 // String org
      1471: aastore
      1472: dup
      1473: iconst_1
      1474: ldc           #59                 // String sireum
      1476: aastore
      1477: dup
      1478: iconst_2
      1479: ldc           #238                // String cli
      1481: aastore
      1482: dup
      1483: iconst_3
      1484: ldc           #248                // String CliOpt.scala
      1486: aastore
      1487: checkcast     #63                 // class "[Ljava/lang/Object;"
      1490: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1493: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1496: invokestatic  #251                // Method f0$27:()Ljava/lang/String;
      1499: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1502: aastore
      1503: dup
      1504: bipush        27
      1506: new           #44                 // class scala/Tuple2
      1509: dup
      1510: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1513: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1516: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1519: iconst_3
      1520: anewarray     #55                 // class java/lang/String
      1523: dup
      1524: iconst_0
      1525: ldc           #57                 // String org
      1527: aastore
      1528: dup
      1529: iconst_1
      1530: ldc           #59                 // String sireum
      1532: aastore
      1533: dup
      1534: iconst_2
      1535: ldc           #253                // String MEither.scala
      1537: aastore
      1538: checkcast     #63                 // class "[Ljava/lang/Object;"
      1541: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1544: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1547: invokestatic  #256                // Method f0$28:()Ljava/lang/String;
      1550: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1553: aastore
      1554: dup
      1555: bipush        28
      1557: new           #44                 // class scala/Tuple2
      1560: dup
      1561: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1564: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1567: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1570: iconst_4
      1571: anewarray     #55                 // class java/lang/String
      1574: dup
      1575: iconst_0
      1576: ldc           #57                 // String org
      1578: aastore
      1579: dup
      1580: iconst_1
      1581: ldc           #59                 // String sireum
      1583: aastore
      1584: dup
      1585: iconst_2
      1586: ldc_w         #258                // String parser
      1589: aastore
      1590: dup
      1591: iconst_3
      1592: ldc_w         #260                // String ParseTree.scala
      1595: aastore
      1596: checkcast     #63                 // class "[Ljava/lang/Object;"
      1599: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1602: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1605: invokestatic  #263                // Method f0$29:()Ljava/lang/String;
      1608: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1611: aastore
      1612: dup
      1613: bipush        29
      1615: new           #44                 // class scala/Tuple2
      1618: dup
      1619: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1622: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1625: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1628: iconst_4
      1629: anewarray     #55                 // class java/lang/String
      1632: dup
      1633: iconst_0
      1634: ldc           #57                 // String org
      1636: aastore
      1637: dup
      1638: iconst_1
      1639: ldc           #59                 // String sireum
      1641: aastore
      1642: dup
      1643: iconst_2
      1644: ldc_w         #258                // String parser
      1647: aastore
      1648: dup
      1649: iconst_3
      1650: ldc_w         #265                // String JsonParser.scala
      1653: aastore
      1654: checkcast     #63                 // class "[Ljava/lang/Object;"
      1657: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1660: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1663: new           #165                // class java/lang/StringBuilder
      1666: dup
      1667: ldc           #166                // int 0
      1669: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
      1672: invokestatic  #268                // Method f0$30:()Ljava/lang/String;
      1675: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1678: invokestatic  #271                // Method f1$3:()Ljava/lang/String;
      1681: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1684: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      1687: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1690: aastore
      1691: dup
      1692: bipush        30
      1694: new           #44                 // class scala/Tuple2
      1697: dup
      1698: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1701: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1704: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1707: iconst_3
      1708: anewarray     #55                 // class java/lang/String
      1711: dup
      1712: iconst_0
      1713: ldc           #57                 // String org
      1715: aastore
      1716: dup
      1717: iconst_1
      1718: ldc           #59                 // String sireum
      1720: aastore
      1721: dup
      1722: iconst_2
      1723: ldc_w         #273                // String Json.scala
      1726: aastore
      1727: checkcast     #63                 // class "[Ljava/lang/Object;"
      1730: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1733: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1736: new           #165                // class java/lang/StringBuilder
      1739: dup
      1740: ldc           #166                // int 0
      1742: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
      1745: invokestatic  #276                // Method f0$31:()Ljava/lang/String;
      1748: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1751: invokestatic  #279                // Method f1$4:()Ljava/lang/String;
      1754: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1757: invokestatic  #282                // Method f2$2:()Ljava/lang/String;
      1760: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1763: invokestatic  #285                // Method f3$2:()Ljava/lang/String;
      1766: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      1769: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      1772: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1775: aastore
      1776: dup
      1777: bipush        31
      1779: new           #44                 // class scala/Tuple2
      1782: dup
      1783: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1786: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1789: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1792: iconst_3
      1793: anewarray     #55                 // class java/lang/String
      1796: dup
      1797: iconst_0
      1798: ldc           #57                 // String org
      1800: aastore
      1801: dup
      1802: iconst_1
      1803: ldc           #59                 // String sireum
      1805: aastore
      1806: dup
      1807: iconst_2
      1808: ldc_w         #287                // String MBox.scala
      1811: aastore
      1812: checkcast     #63                 // class "[Ljava/lang/Object;"
      1815: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1818: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1821: invokestatic  #290                // Method f0$32:()Ljava/lang/String;
      1824: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1827: aastore
      1828: dup
      1829: bipush        32
      1831: new           #44                 // class scala/Tuple2
      1834: dup
      1835: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1838: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1841: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1844: iconst_3
      1845: anewarray     #55                 // class java/lang/String
      1848: dup
      1849: iconst_0
      1850: ldc           #57                 // String org
      1852: aastore
      1853: dup
      1854: iconst_1
      1855: ldc           #59                 // String sireum
      1857: aastore
      1858: dup
      1859: iconst_2
      1860: ldc_w         #292                // String Graph.scala
      1863: aastore
      1864: checkcast     #63                 // class "[Ljava/lang/Object;"
      1867: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1870: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1873: invokestatic  #295                // Method f0$33:()Ljava/lang/String;
      1876: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1879: aastore
      1880: dup
      1881: bipush        33
      1883: new           #44                 // class scala/Tuple2
      1886: dup
      1887: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1890: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1893: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1896: iconst_4
      1897: anewarray     #55                 // class java/lang/String
      1900: dup
      1901: iconst_0
      1902: ldc           #57                 // String org
      1904: aastore
      1905: dup
      1906: iconst_1
      1907: ldc           #59                 // String sireum
      1909: aastore
      1910: dup
      1911: iconst_2
      1912: ldc_w         #297                // String project
      1915: aastore
      1916: dup
      1917: iconst_3
      1918: ldc           #240                // String JSON.scala
      1920: aastore
      1921: checkcast     #63                 // class "[Ljava/lang/Object;"
      1924: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1927: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1930: invokestatic  #300                // Method f0$34:()Ljava/lang/String;
      1933: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1936: aastore
      1937: dup
      1938: bipush        34
      1940: new           #44                 // class scala/Tuple2
      1943: dup
      1944: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      1947: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      1950: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      1953: iconst_4
      1954: anewarray     #55                 // class java/lang/String
      1957: dup
      1958: iconst_0
      1959: ldc           #57                 // String org
      1961: aastore
      1962: dup
      1963: iconst_1
      1964: ldc           #59                 // String sireum
      1966: aastore
      1967: dup
      1968: iconst_2
      1969: ldc_w         #297                // String project
      1972: aastore
      1973: dup
      1974: iconst_3
      1975: ldc_w         #302                // String Project.scala
      1978: aastore
      1979: checkcast     #63                 // class "[Ljava/lang/Object;"
      1982: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      1985: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      1988: invokestatic  #305                // Method f0$35:()Ljava/lang/String;
      1991: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      1994: aastore
      1995: dup
      1996: bipush        35
      1998: new           #44                 // class scala/Tuple2
      2001: dup
      2002: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2005: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2008: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2011: iconst_3
      2012: anewarray     #55                 // class java/lang/String
      2015: dup
      2016: iconst_0
      2017: ldc           #57                 // String org
      2019: aastore
      2020: dup
      2021: iconst_1
      2022: ldc           #59                 // String sireum
      2024: aastore
      2025: dup
      2026: iconst_2
      2027: ldc_w         #307                // String Bag.scala
      2030: aastore
      2031: checkcast     #63                 // class "[Ljava/lang/Object;"
      2034: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2037: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2040: invokestatic  #310                // Method f0$36:()Ljava/lang/String;
      2043: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2046: aastore
      2047: dup
      2048: bipush        36
      2050: new           #44                 // class scala/Tuple2
      2053: dup
      2054: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2057: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2060: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2063: iconst_4
      2064: anewarray     #55                 // class java/lang/String
      2067: dup
      2068: iconst_0
      2069: ldc           #57                 // String org
      2071: aastore
      2072: dup
      2073: iconst_1
      2074: ldc           #59                 // String sireum
      2076: aastore
      2077: dup
      2078: iconst_2
      2079: ldc_w         #312                // String presentasi
      2082: aastore
      2083: dup
      2084: iconst_3
      2085: ldc           #240                // String JSON.scala
      2087: aastore
      2088: checkcast     #63                 // class "[Ljava/lang/Object;"
      2091: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2094: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2097: invokestatic  #315                // Method f0$37:()Ljava/lang/String;
      2100: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2103: aastore
      2104: dup
      2105: bipush        37
      2107: new           #44                 // class scala/Tuple2
      2110: dup
      2111: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2114: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2117: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2120: iconst_4
      2121: anewarray     #55                 // class java/lang/String
      2124: dup
      2125: iconst_0
      2126: ldc           #57                 // String org
      2128: aastore
      2129: dup
      2130: iconst_1
      2131: ldc           #59                 // String sireum
      2133: aastore
      2134: dup
      2135: iconst_2
      2136: ldc_w         #312                // String presentasi
      2139: aastore
      2140: dup
      2141: iconst_3
      2142: ldc_w         #317                // String Presentation.scala
      2145: aastore
      2146: checkcast     #63                 // class "[Ljava/lang/Object;"
      2149: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2152: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2155: invokestatic  #320                // Method f0$38:()Ljava/lang/String;
      2158: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2161: aastore
      2162: dup
      2163: bipush        38
      2165: new           #44                 // class scala/Tuple2
      2168: dup
      2169: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2172: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2175: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2178: iconst_3
      2179: anewarray     #55                 // class java/lang/String
      2182: dup
      2183: iconst_0
      2184: ldc           #57                 // String org
      2186: aastore
      2187: dup
      2188: iconst_1
      2189: ldc           #59                 // String sireum
      2191: aastore
      2192: dup
      2193: iconst_2
      2194: ldc_w         #322                // String MessagePack.scala
      2197: aastore
      2198: checkcast     #63                 // class "[Ljava/lang/Object;"
      2201: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2204: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2207: new           #165                // class java/lang/StringBuilder
      2210: dup
      2211: ldc           #166                // int 0
      2213: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
      2216: invokestatic  #325                // Method f0$39:()Ljava/lang/String;
      2219: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2222: invokestatic  #328                // Method f1$5:()Ljava/lang/String;
      2225: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2228: invokestatic  #331                // Method f2$3:()Ljava/lang/String;
      2231: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2234: invokestatic  #334                // Method f3$3:()Ljava/lang/String;
      2237: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2240: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      2243: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2246: aastore
      2247: dup
      2248: bipush        39
      2250: new           #44                 // class scala/Tuple2
      2253: dup
      2254: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2257: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2260: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2263: iconst_3
      2264: anewarray     #55                 // class java/lang/String
      2267: dup
      2268: iconst_0
      2269: ldc           #57                 // String org
      2271: aastore
      2272: dup
      2273: iconst_1
      2274: ldc           #59                 // String sireum
      2276: aastore
      2277: dup
      2278: iconst_2
      2279: ldc_w         #336                // String justification.scala
      2282: aastore
      2283: checkcast     #63                 // class "[Ljava/lang/Object;"
      2286: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2289: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2292: invokestatic  #339                // Method f0$40:()Ljava/lang/String;
      2295: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2298: aastore
      2299: dup
      2300: bipush        40
      2302: new           #44                 // class scala/Tuple2
      2305: dup
      2306: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2309: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2312: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2315: iconst_3
      2316: anewarray     #55                 // class java/lang/String
      2319: dup
      2320: iconst_0
      2321: ldc           #57                 // String org
      2323: aastore
      2324: dup
      2325: iconst_1
      2326: ldc           #59                 // String sireum
      2328: aastore
      2329: dup
      2330: iconst_2
      2331: ldc_w         #341                // String HashSMap.scala
      2334: aastore
      2335: checkcast     #63                 // class "[Ljava/lang/Object;"
      2338: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2341: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2344: invokestatic  #344                // Method f0$41:()Ljava/lang/String;
      2347: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2350: aastore
      2351: dup
      2352: bipush        41
      2354: new           #44                 // class scala/Tuple2
      2357: dup
      2358: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2361: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2364: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2367: iconst_3
      2368: anewarray     #55                 // class java/lang/String
      2371: dup
      2372: iconst_0
      2373: ldc           #57                 // String org
      2375: aastore
      2376: dup
      2377: iconst_1
      2378: ldc           #59                 // String sireum
      2380: aastore
      2381: dup
      2382: iconst_2
      2383: ldc_w         #346                // String SeqUtil.scala
      2386: aastore
      2387: checkcast     #63                 // class "[Ljava/lang/Object;"
      2390: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2393: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2396: invokestatic  #349                // Method f0$42:()Ljava/lang/String;
      2399: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2402: aastore
      2403: dup
      2404: bipush        42
      2406: new           #44                 // class scala/Tuple2
      2409: dup
      2410: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2413: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2416: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2419: iconst_3
      2420: anewarray     #55                 // class java/lang/String
      2423: dup
      2424: iconst_0
      2425: ldc           #57                 // String org
      2427: aastore
      2428: dup
      2429: iconst_1
      2430: ldc           #59                 // String sireum
      2432: aastore
      2433: dup
      2434: iconst_2
      2435: ldc_w         #351                // String MJen.scala
      2438: aastore
      2439: checkcast     #63                 // class "[Ljava/lang/Object;"
      2442: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2445: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2448: invokestatic  #354                // Method f0$43:()Ljava/lang/String;
      2451: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2454: aastore
      2455: dup
      2456: bipush        43
      2458: new           #44                 // class scala/Tuple2
      2461: dup
      2462: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2465: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2468: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2471: iconst_3
      2472: anewarray     #55                 // class java/lang/String
      2475: dup
      2476: iconst_0
      2477: ldc           #57                 // String org
      2479: aastore
      2480: dup
      2481: iconst_1
      2482: ldc           #59                 // String sireum
      2484: aastore
      2485: dup
      2486: iconst_2
      2487: ldc_w         #356                // String HashSSet.scala
      2490: aastore
      2491: checkcast     #63                 // class "[Ljava/lang/Object;"
      2494: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2497: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2500: invokestatic  #359                // Method f0$44:()Ljava/lang/String;
      2503: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2506: aastore
      2507: dup
      2508: bipush        44
      2510: new           #44                 // class scala/Tuple2
      2513: dup
      2514: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2517: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2520: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2523: iconst_4
      2524: anewarray     #55                 // class java/lang/String
      2527: dup
      2528: iconst_0
      2529: ldc           #57                 // String org
      2531: aastore
      2532: dup
      2533: iconst_1
      2534: ldc           #59                 // String sireum
      2536: aastore
      2537: dup
      2538: iconst_2
      2539: ldc_w         #361                // String bitcodec
      2542: aastore
      2543: dup
      2544: iconst_3
      2545: ldc_w         #363                // String Runtime.scala
      2548: aastore
      2549: checkcast     #63                 // class "[Ljava/lang/Object;"
      2552: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2555: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2558: invokestatic  #366                // Method f0$45:()Ljava/lang/String;
      2561: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2564: aastore
      2565: dup
      2566: bipush        45
      2568: new           #44                 // class scala/Tuple2
      2571: dup
      2572: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2575: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2578: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2581: iconst_4
      2582: anewarray     #55                 // class java/lang/String
      2585: dup
      2586: iconst_0
      2587: ldc           #57                 // String org
      2589: aastore
      2590: dup
      2591: iconst_1
      2592: ldc           #59                 // String sireum
      2594: aastore
      2595: dup
      2596: iconst_2
      2597: ldc_w         #361                // String bitcodec
      2600: aastore
      2601: dup
      2602: iconst_3
      2603: ldc_w         #368                // String Spec.scala
      2606: aastore
      2607: checkcast     #63                 // class "[Ljava/lang/Object;"
      2610: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2613: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2616: new           #165                // class java/lang/StringBuilder
      2619: dup
      2620: ldc           #166                // int 0
      2622: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
      2625: invokestatic  #371                // Method f0$46:()Ljava/lang/String;
      2628: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2631: invokestatic  #374                // Method f1$6:()Ljava/lang/String;
      2634: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2637: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      2640: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2643: aastore
      2644: dup
      2645: bipush        46
      2647: new           #44                 // class scala/Tuple2
      2650: dup
      2651: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2654: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2657: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2660: iconst_4
      2661: anewarray     #55                 // class java/lang/String
      2664: dup
      2665: iconst_0
      2666: ldc           #57                 // String org
      2668: aastore
      2669: dup
      2670: iconst_1
      2671: ldc           #59                 // String sireum
      2673: aastore
      2674: dup
      2675: iconst_2
      2676: ldc_w         #376                // String ops
      2679: aastore
      2680: dup
      2681: iconst_3
      2682: ldc_w         #378                // String COps.scala
      2685: aastore
      2686: checkcast     #63                 // class "[Ljava/lang/Object;"
      2689: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2692: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2695: invokestatic  #381                // Method f0$47:()Ljava/lang/String;
      2698: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2701: aastore
      2702: dup
      2703: bipush        47
      2705: new           #44                 // class scala/Tuple2
      2708: dup
      2709: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2712: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2715: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2718: iconst_4
      2719: anewarray     #55                 // class java/lang/String
      2722: dup
      2723: iconst_0
      2724: ldc           #57                 // String org
      2726: aastore
      2727: dup
      2728: iconst_1
      2729: ldc           #59                 // String sireum
      2731: aastore
      2732: dup
      2733: iconst_2
      2734: ldc_w         #376                // String ops
      2737: aastore
      2738: dup
      2739: iconst_3
      2740: ldc_w         #383                // String StringOps.scala
      2743: aastore
      2744: checkcast     #63                 // class "[Ljava/lang/Object;"
      2747: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2750: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2753: invokestatic  #386                // Method f0$48:()Ljava/lang/String;
      2756: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2759: aastore
      2760: dup
      2761: bipush        48
      2763: new           #44                 // class scala/Tuple2
      2766: dup
      2767: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2770: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2773: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2776: iconst_4
      2777: anewarray     #55                 // class java/lang/String
      2780: dup
      2781: iconst_0
      2782: ldc           #57                 // String org
      2784: aastore
      2785: dup
      2786: iconst_1
      2787: ldc           #59                 // String sireum
      2789: aastore
      2790: dup
      2791: iconst_2
      2792: ldc_w         #376                // String ops
      2795: aastore
      2796: dup
      2797: iconst_3
      2798: ldc_w         #388                // String GraphOps.scala
      2801: aastore
      2802: checkcast     #63                 // class "[Ljava/lang/Object;"
      2805: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2808: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2811: invokestatic  #391                // Method f0$49:()Ljava/lang/String;
      2814: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2817: aastore
      2818: dup
      2819: bipush        49
      2821: new           #44                 // class scala/Tuple2
      2824: dup
      2825: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2828: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2831: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2834: iconst_4
      2835: anewarray     #55                 // class java/lang/String
      2838: dup
      2839: iconst_0
      2840: ldc           #57                 // String org
      2842: aastore
      2843: dup
      2844: iconst_1
      2845: ldc           #59                 // String sireum
      2847: aastore
      2848: dup
      2849: iconst_2
      2850: ldc_w         #376                // String ops
      2853: aastore
      2854: dup
      2855: iconst_3
      2856: ldc_w         #393                // String SOps.scala
      2859: aastore
      2860: checkcast     #63                 // class "[Ljava/lang/Object;"
      2863: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2866: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2869: new           #165                // class java/lang/StringBuilder
      2872: dup
      2873: ldc           #166                // int 0
      2875: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
      2878: invokestatic  #396                // Method f0$50:()Ljava/lang/String;
      2881: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2884: invokestatic  #399                // Method f1$7:()Ljava/lang/String;
      2887: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2890: invokestatic  #402                // Method f2$4:()Ljava/lang/String;
      2893: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2896: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      2899: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      2902: aastore
      2903: dup
      2904: bipush        50
      2906: new           #44                 // class scala/Tuple2
      2909: dup
      2910: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      2913: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      2916: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      2919: iconst_4
      2920: anewarray     #55                 // class java/lang/String
      2923: dup
      2924: iconst_0
      2925: ldc           #57                 // String org
      2927: aastore
      2928: dup
      2929: iconst_1
      2930: ldc           #59                 // String sireum
      2932: aastore
      2933: dup
      2934: iconst_2
      2935: ldc_w         #376                // String ops
      2938: aastore
      2939: dup
      2940: iconst_3
      2941: ldc_w         #404                // String Bits.scala
      2944: aastore
      2945: checkcast     #63                 // class "[Ljava/lang/Object;"
      2948: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      2951: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      2954: new           #165                // class java/lang/StringBuilder
      2957: dup
      2958: ldc           #166                // int 0
      2960: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
      2963: invokestatic  #407                // Method f0$51:()Ljava/lang/String;
      2966: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2969: invokestatic  #410                // Method f1$8:()Ljava/lang/String;
      2972: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2975: invokestatic  #413                // Method f2$5:()Ljava/lang/String;
      2978: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2981: invokestatic  #416                // Method f3$4:()Ljava/lang/String;
      2984: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2987: invokestatic  #419                // Method f4$2:()Ljava/lang/String;
      2990: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2993: invokestatic  #422                // Method f5$2:()Ljava/lang/String;
      2996: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      2999: invokestatic  #425                // Method f6$1:()Ljava/lang/String;
      3002: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3005: invokestatic  #428                // Method f7$1:()Ljava/lang/String;
      3008: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3011: invokestatic  #431                // Method f8$1:()Ljava/lang/String;
      3014: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3017: invokestatic  #434                // Method f9$1:()Ljava/lang/String;
      3020: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3023: invokestatic  #437                // Method f10$1:()Ljava/lang/String;
      3026: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3029: invokestatic  #440                // Method f11$1:()Ljava/lang/String;
      3032: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3035: invokestatic  #443                // Method f12$1:()Ljava/lang/String;
      3038: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3041: invokestatic  #446                // Method f13$1:()Ljava/lang/String;
      3044: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3047: invokestatic  #449                // Method f14$1:()Ljava/lang/String;
      3050: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      3053: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      3056: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      3059: aastore
      3060: dup
      3061: bipush        51
      3063: new           #44                 // class scala/Tuple2
      3066: dup
      3067: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      3070: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      3073: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      3076: iconst_3
      3077: anewarray     #55                 // class java/lang/String
      3080: dup
      3081: iconst_0
      3082: ldc           #57                 // String org
      3084: aastore
      3085: dup
      3086: iconst_1
      3087: ldc           #59                 // String sireum
      3089: aastore
      3090: dup
      3091: iconst_2
      3092: ldc_w         #451                // String Map.scala
      3095: aastore
      3096: checkcast     #63                 // class "[Ljava/lang/Object;"
      3099: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      3102: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      3105: invokestatic  #454                // Method f0$52:()Ljava/lang/String;
      3108: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      3111: aastore
      3112: dup
      3113: bipush        52
      3115: new           #44                 // class scala/Tuple2
      3118: dup
      3119: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      3122: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      3125: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      3128: iconst_3
      3129: anewarray     #55                 // class java/lang/String
      3132: dup
      3133: iconst_0
      3134: ldc           #57                 // String org
      3136: aastore
      3137: dup
      3138: iconst_1
      3139: ldc           #59                 // String sireum
      3141: aastore
      3142: dup
      3143: iconst_2
      3144: ldc_w         #456                // String HashSBag.scala
      3147: aastore
      3148: checkcast     #63                 // class "[Ljava/lang/Object;"
      3151: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      3154: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      3157: invokestatic  #459                // Method f0$53:()Ljava/lang/String;
      3160: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      3163: aastore
      3164: dup
      3165: bipush        53
      3167: new           #44                 // class scala/Tuple2
      3170: dup
      3171: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      3174: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      3177: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      3180: iconst_3
      3181: anewarray     #55                 // class java/lang/String
      3184: dup
      3185: iconst_0
      3186: ldc           #57                 // String org
      3188: aastore
      3189: dup
      3190: iconst_1
      3191: ldc           #59                 // String sireum
      3193: aastore
      3194: dup
      3195: iconst_2
      3196: ldc_w         #461                // String OsProto.scala
      3199: aastore
      3200: checkcast     #63                 // class "[Ljava/lang/Object;"
      3203: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      3206: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      3209: invokestatic  #464                // Method f0$54:()Ljava/lang/String;
      3212: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      3215: aastore
      3216: dup
      3217: bipush        54
      3219: new           #44                 // class scala/Tuple2
      3222: dup
      3223: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      3226: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      3229: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      3232: iconst_3
      3233: anewarray     #55                 // class java/lang/String
      3236: dup
      3237: iconst_0
      3238: ldc           #57                 // String org
      3240: aastore
      3241: dup
      3242: iconst_1
      3243: ldc           #59                 // String sireum
      3245: aastore
      3246: dup
      3247: iconst_2
      3248: ldc_w         #466                // String Set.scala
      3251: aastore
      3252: checkcast     #63                 // class "[Ljava/lang/Object;"
      3255: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      3258: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      3261: invokestatic  #469                // Method f0$55:()Ljava/lang/String;
      3264: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      3267: aastore
      3268: dup
      3269: bipush        55
      3271: new           #44                 // class scala/Tuple2
      3274: dup
      3275: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      3278: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      3281: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      3284: iconst_3
      3285: anewarray     #55                 // class java/lang/String
      3288: dup
      3289: iconst_0
      3290: ldc           #57                 // String org
      3292: aastore
      3293: dup
      3294: iconst_1
      3295: ldc           #59                 // String sireum
      3297: aastore
      3298: dup
      3299: iconst_2
      3300: ldc_w         #471                // String ContractUtil.scala
      3303: aastore
      3304: checkcast     #63                 // class "[Ljava/lang/Object;"
      3307: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      3310: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      3313: invokestatic  #474                // Method f0$56:()Ljava/lang/String;
      3316: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      3319: aastore
      3320: dup
      3321: bipush        56
      3323: new           #44                 // class scala/Tuple2
      3326: dup
      3327: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
      3330: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
      3333: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
      3336: iconst_3
      3337: anewarray     #55                 // class java/lang/String
      3340: dup
      3341: iconst_0
      3342: ldc           #57                 // String org
      3344: aastore
      3345: dup
      3346: iconst_1
      3347: ldc           #59                 // String sireum
      3349: aastore
      3350: dup
      3351: iconst_2
      3352: ldc_w         #476                // String Poset.scala
      3355: aastore
      3356: checkcast     #63                 // class "[Ljava/lang/Object;"
      3359: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      3362: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      3365: invokestatic  #479                // Method f0$57:()Ljava/lang/String;
      3368: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
      3371: aastore
      3372: checkcast     #63                 // class "[Ljava/lang/Object;"
      3375: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
      3378: invokevirtual #480                // Method scala/collection/immutable/ListMap$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
      3381: checkcast     #482                // class scala/collection/immutable/Map
      3384: areturn
      LineNumberTable:
        line 31: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0    3385     0  this   Lorg/sireum/Library_Ext$;
    Signature: #32                          // ()Lscala/collection/Map<Lscala/collection/immutable/Vector<Ljava/lang/String;>;Ljava/lang/String;>;

  public scala.collection.Map<scala.collection.immutable.Vector<java.lang.String>, java.lang.String> jvmMap();
    descriptor: ()Lscala/collection/Map;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=13, locals=1, args_size=1
         0: getstatic     #37                 // Field scala/collection/immutable/ListMap$.MODULE$:Lscala/collection/immutable/ListMap$;
         3: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
         6: bipush        6
         8: anewarray     #44                 // class scala/Tuple2
        11: dup
        12: iconst_0
        13: new           #44                 // class scala/Tuple2
        16: dup
        17: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
        20: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
        23: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
        26: iconst_3
        27: anewarray     #55                 // class java/lang/String
        30: dup
        31: iconst_0
        32: ldc           #57                 // String org
        34: aastore
        35: dup
        36: iconst_1
        37: ldc           #59                 // String sireum
        39: aastore
        40: dup
        41: iconst_2
        42: ldc_w         #486                // String Asm.scala
        45: aastore
        46: checkcast     #63                 // class "[Ljava/lang/Object;"
        49: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
        52: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
        55: invokestatic  #489                // Method f0$58:()Ljava/lang/String;
        58: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
        61: aastore
        62: dup
        63: iconst_1
        64: new           #44                 // class scala/Tuple2
        67: dup
        68: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
        71: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
        74: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
        77: iconst_4
        78: anewarray     #55                 // class java/lang/String
        81: dup
        82: iconst_0
        83: ldc           #57                 // String org
        85: aastore
        86: dup
        87: iconst_1
        88: ldc           #59                 // String sireum
        90: aastore
        91: dup
        92: iconst_2
        93: ldc_w         #297                // String project
        96: aastore
        97: dup
        98: iconst_3
        99: ldc_w         #491                // String ProjectUtil.scala
       102: aastore
       103: checkcast     #63                 // class "[Ljava/lang/Object;"
       106: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       109: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       112: invokestatic  #494                // Method f0$59:()Ljava/lang/String;
       115: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       118: aastore
       119: dup
       120: iconst_2
       121: new           #44                 // class scala/Tuple2
       124: dup
       125: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       128: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       131: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       134: iconst_4
       135: anewarray     #55                 // class java/lang/String
       138: dup
       139: iconst_0
       140: ldc           #57                 // String org
       142: aastore
       143: dup
       144: iconst_1
       145: ldc           #59                 // String sireum
       147: aastore
       148: dup
       149: iconst_2
       150: ldc_w         #297                // String project
       153: aastore
       154: dup
       155: iconst_3
       156: ldc_w         #496                // String DependencyManager.scala
       159: aastore
       160: checkcast     #63                 // class "[Ljava/lang/Object;"
       163: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       166: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       169: invokestatic  #499                // Method f0$60:()Ljava/lang/String;
       172: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       175: aastore
       176: dup
       177: iconst_3
       178: new           #44                 // class scala/Tuple2
       181: dup
       182: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       185: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       188: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       191: iconst_3
       192: anewarray     #55                 // class java/lang/String
       195: dup
       196: iconst_0
       197: ldc           #57                 // String org
       199: aastore
       200: dup
       201: iconst_1
       202: ldc           #59                 // String sireum
       204: aastore
       205: dup
       206: iconst_2
       207: ldc_w         #501                // String GitHub.scala
       210: aastore
       211: checkcast     #63                 // class "[Ljava/lang/Object;"
       214: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       217: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       220: invokestatic  #504                // Method f0$61:()Ljava/lang/String;
       223: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       226: aastore
       227: dup
       228: iconst_4
       229: new           #44                 // class scala/Tuple2
       232: dup
       233: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       236: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       239: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       242: iconst_3
       243: anewarray     #55                 // class java/lang/String
       246: dup
       247: iconst_0
       248: ldc           #57                 // String org
       250: aastore
       251: dup
       252: iconst_1
       253: ldc           #59                 // String sireum
       255: aastore
       256: dup
       257: iconst_2
       258: ldc_w         #506                // String Os.scala
       261: aastore
       262: checkcast     #63                 // class "[Ljava/lang/Object;"
       265: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       268: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       271: new           #165                // class java/lang/StringBuilder
       274: dup
       275: ldc           #166                // int 0
       277: invokespecial #169                // Method java/lang/StringBuilder."<init>":(I)V
       280: invokestatic  #509                // Method f0$62:()Ljava/lang/String;
       283: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       286: invokestatic  #512                // Method f1$9:()Ljava/lang/String;
       289: invokevirtual #176                // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       292: invokevirtual #194                // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
       295: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       298: aastore
       299: dup
       300: iconst_5
       301: new           #44                 // class scala/Tuple2
       304: dup
       305: getstatic     #49                 // Field scala/package$.MODULE$:Lscala/package$;
       308: invokevirtual #53                 // Method scala/package$.Vector:()Lscala/collection/immutable/Vector$;
       311: getstatic     #42                 // Field scala/runtime/ScalaRunTime$.MODULE$:Lscala/runtime/ScalaRunTime$;
       314: iconst_3
       315: anewarray     #55                 // class java/lang/String
       318: dup
       319: iconst_0
       320: ldc           #57                 // String org
       322: aastore
       323: dup
       324: iconst_1
       325: ldc           #59                 // String sireum
       327: aastore
       328: dup
       329: iconst_2
       330: ldc_w         #514                // String Coursier.scala
       333: aastore
       334: checkcast     #63                 // class "[Ljava/lang/Object;"
       337: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       340: invokevirtual #73                 // Method scala/collection/immutable/Vector$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       343: invokestatic  #517                // Method f0$63:()Ljava/lang/String;
       346: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
       349: aastore
       350: checkcast     #63                 // class "[Ljava/lang/Object;"
       353: invokevirtual #67                 // Method scala/runtime/ScalaRunTime$.wrapRefArray:([Ljava/lang/Object;)Lscala/collection/immutable/ArraySeq;
       356: invokevirtual #480                // Method scala/collection/immutable/ListMap$.apply:(Lscala/collection/immutable/Seq;)Ljava/lang/Object;
       359: checkcast     #482                // class scala/collection/immutable/Map
       362: areturn
      LineNumberTable:
        line 42: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0     363     0  this   Lorg/sireum/Library_Ext$;
    Signature: #32                          // ()Lscala/collection/Map<Lscala/collection/immutable/Vector<Ljava/lang/String;>;Ljava/lang/String;>;

  public org.sireum.$internal.Trie$Node<java.lang.String, java.lang.String> trie();
    descriptor: ()Lorg/sireum/$internal/Trie$Node;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: getstatic     #525                // Field org/sireum/$internal/RC$.MODULE$:Lorg/sireum/$internal/RC$;
         3: aload_0
         4: invokevirtual #527                // Method sharedMap:()Lscala/collection/Map;
         7: aload_0
         8: invokevirtual #529                // Method jvmMap:()Lscala/collection/Map;
        11: invokeinterface #535,  2          // InterfaceMethod scala/collection/Map.$plus$plus:(Lscala/collection/IterableOnce;)Lscala/collection/IterableOps;
        16: checkcast     #531                // class scala/collection/Map
        19: invokevirtual #539                // Method org/sireum/$internal/RC$.toTrie:(Lscala/collection/Map;)Lorg/sireum/$internal/Trie$Node;
        22: areturn
      LineNumberTable:
        line 53: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  this   Lorg/sireum/Library_Ext$;
    Signature: #520                         // ()Lorg/sireum/$internal/Trie$Node<Ljava/lang/String;Ljava/lang/String;>;

  public org.sireum.IS<org.sireum.Z, scala.Tuple2<org.sireum.Option<org.sireum.String>, org.sireum.String>> sharedFiles();
    descriptor: ()Lorg/sireum/IS;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: getstatic     #547                // Field org/sireum/package$.MODULE$:Lorg/sireum/package$;
         3: invokevirtual #551                // Method org/sireum/package$.ISZ:()Lorg/sireum/$internal/PackageTrait$ISZ$;
         6: aload_0
         7: invokevirtual #527                // Method sharedMap:()Lscala/collection/Map;
        10: invokeinterface #555,  1          // InterfaceMethod scala/collection/Map.toSeq:()Lscala/collection/immutable/Seq;
        15: invokedynamic #575,  0            // InvokeDynamic #0:apply:()Lscala/Function1;
        20: invokeinterface #581,  2          // InterfaceMethod scala/collection/immutable/Seq.map:(Lscala/Function1;)Ljava/lang/Object;
        25: checkcast     #577                // class scala/collection/immutable/Seq
        28: invokevirtual #584                // Method org/sireum/$internal/PackageTrait$ISZ$.apply:(Lscala/collection/immutable/Seq;)Lorg/sireum/IS;
        31: areturn
      LineNumberTable:
        line 56: 0
        line 56: 6
        line 57: 15
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      32     0  this   Lorg/sireum/Library_Ext$;
    Signature: #542                         // ()Lorg/sireum/IS<Lorg/sireum/Z;Lscala/Tuple2<Lorg/sireum/Option<Lorg/sireum/String;>;Lorg/sireum/String;>;>;

  public org.sireum.IS<org.sireum.Z, scala.Tuple2<org.sireum.Option<org.sireum.String>, org.sireum.String>> jvmFiles();
    descriptor: ()Lorg/sireum/IS;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: getstatic     #547                // Field org/sireum/package$.MODULE$:Lorg/sireum/package$;
         3: invokevirtual #551                // Method org/sireum/package$.ISZ:()Lorg/sireum/$internal/PackageTrait$ISZ$;
         6: aload_0
         7: invokevirtual #529                // Method jvmMap:()Lscala/collection/Map;
        10: invokeinterface #555,  1          // InterfaceMethod scala/collection/Map.toSeq:()Lscala/collection/immutable/Seq;
        15: invokedynamic #590,  0            // InvokeDynamic #1:apply:()Lscala/Function1;
        20: invokeinterface #581,  2          // InterfaceMethod scala/collection/immutable/Seq.map:(Lscala/Function1;)Ljava/lang/Object;
        25: checkcast     #577                // class scala/collection/immutable/Seq
        28: invokevirtual #584                // Method org/sireum/$internal/PackageTrait$ISZ$.apply:(Lscala/collection/immutable/Seq;)Lorg/sireum/IS;
        31: areturn
      LineNumberTable:
        line 60: 0
        line 60: 6
        line 61: 15
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      32     0  this   Lorg/sireum/Library_Ext$;
    Signature: #542                         // ()Lorg/sireum/IS<Lorg/sireum/Z;Lscala/Tuple2<Lorg/sireum/Option<Lorg/sireum/String;>;Lorg/sireum/String;>;>;

  public org.sireum.IS<org.sireum.Z, scala.Tuple2<org.sireum.Option<org.sireum.String>, org.sireum.String>> files();
    descriptor: ()Lorg/sireum/IS;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokevirtual #593                // Method sharedFiles:()Lorg/sireum/IS;
         4: aload_0
         5: invokevirtual #595                // Method jvmFiles:()Lorg/sireum/IS;
         8: invokevirtual #600                // Method org/sireum/IS.$plus$plus:(Lorg/sireum/IS;)Lorg/sireum/IS;
        11: areturn
      LineNumberTable:
        line 63: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      12     0  this   Lorg/sireum/Library_Ext$;
    Signature: #542                         // ()Lorg/sireum/IS<Lorg/sireum/Z;Lscala/Tuple2<Lorg/sireum/Option<Lorg/sireum/String;>;Lorg/sireum/String;>;>;

  private static final java.lang.String f0$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #602                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject HashBag {\n\n  @pure def empty[T]: HashBag[T] = {\n    return HashBag(HashMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashBag[T] = {\n    return HashBag(HashMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashBag[T] = {\n    return HashBag.empty[T] ++ s\n  }\n\n}\n\n@datatype class HashBag[T](val map: HashMap[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): HashBag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def +#(p: (T, Z)): HashBag[T] = {\n    return addN(p._1, p._2)\n  }\n\n  @pure def addN(e: T, n: Z): HashBag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def ++[I](es: IS[I, T]): HashBag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashBag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](s: IS[I, T]): HashBag[T] = {\n    var r = this\n    for (e <- s) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def -#(p: (T, Z)): HashBag[T] = {\n    return removeN(p._1, p._2)\n  }\n\n  @pure def removeN(e: T, n: Z): HashBag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def \\(other: HashBag[T]): HashBag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: HashBag[T]): HashBag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashBag[T]): HashBag[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashBag[T]): HashBag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashBag[T]): HashBag[T] = {\n    var r = HashBag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r.addN(e._1, n)\n      } else {\n        r = r.addN(e._1, m)\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$2();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #604                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.U64._\n\n@sig trait Indexable[T] {\n  @pure def at(i: Z): T\n  @pure def has(i: Z): B\n}\n\nobject Indexable {\n\n  @sig trait Pos[T] extends Indexable[T] {\n    @pure def posOpt(offset: Z, length: Z): Option[message.Position]\n  }\n\n  @datatype class Isz[T](val is: ISZ[T]) extends Indexable[T] {\n    @strictpure override def at(i: Z): T = is(i)\n    @strictpure override def has(i: Z): B = i < is.size\n  }\n\n  @datatype class IszDocInfo[T](val is: ISZ[T], val info: message.DocInfo) extends Indexable.Pos[T] {\n    @strictpure override def at(i: Z): T = is(i)\n    @strictpure override def has(i: Z): B = i < is.size\n    @strictpure def posOpt(offset: Z, length: Z): Option[message.Position] =\n      Some(message.PosInfo(info, (conversions.Z.toU64(offset) << u64\"32\") | conversions.Z.toU64(length)))\n  }\n\n  @strictpure def fromIsz[T](is: ISZ[T]): Indexable[T] = Isz(is)\n\n  @strictpure def fromIszDocInfo[T](is: ISZ[T], info: message.DocInfo): Indexable.Pos[T] = IszDocInfo(is, info)\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$3();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #606                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@datatype trait Either[L, R] {\n\n  @pure def isLeft: B = Contract.Only(Ensures(Res == ∃{e: L => Either.Left[L, R](e) == this}))\n\n  @pure def isRight: B = Contract.Only(Ensures(!isLeft))\n\n  @pure def leftOpt: Option[L] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Either.Left[L, R](Res[Option[L]].get) == this)\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Res == None[L]())\n    ),\n  )\n\n  @pure def left: L = Contract.Only(\n    Requires(isLeft),\n    Ensures(Either.Left[L, R](Res) == this)\n  )\n\n  @pure def rightOpt: Option[R] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Res == None[R]())\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Either.Right[L, R](Res[Option[R]].get) == this)\n    )\n  )\n\n  @pure def right: R = Contract.Only(\n    Requires(isRight),\n    Ensures(Either.Right[L, R](Res) == this)\n  )\n}\n\nobject Either {\n\n  @datatype class Left[L, R](val value: L) extends Either[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def leftOpt: Option[L] = {\n      Contract(Ensures(Res == Some(value)))\n      return Some(value)\n    }\n\n    @pure override def left: L = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n    @pure override def rightOpt: Option[R] = {\n      Contract(Ensures(Res == None[R]()))\n      return None()\n    }\n\n    @pure override def right: R = {\n      Contract(Requires(F))\n      halt(\"Invalid \'Either.Left\' operation \'right\'.\")\n    }\n\n  }\n\n  @datatype class Right[L, R](val value: R) extends Either[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def leftOpt: Option[L] = {\n      Contract(Ensures(Res == None[L]()))\n      return None()\n    }\n\n    @pure override def left: L = {\n      Contract(Requires(F))\n      halt(\"Invalid \'Either.Right\' operation \'left\'.\")\n    }\n\n    @pure override def rightOpt: Option[R] = {\n      Contract(Ensures(Res == Some(value)))\n      return Some(value)\n    }\n\n    @pure override def right: R = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n  }\n\n  @strictpure def left[L, R](value: L): Either[L, R] = Left[L, R](value)\n\n  @strictpure def right[L, R](value: R): Either[L, R] = Right[L, R](value)\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$4();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #608                // String // #Sireum\n/*\n MIT License\n\n Copyright (c) 2020 brainhub\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n\npackage org.sireum.crypto\n\nimport org.sireum._\nimport org.sireum.U8._\nimport org.sireum.U64._\n\n// Adapted from https://github.com/brainhub/SHA3IUF\n\nobject SHA3 {\n\n  val spongeWords: Z = 25\n  val rounds: Z = 24\n\n  // @formatter:off\n  val rndc: ISZ[U64] = ISZ(\n    u64\"0x0000000000000001\", u64\"0x0000000000008082\",\n    u64\"0x800000000000808a\", u64\"0x8000000080008000\",\n    u64\"0x000000000000808b\", u64\"0x0000000080000001\",\n    u64\"0x8000000080008081\", u64\"0x8000000000008009\",\n    u64\"0x000000000000008a\", u64\"0x0000000000000088\",\n    u64\"0x0000000080008009\", u64\"0x000000008000000a\",\n    u64\"0x000000008000808b\", u64\"0x800000000000008b\",\n    u64\"0x8000000000008089\", u64\"0x8000000000008003\",\n    u64\"0x8000000000008002\", u64\"0x8000000000000080\",\n    u64\"0x000000000000800a\", u64\"0x800000008000000a\",\n    u64\"0x8000000080008081\", u64\"0x8000000000008080\",\n    u64\"0x0000000080000001\", u64\"0x8000000080008008\"\n  )\n\n  val rotc: ISZ[U64] = ISZ(\n    u64\"1\", u64\"3\", u64\"6\", u64\"10\", u64\"15\", u64\"21\", u64\"28\", u64\"36\",\n    u64\"45\", u64\"55\", u64\"2\", u64\"14\", u64\"27\", u64\"41\", u64\"56\", u64\"8\",\n    u64\"25\", u64\"43\", u64\"62\", u64\"18\", u64\"39\", u64\"61\", u64\"20\", u64\"44\"\n  )\n\n  val piln: ISZ[Z] = ISZ(\n    10,  7, 11, 17, 18,  3,  5, 16,\n     8, 21, 24,  4, 15, 23, 19, 13,\n    12,  2, 20, 14, 22,  9,  6,  1\n  )\n  // @formatter:on\n\n  @pure def rotl(x: U64, y: U64): U64 = {\n    return (x << y) | (x >> (u64\"64\" - y))\n  }\n\n  def keccakf(s: MSZ[U64]): Unit = {\n    var t = u64\"0\"\n    val bc = MSZ.create(5, u64\"0\")\n\n    for (round <- z\"0\" until rounds) {\n      /* Theta */\n      for (i <- 0 until 5) {\n        bc(i) = s(i) |^ s(i + 5) |^ s(i + 10) |^ s(i + 15) |^ s(i + 20)\n      }\n\n      for (i <- 0 until 5) {\n        t = bc((i + 4) % 5) |^ rotl(bc((i + 1) % 5), u64\"1\")\n        for (j <- 0 until 25 by 5) {\n          s(j + i) = s(j + i) |^ t\n        }\n      }\n\n      /* Rho Pi */\n      t = s(1)\n      for (i <- 0 until 24) {\n        val j = piln(i)\n        bc(0) = s(j)\n        s(j) = rotl(t, rotc(i))\n        t = bc(0)\n      }\n\n      /* Chi */\n      for (j <- 0 until 25 by 5) {\n        for (i <- 0 until 5) {\n          bc(i) = s(j + i)\n        }\n        for (i <- 0 until 5) {\n          s(j + i) = s(j + i) |^ ((~bc((i + 1) % 5)) & bc((i + 2) % 5))\n        }\n      }\n\n      /* Iota */\n      s(0) = s(0) |^ rndc(round)\n    }\n  }\n\n  @pure def init256: SHA3 = {\n    return SHA3(8)\n  }\n\n  @pure def init384: SHA3 = {\n    return SHA3(12)\n  }\n\n  @pure def init512: SHA3 = {\n    return SHA3(16)\n  }\n\n  @pure def sum256(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init256\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n  @pure def sum384(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init384\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n  @pure def sum512(data: ISZ[U8]): ISZ[U8] = {\n    val sha3 = init512\n    sha3.update(data)\n    val r = sha3.finalise()\n    return r\n  }\n\n}\n\nimport SHA3._\n\n@record class SHA3(val capacityWords: Z) {\n  var saved: U64 = u64\"0\"\n  var byteIndex: U64 = u64\"0\"\n  var wordIndex: Z = 0\n  var s: MSZ[U64] = MS.create[Z, U64](25, u64\"0\")\n\n  def update(buf: ISZ[U8]): Unit = {\n\n    assert(byteIndex < u64\"8\")\n    assert(wordIndex < 25)\n\n    var oldTail = (8 - conversions.U64.toZ(byteIndex)) % 8\n    var len = buf.size\n\n    var index = 0\n    if (len < oldTail) {\n      while (len > 0) {\n        saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n        byteIndex = byteIndex + u64\"1\"\n        index = index + 1\n        len = len - 1\n      }\n      assert(byteIndex < u64\"8\")\n      return\n    }\n\n    if (oldTail > 0) {\n      len = len - oldTail\n      while (oldTail > 0) {\n        saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n        byteIndex = byteIndex + u64\"1\"\n        index = index + 1\n        oldTail = oldTail - 1\n      }\n      s(wordIndex) = s(wordIndex) |^ saved\n      assert(byteIndex == u64\"8\")\n      byteIndex = u64\"0\"\n      saved = u64\"0\"\n      wordIndex = wordIndex + 1\n      if (wordIndex == spongeWords - capacityWords) {\n        keccakf(s)\n        wordIndex = 0\n      }\n    }\n\n    assert(byteIndex == u64\"0\")\n\n    val words = len / 8\n    for (_ <- z\"0\" until words) {\n      val t = conversions.U8.toU64(buf(index)) |\n        (conversions.U8.toU64(buf(index + 1)) << u64\"8\") |\n        (conversions.U8.toU64(buf(index + 2)) << u64\"16\") |\n        (conversions.U8.toU64(buf(index + 3)) << u64\"24\") |\n        (conversions.U8.toU64(buf(index + 4)) << u64\"32\") |\n        (conversions.U8.toU64(buf(index + 5)) << u64\"40\") |\n        (conversions.U8.toU64(buf(index + 6)) << u64\"48\") |\n        (conversions.U8.toU64(buf(index + 7)) << u64\"56\")\n      s(wordIndex) = s(wordIndex) |^ t\n      wordIndex = wordIndex + 1\n      if (wordIndex == spongeWords - capacityWords) {\n        keccakf(s)\n        wordIndex = 0\n      }\n      index = index + 8\n    }\n\n    var tail = len - words * 8\n    assert(byteIndex == u64\"0\" && tail < 8)\n    while (tail > 0) {\n      saved = saved | (conversions.U8.toU64(buf(index)) << (byteIndex * u64\"8\"))\n      byteIndex = byteIndex + u64\"1\"\n      index = index + 1\n      tail = tail - 1\n    }\n    assert(byteIndex < u64\"8\")\n  }\n\n  def finalise(): ISZ[U8] = {\n    s(wordIndex) = s(wordIndex) |^ (saved |^ ((u64\"0x02\" | (u64\"1\" << u64\"2\")) << (byteIndex * u64\"8\")))\n    s(spongeWords - capacityWords - 1) = s(spongeWords - capacityWords - 1) |^ u64\"0x8000000000000000\"\n    keccakf(s)\n\n    val sb = MSZ.create(capacityWords * 4, u8\"0\")\n    for (i <- z\"0\" until (capacityWords / 2)) {\n      val t = s(i)\n      sb(i * 8) = conversions.U64.toU8(t & u64\"0xFF\")\n      sb(i * 8 + 1) = conversions.U64.toU8((t >> u64\"8\") & u64\"0xFF\")\n      sb(i * 8 + 2) = conversions.U64.toU8((t >> u64\"16\") & u64\"0xFF\")\n      sb(i * 8 + 3) = conversions.U64.toU8((t >> u64\"24\") & u64\"0xFF\")\n      sb(i * 8 + 4) = conversions.U64.toU8((t >> u64\"32\") & u64\"0xFF\")\n      sb(i * 8 + 5) = conversions.U64.toU8((t >> u64\"40\") & u64\"0xFF\")\n      sb(i * 8 + 6) = conversions.U64.toU8((t >> u64\"48\") & u64\"0xFF\")\n      sb(i * 8 + 7) = conversions.U64.toU8((t >> u64\"56\") & u64\"0xFF\")\n    }\n    return sb.toIS\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$5();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #610                // String // #Sireum\npackage org.sireum\n\nimport U32._\nimport U64._\n\nobject Hash {\n\n  @pure def murmur3a(data: ISZ[U8], seed: U32): U32 = {\n\n    /*\n     Copyright (c) 2017-2022, Robby, Kansas State University\n     All rights reserved.\n\n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions are met:\n\n     1. Redistributions of source code must retain the above copyright notice, this\n        list of conditions and the following disclaimer.\n     2. Redistributions in binary form must reproduce the above copyright notice,\n        this list of conditions and the following disclaimer in the documentation\n        and/or other materials provided with the distribution.\n\n     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n\n    @pure def process(d0: U32, h: U32): U32 = {\n      var d = d0\n      d = d * u32\"0xCC9E2D51\"\n      d = (d << u32\"15\") | (d >>> u32\"17\")\n      d = d * u32\"0x1B873593\"\n      return h |^ d\n    }\n\n    val dataSize = data.size\n    var h = seed\n\n    var i: Z = 0\n    if (dataSize > 3) {\n      while (dataSize - i >= 4) {\n        val d =\n          conversions.U8.toU32(data(i)) |\n            (conversions.U8.toU32(data(i + 1)) << u32\"8\") |\n            (conversions.U8.toU32(data(i + 2)) << u32\"16\") |\n            (conversions.U8.toU32(data(i + 3)) << u32\"24\")\n        i = i + 4\n        h = process(d, h)\n        h = (h << u32\"13\") | (h >> u32\"19\")\n        h = (h * u32\"5\") + u32\"0xE6546B64\"\n      }\n    }\n\n    dataSize - i match {\n      case z\"1\" =>\n        val d = conversions.U8.toU32(data(i))\n        h = process(d, h)\n      case z\"2\" =>\n        val d = conversions.U8.toU32(data(i)) |\n          (conversions.U8.toU32(data(i + 1)) << u32\"8\")\n        h = process(d, h)\n      case z\"3\" =>\n        val d = conversions.U8.toU32(data(i)) |\n          (conversions.U8.toU32(data(i + 1)) << u32\"8\") |\n          (conversions.U8.toU32(data(i + 2)) << u32\"16\")\n        h = process(d, h)\n      case _ =>\n    }\n\n    h = h |^ conversions.Z.toU32(dataSize)\n    h = h |^ (h >> u32\"16\")\n    h = h * u32\"0x85EBCA6B\"\n    h = h |^ (h >> u32\"13\")\n    h = h * u32\"0xC2B2AE35\"\n    h = h |^ (h >> u32\"16\")\n\n    return h\n  }\n\n  @pure def t1ha0(data: ISZ[U8], seed: U64): U64 = {\n\n    // Adapted from: https://github.com/leo-yuriev/t1ha/tree/v2.0.2\n    /*\n     *  Copyright (c) 2016-2018 Positive Technologies, https://www.ptsecurity.com,\n     *  Fast Positive Hash.\n     *\n     *  Portions Copyright (c) 2010-2018 Leonid Yuriev <leo@yuriev.ru>,\n     *  The 1Hippeus project (t1h).\n     *\n     *  This software is provided \'as-is\', without any express or implied\n     *  warranty. In no event will the authors be held liable for any damages\n     *  arising from the use of this software.\n     *\n     *  Permission is granted to anyone to use this software for any purpose,\n     *  including commercial applications, and to alter it and redistribute it\n     *  freely, subject to the following restrictions:\n     *\n     *  1. The origin of this software must not be misrepresented; you must not\n     *     claim that you wrote the original software. If you use this software\n     *     in a product, an acknowledgement in the product documentation would be\n     *     appreciated but is not required.\n     *  2. Altered source versions must be plainly marked as such, and must not be\n     *     misrepresented as being the original software.\n     *  3. This notice may not be removed or altered from any source distribution.\n     */\n\n    @pure def rot(n: U32, m: U32): U32 = {\n      return (n >>> m) | (n << (u32\"32\" - m))\n    }\n\n    @pure def fetch(i: Z): U32 = {\n      return conversions.U8.toU32(data(i)) |\n        conversions.U8.toU32(data(i + 1)) << u32\"8\" |\n        conversions.U8.toU32(data(i + 2)) << u32\"16\" |\n        conversions.U8.toU32(data(i + 3)) << u32\"24\"\n    }\n\n    @pure def tail(i: Z): U32 = {\n      data.size - i match {\n        case z\"1\" =>\n          return conversions.U8.toU32(data(i))\n        case z\"2\" =>\n          return conversions.U8.toU32(data(i)) |\n            conversions.U8.toU32(data(i + 1)) << u32\"8\"\n        case z\"3\" =>\n          return conversions.U8.toU32(data(i)) |\n            conversions.U8.toU32(data(i + 1)) << u32\"8\" |\n            conversions.U8.toU32(data(i + 2)) << u32\"16\"\n        case _ => fetch(i)\n      }\n    }\n\n    val prime0: U32 = u32\"0x92D78269\"\n    val prime1: U32 = u32\"0xCA9B4735\"\n    val prime2: U32 = u32\"0xA4ABA1C3\"\n    val prime3: U32 = u32\"0xF6499843\"\n    val prime4: U32 = u32\"0x86F0FD61\"\n    val prime5: U32 = u32\"0xCA2DA6FB\"\n    val prime6: U32 = u32\"0xC4BB3575\"\n\n    val dataSize = data.size\n    val dataSize32 = conversions.Z.toU32(dataSize)\n\n    var a: U32 = rot(dataSize32, u32\"17\") + conversions.U64.toU32(seed & u64\"0xFFFFFFFF\")\n    var b: U32 = dataSize32 |^ conversions.U64.toU32(seed >>> u64\"32\")\n\n    var i = 0\n    if (dataSize > 16) {\n      var c = ~a\n      var d = rot(b, u32\"5\")\n\n      while (dataSize - i >= 16) {\n        val w0 = fetch(i)\n        val w1 = fetch(i + 4)\n        val w2 = fetch(i + 8)\n        val w3 = fetch(i + 12)\n\n        val c02 = w0 |^ rot(w2 + c, u32\"11\")\n        val d13 = w1 + rot(w3 + d, u32\"17\")\n        c = c |^ rot(b + w1, u32\"7\")\n        d = d |^ rot(a + w0, u32\"3\")\n        b = prime1 * (c02 + w3)\n        a = prime0 * (d13 |^ w2)\n        i = i + 16\n      }\n\n      c = c + a\n      d = d + b\n      a = a |^ (prime6 * (rot(c, u32\"16\") + d))\n      b = b |^ (prime5 * (c + rot(d, u32\"16\")))\n    }\n\n    val len = dataSize - i\n    (len - 1) / 4 match {\n      case z\"3\" =>\n        var l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime4)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + fetch(i)) * conversions.U32.toU64(prime3)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case z\"2\" =>\n        var l = conversions.U32.toU64(a + fetch(i)) * conversions.U32.toU64(prime3)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case z\"1\" =>\n        var l = conversions.U32.toU64(b + fetch(i)) * conversions.U32.toU64(prime2)\n        a = a |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        b = b + conversions.U64.toU32(l >>> u64\"32\")\n        i = i + 4\n        l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n        b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n        a = a + conversions.U64.toU32(l >>> u64\"32\")\n      case _ =>\n        if (len > 0) {\n          val l = conversions.U32.toU64(a + tail(i)) * conversions.U32.toU64(prime1)\n          b = b |^ conversions.U64.toU32(l & u64\"0xFFFFFFFF\")\n          a = a + conversions.U64.toU32(l >>> u64\"32\")\n        }\n    }\n\n    var l = conversions.U32.toU64(b |^ rot(a, u32\"13\")) | (conversions.U32.toU64(a) << u64\"32\")\n    l = l * u64\"0xEC99BF0D8372CAAB\"\n    l = l |^ (l >> u64\"41\")\n    l = l * u64\"0x9C06FAF4D023E3AB\"\n    l = l |^ (l >> u64\"47\")\n    l = l * u64\"0xCB5AF53AE3AAAC31\"\n\n    return l\n  }\n\n  @pure def t1ha(isFirst: B, data: ISZ[U8], seed: U64): U64 = {\n\n    @pure def mullu(a: U64, b: U64): (U64, U64) = {\n      // Adapted from: https://golang.org/src/runtime/softfloat64.go (mullu)\n      /*\n        Copyright (c) 2009 The Go Authors. All rights reserved.\n\n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions are\n        met:\n\n        * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following disclaimer\n        in the documentation and/or other materials provided with the\n        distribution.\n        * Neither the name of Google Inc. nor the names of its\n        contributors may be used to endorse or promote products derived from\n        this software without specific prior written permission.\n\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n        \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n       */\n\n      val s = u64\"32\"\n      val mask = (u64\"1\" << s) - u64\"1\"\n      val a0 = a & mask\n      val a1 = a >> s\n      val b0 = b & mask\n      val b1 = b >> s\n      val w0 = a0 * b0\n      val t = a1 * b0 + (w0 >> s)\n      var w1 = t & mask\n      val w2 = t >> s\n      w1 = w1 + a0 * b1\n      return (a * b, a1 * b1 + w2 + (w1 >> s))\n    }\n\n    // Adapted from: https://github.com/leo-yuriev/t1ha/tree/v2.0.2\n    /*\n     *  Copyright (c) 2016-2018 Positive Technologies, https://www.ptsecurity.com,\n     *  Fast Positive Hash.\n     *\n     *  Portions Copyright (c) 2010-2018 Leonid Yuriev <leo@yuriev.ru>,\n     *  The 1Hippeus project (t1h).\n     *\n     *  This software is provided \'as-is\', without any express or implied\n     *  warranty. In no event will the authors be held liable for any damages\n     *  arising from the use of this software.\n     *\n     *  Permission is granted to anyone to use this software for any purpose,\n     *  including commercial applications, and to alter it and redistribute it\n     *  freely, subject to the following restrictions:\n     *\n     *  1. The origin of this software must not be misrepresented; you must not\n     *     claim that you wrote the original software. If you use this software\n     *     in a product, an acknowledgement in the product documentation would be\n     *     appreciated but is not required.\n     *  2. Altered source versions must be plainly marked as such, and must not be\n     *     misrepresented as being the original software.\n     *  3. This notice may not be removed or altered from any source distribution.\n     */\n\n    @pure def rot(n: U64, m: U64): U64 = {\n      return (n >>> m) | (n << (u64\"64\" - m))\n    }\n\n    @pure def mix(v: U64, p: U64): U64 = {\n      val v2 = v * p\n      return v2 |^ rot(v2, u64\"41\")\n    }\n\n    @pure def mux(v: U64, prime: U64): U64 = {\n      val p = mullu(v, prime)\n      return p._1 |^ p._2\n    }\n\n    @pure def fetch(i: Z): U64 = {\n      return conversions.U8.toU64(data(i)) |\n        conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n        conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n        conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n        conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n        conversions.U8.toU64(data(i + 5)) << u64\"40\" |\n        conversions.U8.toU64(data(i + 6)) << u64\"48\" |\n        conversions.U8.toU64(data(i + 7)) << u64\"56\"\n    }\n\n    @pure def tail(i: Z): U64 = {\n      data.size - i match {\n        case z\"1\" =>\n          return conversions.U8.toU64(data(i))\n        case z\"2\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\"\n        case z\"3\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\"\n        case z\"4\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\"\n        case z\"5\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\"\n        case z\"6\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n            conversions.U8.toU64(data(i + 5)) << u64\"40\"\n        case z\"7\" =>\n          return conversions.U8.toU64(data(i)) |\n            conversions.U8.toU64(data(i + 1)) << u64\"8\" |\n            conversions.U8.toU64(data(i + 2)) << u64\"16\" |\n            conversions.U8.toU64(data(i + 3)) << u64\"24\" |\n            conversions.U8.toU64(data(i + 4)) << u64\"32\" |\n            conversions.U8.toU64(data(i + 5)) << u64\"40\" |\n            conversions.U8.toU64(data(i + 6)) << u64\"48\"\n        case _ => return fetch(i)\n      }\n    }\n\n    val prime0: U64 = u64\"0xEC99BF0D8372CAAB\"\n    val prime1: U64 = u64\"0x82434FE90EDCEF39\"\n    val prime2: U64 = u64\"0xD4F06DB99D67BE4B\"\n    val prime3: U64 = u64\"0xBD9CACC22C6E9571\"\n    val prime4: U64 = u64\"0x9C06FAF4D023E3AB\"\n    val prime5: U64 = u64\"0xC060724A8424F345\"\n    val prime6: U64 = u64\"0xCB5AF53AE3AAAC31\"\n\n    @pure def first(): U64 = {\n      val dataSize = data.size\n      val dataSize64 = conversions.Z.toU64(dataSize)\n\n      var a: U64 = seed\n      var b: U64 = conversions.Z.toU64(dataSize)\n\n      var i = 0\n      if (dataSize > 32) {\n        var c = rot(dataSize64, u64\"17\") + seed\n        var d = dataSize64 |^ rot(seed, u64\"17\")\n\n        while (dataSize - i >= 32) {\n          val w0 = fetch(i)\n          val w1 = fetch(i + 8)\n          val w2 = fetch(i + 16)\n          val w3 = fetch(i + 24)\n\n          val d02 = w0 |^ rot(w2 + d, u64\"17\")\n          val c13 = w1 |^ rot(w3 + c, u64\"17\")\n          c = c + (a |^ rot(w0, u64\"41\"))\n          d = d - (b |^ rot(w1, u64\"31\"))\n          a = a |^ (prime1 * (d02 + w3))\n          b = b |^ (prime0 * (c13 + w2))\n          i = i + 32\n        }\n\n        a = a |^ (prime6 * (rot(c, u64\"17\") + d))\n        b = b |^ (prime5 * (c + rot(d, u64\"17\")))\n      }\n\n      val len = dataSize - i\n      (len - 1) / 8 match {\n        case z\"3\" =>\n          b = b + mux(fetch(i), prime4)\n          i = i + 8\n          a = a + mux(fetch(i), prime3)\n          i = i + 8\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case z\"2\" =>\n          a = a + mux(fetch(i), prime3)\n          i = i + 8\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case z\"1\" =>\n          b = b + mux(fetch(i), prime2)\n          i = i + 8\n          a = a + mux(tail(i), prime1)\n        case _ =>\n          if (len > 0) {\n            a = a + mux(tail(i), prime1)\n          }\n      }\n\n      return mux(rot(a + b, u64\"17\"), prime4) + mix(a |^ b, prime0)\n    }\n\n    @pure def second(): U64 = {\n      val dataSize = data.size\n      val dataSize64 = conversions.Z.toU64(dataSize)\n\n      var a: U64 = seed\n      var b: U64 = dataSize64\n\n      var i = 0\n      if (dataSize > 32) {\n        var c: U64 = rot(dataSize64, u64\"23\") + ~seed\n        var d: U64 = ~dataSize64 + rot(seed, u64\"19\")\n\n        while (dataSize - i >= 32) {\n          val w0 = fetch(i + 0)\n          val w1 = fetch(i + 8)\n          val w2 = fetch(i + 16)\n          val w3 = fetch(i + 24)\n\n          val d02 = w0 + rot(w2 + d, u64\"56\")\n          val c13 = w1 + rot(w3 + c, u64\"19\")\n          d = d |^ (b + rot(w1, u64\"38\"))\n          c = c |^ (a + rot(w0, u64\"57\"))\n          b = b |^ (prime6 * (c13 + w2))\n          a = a |^ (prime5 * (d02 + w3))\n          i = i + 32\n        }\n\n        a = a |^ (prime6 * (c + rot(d, u64\"23\")))\n        b = b |^ (prime5 * (rot(c, u64\"19\") + d))\n      }\n\n      val len = dataSize - i\n      (len - 1) / 8 match {\n        case z\"3\" =>\n          var p = mullu(b + fetch(i), prime4)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + fetch(i), prime3)\n          b = b |^ p._1\n          a = a + p._2\n          i = i + 8\n          p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case z\"2\" =>\n          var p = mullu(a + fetch(i), prime3)\n          b = b |^ p._1\n          a = a + p._2\n          i = i + 8\n          p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case z\"1\" =>\n          var p = mullu(b + fetch(i), prime2)\n          a = a |^ p._1\n          b = b + p._2\n          i = i + 8\n          p = mullu(a + tail(i), prime1)\n          b = b |^ p._1\n          a = a + p._2\n        case _ =>\n          if (len > 0) {\n            val p = mullu(a + tail(i), prime1)\n            b = b |^ p._1\n            a = a + p._2\n          }\n      }\n\n      return mux(((a + rot(b, u64\"41\")) * prime0) |^ ((rot(a, u64\"23\") + b) * prime6), prime5)\n    }\n\n    return if (isFirst) first() else second()\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$6();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #612                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nimport ContractUtil._\n\n@record trait CircularQueue[E] {\n\n  @spec var rep: MSZ[E] = $\n\n  @spec def repInv = Invariant(rep.size <= max)\n\n  @pure def max: Z\n\n  @pure def default: E\n\n  @pure def scrub: B\n\n  @pure def policy: CircularQueue.Policy.Type\n\n  def size: Z = Contract.Only(Ensures(Res == rep.size))\n\n  def isEmpty: B = Contract.Only(Ensures(Res == (rep.size == 0)))\n\n  def nonEmpty: B = Contract.Only(Ensures(Res == (rep.size != 0)))\n\n  def isFull: B = Contract.Only(Ensures(Res == (rep.size == max)))\n\n  def enqueue(element: E): Unit = Contract.Only(\n    Modifies(rep),\n    Case(\"Non-full\",\n      Requires(rep.size < max),\n      Ensures(rep == In(rep) :+ element)\n    ),\n    Case(\"Drop front policy and full\",\n      Requires(\n        policy == CircularQueue.Policy.DropFront,\n        rep.size == max\n      ),\n      Ensures(\n        rep.size == In(rep).size,\n        All(1 until rep.size)(i => rep(i - 1) == In(rep)(i)),\n        rep(rep.size - 1) == element\n      )\n    ),\n    Case(\"Drop rear policy and full\",\n      Requires(\n        policy == CircularQueue.Policy.DropRear,\n        rep.size == max\n      ),\n      Ensures(\n        rep.size == In(rep).size,\n        msEqualExcept(rep, In(rep), rep.size - 1),\n        rep(rep.size - 1) == element\n      )\n    )\n  )\n\n  def dequeue(): E = Contract.Only(\n    Requires(rep.size > 0),\n    Modifies(rep),\n    Ensures(\n      rep.size == In(rep).size - 1,\n      All(1 until In(rep).size)(i => rep(i - 1) == In(rep)(i)),\n      Res == In(rep)(0)\n    )\n  )\n\n  def elements: MSZ[E] = Contract.Only(Ensures(Res == rep))\n\n  override def string: String = {\n    return elements.string\n  }\n}\n\nobject CircularQueue {\n\n  @enum object Policy {\n    \"NoDrop\"\n    \"DropFront\"\n    \"DropRear\"\n  }\n\n  @strictpure def inv[E](max: Z, default: E, scrub: B, queue: MSZ[E], front: Z, rear: Z, numOfElements: Z): B =\n    max > 0 &\n      max + 1 == queue.size &\n      queue.isInBound(front) &\n      queue.isInBound(rear) &\n      0 <= numOfElements &\n      numOfElements <= max &\n      (rear >= front) === (numOfElements == rear - front) &\n      (rear < front) === (numOfElements == rear + queue.size - front) &\n      (scrub ->: All(0 until queue.size - numOfElements)(i => queue(modPos(rear + i, queue.size)) == default))\n\n  @strictpure def refinement[E](rep: MSZ[E], queue: MSZ[E], numOfElements: Z, front: Z): B =\n    rep.size == numOfElements &\n      All(rep.indices)(i => rep(i) == queue(modPos(front + i, queue.size)))\n\n  @strictpure def createEnsures[E](res: CircularQueue[E], max: Z, default: E, scrub: B, policy: Policy.Type): B =\n    res.max == max &\n      res.default == default &\n      res.scrub == scrub &\n      res.policy == policy\n\n  object NoDrop {\n\n    @pure def create[E](max: Z, default: E, scrub: B): NoDrop[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[NoDrop[E]].rep == MSZ[E]()\n        )\n      )\n\n      return NoDrop(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: NoDrop[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class NoDrop[E](val max: Z,\n                          val default: E,\n                          val scrub: B,\n                          val queue: MSZ[E],\n                          var front: Z,\n                          var rear: Z,\n                          var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.NoDrop\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Requires(numOfElements != max),\n        Modifies(queue, rear, front, numOfElements),\n        Ensures(\n          queue(In(rear)) == element,\n          rear == modPos(In(rear) + 1, queue.size),\n          numOfElements == In(numOfElements) + 1,\n          msEqualExcept(queue, In(queue), In(rear))\n        )\n      )\n\n      queue(rear) = element\n      rear = modPos(rear + 1, queue.size)\n      numOfElements = numOfElements + 1\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  object DropFront {\n\n    @pure def create[E](max: Z, default: E, scrub: B): DropFront[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[DropFront[E]].rep == MSZ[E]()\n        )\n      )\n\n      return DropFront(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: DropFront[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class DropFront[E](val max: Z,\n                             val default: E,\n                             val scrub: B,\n                             val queue: MSZ[E],\n                             var front: Z,\n                             var rear: Z,\n                             var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.DropFront\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Modifies(queue, rear, front, numOfElements),\n        Ensures(\n          queue(In(rear)) == element,\n          rear == modPos(In(rear) + 1, queue.size),\n          (In(numOfElements) < max) === (numOfElements == In(numOfElements) + 1),\n          (In(numOfElements) == max) === (numOfElements == In(numOfElements)),\n          msEqualExcept(queue, In(queue), In(rear))\n        )\n      )\n\n      if (isFull) {\n        dequeue()\n      }\n      queue(rear) = element\n      rear = modPos(rear + 1, queue.size)\n      numOfElements = numOfElements + 1\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  object DropRear {\n\n    @pure def create[E](max: Z, default: E, scrub: B): DropRear[E] = {\n      Contract(\n        Ensures(\n          createEnsures(Res, max, default, scrub, Policy.NoDrop) &\n            additionalCreateEnsures(Res) &\n            Res[DropRear[E]].rep == MSZ[E]()\n        )\n      )\n      return DropRear(max, default, scrub, MS.create(max + 1, default), 0, 0, 0)\n    }\n\n    @strictpure def additionalCreateEnsures[E](res: DropRear[E]): B =\n      res.front == 0 &\n        res.rear == 0 &\n        res.numOfElements == 0 &\n        isAllMS(res.queue, res.default)\n  }\n\n  @record class DropRear[E](val max: Z,\n                            val default: E,\n                            val scrub: B,\n                            val queue: MSZ[E],\n                            var front: Z,\n                            var rear: Z,\n                            var numOfElements: Z) extends CircularQueue[E] {\n\n    @spec def invariant = Invariant(\n      inv(max, default, scrub, queue, front, rear, numOfElements)\n    )\n\n    Contract(\n      DataRefinement(rep)(queue, front, rear, numOfElements)(\n        refinement(rep, queue, numOfElements, front)\n      )\n    )\n\n    @strictpure def policy: Policy.Type = Policy.DropRear\n\n    override def size: Z = {\n      Contract(Ensures(Res == numOfElements))\n\n      return numOfElements\n    }\n\n    override def isEmpty: B = {\n      Contract(Ensures(Res == (numOfElements == 0)))\n\n      return numOfElements == 0\n    }\n\n    override def nonEmpty: B = {\n      Contract(Ensures(Res == (numOfElements != 0)))\n\n      return !isEmpty\n    }\n\n    override def isFull: B = {\n      Contract(Ensures(Res == (numOfElements == max)))\n\n      return numOfElements == max\n    }\n\n    override def enqueue(element: E): Unit = {\n      Contract(\n        Modifies(queue, rear, front, numOfElements),\n        Case(\"Non-full and rear is not the last index\",\n          Requires(\n            In(numOfElements) < max,\n            rear < max\n          ),\n          Ensures(\n            numOfElements == In(numOfElements) + 1,\n            rear == In(rear) + 1,\n            queue(In(rear)) == element,\n            msEqualExcept(queue, In(queue), In(rear))\n          )\n        ),\n        Case(\"Non-full and rear is the last index\",\n          Requires(\n            In(numOfElements) < max,\n            rear == max\n          ),\n          Ensures(\n            numOfElements == In(numOfElements) + 1,\n            rear == 0,\n            queue(max) == element,\n            msEqualExcept(queue, In(queue), max)\n          )\n        ),\n        Case(\"Full and rear is the first index\",\n          Requires(\n            numOfElements == max,\n            rear == 0\n          ),\n          Ensures(\n            numOfElements == In(numOfElements),\n            rear == In(rear),\n            queue(max) == element,\n            msEqualExcept(queue, In(queue), max)\n          )\n        ),\n        Case(\"Full and rear is not the first index\",\n          Requires(\n            In(numOfElements) == max,\n            rear > 0\n          ),\n          Ensures(\n            numOfElements == In(numOfElements),\n            rear == In(rear),\n            queue(rear - 1) == element,\n            msEqualExcept(queue, In(queue), rear - 1)\n          )\n        )\n      )\n\n      if (isFull) {\n        queue(modNeg(rear - 1, queue.size)) = element\n      } else {\n        queue(rear) = element\n        rear = modPos(rear + 1, queue.size)\n        numOfElements = numOfElements + 1\n      }\n    }\n\n    override def dequeue(): E = {\n      Contract(\n        Requires(numOfElements != 0),\n        Modifies(queue, front, numOfElements),\n        Ensures(\n          numOfElements == In(numOfElements) - 1,\n          front == modPos(In(front) + 1, queue.size),\n          Res == queue(In(front))\n        )\n      )\n\n      val r = queue(front)\n      if (scrub) {\n        queue(front) = default\n      }\n      front = modPos(front + 1, queue.size)\n      numOfElements = numOfElements - 1\n      return r\n    }\n\n    override def elements: MSZ[E] = {\n      Contract(Ensures(refinement(Res, queue, numOfElements, front)))\n\n      val r = MSZ.create(numOfElements, default)\n      for (i <- 0 until numOfElements) {\n        r(i) = queue(modPos(front + i, queue.size))\n      }\n      return r\n    }\n  }\n\n  @pure def create[E](max: Z, default: E, scrub: B, policy: Policy.Type): CircularQueue[E] = {\n    Contract(Ensures(createEnsures(Res, max, default, scrub, policy)))\n\n    policy match {\n      case Policy.NoDrop => return NoDrop.create(max, default, scrub)\n      case Policy.DropFront => return DropFront.create(max, default, scrub)\n      case Policy.DropRear => return DropRear.create(max, default, scrub)\n    }\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$7();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #614                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n@ext object Library {\n\n  def sharedFiles: ISZ[(Option[String], String)] = $\n\n  def files: ISZ[(Option[String], String)] = $\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$8();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #616                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject UnionFind {\n\n  type Index = Z\n\n  object Internal {\n\n    @pure def find[T](ds: UnionFind[T], e: Index): Index = {\n      var root = e\n      while (ds.parentOf(root) != root) {\n        root = ds.parentOf(root)\n      }\n      return root\n    }\n\n    @pure def findCompress[T](ds: UnionFind[T], e: Index): (UnionFind[T], Index) = {\n      var root = e\n      var newParentOf = ds.parentOf\n      while (newParentOf(root) != root) {\n        newParentOf = newParentOf(root ~> newParentOf(newParentOf(root)))\n        root = newParentOf(root)\n      }\n      return (ds(parentOf = newParentOf), root)\n    }\n\n    @pure def merge[T](ds: UnionFind[T], e1: Index, e2: Index): UnionFind[T] = {\n      var newDs = ds\n      val rootN: Index = {\n        val pe1 = findCompress(newDs, e1)\n        newDs = pe1._1\n        pe1._2\n      }\n      val rootM: Index = {\n        val pe2 = findCompress(newDs, e2)\n        newDs = pe2._1\n        pe2._2\n      }\n      val (rep, other): (Index, Index) =\n        if (newDs.sizeOf(rootM) > newDs.sizeOf(rootN)) (rootM, rootN) else (rootN, rootM)\n      return newDs(\n        parentOf = newDs.parentOf(other ~> rep),\n        sizeOf = newDs.sizeOf(rep ~> (newDs.sizeOf(rep) + newDs.sizeOf(other)))\n      )\n    }\n  }\n\n  @pure def create[T](elements: ISZ[T]): UnionFind[T] = {\n    val size = elements.size\n    var es = HashSMap.emptyInit[T, Index](size)\n    for (e <- elements) {\n      es = es + e ~> es.size\n    }\n    val parentOf: IS[Index, Index] = for (i <- z\"0\" until size) yield i\n    val sizeOf = IS.create[Index, Index](size, 1)\n    return UnionFind(es, elements, parentOf, sizeOf)\n  }\n}\n\n@datatype class UnionFind[T](\n  val elements: HashSMap[T, UnionFind.Index],\n  val elementsInverse: IS[UnionFind.Index, T],\n  val parentOf: IS[UnionFind.Index, UnionFind.Index],\n  val sizeOf: IS[UnionFind.Index, UnionFind.Index]\n) {\n\n  @pure def size: Z = {\n    return elements.size\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: UnionFind[T]): B = {\n    if (elementsInverse.size != other.elementsInverse.size) {\n      return F\n    }\n    if ((HashSSet ++ elementsInverse) != (HashSSet ++ other.elementsInverse)) {\n      return F\n    }\n    var seen = HashSSet.emptyInit[(T, T)](size)\n    for (element1 <- elementsInverse; element2 <- elementsInverse if element1 != element2) {\n      val p = (element1, element2)\n      if (!seen.contains(p)) {\n        seen = seen + p + ((element2, element1))\n        if (inSameSet(element1, element2) != inSameSet(element1, element2)) {\n          return F\n        }\n      }\n    }\n    return T\n  }\n\n  @pure def inSameSet(element1: T, element2: T): B = {\n    return UnionFind.Internal.find(this, elements.get(element1).get) == UnionFind.Internal\n      .find(this, elements.get(element2).get)\n  }\n\n  @pure def inSameSetCompress(element1: T, element2: T): (UnionFind[T], B) = {\n    val e1 = elements.get(element1).get\n    val e2 = elements.get(element2).get\n    var newDs = this\n    val rep1: UnionFind.Index = {\n      val p1 = UnionFind.Internal.findCompress(newDs, e1)\n      newDs = p1._1\n      p1._2\n    }\n    val rep2: UnionFind.Index = {\n      val p2 = UnionFind.Internal.findCompress(newDs, e2)\n      newDs = p2._1\n      p2._2\n    }\n    return (newDs, rep1 == rep2)\n  }\n\n  @pure def find(element: T): T = {\n    val n = elements.get(element).get\n    val rep = UnionFind.Internal.find(this, n)\n    return elementsInverse(rep)\n  }\n\n  @pure def findCompress(element: T): (UnionFind[T], T) = {\n    val n = elements.get(element).get\n    val (newDs, rep) = UnionFind.Internal.findCompress(this, n)\n    return (newDs, elementsInverse(rep))\n  }\n\n  @pure def merge(element1: T, element2: T): UnionFind[T] = {\n    val e1 = elements.get(element1).get\n    val e2 = elements.get(element2).get\n    return UnionFind.Internal.merge(this, e1, e2)\n  }\n\n  @pure def toST(f: T => ST): ST = {\n    var map = HashSMap.emptyInit[UnionFind.Index, ISZ[ST]](size)\n    for (element <- elementsInverse) {\n      val rep = UnionFind.Internal.find(this, elements.get(element).get)\n      map = map + rep ~> (map.get(rep).getOrElse(ISZ[ST]()) :+ f(element))\n    }\n    val sets: ISZ[ST] = for (sts <- map.values) yield st\"\"\"{\n    |  ${(sts, \",\\n\")}\n    |}\"\"\"\n    val r =\n      st\"\"\"{\n      |  ${(sets, \",\\n\")}\n      |}\"\"\"\n    return r\n  }\n\n  @pure override def string: String = {\n    return toST(e => st\"$e\").render\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$9();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #618                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Time {\n  def currentMillis: Z = $\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$10();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #620                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\nobject Console {\n\n  def pause(prompt: String): Unit = {\n    readLine(prompt)\n  }\n\n  def readLine(prompt: String): String = {\n    if (prompt.size > 0) {\n      print(prompt)\n    }\n    return Ext.readLine()\n  }\n\n  @ext(\"Console_Ext\") object Ext {\n    def readLine(): String = $\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$11();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #622                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Debug {\n  def onError[T](f: => T, handler: String => Unit): T = $\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$12();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #624                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.extension\n\nimport org.sireum._\n\n@ext object Cancel {\n  def handleCancellable[T](p: () => T): Unit = $\n  def cancellable[T](p: () => T): T = $\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$13();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #626                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@range(min = -128, max = 127) class Z8\n\n@range(min = -32768, max = 32767) class Z16\n\n@range(min = -2147483648, max = 2147483647) class Z32\n\n@range(min = -9223372036854775808L, max = 9223372036854775807L) class Z64\n\n@range(min = 0) class N\n\n@range(min = 0, max = 255) class N8\n\n@range(min = 0, max = 65535) class N16\n\n@range(min = 0, max = 4294967295L) class N32\n\n@range(min = 0, max = z\"18,446,744,073,709,551,617\") class N64\n\n@bits(signed = T, width = 8) class S8\n\n@bits(signed = T, width = 16) class S16\n\n@bits(signed = T, width = 32) class S32\n\n@bits(signed = T, width = 64) class S64\n\n@bits(signed = F, width = 8, min = 0, max = 1) class U1\n\n@bits(signed = F, width = 8, min = 0, max = 3) class U2\n\n@bits(signed = F, width = 8, min = 0, max = 7) class U3\n\n@bits(signed = F, width = 8, min = 0, max = 15) class U4\n\n@bits(signed = F, width = 8, min = 0, max = 31) class U5\n\n@bits(signed = F, width = 8, min = 0, max = 63) class U6\n\n@bits(signed = F, width = 8, min = 0, max = 127) class U7\n\n@bits(signed = F, width = 8) class U8\n\n@bits(signed = F, width = 16, min = 0, max = 511) class U9\n\n@bits(signed = F, width = 16, min = 0, max = 1023) class U10\n\n@bits(signed = F, width = 16, min = 0, max = 2047) class U11\n\n@bits(signed = F, width = 16, min = 0, max = 4095) class U12\n\n@bits(signed = F, width = 16, min = 0, max = 8191) class U13\n\n@bits(signed = F, width = 16, min = 0, max = 16383) class U14\n\n@bits(signed = F, width = 16, min = 0, max = 32767) class U15\n\n@bits(signed = F, width = 16) class U16\n\n@bits(signed = F, width = 32, min = 0, max = 131071) class U17\n\n@bits(signed = F, width = 32, min = 0, max = 262143) class U18\n\n@bits(signed = F, width = 32, min = 0, max = 524287) class U19\n\n@bits(signed = F, width = 32, min = 0, max = 1048575) class U20\n\n@bits(signed = F, width = 32, min = 0, max = 2097151) class U21\n\n@bits(signed = F, width = 32, min = 0, max = 4194303) class U22\n\n@bits(signed = F, width = 32, min = 0, max = 8388607) class U23\n\n@bits(signed = F, width = 32, min = 0, max = 16777215) class U24\n\n@bits(signed = F, width = 32, min = 0, max = 33554431) class U25\n\n@bits(signed = F, width = 32, min = 0, max = 67108863) class U26\n\n@bits(signed = F, width = 32, min = 0, max = 134217727) class U27\n\n@bits(signed = F, width = 32, min = 0, max = 268435455) class U28\n\n@bits(signed = F, width = 32, min = 0, max = 536870911) class U29\n\n@bits(signed = F, width = 32, min = 0, max = 1073741823) class U30\n\n@bits(signed = F, width = 32, min = 0, max = 2147483647) class U31\n\n@bits(signed = F, width = 32) class U32\n\n@bits(signed = F, width = 64, min = 0, max = 8589934591L) class U33\n\n@bits(signed = F, width = 64, min = 0, max = 17179869183L) class U34\n\n@bits(signed = F, width = 64, min = 0, max = 34359738367L) class U35\n\n@bits(signed = F, width = 64, min = 0, max = 68719476735L) class U36\n\n@bits(signed = F, width = 64, min = 0, max = 137438953471L) class U37\n\n@bits(signed = F, width = 64, min = 0, max = 274877906943L) class U38\n\n@bits(signed = F, width = 64, min = 0, max = 549755813887L) class U39\n\n@bits(signed = F, width = 64, min = 0, max = 1099511627775L) class U40\n\n@bits(signed = F, width = 64, min = 0, max = 2199023255551L) class U41\n\n@bits(signed = F, width = 64, min = 0, max = 4398046511103L) class U42\n\n@bits(signed = F, width = 64, min = 0, max = 8796093022207L) class U43\n\n@bits(signed = F, width = 64, min = 0, max = 17592186044415L) class U44\n\n@bits(signed = F, width = 64, min = 0, max = 35184372088831L) class U45\n\n@bits(signed = F, width = 64, min = 0, max = 70368744177663L) class U46\n\n@bits(signed = F, width = 64, min = 0, max = 140737488355327L) class U47\n\n@bits(signed = F, width = 64, min = 0, max = 281474976710655L) class U48\n\n@bits(signed = F, width = 64, min = 0, max = 562949953421311L) class U49\n\n@bits(signed = F, width = 64, min = 0, max = 1125899906842623L) class U50\n\n@bits(signed = F, width = 64, min = 0, max = 2251799813685247L) class U51\n\n@bits(signed = F, width = 64, min = 0, max = 4503599627370495L) class U52\n\n@bits(signed = F, width = 64, min = 0, max = 9007199254740991L) class U53\n\n@bits(signed = F, width = 64, min = 0, max = 18014398509481983L) class U54\n\n@bits(signed = F, width = 64, min = 0, max = 36028797018963967L) class U55\n\n@bits(signed = F, width = 64, min = 0, max = 72057594037927935L) class U56\n\n@bits(signed = F, width = 64, min = 0, max = 144115188075855871L) class U57\n\n@bits(signed = F, width = 64, min = 0, max = 288230376151711743L) class U58\n\n@bits(signed = F, width = 64, min = 0, max = 576460752303423487L) class U59\n\n@bits(signed = F, width = 64, min = 0, max = 1152921504606846975L) class U60\n\n@bits(signed = F, width = 64, min = 0, max = 2305843009213693951L) class U61\n\n@bits(signed = F, width = 64, min = 0, max = 4611686018427387903L) class U62\n\n@bits(signed = F, width = 64, min = 0, max = 9223372036854775807L) class U63\n\n@bits(signed = F, width = 64) class U64\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$14();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #628                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.ops.ISZOps\n\n\nobject Stack {\n  @pure def empty[T]: Stack[T] = {\n    return Stack[T](ISZ())\n  }\n}\n\n@datatype class Stack[T](val elements: ISZ[T]) {\n\n  @pure def size: Z = {\n    return elements.size\n  }\n\n  @pure def isEmpty: B = {\n    return elements.isEmpty\n  }\n\n  @pure def nonEmpty: B = {\n    return elements.nonEmpty\n  }\n\n  @pure def peek: Option[T] = {\n    if (nonEmpty) {\n      return Some(elements(elements.size - 1))\n    } else {\n      return None()\n    }\n  }\n\n  @pure def push(e: T): Stack[T] = {\n    return Stack(elements :+ e)\n  }\n\n  @pure def pop: Option[(T, Stack[T])] = {\n    if (nonEmpty) {\n      return Some((elements(elements.size - 1), Stack(ISZOps(elements).dropRight(1))))\n    } else {\n      return None()\n    }\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$15();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #630                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Option {\n\n  @strictpure def some[T](value: T): Option[T] = Some(value)\n\n  @strictpure def none[T](): Option[T] = None()\n}\n\n@datatype trait Option[T] {\n\n  @pure def isEmpty: B = Contract.Only(\n    Ensures(Res == (this == None[T]()))\n  )\n\n  @pure def nonEmpty: B = Contract.Only(\n    Ensures(Res == !isEmpty)\n  )\n\n  @pure def map[T2](f: T => T2 @pure): Option[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == None[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == Some(f(get)))\n    )\n  )\n\n  @pure def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == None[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def forall(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == T)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def exists(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == F)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def get: T = Contract.Only(\n    Requires(nonEmpty),\n    Ensures(Some(Res) == this)\n  )\n\n  @pure def getOrElse(default: => T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Some(Res) == this)\n    )\n  )\n\n  @pure def getOrElseEager(default: T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Some(Res) == this)\n    )\n  )\n\n  @pure def toIS: ISZ[T] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == ISZ[T]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == ISZ[T](get))\n    )\n  )\n\n  def foreach[V](f: T => V): Unit\n}\n\n@datatype class None[T] extends Option[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): Option[T2] = {\n    Contract(Ensures(Res == None[T2]()))\n    return None[T2]()\n  }\n\n  @pure override def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = {\n    Contract(Ensures(Res == None[T2]()))\n    return None[T2]()\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def get: T = {\n    Contract(Requires(F))\n    halt(\"Invalid \'None\' operation \'get\'.\")\n  }\n\n  @pure override def toIS: IS[Z, T] = {\n    Contract(Ensures(Res[ISZ[T]].size == 0))\n    return IS[Z, T]()\n  }\n\n  override def foreach[V](f: T => V): Unit = {}\n}\n\n@datatype class Some[T](val value: T) extends Option[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): Option[T2] = {\n    Contract(Ensures(Res == Some(f(value))))\n    return Some(f(value))\n  }\n\n  @pure override def flatMap[T2](f: T => Option[T2] @pure): Option[T2] = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def get: T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def toIS: IS[Z, T] = {\n    Contract(Ensures(Res == ISZ(value)))\n    return ISZ(value)\n  }\n\n  override def foreach[V](f: T => V): Unit = {\n    f(value)\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$16();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #632                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.conversions\n\nimport org.sireum._\n\nobject Collection {\n\n  @pure def mapToHashMap[K, W](map: Map[K, W]): HashMap[K, W] = {\n    var r = HashMap.emptyInit[K, W](map.size)\n    for (kv <- map.entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def mapToHashSMap[K, W](map: Map[K, W]): HashSMap[K, W] = {\n    var r = HashSMap.emptyInit[K, W](map.size)\n    for (kv <- map.entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def bagToHashBag[T](bag: Bag[T]): HashBag[T] = {\n    return HashBag(mapToHashMap(bag.map))\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$17();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #634                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.conversions\n\nimport org.sireum._\nimport org.sireum.Z8._\nimport org.sireum.Z16._\nimport org.sireum.Z32._\nimport org.sireum.Z64._\n\n@ext object B {\n\n  @pure def toB(b: B): B = Contract.Only(Ensures(Res == b))\n\n  @pure def toZ(b: B): Z = Contract.Only(Ensures(Res == (if (b) 1 else 0)))\n\n  @pure def toZ8(b: B): Z8 = Contract.Only(Ensures(Res == (if (b) z8\"1\" else z8\"0\")))\n\n  @pure def toZ16(b: B): Z16 = Contract.Only(Ensures(Res == (if (b) z16\"1\" else z16\"0\")))\n\n  @pure def toZ32(b: B): Z32 = Contract.Only(Ensures(Res == (if (b) z32\"1\" else z32\"0\")))\n\n  @pure def toZ64(b: B): Z64 = Contract.Only(Ensures(Res == (if (b) z64\"1\" else z64\"0\")))\n\n  @pure def toN(b: B): N =\n    $ // l\"\"\" ensures result ≡ (if (b) n\"1\" else n\"0\") \"\"\"\n\n  @pure def toN8(b: B): N8 =\n    $ // l\"\"\" ensures result ≡ (if (b) n8\"1\" else n8\"0\") \"\"\"\n\n  @pure def toN16(b: B): N16 =\n    $ // l\"\"\" ensures result ≡ (if (b) n16\"1\" else n16\"0\") \"\"\"\n\n  @pure def toN32(b: B): N32 =\n    $ // l\"\"\" ensures result ≡ (if (b) n32\"1\" else n32\"0\") \"\"\"\n\n  @pure def toN64(b: B): N64 =\n    $ // l\"\"\" ensures result ≡ (if (b) n64\"1\" else n64\"0\") \"\"\"\n\n  @pure def toS8(b: B): S8 =\n    $ // l\"\"\" ensures result ≡ (if (b) s8\"1\" else s8\"0\") \"\"\"\n\n  @pure def toS16(b: B): S16 =\n    $ // l\"\"\" ensures result ≡ (if (b) s16\"1\" else s16\"0\") \"\"\"\n\n  @pure def toS32(b: B): S32 =\n    $ // l\"\"\" ensures result ≡ (if (b) s32\"1\" else s32\"0\") \"\"\"\n\n  @pure def toS64(b: B): S64 =\n    $ // l\"\"\" ensures result ≡ (if (b) s64\"1\" else s64\"0\") \"\"\"\n\n  @pure def toU8(b: B): U8 =\n    $ // l\"\"\" ensures result ≡ (if (b) u8\"1\" else u8\"0\") \"\"\"\n\n  @pure def toU16(b: B): U16 =\n    $ // l\"\"\" ensures result ≡ (if (b) u16\"1\" else u16\"0\") \"\"\"\n\n  @pure def toU32(b: B): U32 =\n    $ // l\"\"\" ensures result ≡ (if (b) u32\"1\" else u32\"0\") \"\"\"\n\n  @pure def toU64(b: B): U64 =\n    $ // l\"\"\" ensures result ≡ (if (b) u64\"1\" else u64\"0\") \"\"\"\n\n  @pure def toF32(b: B): F32 =\n    $ // l\"\"\" ensures result ≡ (if (b) f32\"1.0\" else f32\"0.0\") \"\"\"\n\n  @pure def toF64(b: B): F64 =\n    $ // l\"\"\" ensures result ≡ (if (b) f64\"1.0\" else f64\"0.0\") \"\"\"\n\n  @pure def toR(b: B): R =\n    $ // l\"\"\" ensures result ≡ (if (b) r\"1.0\" else r\"0.0\") \"\"\"\n}\n\n@ext object C {\n  @pure def toU32(c: C): U32 = $\n  @pure def toCodePoints(c: C): ISZ[C] = $\n}\n\n@ext object Z {\n\n  @pure def isInRangeSigned8(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-128 ≤ n ∧ n ≤ 127) \"\"\"\n\n  @pure def isInRangeSigned16(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-32768 ≤ n ∧ n ≤ 32767) \"\"\"\n\n  @pure def isInRangeSigned32(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (-2147483648 ≤ n ∧ n ≤ 2147483647) \"\"\"\n\n  @pure def isInRangeSigned64(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\") \"\"\"\n\n  @pure def isInRangeUnsigned8(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ 255) \"\"\"\n\n  @pure def isInRangeUnsigned16(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ 65535) \"\"\"\n\n  @pure def isInRangeUnsigned32(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ z\"4294967295\") \"\"\"\n\n  @pure def isInRangeUnsigned64(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (0 ≤ n ∧ n ≤ z\"18446744073709551615\") \"\"\"\n\n  @pure def toB(n: Z): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ 0) \"\"\"\n\n  @pure def toZ(n: Z): Z =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ8(n: Z): Z8 =\n    $ // l\"\"\" requires -128 ≤ n ∧ n ≤ 127\n      //      ensures  Z8.toZ(result) ≡ n \"\"\"\n\n  @pure def toZ16(n: Z): Z16 =\n    $ // l\"\"\" requires -32768 ≤ n ∧ n ≤ 32767\n      //      ensures  Z16.toZ(result) ≡ n    \"\"\"\n\n  @pure def toZ32(n: Z): Z32 =\n    $ // l\"\"\" requires -2147483648 ≤ n ∧ n ≤ 2147483647\n      //      ensures  Z32.toZ(result) ≡ n              \"\"\"\n\n  @pure def toZ64(n: Z): Z64 =\n    $ // l\"\"\" requires z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\"\n      //      ensures  Z64.toZ(result) ≡ n                                      \"\"\"\n\n  @pure def toN(n: Z): N =\n    $ // l\"\"\" requires n ≥ 0\n      //      ensures  N.toZ(result) ≡ n \"\"\"\n\n  @pure def toN8(n: Z): N8 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 255\n      //      ensures  N8.toZ(result) ≡ n \"\"\"\n\n  @pure def toN16(n: Z): N16 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 65535\n      //      ensures  N16.toZ(result) ≡ n \"\"\"\n\n  @pure def toN32(n: Z): N32 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"4294967295\"\n      //      ensures  N32.toZ(result) ≡ n      \"\"\"\n\n  @pure def toN64(n: Z): N64 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"18446744073709551615\"\n      //      ensures  N64.toZ(result) ≡ n                 \"\"\"\n\n  @pure def toS8(n: Z): S8 =\n    $ // l\"\"\" requires -128 ≤ n ∧ n ≤ 127\n      //      ensures  S8.toZ(result) ≡ n \"\"\"\n\n  @pure def toS16(n: Z): S16 =\n    $ // l\"\"\" requires -32768 ≤ n ∧ n ≤ 32767\n      //      ensures  S16.toZ(result) ≡ n   \"\"\"\n\n  @pure def toS32(n: Z): S32 =\n    $ // l\"\"\" requires -2147483648 ≤ n ∧ n ≤ 2147483647\n      //      ensures  S32.toZ(result) ≡ n              \"\"\"\n\n  @pure def toS64(n: Z): S64 =\n    $ // l\"\"\" requires z\"-9223372036854775808\" ≤ n ∧ n ≤ z\"9223372036854775807\"\n      //      ensures  S64.toZ(result) ≡ n                                      \"\"\"\n\n  @pure def toU8(n: Z): U8 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 255\n      //      ensures  U8.toZ(result) ≡ n \"\"\"\n\n  @pure def toU16(n: Z): U16 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ 65535\n      //      ensures  U16.toZ(result) ≡ n \"\"\"\n\n  @pure def toU32(n: Z): U32 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"4294967295\"\n      //      ensures  U32.toZ(result) ≡ n       \"\"\"\n\n  @pure def toU64(n: Z): U64 =\n    $ // l\"\"\" requires 0 ≤ n ∧ n ≤ z\"18446744073709551615\"\n      //      ensures  U64.toZ(result) ≡ n                 \"\"\"\n\n  /* @first */\n  @pure def toR(n: Z): R = $\n\n  @pure def toBinary(n: Z): ISZ[U8] = $\n\n  @pure def fromBinary(bin: ISZ[U8]): Z = $\n}\n\n@ext object Z8 {\n\n  @pure def toB(n: Z8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z8\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z8): Z = $\n\n  @pure def toZ8(n: Z8): Z8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ16(n: Z8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: Z8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: Z8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z8): N =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z8): N8 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN16(n: Z8): N16 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: Z8): N32 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z8): N64 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z8): S8 =\n    $ // l\"\"\" ensures S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: Z8): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: Z8): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z8): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z8): U8 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU16(n: Z8): U16 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU32(n: Z8): U32 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z8): U64 =\n    $ // l\"\"\" requires n ≥ z8\"0\"\n      //      ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z8): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z16 {\n\n  @pure def toB(n: Z16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z16\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z16): Z = $\n\n  @pure def toZ8(n: Z16): Z8 =\n    $ // l\"\"\" requires z16\"-128\" ≤ n ∧ n ≤ z16\"127\"\n      //      ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z16): Z16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ32(n: Z16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: Z16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z16): N =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z16): N8 =\n    $ // l\"\"\" requires z16\"0\" ≤ n ∧ n ≤ z16\"255\"\n      //      ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z16): N16 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: Z16): N32 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z16): N64 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z16): S8 =\n    $ // l\"\"\" requires z16\"-128\" ≤ n ∧ n ≤ z16\"127\"\n      //      ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z16): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: Z16): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z16): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z16): U8 =\n    $ // l\"\"\" requires z16\"0\" ≤ n ∧ n ≤ z16\"255\"\n      //      ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z16): U16 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU32(n: Z16): U32 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z16): U64 =\n    $ // l\"\"\" requires n ≥ z16\"0\"\n      //      ensures  U64.toNZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z16): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z32 {\n\n  @pure def toB(n: Z32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z32\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z32): Z = $\n\n  @pure def toZ8(n: Z32): Z8 =\n    $ // l\"\"\" requires z32\"-128\" ≤ n ∧ n ≤ z32\"127\"\n      //      ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z32): Z16 =\n    $ // l\"\"\" requires z32\"-32768\" ≤ n ∧ n ≤ z32\"32767\"\n      //      ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: Z32): Z32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toZ64(n: Z32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: Z32): N =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z32): N8 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"255\"\n      //      ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z32): N16 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"65535\"\n      //      ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: Z32): N32 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: Z32): N64 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z32): S8 =\n    $ // l\"\"\" requires z32\"-128\" ≤ n ∧ n ≤ z32\"127\"\n      //      ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z32): S16 =\n    $ // l\"\"\" requires z32\"-32768\" ≤ n ∧ n ≤ z32\"32767\"\n      //      ensures  S16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toS32(n: Z32): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: Z32): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z32): U8 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"255\"\n      //      ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z32): U16 =\n    $ // l\"\"\" requires z32\"0\" ≤ n ∧ n ≤ z32\"65535\"\n      //      ensures  U16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toU32(n: Z32): U32 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n      //      ensures  U32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU64(n: Z32): U64 =\n    $ // l\"\"\" requires n ≥ z32\"0\"\n         // ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z32): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object Z64 {\n\n  @pure def toB(n: Z64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ z64\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: Z64): Z = $\n\n  @pure def toZ8(n: Z64): Z8 =\n    $ // l\"\"\" requires z64\"-128\" ≤ n ∧ n ≤ z64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: Z64): Z16 =\n    $ // l\"\"\" requires z64\"-32768\" ≤ n ∧ n ≤ z64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: Z64): Z32 =\n    $ // l\"\"\" requires z64\"-2147483648\" ≤ n ∧ n ≤ z64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toZ64(n: Z64): Z64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN(n: Z64): N =\n    $ // l\"\"\" requires n ≥ z64\"0\"\n         // ensures  N.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN8(n: Z64): N8 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: Z64): N16 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: Z64): N32 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"4294967295\"\n         // ensures  N32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toN64(n: Z64): N64 =\n    $ // l\"\"\" ensures N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: Z64): S8 =\n    $ // l\"\"\" requires z64\"-128\" ≤ n ∧ n ≤ z64\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toS16(n: Z64): S16 =\n    $ // l\"\"\" requires z64\"-32768\" ≤ n ∧ n ≤ z64\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toS32(n: Z64): S32 =\n    $ // l\"\"\" requires z64\"-2147483648\" ≤ n ∧ n ≤ z64\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toS64(n: Z64): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: Z64): U8 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"255\"\n         // ensures  U8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU16(n: Z64): U16 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"65535\"\n         // ensures  U16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toU32(n: Z64): U32 =\n    $ // l\"\"\" requires z64\"0\" ≤ n ∧ n ≤ z64\"4294967295\"\n         // ensures  U32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toU64(n: Z64): U64 =\n    $ // l\"\"\" requires z64\"0\" ≤ n\n         // ensures  U64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toR(n: Z64): R =\n    $ // l\"\"\" ensures result ≡ Z.toR(toZ(n)) \"\"\"\n}\n\n@ext object N {\n\n  @pure def toB(n: N): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N): Z = $\n\n  @pure def toZ8(n: N): Z8 =\n    $ // l\"\"\" requires n ≤ n\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N): Z16 =\n    $ // l\"\"\" requires n ≤ n\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N): Z32 =\n    $ // l\"\"\" requires n ≤ n\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N): Z64 =\n    $ // l\"\"\" requires n ≤ n\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN(n: N): N =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN8(n: N): N8 =\n    $ // l\"\"\" requires n ≤ n\"255\"\n         // ensures  N8.toN(result) ≡ n \"\"\"\n\n  @pure def toN16(n: N): N16 =\n    $ // l\"\"\" requires n ≤ n\"65535\"\n         // ensures  N16.toN(result) ≡ n \"\"\"\n\n  @pure def toN32(n: N): N32 =\n    $ // l\"\"\" requires n ≤ n\"4294967295\"\n         // ensures  N32.toN(result) ≡ n \"\"\"\n\n  @pure def toN64(n: N): N64 =\n    $ // l\"\"\" requires n ≤ n\"18446744073709551615\"\n         // ensures  N64.toN(result) ≡ n         \"\"\"\n\n  @pure def toS8(n: N): S8 =\n    $ // l\"\"\" requires n ≤ n\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N): S16 =\n    $ // l\"\"\" requires n ≤ n\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N): S32 =\n    $ // l\"\"\" requires n ≤ n\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N): S64 =\n    $ // l\"\"\" requires n ≤ n\"9223372036854775807\"\n         // ensures  S64.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toU8(n: N): U8 =\n    $ // l\"\"\" requires n ≤ n\"255\"\n         // ensures  U8.toN(result) ≡ n \"\"\"\n\n  @pure def toU16(n: N): U16 =\n    $ // l\"\"\" requires n ≤ n\"65535\"\n         // ensures  U16.toN(result) ≡ n \"\"\"\n\n  @pure def toU32(n: N): U32 =\n    $ // l\"\"\" requires n ≤ n\"4294967295\"\n         // ensures  U32.toN(result) ≡ n \"\"\"\n\n  @pure def toU64(n: N): U64 =\n    $ // l\"\"\" requires n ≤ n\"18446744073709551615\"\n         // ensures  U64.toN(result) ≡ n         \"\"\"\n\n  /* @first */\n  @pure def toR(n: N): R = $\n}\n\n@ext object N8 {\n\n  @pure def toB(n: N8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n8\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N8): Z = $\n\n  @pure def toZ8(n: N8): Z8 =\n    $ // l\"\"\" requires n ≤ n8\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N8): N = $\n\n  @pure def toN8(n: N8): N8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN16(n: N8): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N8): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N8): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N8): S8 =\n    $ // l\"\"\" requires n ≤ n8\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N8): S16 =\n    $ // l\"\"\" ensures S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N8): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N8): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N8): U8 =\n    $ // l\"\"\" ensures U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N8): U16 =\n    $ // l\"\"\" ensures U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N8): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N8): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N8): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N16 {\n\n  @pure def toB(n: N16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n16\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N16): Z = $\n\n  @pure def toZ8(n: N16): Z8 =\n    $ // l\"\"\" requires n ≤ n16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N16): Z16 =\n    $ // l\"\"\" requires n ≤ n16\"32767\"\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #636                // String        // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N16): N = $\n\n  @pure def toN8(n: N16): N8 =\n    $ // l\"\"\" requires n ≤ n16\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N16): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N16): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N16): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N16): S8 =\n    $ // l\"\"\" requires n ≤ n16\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N16): S16 =\n    $ // l\"\"\" requires n ≤ n16\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N16): S32 =\n    $ // l\"\"\" ensures S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N16): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N16): U8 =\n    $ // l\"\"\" requires n ≤ n16\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N16): U16 =\n    $ // l\"\"\" ensures U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N16): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N16): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N16): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N32 {\n\n  @pure def toB(n: N32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n32\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N32): Z = $\n\n  @pure def toZ8(n: N32): Z8 =\n    $ // l\"\"\" requires n ≤ n32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N32): Z16 =\n    $ // l\"\"\" requires n ≤ n32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N32): Z32 =\n    $ // l\"\"\" requires n ≤ n32\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toN(n: N32): N = $\n\n  @pure def toN8(n: N32): N8 =\n    $ // l\"\"\" requires n ≤ n32\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N32): N16 =\n    $ // l\"\"\" requires n ≤ n32\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N32): N32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toN64(n: N32): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toS8(n: N32): S8 =\n    $ // l\"\"\" requires n ≤ n32\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N32): S16 =\n    $ // l\"\"\" requires n ≤ n32\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N32): S32 =\n    $ // l\"\"\" requires n ≤ n32\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N32): S64 =\n    $ // l\"\"\" ensures S64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toU8(n: N32): U8 =\n    $ // l\"\"\" requires n ≤ n32\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N32): U16 =\n    $ // l\"\"\" requires n ≤ n32\"65535\"\n         // ensures  U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N32): U32 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N32): U64 =\n    $ // l\"\"\" ensures U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N32): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object N64 {\n\n  @pure def toB(n: N64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ n64\"0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: N64): Z = $\n\n  @pure def toZ8(n: N64): Z8 =\n    $ // l\"\"\" requires n ≤ n64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: N64): Z16 =\n    $ // l\"\"\" requires n ≤ n64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: N64): Z32 =\n    $ // l\"\"\" requires n ≤ n64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: N64): Z64 =\n    $ // l\"\"\" requires n ≤ n64\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n)     \"\"\"\n\n  /* @first */\n  @pure def toN(n: N64): N = $\n\n  @pure def toN8(n: N64): N8 =\n    $ // l\"\"\" requires n ≤ n64\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: N64): N16 =\n    $ // l\"\"\" requires n ≤ n64\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: N64): N32 =\n    $ // l\"\"\" requires n ≤ n64\"4294967295\"\n         // ensures  N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: N64): N64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toS8(n: N64): S8 =\n    $ // l\"\"\" requires n ≤ n64\"127\"\n         // ensures  S8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS16(n: N64): S16 =\n    $ // l\"\"\" requires n ≤ n64\"32767\"\n         // ensures  S16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS32(n: N64): S32 =\n    $ // l\"\"\" requires n ≤ n64\"2147483647\"\n         // ensures  S32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS64(n: N64): S64 =\n    $ // l\"\"\" requires n ≤ n64\"9223372036854775807\"\n         // ensures  S64.toZ(result) ≡ toZ(n)     \"\"\"\n\n  @pure def toU8(n: N64): U8 =\n    $ // l\"\"\" requires n ≤ n64\"255\"\n         // ensures  U8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU16(n: N64): U16 =\n    $ // l\"\"\" requires n ≤ n64\"65535\"\n         // ensures  U16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU32(n: N64): U32 =\n    $ // l\"\"\" requires n ≤ n64\"4294967295\"\n         // ensures  U32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toU64(n: N64): U64 =\n    $ // l\"\"\" ensures U64.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toR(n: N64): R =\n    $ // l\"\"\" ensures result ≡ N.toR(toN(n)) \"\"\"\n}\n\n@ext object S8 {\n\n  @pure def toB(n: S8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s8\"0\") \"\"\"\n\n  @pure def toZ(n: S8): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s8\"0\")\n//                               (if ((n & s8\"0x01\") ≠ s8\"0x01\") 0 else 0x01) +\n//                               (if ((n & s8\"0x02\") ≠ s8\"0x02\") 0 else 0x02) +\n//                               (if ((n & s8\"0x04\") ≠ s8\"0x04\") 0 else 0x04) +\n//                               (if ((n & s8\"0x08\") ≠ s8\"0x08\") 0 else 0x08) +\n//                               (if ((n & s8\"0x10\") ≠ s8\"0x10\") 0 else 0x10) +\n//                               (if ((n & s8\"0x20\") ≠ s8\"0x20\") 0 else 0x20) +\n//                               (if ((n & s8\"0x40\") ≠ s8\"0x40\") 0 else 0x40)\n//                           else\n//                             -((if ((n & s8\"0x01\") ≡ s8\"0x01\") 0 else 0x01) +\n//                               (if ((n & s8\"0x02\") ≡ s8\"0x02\") 0 else 0x02) +\n//                               (if ((n & s8\"0x04\") ≡ s8\"0x04\") 0 else 0x04) +\n//                               (if ((n & s8\"0x08\") ≡ s8\"0x08\") 0 else 0x08) +\n//                               (if ((n & s8\"0x10\") ≡ s8\"0x10\") 0 else 0x10) +\n//                               (if ((n & s8\"0x20\") ≡ s8\"0x20\") 0 else 0x20) +\n//                               (if ((n & s8\"0x40\") ≡ s8\"0x40\") 0 else 0x40) + 1)) \"\"\"\n\n  @pure def toZ8(n: S8): Z8 =\n    $ // l\"\"\" ensures Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: S8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: S8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S8): N =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  result ≡ (if ((n & s8\"0x01\") ≠ s8\"0x01\") n\"0\" else n\"0x01\") +\n//                           (if ((n & s8\"0x02\") ≠ s8\"0x02\") n\"0\" else n\"0x02\") +\n//                           (if ((n & s8\"0x04\") ≠ s8\"0x04\") n\"0\" else n\"0x04\") +\n//                           (if ((n & s8\"0x08\") ≠ s8\"0x08\") n\"0\" else n\"0x08\") +\n//                           (if ((n & s8\"0x10\") ≠ s8\"0x10\") n\"0\" else n\"0x10\") +\n//                           (if ((n & s8\"0x20\") ≠ s8\"0x20\") n\"0\" else n\"0x20\") +\n//                           (if ((n & s8\"0x40\") ≠ s8\"0x40\") n\"0\" else n\"0x40\")   \"\"\"\n\n  @pure def toN8(n: S8): N8 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN16(n: S8): N16 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: S8): N32 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S8): N64 =\n    $ // l\"\"\" requires n ≥ s8\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toS8(n: S8): S8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S8): S16 = $\n\n  /* @first */\n  @pure def toS32(n: S8): S32 = $\n\n  /* @first */\n  @pure def toS64(n: S8): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S8): U8 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU8(n: S8): U8 = $\n\n  /* @first */\n  @pure def toU16(n: S8): U16 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S8): U32 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S8): U64 =\n    $ // l\"\"\" requires n ≥ s8\"0\" \"\"\"\n}\n\n@ext object S16 {\n\n  @pure def toB(n: S16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s16\"0\") \"\"\"\n\n  @pure def toZ(n: S16): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s16\"0\")\n//                               (if ((n & s16\"0x0001\") ≠ s16\"0x0001\") 0 else 0x0001) +\n//                               (if ((n & s16\"0x0002\") ≠ s16\"0x0002\") 0 else 0x0002) +\n//                               (if ((n & s16\"0x0004\") ≠ s16\"0x0004\") 0 else 0x0004) +\n//                               (if ((n & s16\"0x0008\") ≠ s16\"0x0008\") 0 else 0x0008) +\n//                               (if ((n & s16\"0x0010\") ≠ s16\"0x0010\") 0 else 0x0010) +\n//                               (if ((n & s16\"0x0020\") ≠ s16\"0x0020\") 0 else 0x0020) +\n//                               (if ((n & s16\"0x0040\") ≠ s16\"0x0040\") 0 else 0x0040) +\n//                               (if ((n & s16\"0x0080\") ≠ s16\"0x0080\") 0 else 0x0080) +\n//                               (if ((n & s16\"0x0100\") ≠ s16\"0x0100\") 0 else 0x0100) +\n//                               (if ((n & s16\"0x0200\") ≠ s16\"0x0200\") 0 else 0x0200) +\n//                               (if ((n & s16\"0x0400\") ≠ s16\"0x0400\") 0 else 0x0400) +\n//                               (if ((n & s16\"0x0800\") ≠ s16\"0x0800\") 0 else 0x0800) +\n//                               (if ((n & s16\"0x1000\") ≠ s16\"0x1000\") 0 else 0x1000) +\n//                               (if ((n & s16\"0x2000\") ≠ s16\"0x2000\") 0 else 0x2000) +\n//                               (if ((n & s16\"0x4000\") ≠ s16\"0x4000\") 0 else 0x4000)\n//                           else\n//                             -((if ((n & s16\"0x0001\") ≡ s16\"0x0001\") 0 else 0x0001) +\n//                               (if ((n & s16\"0x0002\") ≡ s16\"0x0002\") 0 else 0x0002) +\n//                               (if ((n & s16\"0x0004\") ≡ s16\"0x0004\") 0 else 0x0004) +\n//                               (if ((n & s16\"0x0008\") ≡ s16\"0x0008\") 0 else 0x0008) +\n//                               (if ((n & s16\"0x0010\") ≡ s16\"0x0010\") 0 else 0x0010) +\n//                               (if ((n & s16\"0x0020\") ≡ s16\"0x0020\") 0 else 0x0020) +\n//                               (if ((n & s16\"0x0040\") ≡ s16\"0x0040\") 0 else 0x0040) +\n//                               (if ((n & s16\"0x0080\") ≡ s16\"0x0080\") 0 else 0x0080) +\n//                               (if ((n & s16\"0x0100\") ≡ s16\"0x0100\") 0 else 0x0100) +\n//                               (if ((n & s16\"0x0200\") ≡ s16\"0x0200\") 0 else 0x0200) +\n//                               (if ((n & s16\"0x0400\") ≡ s16\"0x0400\") 0 else 0x0400) +\n//                               (if ((n & s16\"0x0800\") ≡ s16\"0x0800\") 0 else 0x0800) +\n//                               (if ((n & s16\"0x1000\") ≡ s16\"0x1000\") 0 else 0x1000) +\n//                               (if ((n & s16\"0x2000\") ≡ s16\"0x2000\") 0 else 0x2000) +\n//                               (if ((n & s16\"0x4000\") ≡ s16\"0x4000\") 0 else 0x4000) + 1)) \"\"\"\n\n  @pure def toZ8(n: S16): Z8 =\n    $ // l\"\"\" requires s16\"-128\" ≤ n ∧ n ≤ s16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S16): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: S16): Z32 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S16): Z64 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S16): N =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  result ≡ (if ((n & s16\"0x0001\") ≠ s16\"0x0001\") n\"0\" else n\"0x0001\") +\n//                           (if ((n & s16\"0x0002\") ≠ s16\"0x0002\") n\"0\" else n\"0x0002\") +\n//                           (if ((n & s16\"0x0004\") ≠ s16\"0x0004\") n\"0\" else n\"0x0004\") +\n//                           (if ((n & s16\"0x0008\") ≠ s16\"0x0008\") n\"0\" else n\"0x0008\") +\n//                           (if ((n & s16\"0x0010\") ≠ s16\"0x0010\") n\"0\" else n\"0x0010\") +\n//                           (if ((n & s16\"0x0020\") ≠ s16\"0x0020\") n\"0\" else n\"0x0020\") +\n//                           (if ((n & s16\"0x0040\") ≠ s16\"0x0040\") n\"0\" else n\"0x0040\") +\n//                           (if ((n & s16\"0x0080\") ≠ s16\"0x0080\") n\"0\" else n\"0x0080\") +\n//                           (if ((n & s16\"0x0100\") ≠ s16\"0x0100\") n\"0\" else n\"0x0100\") +\n//                           (if ((n & s16\"0x0200\") ≠ s16\"0x0200\") n\"0\" else n\"0x0200\") +\n//                           (if ((n & s16\"0x0400\") ≠ s16\"0x0400\") n\"0\" else n\"0x0400\") +\n//                           (if ((n & s16\"0x0800\") ≠ s16\"0x0800\") n\"0\" else n\"0x0800\") +\n//                           (if ((n & s16\"0x1000\") ≠ s16\"0x1000\") n\"0\" else n\"0x1000\") +\n//                           (if ((n & s16\"0x2000\") ≠ s16\"0x2000\") n\"0\" else n\"0x2000\") +\n//                           (if ((n & s16\"0x4000\") ≠ s16\"0x4000\") n\"0\" else n\"0x4000\")   \"\"\"\n\n  @pure def toN8(n: S16): N8 =\n    $ // l\"\"\" requires s16\"0\" ≤ n ∧ n ≤ s16\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S16): N16 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN32(n: S16): N32 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S16): N64 =\n    $ // l\"\"\" requires n ≥ s16\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S16): S8 =\n    $ // l\"\"\" requires s16\"-128\" ≤ n ∧ n ≤ s16\"127\" \"\"\"\n\n  @pure def toS16(n: S16): S16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS32(n: S16): S32 = $\n\n  /* @first */\n  @pure def toS64(n: S16): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S16): U8 =\n    $ // l\"\"\" requires s16\"0\" ≤ n ∧ n ≤ s16\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S16): U16 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU16(n: S16): U16 = $\n\n  /* @first */\n  @pure def toU32(n: S16): U32 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S16): U64 =\n    $ // l\"\"\" requires n ≥ s16\"0\" \"\"\"\n}\n\n@ext object S32 {\n\n  @pure def toB(n: S32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s32\"0\") \"\"\"\n\n  @pure def toZ(n: S32): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s32\"0\")\n//                               (if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                               (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                               (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                               (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                               (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                               (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                               (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                               (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                               (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                               (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                               (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                               (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                               (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                               (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                               (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                               (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                               (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                               (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//                               (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                               (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                               (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                               (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                               (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                               (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                               (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                               (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                               (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                               (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                               (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                               (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                               (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000)\n//                           else\n//                             -((if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                               (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                               (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                               (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                               (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                               (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                               (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                               (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                               (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                               (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                               (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                               (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                               (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                               (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                               (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                               (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                               (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                               (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f2$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #638                // String          (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                               (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                               (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                               (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                               (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                               (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                               (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                               (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                               (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                               (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                               (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                               (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                               (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000) + 1)) \"\"\"\n\n  @pure def toZ8(n: S32): Z8 =\n    $ // l\"\"\" requires s32\"-128\" ≤ n ∧ n ≤ s32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S32): Z16 =\n    $ // l\"\"\" requires s32\"-32768\" ≤ n ∧ n ≤ s32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: S32): Z32 =\n    $ // l\"\"\" ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: S32): Z64 =\n    $ // l\"\"\" ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S32): N =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  result ≡ (if ((n & s32\"0x00000001\") ≠ s32\"0x00000001\") 0 else 0x00000001) +\n//                           (if ((n & s32\"0x00000002\") ≠ s32\"0x00000002\") 0 else 0x00000002) +\n//                           (if ((n & s32\"0x00000004\") ≠ s32\"0x00000004\") 0 else 0x00000004) +\n//                           (if ((n & s32\"0x00000008\") ≠ s32\"0x00000008\") 0 else 0x00000008) +\n//                           (if ((n & s32\"0x00000010\") ≠ s32\"0x00000010\") 0 else 0x00000010) +\n//                           (if ((n & s32\"0x00000020\") ≠ s32\"0x00000020\") 0 else 0x00000020) +\n//                           (if ((n & s32\"0x00000040\") ≠ s32\"0x00000040\") 0 else 0x00000040) +\n//                           (if ((n & s32\"0x00000080\") ≠ s32\"0x00000080\") 0 else 0x00000080) +\n//                           (if ((n & s32\"0x00000100\") ≠ s32\"0x00000100\") 0 else 0x00000100) +\n//                           (if ((n & s32\"0x00000200\") ≠ s32\"0x00000200\") 0 else 0x00000200) +\n//                           (if ((n & s32\"0x00000400\") ≠ s32\"0x00000400\") 0 else 0x00000400) +\n//                           (if ((n & s32\"0x00000800\") ≠ s32\"0x00000800\") 0 else 0x00000800) +\n//                           (if ((n & s32\"0x00001000\") ≠ s32\"0x00001000\") 0 else 0x00001000) +\n//                           (if ((n & s32\"0x00002000\") ≠ s32\"0x00002000\") 0 else 0x00002000) +\n//                           (if ((n & s32\"0x00004000\") ≠ s32\"0x00004000\") 0 else 0x00004000) +\n//                           (if ((n & s32\"0x00008000\") ≠ s32\"0x00008000\") 0 else 0x00008000) +\n//                           (if ((n & s32\"0x00010000\") ≠ s32\"0x00010000\") 0 else 0x00010000) +\n//                           (if ((n & s32\"0x00020000\") ≠ s32\"0x00020000\") 0 else 0x00020000) +\n//                           (if ((n & s32\"0x00040000\") ≠ s32\"0x00040000\") 0 else 0x00040000) +\n//                           (if ((n & s32\"0x00080000\") ≠ s32\"0x00080000\") 0 else 0x00080000) +\n//                           (if ((n & s32\"0x00100000\") ≠ s32\"0x00100000\") 0 else 0x00100000) +\n//                           (if ((n & s32\"0x00200000\") ≠ s32\"0x00200000\") 0 else 0x00200000) +\n//                           (if ((n & s32\"0x00400000\") ≠ s32\"0x00400000\") 0 else 0x00400000) +\n//                           (if ((n & s32\"0x00800000\") ≠ s32\"0x00800000\") 0 else 0x00800000) +\n//                           (if ((n & s32\"0x01000000\") ≠ s32\"0x01000000\") 0 else 0x01000000) +\n//                           (if ((n & s32\"0x02000000\") ≠ s32\"0x02000000\") 0 else 0x02000000) +\n//                           (if ((n & s32\"0x04000000\") ≠ s32\"0x04000000\") 0 else 0x04000000) +\n//                           (if ((n & s32\"0x08000000\") ≠ s32\"0x08000000\") 0 else 0x08000000) +\n//                           (if ((n & s32\"0x10000000\") ≠ s32\"0x10000000\") 0 else 0x10000000) +\n//                           (if ((n & s32\"0x20000000\") ≠ s32\"0x20000000\") 0 else 0x20000000) +\n//                           (if ((n & s32\"0x40000000\") ≠ s32\"0x40000000\") 0 else 0x40000000)   \"\"\"\n\n  @pure def toN8(n: S32): N8 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S32): N16 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: S32): N32 =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  N32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN64(n: S32): N64 =\n    $ // l\"\"\" requires n ≥ s32\"0\"\n         // ensures  N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S32): S8 =\n    $ // l\"\"\" requires s32\"-128\" ≤ n ∧ n ≤ s32\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S32): S16 =\n    $ // l\"\"\" requires s32\"-32768\" ≤ n ∧ n ≤ s32\"32767\" \"\"\"\n\n  @pure def toS32(n: S32): S32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toS64(n: S32): S64 = $\n\n  /* @first */\n  @pure def toU8(n: S32): U8 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S32): U16 =\n    $ // l\"\"\" requires s32\"0\" ≤ n ∧ n ≤ s32\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S32): U32 =\n    $ // l\"\"\" requires n ≥ s32\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU32(n: S32): U32 = $\n\n  /* @first */\n  @pure def toU64(n: S32): U64 =\n    $ // l\"\"\" requires n ≥ s32\"0\" \"\"\"\n}\n\n@ext object S64 {\n\n  @pure def toB(n: S64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ s64\"0\") \"\"\"\n\n  @pure def toZ(n: S64): Z =\n    $ // l\"\"\" ensures result ≡ (if (n ≥ s64\"0\")\n//                               (if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                               (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                               (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                               (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                               (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                               (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                               (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                               (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                               (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                               (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                               (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                               (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                               (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                               (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                               (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                               (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                               (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                               (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                               (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                               (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                               (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                               (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                               (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                               (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                               (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                               (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                               (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                               (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                               (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                               (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                               (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                               (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                               (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                               (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                               (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                               (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                               (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                               (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                               (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                               (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                               (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                               (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                               (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                               (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                               (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                               (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                               (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                               (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                               (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                               (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                               (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                               (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                               (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                               (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                               (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                               (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                               (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                               (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                               (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                               (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                               (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                               (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                               (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)\n//                           else\n//                             -((if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                               (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                               (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                               (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                               (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                               (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                               (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                               (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                               (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                               (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                               (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                               (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                               (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                               (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                               (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                               (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                               (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                               (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                               (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                               (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                               (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                               (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                               (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                               (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                               (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                               (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                               (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                               (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                               (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                               (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                               (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                               (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                               (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                               (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                               (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                               (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                               (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                               (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                               (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                               (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                               (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                               (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                               (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                               (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                               (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                               (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                               (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x000
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f3$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #640                // String 0400000000000l) +\n//                               (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                               (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                               (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                               (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                               (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                               (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                               (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                               (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                               (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                               (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                               (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                               (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                               (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                               (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                               (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                               (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)) + 1) \"\"\"\n\n  @pure def toZ8(n: S64): Z8 =\n    $ // l\"\"\" requires s64\"-128\" ≤ n ∧ n ≤ s64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n)      \"\"\"\n\n  @pure def toZ16(n: S64): Z16 =\n    $ // l\"\"\" requires s64\"-32768\" ≤ n ∧ n ≤ s64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toZ32(n: S64): Z32 =\n    $ // l\"\"\" requires s64\"-2147483648\" ≤ n ∧ n ≤ s64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n)                   \"\"\"\n\n  @pure def toZ64(n: S64): Z64 =\n    $ // l\"\"\" ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: S64): N =\n    $ // l\"\"\" requires n ≥ s64\"0\"\n         // ensures  result ≡ (if ((n & s64\"0x0000000000000001\") ≠ s64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                           (if ((n & s64\"0x0000000000000002\") ≠ s64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                           (if ((n & s64\"0x0000000000000004\") ≠ s64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                           (if ((n & s64\"0x0000000000000008\") ≠ s64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                           (if ((n & s64\"0x0000000000000010\") ≠ s64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                           (if ((n & s64\"0x0000000000000020\") ≠ s64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                           (if ((n & s64\"0x0000000000000040\") ≠ s64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                           (if ((n & s64\"0x0000000000000080\") ≠ s64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                           (if ((n & s64\"0x0000000000000100\") ≠ s64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                           (if ((n & s64\"0x0000000000000200\") ≠ s64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                           (if ((n & s64\"0x0000000000000400\") ≠ s64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                           (if ((n & s64\"0x0000000000000800\") ≠ s64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                           (if ((n & s64\"0x0000000000001000\") ≠ s64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                           (if ((n & s64\"0x0000000000002000\") ≠ s64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                           (if ((n & s64\"0x0000000000004000\") ≠ s64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                           (if ((n & s64\"0x0000000000008000\") ≠ s64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                           (if ((n & s64\"0x0000000000010000\") ≠ s64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                           (if ((n & s64\"0x0000000000020000\") ≠ s64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                           (if ((n & s64\"0x0000000000040000\") ≠ s64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                           (if ((n & s64\"0x0000000000080000\") ≠ s64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                           (if ((n & s64\"0x0000000000100000\") ≠ s64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                           (if ((n & s64\"0x0000000000200000\") ≠ s64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                           (if ((n & s64\"0x0000000000400000\") ≠ s64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                           (if ((n & s64\"0x0000000000800000\") ≠ s64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                           (if ((n & s64\"0x0000000001000000\") ≠ s64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                           (if ((n & s64\"0x0000000002000000\") ≠ s64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                           (if ((n & s64\"0x0000000004000000\") ≠ s64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                           (if ((n & s64\"0x0000000008000000\") ≠ s64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                           (if ((n & s64\"0x0000000010000000\") ≠ s64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                           (if ((n & s64\"0x0000000020000000\") ≠ s64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                           (if ((n & s64\"0x0000000040000000\") ≠ s64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                           (if ((n & s64\"0x0000000080000000\") ≠ s64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                           (if ((n & s64\"0x0000000100000000\") ≠ s64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                           (if ((n & s64\"0x0000000200000000\") ≠ s64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                           (if ((n & s64\"0x0000000400000000\") ≠ s64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                           (if ((n & s64\"0x0000000800000000\") ≠ s64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                           (if ((n & s64\"0x0000001000000000\") ≠ s64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                           (if ((n & s64\"0x0000002000000000\") ≠ s64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                           (if ((n & s64\"0x0000004000000000\") ≠ s64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                           (if ((n & s64\"0x0000008000000000\") ≠ s64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                           (if ((n & s64\"0x0000010000000000\") ≠ s64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                           (if ((n & s64\"0x0000020000000000\") ≠ s64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                           (if ((n & s64\"0x0000040000000000\") ≠ s64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                           (if ((n & s64\"0x0000080000000000\") ≠ s64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                           (if ((n & s64\"0x0000100000000000\") ≠ s64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                           (if ((n & s64\"0x0000200000000000\") ≠ s64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                           (if ((n & s64\"0x0000400000000000\") ≠ s64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                           (if ((n & s64\"0x0000800000000000\") ≠ s64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                           (if ((n & s64\"0x0001000000000000\") ≠ s64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                           (if ((n & s64\"0x0002000000000000\") ≠ s64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                           (if ((n & s64\"0x0004000000000000\") ≠ s64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                           (if ((n & s64\"0x0008000000000000\") ≠ s64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                           (if ((n & s64\"0x0010000000000000\") ≠ s64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                           (if ((n & s64\"0x0020000000000000\") ≠ s64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                           (if ((n & s64\"0x0040000000000000\") ≠ s64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                           (if ((n & s64\"0x0080000000000000\") ≠ s64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                           (if ((n & s64\"0x0100000000000000\") ≠ s64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                           (if ((n & s64\"0x0200000000000000\") ≠ s64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                           (if ((n & s64\"0x0400000000000000\") ≠ s64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                           (if ((n & s64\"0x0800000000000000\") ≠ s64\"0x0800000000000000\") 0 else 0x0800000000000000l) +\n//                           (if ((n & s64\"0x1000000000000000\") ≠ s64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                           (if ((n & s64\"0x2000000000000000\") ≠ s64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                           (if ((n & s64\"0x4000000000000000\") ≠ s64\"0x4000000000000000\") 0 else 0x4000000000000000l)   \"\"\"\n\n  @pure def toN8(n: S64): N8 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"255\"\n         // ensures  N8.toZ(result) ≡ toZ(n)   \"\"\"\n\n  @pure def toN16(n: S64): N16 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"65535\"\n         // ensures  N16.toZ(result) ≡ toZ(n)    \"\"\"\n\n  @pure def toN32(n: S64): N32 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"4294967295\"\n         // ensures  N32.toZ(result) ≡ toZ(n)         \"\"\"\n\n  @pure def toN64(n: S64): N64 =\n    $ // l\"\"\" ensures N64.toZ(result) ≡ toZ(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: S64): S8 =\n    $ // l\"\"\" requires s64\"-128\" ≤ n ∧ n ≤ s64\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: S64): S16 =\n    $ // l\"\"\" requires s64\"-32768\" ≤ n ∧ n ≤ s64\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: S64): S32 =\n    $ // l\"\"\" requires s64\"-2147483648\" ≤ n ∧ n ≤ s64\"2147483647\" \"\"\"\n\n  @pure def toS64(n: S64): S64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU8(n: S64): U8 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: S64): U16 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: S64): U32 =\n    $ // l\"\"\" requires s64\"0\" ≤ n ∧ n ≤ s64\"4294967295\" \"\"\"\n\n  /* @first */\n  @pure def toU64(n: S64): U64 =\n    $ // l\"\"\" requires n ≥ s64\"0\" \"\"\"\n\n  /* @first */\n  @pure def toRawU64(n: S64): U64 = $\n}\n\n@ext object U1 {\n  @pure def toU8(n: U1): U8 = $\n  @pure def toU16(n: U1): U16 = $\n  @pure def toU32(n: U1): U32 = $\n  @pure def toU64(n: U1): U64 = $\n}\n\n@ext object U2 {\n  @pure def toU8(n: U2): U8 = $\n  @pure def toU16(n: U2): U16 = $\n  @pure def toU32(n: U2): U32 = $\n  @pure def toU64(n: U2): U64 = $\n}\n\n@ext object U3 {\n  @pure def toU8(n: U3): U8 = $\n  @pure def toU16(n: U3): U16 = $\n  @pure def toU32(n: U3): U32 = $\n  @pure def toU64(n: U3): U64 = $\n}\n\n@ext object U4 {\n  @pure def toU8(n: U4): U8 = $\n  @pure def toU16(n: U4): U16 = $\n  @pure def toU32(n: U4): U32 = $\n  @pure def toU64(n: U4): U64 = $\n}\n\n@ext object U5 {\n  @pure def toU8(n: U5): U8 = $\n  @pure def toU16(n: U5): U16 = $\n  @pure def toU32(n: U5): U32 = $\n  @pure def toU64(n: U5): U64 = $\n}\n\n@ext object U6 {\n  @pure def toU8(n: U6): U8 = $\n  @pure def toU16(n: U6): U16 = $\n  @pure def toU32(n: U6): U32 = $\n  @pure def toU64(n: U6): U64 = $\n}\n\n@ext object U7 {\n  @pure def toU8(n: U7): U8 = $\n  @pure def toU16(n: U7): U16 = $\n  @pure def toU32(n: U7): U32 = $\n  @pure def toU64(n: U7): U64 = $\n}\n\n@ext object U8 {\n\n  @pure def toB(n: U8): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u8\"0\") \"\"\"\n\n  @pure def toZ(n: U8): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u8\"0x01\") ≠ u8\"0x01\") 0 else 0x01) +\n//                          (if ((n & u8\"0x02\") ≠ u8\"0x02\") 0 else 0x02) +\n//                          (if ((n & u8\"0x04\") ≠ u8\"0x04\") 0 else 0x04) +\n//                          (if ((n & u8\"0x08\") ≠ u8\"0x08\") 0 else 0x08) +\n//                          (if ((n & u8\"0x10\") ≠ u8\"0x10\") 0 else 0x10) +\n//                          (if ((n & u8\"0x20\") ≠ u8\"0x20\") 0 else 0x20) +\n//                          (if ((n & u8\"0x40\") ≠ u8\"0x40\") 0 else 0x40) +\n//                          (if ((n & u8\"0x80\") ≠ u8\"0x80\") 0 else 0x80)   \"\"\"\n\n  @pure def toZ8(n: U8): Z8 =\n    $ // l\"\"\" requires n ≤ u8\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U8): Z16 =\n    $ // l\"\"\" ensures Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U8): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U8): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U8): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u8\"0x01\") ≠ u8\"0x01\") n\"0\" else n\"0x01\") +\n//                          (if ((n & u8\"0x02\") ≠ u8\"0x02\") n\"0\" else n\"0x02\") +\n//                          (if ((n & u8\"0x04\") ≠ u8\"0x04\") n\"0\" else n\"0x04\") +\n//                          (if ((n & u8\"0x08\") ≠ u8\"0x08\") n\"0\" else n\"0x08\") +\n//                          (if ((n & u8\"0x10\") ≠ u8\"0x10\") n\"0\" else n\"0x10\") +\n//                          (if ((n & u8\"0x20\") ≠ u8\"0x20\") n\"0\" else n\"0x20\") +\n//                          (if ((n & u8\"0x40\") ≠ u8\"0x40\") n\"0\" else n\"0x40\") +\n//                          (if ((n & u8\"0x80\") ≠ u8\"0x80\") n\"0\" else n\"0x80\")   \"\"\"\n\n  @pure def toN8(n: U8): N8 =\n    $ // l\"\"\" requires n ≤ u8\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U8): N16 =\n    $ // l\"\"\" ensures N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U8): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U8): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U8): S8 =\n    $ // l\"\"\" requires n ≤ u8\"127\" \"\"\"\n\n  /* @first */\n  @pure def toRawS8(n: U8): S8 = $\n\n  /* @first */\n  @pure def toS16(n: U8): S16 = $\n\n  /* @first */\n  @pure def toS32(n: U8): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U8): S64 = $\n\n  @pure def toU1(n: U8): U1 = $\n\n  @pure def toU2(n: U8): U2 = $\n\n  @pure def toU3(n: U8): U3 = $\n\n  @pure def toU4(n: U8): U4 = $\n\n  @pure def toU5(n: U8): U5 = $\n\n  @pure def toU6(n: U8): U6 = $\n\n  @pure def toU7(n: U8): U7 = $\n\n  @pure def toU8(n: U8): U8 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U8): U16 = $\n\n  /* @first */\n  @pure def toU32(n: U8): U32 = $\n\n  /* @first */\n  @pure def toU64(n: U8): U64 = $\n}\n\n@ext object U9 {\n  @pure def toU16(n: U9): U16 = $\n  @pure def toU32(n: U9): U32 = $\n  @pure def toU64(n: U9): U64 = $\n}\n\n@ext object U10 {\n  @pure def toU16(n: U10): U16 = $\n  @pure def toU32(n: U10): U32 = $\n  @pure def toU64(n: U10): U64 = $\n}\n\n@ext object U11 {\n  @pure def toU16(n: U11): U16 = $\n  @pure def toU32(n: U11): U32 = $\n  @pure def toU64(n: U11): U64 = $\n}\n\n@ext object U12 {\n  @pure def toU16(n: U12): U16 = $\n  @pure def toU32(n: U12): U32 = $\n  @pure def toU64(n: U12): U64 = $\n}\n\n@ext object U13 {\n  @pure def toU16(n: U13): U16 = $\n  @pure def toU32(n: U13): U32 = $\n  @pure def toU64(n: U13): U64 = $\n}\n\n@ext object U14 {\n  @pure def toU16(n: U14): U16 = $\n  @pure def toU32(n: U14): U32 = $\n  @pure def toU64(n: U14): U64 = $\n}\n\n@ext object U15 {\n  @pure def toU16(n: U15): U16 = $\n  @pure def toU32(n: U15): U32 = $\n  @pure def toU64(n: U15): U64 = $\n}\n\n@ext object U16 {\n\n  @pure def toB(n: U16): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u16\"0\") \"\"\"\n\n  @pure def toZ(n: U16): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u16\"0x0001\") ≠ u16\"0x0001\") 0 else 0x0001) +\n//                          (if ((n & u16\"0x0002\") ≠ u16\"0x0002\") 0 else 0x0002) +\n//                          (if ((n & u16\"0x0004\") ≠ u16\"0x0004\") 0 else 0x0004) +\n//                          (if ((n & u16\"0x0008\") ≠ u16\"0x0008\") 0 else 0x0008) +\n//                          (if ((n & u16\"0x0010\") ≠ u16\"0x0010\") 0 else 0x0010) +\n//                          (if ((n & u16\"0x0020\") ≠ u16\"0x0020\") 0 else 0x0020) +\n//                          (if ((n & u16\"0x0040\") ≠ u16\"0x0040\") 0 else 0x0040) +\n//                          (if ((n & u16\"0x0080\") ≠ u16\"0x0080\") 0 else 0x0080) +\n//                          (if ((n & u16\"0x0100\") ≠ u16\"0x0100\") 0 else 0x0100) +\n//                          (if ((n & u16\"0x0200\") ≠ u16\"0x0200\") 0 else 0x0200) +\n//                          (if ((n & u16\"0x0400\") ≠ u16\"0x0400\") 0 else 0x0400) +\n//                          (if ((n & u16\"0x0800\") ≠ u16\"0x0800\") 0 else 0x0800) +\n//                          (if ((n & u16\"0x1000\") ≠ u16\"0x1000\") 0 else 0x1000) +\n//                          (if ((n & u16\"0x2000\") ≠ u16\"0x2000\") 0 else 0x2000) +\n//                          (if ((n & u16\"0x4000\") ≠ u16\"0x4000\") 0 else 0x4000) +\n//                          (if ((n & u16\"0x8000\") ≠ u16\"0x8000\") 0 else 0x8000)   \"\"\"\n\n  @pure def toZ8(n: U16): Z8 =\n    $ // l\"\"\" requires n ≤ u16\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U16): Z16 =\n    $ // l\"\"\" requires n ≤ u16\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U16): Z32 =\n    $ // l\"\"\" ensures Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U16): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U16): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u16\"0x0001\") ≠ u16\"0x0001\") n\"0\" else n\"0x0001\") +\n//                          (if ((n & u16\"0x0002\") ≠ u16\"0x0002\") n\"0\" else n\"0x0002\") +\n//                          (if ((n & u16\"0x0004\") ≠ u16\"0x0004\") n\"0\" else n\"0x0004\") +\n//                          (if ((n & u16\"0x0008\") ≠ u16\"0x0008\") n\"0\" else n\"0x0008\") +\n//                          (if ((n & u16\"0x0010\") ≠ u16\"0x0010\") n\"0\" else n\"0x0010\") +\n//                          (if ((n & u16\"0x0020\") ≠ u16\"0x0020\") n\"0\" else n\"0x0020\") +\n//                          (if ((n & u16\"0x0040\") ≠ u16\"0x0040\") n\"0\" else n\"0x0040\") +\n//                          (if ((n & u16\"0x0080\") ≠ u16\"0x0080\") n\"0\" else n\"0x0080\") +\n//                          (if ((n & u16\"0x0100\") ≠ u16\"0x0100\") n\"0\" else n\"0x0100\") +\n//                          (if ((n & u16\"0x0200\") ≠ u16\"0x0200\") n\"0\" else n\"0x0200\") +\n//                          (if ((n & u16\"0x0400\") ≠ u16\"0x0400\") n\"0\" else n\"0x0400\") +\n//                          (if ((n & u16\"0x0800\") ≠ u16\"0x0800\") n\"0\" else n\"0x0800\") +\n//                          (if ((n & u16\"0x1000\") ≠ u16\"0x1000\") n\"0\" else n\"0x1000\") +\n//                          (if ((n & u16\"0x2000\") ≠ u16\"0x2000\") n\"0\" else n\"0x2000\") +\n//                          (if ((n & u16\"0x4000\") ≠ u16\"0x4000\") n\"0\" else n\"0x4000\") +\n//                          (if ((n & u16\"0x8000\") ≠ u16\"0x8000\") n\"0\" else n\"0x8000\")   \"\"\"\n\n  @pure def toN8(n: U16): N8 =\n    $ // l\"\"\" requires n ≤ u16\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U16): N16 =\n    $ // l\"\"\" requires n ≤ u16\"65535\"\n         // ensures
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f4$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #642                // String   N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U16): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U16): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U16): S8 =\n    $ // l\"\"\" requires n ≤ u16\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U16): S16 =\n    $ // l\"\"\" requires n ≤ u16\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toRawS16(n: U16): S16 = $\n\n  /* @first */\n  @pure def toS32(n: U16): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U16): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U16): U8 = $\n\n  @pure def toU9(n: U16): U9 = $\n\n  @pure def toU10(n: U16): U10 = $\n\n  @pure def toU11(n: U16): U11 = $\n\n  @pure def toU12(n: U16): U12 = $\n\n  @pure def toU13(n: U16): U13 = $\n\n  @pure def toU14(n: U16): U14 = $\n\n  @pure def toU15(n: U16): U15 = $\n\n  @pure def toU16(n: U16): U16 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU32(n: U16): U32 = $\n\n  /* @first */\n  @pure def toU64(n: U16): U64 = $\n}\n\n@ext object U17 {\n  @pure def toU32(n: U17): U32 = $\n  @pure def toU64(n: U17): U64 = $\n}\n\n@ext object U18 {\n  @pure def toU32(n: U18): U32 = $\n  @pure def toU64(n: U18): U64 = $\n}\n\n@ext object U19 {\n  @pure def toU32(n: U19): U32 = $\n  @pure def toU64(n: U19): U64 = $\n}\n\n@ext object U20 {\n  @pure def toU32(n: U20): U32 = $\n  @pure def toU64(n: U20): U64 = $\n}\n\n@ext object U21 {\n  @pure def toU32(n: U21): U32 = $\n  @pure def toU64(n: U21): U64 = $\n}\n\n@ext object U22 {\n  @pure def toU32(n: U22): U32 = $\n  @pure def toU64(n: U22): U64 = $\n}\n\n@ext object U23 {\n  @pure def toU32(n: U23): U32 = $\n  @pure def toU64(n: U23): U64 = $\n}\n\n@ext object U24 {\n  @pure def toU32(n: U24): U32 = $\n  @pure def toU64(n: U24): U64 = $\n}\n\n@ext object U25 {\n  @pure def toU32(n: U25): U32 = $\n  @pure def toU64(n: U25): U64 = $\n}\n\n@ext object U26 {\n  @pure def toU32(n: U26): U32 = $\n  @pure def toU64(n: U26): U64 = $\n}\n\n@ext object U27 {\n  @pure def toU32(n: U27): U32 = $\n  @pure def toU64(n: U27): U64 = $\n}\n\n@ext object U28 {\n  @pure def toU32(n: U28): U32 = $\n  @pure def toU64(n: U28): U64 = $\n}\n\n@ext object U29 {\n  @pure def toU32(n: U29): U32 = $\n  @pure def toU64(n: U29): U64 = $\n}\n\n@ext object U30 {\n  @pure def toU32(n: U30): U32 = $\n  @pure def toU64(n: U30): U64 = $\n}\n\n@ext object U31 {\n  @pure def toU32(n: U31): U32 = $\n  @pure def toU64(n: U31): U64 = $\n}\n\n@ext object U32 {\n\n  @pure def toB(n: U32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u32\"0\") \"\"\"\n\n  @pure def toZ(n: U32): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") 0 else 0x00000001) +\n//                          (if ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") 0 else 0x00000002) +\n//                          (if ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") 0 else 0x00000004) +\n//                          (if ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") 0 else 0x00000008) +\n//                          (if ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") 0 else 0x00000010) +\n//                          (if ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") 0 else 0x00000020) +\n//                          (if ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") 0 else 0x00000040) +\n//                          (if ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") 0 else 0x00000080) +\n//                          (if ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") 0 else 0x00000100) +\n//                          (if ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") 0 else 0x00000200) +\n//                          (if ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") 0 else 0x00000400) +\n//                          (if ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") 0 else 0x00000800) +\n//                          (if ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") 0 else 0x00001000) +\n//                          (if ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") 0 else 0x00002000) +\n//                          (if ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") 0 else 0x00004000) +\n//                          (if ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") 0 else 0x00008000) +\n//                          (if ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") 0 else 0x00010000) +\n//                          (if ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") 0 else 0x00020000) +\n//                          (if ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") 0 else 0x00040000) +\n//                          (if ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") 0 else 0x00080000) +\n//                          (if ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") 0 else 0x00100000) +\n//                          (if ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") 0 else 0x00200000) +\n//                          (if ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") 0 else 0x00400000) +\n//                          (if ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") 0 else 0x00800000) +\n//                          (if ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") 0 else 0x01000000) +\n//                          (if ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") 0 else 0x02000000) +\n//                          (if ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") 0 else 0x04000000) +\n//                          (if ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") 0 else 0x08000000) +\n//                          (if ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") 0 else 0x10000000) +\n//                          (if ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") 0 else 0x20000000) +\n//                          (if ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") 0 else 0x40000000) +\n//                          (if ((n & u32\"0x80000000\") ≠ u32\"0x80000000\") 0 else 0x80000000)   \"\"\"\n\n  @pure def toZ8(n: U32): Z8 =\n    $ // l\"\"\" requires n ≤ u32\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U32): Z16 =\n    $ // l\"\"\" requires n ≤ u32\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U32): Z32 =\n    $ // l\"\"\" requires n ≤ u32\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U32): Z64 =\n    $ // l\"\"\" ensures Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U32): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") n\"0\" else n\"0x00000001\") +\n//                          (if ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") n\"0\" else n\"0x00000002\") +\n//                          (if ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") n\"0\" else n\"0x00000004\") +\n//                          (if ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") n\"0\" else n\"0x00000008\") +\n//                          (if ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") n\"0\" else n\"0x00000010\") +\n//                          (if ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") n\"0\" else n\"0x00000020\") +\n//                          (if ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") n\"0\" else n\"0x00000040\") +\n//                          (if ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") n\"0\" else n\"0x00000080\") +\n//                          (if ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") n\"0\" else n\"0x00000100\") +\n//                          (if ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") n\"0\" else n\"0x00000200\") +\n//                          (if ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") n\"0\" else n\"0x00000400\") +\n//                          (if ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") n\"0\" else n\"0x00000800\") +\n//                          (if ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") n\"0\" else n\"0x00001000\") +\n//                          (if ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") n\"0\" else n\"0x00002000\") +\n//                          (if ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") n\"0\" else n\"0x00004000\") +\n//                          (if ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") n\"0\" else n\"0x00008000\") +\n//                          (if ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") n\"0\" else n\"0x00010000\") +\n//                          (if ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") n\"0\" else n\"0x00020000\") +\n//                          (if ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") n\"0\" else n\"0x00040000\") +\n//                          (if ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") n\"0\" else n\"0x00080000\") +\n//                          (if ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") n\"0\" else n\"0x00100000\") +\n//                          (if ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") n\"0\" else n\"0x00200000\") +\n//                          (if ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") n\"0\" else n\"0x00400000\") +\n//                          (if ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") n\"0\" else n\"0x00800000\") +\n//                          (if ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") n\"0\" else n\"0x01000000\") +\n//                          (if ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") n\"0\" else n\"0x02000000\") +\n//                          (if ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") n\"0\" else n\"0x04000000\") +\n//                          (if ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") n\"0\" else n\"0x08000000\") +\n//                          (if ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") n\"0\" else n\"0x10000000\") +\n//                          (if ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") n\"0\" else n\"0x20000000\") +\n//                          (if ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") n\"0\" else n\"0x40000000\") +\n//                          (if ((n & u32\"0x80000000\") ≠ u32\"0x80000000\") n\"0\" else n\"0x80000000\")   \"\"\"\n\n  @pure def toN8(n: U32): N8 =\n    $ // l\"\"\" requires n ≤ u32\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U32): N16 =\n    $ // l\"\"\" requires n ≤ u32\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U32): N32 =\n    $ // l\"\"\" ensures N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U32): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U32): S8 =\n    $ // l\"\"\" requires n ≤ u32\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U32): S16 =\n    $ // l\"\"\" requires n ≤ u32\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: U32): S32 =\n    $ // l\"\"\" requires n ≤ u32\"2147483647\" \"\"\"\n\n  /* @first */\n  @pure def toRawS32(n: U32): S32 = $\n\n  /* @first */\n  @pure def toS64(n: U32): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U32): U8 =\n    $ // l\"\"\" requires n ≤ u32\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U32): U16 =\n    $ // l\"\"\" requires n ≤ u32\"65535\" \"\"\"\n\n  @pure def toU17(n: U32): U17 = $\n\n  @pure def toU18(n: U32): U18 = $\n\n  @pure def toU19(n: U32): U19 = $\n\n  @pure def toU20(n: U32): U20 = $\n\n  @pure def toU21(n: U32): U21 = $\n\n  @pure def toU22(n: U32): U22 = $\n\n  @pure def toU23(n: U32): U23 = $\n\n  @pure def toU24(n: U32): U24 = $\n\n  @pure def toU25(n: U32): U25 = $\n\n  @pure def toU26(n: U32): U26 = $\n\n  @pure def toU27(n: U32): U27 = $\n\n  @pure def toU28(n: U32): U28 = $\n\n  @pure def toU29(n: U32): U29 = $\n\n  @pure def toU30(n: U32): U30 = $\n\n  @pure def toU31(n: U32): U31 = $\n\n  @pure def toU32(n: U32): U32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toU64(n: U32): U64 = $\n\n  /* @first */\n  @pure def toRawF32(n: U32): F32 = $\n\n  @pure def toC(n: U32): C = $\n}\n\n@ext object U33 {\n  @pure def toU64(n: U33): U64 = $\n}\n\n@ext object U34 {\n  @pure def toU64(n: U34): U64 = $\n}\n\n@ext object U35 {\n  @pure def toU64(n: U35): U64 = $\n}\n\n@ext object U36 {\n  @pure def toU64(n: U36): U64 = $\n}\n\n@ext object U37 {\n  @pure def toU64(n: U37): U64 = $\n}\n\n@ext object U38 {\n  @pure def toU64(n: U38): U64 = $\n}\n\n@ext object U39 {\n  @pure def toU64(n: U39): U64 = $\n}\n\n@ext object U40 {\n  @pure def toU64(n: U40): U64 = $\n}\n\n@ext object U41 {\n  @pure def toU64(n: U41): U64 = $\n}\n\n@ext object U42 {\n  @pure def toU64(n: U42): U64 = $\n}\n\n@ext object U43 {\n  @pure def toU64(n: U43): U64 = $\n}\n\n@ext object U44 {\n  @pure def toU64(n: U44): U64 = $\n}\n\n@ext object U45 {\n  @pure def toU64(n: U45): U64 = $\n}\n\n@ext object U46 {\n  @pure def toU64(n: U46): U64 = $\n}\n\n@ext object U47 {\n  @pure def toU64(n: U47): U64 = $\n}\n\n@ext object U48 {\n  @pure def toU64(n: U48): U64 = $\n}\n\n@ext object U49 {\n  @pure def toU64(n: U49): U64 = $\n}\n\n@ext object U50 {\n  @pure def toU64(n: U50): U64 = $\n}\n\n@ext object U51 {\n  @pure def toU64(n: U51): U64 = $\n}\n\n@ext object U52 {\n  @pure def toU64(n: U52): U64 = $\n}\n\n@ext object U53 {\n  @pure def toU64(n: U53): U64 = $\n}\n\n@ext object U54 {\n  @pure def toU64(n: U54): U64 = $\n}\n\n@ext object U55 {\n  @pure def toU64(n: U55): U64 = $\n}\n\n@ext object U56 {\n  @pure def toU64(n: U56): U64 = $\n}\n\n@ext object U57 {\n  @pure def toU64(n: U57): U64 = $\n}\n\n@ext object U58 {\n  @pure def toU64(n: U58): U64 = $\n}\n\n@ext object U59 {\n  @pure def toU64(n: U59): U64 = $\n}\n\n@ext object U60 {\n  @pure def toU64(n: U60): U64 = $\n}\n\n@ext object U61 {\n  @pure def toU64(n: U61): U64 = $\n}\n\n@ext object U62 {\n  @pure def toU64(n: U62): U64 = $\n}\n\n@ext object U63 {\n  @pure def toU64(n: U63): U64 = $\n}\n\n@ext object U64 {\n\n  @pure def toB(n: U64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ u64\"0\") \"\"\"\n\n  @pure def toZ(n: U64): Z =\n    $ // l\"\"\" ensures result ≡ (if ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") 0 else 0x0000000000000001l) +\n//                          (if ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") 0 else 0x0000000000000002l) +\n//                          (if ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") 0 else 0x0000000000000004l) +\n//                          (if ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") 0 else 0x0000000000000008l) +\n//                          (if ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") 0 else 0x0000000000000010l) +\n//                          (if ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") 0 else 0x0000000000000020l) +\n//                          (if ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") 0 else 0x0000000000000040l) +\n//                          (if ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") 0 else 0x0000000000000080l) +\n//                          (if ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") 0 else 0x0000000000000100l) +\n//                          (if ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") 0 else 0x0000000000000200l) +\n//                          (if ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") 0 else 0x0000000000000400l) +\n//                          (if ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") 0 else 0x0000000000000800l) +\n//                          (if ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") 0 else 0x0000000000001000l) +\n//                          (if ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") 0 else 0x0000000000002000l) +\n//                          (if ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") 0 else 0x0000000000004000l) +\n//                          (if ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") 0 else 0x0000000000008000l) +\n//                          (if ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") 0 else 0x0000000000010000l) +\n//                          (if ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") 0 else 0x0000000000020000l) +\n//                          (if ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") 0 else 0x0000000000040000l) +\n//                          (if ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") 0 else 0x0000000000080000l) +\n//                          (if ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") 0 else 0x0000000000100000l) +\n//                          (if ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") 0 else 0x0000000000200000l) +\n//                          (if ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") 0 else 0x0000000000400000l) +\n//                          (if ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") 0 else 0x0000000000800000l) +\n//                          (if ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") 0 else 0x0000000001000000l) +\n//                          (if ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") 0 else 0x0000000002000000l) +\n//                          (if ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") 0 else 0x0000000004000000l) +\n//                          (if ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") 0 else 0x0000000008000000l) +\n//                          (if ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") 0 else 0x0000000010000000l) +\n//                          (if ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") 0 else 0x0000000020000000l) +\n//                          (if ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") 0 else 0x0000000040000000l) +\n//                          (if ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") 0 else 0x0000000080000000l) +\n//                          (if ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") 0 else 0x0000000100000000l) +\n//                          (if ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") 0 else 0x0000000200000000l) +\n//                          (if ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") 0 else 0x0000000400000000l) +\n//                          (if ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") 0 else 0x0000000800000000l) +\n//                          (if ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") 0 else 0x0000001000000000l) +\n//                          (if ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") 0 else 0x0000002000000000l) +\n//                          (if ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") 0 else 0x0000004000000000l) +\n//                          (if ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") 0 else 0x0000008000000000l) +\n//                          (if ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") 0 else 0x0000010000000000l) +\n//                          (if ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") 0 else 0x0000020000000000l) +\n//                          (if ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") 0 else 0x0000040000000000l) +\n//                          (if ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") 0 else 0x0000080000000000l) +\n//                          (if ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") 0 else 0x0000100000000000l) +\n//                          (if ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") 0 else 0x0000200000000000l) +\n//                          (if ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") 0 else 0x0000400000000000l) +\n//                          (if ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") 0 else 0x0000800000000000l) +\n//                          (if ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") 0 else 0x0001000000000000l) +\n//                          (if ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") 0 else 0x0002000000000000l) +\n//                          (if ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") 0 else 0x0004000000000000l) +\n//                          (if ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") 0 else 0x0008000000000000l) +\n//                          (if ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") 0 else 0x0010000000000000l) +\n//                          (if ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") 0 else 0x0020000000000000l) +\n//                          (if ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") 0 else 0x0040000000000000l) +\n//                          (if ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") 0 else 0x0080000000000000l) +\n//                          (if ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") 0 else 0x0100000000000000l) +\n//                          (if ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") 0 else 0x0200000000000000l) +\n//                          (if ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") 0 else 0x0400000000000000l) +\n//                          (if ((n & u64\"0x0800000000000000\") ≠ u64\"0
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f5$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #644                // String x0800000000000000\") 0 else 0x0800000000000000l) +\n//                          (if ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") 0 else 0x1000000000000000l) +\n//                          (if ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") 0 else 0x2000000000000000l) +\n//                          (if ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") 0 else 0x4000000000000000l) +\n//                          (if ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\") 0 else 0x8000000000000000l)   \"\"\"\n\n  @pure def toZ8(n: U64): Z8 =\n    $ // l\"\"\" requires n ≤ u64\"127\"\n         // ensures  Z8.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ16(n: U64): Z16 =\n    $ // l\"\"\" requires n ≤ u64\"32767\"\n         // ensures  Z16.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ32(n: U64): Z32 =\n    $ // l\"\"\" requires n ≤ u64\"2147483647\"\n         // ensures  Z32.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toZ64(n: U64): Z64 =\n    $ // l\"\"\" requires n ≤ u64\"9223372036854775807\"\n         // ensures  Z64.toZ(result) ≡ toZ(n) \"\"\"\n\n  @pure def toN(n: U64): N =\n    $ // l\"\"\" ensures result ≡ (if ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") n\"0\" else n\"0x0000000000000001\") +\n//                          (if ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") n\"0\" else n\"0x0000000000000002\") +\n//                          (if ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") n\"0\" else n\"0x0000000000000004\") +\n//                          (if ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") n\"0\" else n\"0x0000000000000008\") +\n//                          (if ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") n\"0\" else n\"0x0000000000000010\") +\n//                          (if ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") n\"0\" else n\"0x0000000000000020\") +\n//                          (if ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") n\"0\" else n\"0x0000000000000040\") +\n//                          (if ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") n\"0\" else n\"0x0000000000000080\") +\n//                          (if ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") n\"0\" else n\"0x0000000000000100\") +\n//                          (if ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") n\"0\" else n\"0x0000000000000200\") +\n//                          (if ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") n\"0\" else n\"0x0000000000000400\") +\n//                          (if ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") n\"0\" else n\"0x0000000000000800\") +\n//                          (if ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") n\"0\" else n\"0x0000000000001000\") +\n//                          (if ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") n\"0\" else n\"0x0000000000002000\") +\n//                          (if ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") n\"0\" else n\"0x0000000000004000\") +\n//                          (if ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") n\"0\" else n\"0x0000000000008000\") +\n//                          (if ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") n\"0\" else n\"0x0000000000010000\") +\n//                          (if ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") n\"0\" else n\"0x0000000000020000\") +\n//                          (if ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") n\"0\" else n\"0x0000000000040000\") +\n//                          (if ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") n\"0\" else n\"0x0000000000080000\") +\n//                          (if ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") n\"0\" else n\"0x0000000000100000\") +\n//                          (if ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") n\"0\" else n\"0x0000000000200000\") +\n//                          (if ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") n\"0\" else n\"0x0000000000400000\") +\n//                          (if ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") n\"0\" else n\"0x0000000000800000\") +\n//                          (if ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") n\"0\" else n\"0x0000000001000000\") +\n//                          (if ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") n\"0\" else n\"0x0000000002000000\") +\n//                          (if ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") n\"0\" else n\"0x0000000004000000\") +\n//                          (if ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") n\"0\" else n\"0x0000000008000000\") +\n//                          (if ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") n\"0\" else n\"0x0000000010000000\") +\n//                          (if ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") n\"0\" else n\"0x0000000020000000\") +\n//                          (if ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") n\"0\" else n\"0x0000000040000000\") +\n//                          (if ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") n\"0\" else n\"0x0000000080000000\") +\n//                          (if ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") n\"0\" else n\"0x0000000100000000\") +\n//                          (if ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") n\"0\" else n\"0x0000000200000000\") +\n//                          (if ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") n\"0\" else n\"0x0000000400000000\") +\n//                          (if ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") n\"0\" else n\"0x0000000800000000\") +\n//                          (if ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") n\"0\" else n\"0x0000001000000000\") +\n//                          (if ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") n\"0\" else n\"0x0000002000000000\") +\n//                          (if ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") n\"0\" else n\"0x0000004000000000\") +\n//                          (if ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") n\"0\" else n\"0x0000008000000000\") +\n//                          (if ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") n\"0\" else n\"0x0000010000000000\") +\n//                          (if ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") n\"0\" else n\"0x0000020000000000\") +\n//                          (if ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") n\"0\" else n\"0x0000040000000000\") +\n//                          (if ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") n\"0\" else n\"0x0000080000000000\") +\n//                          (if ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") n\"0\" else n\"0x0000100000000000\") +\n//                          (if ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") n\"0\" else n\"0x0000200000000000\") +\n//                          (if ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") n\"0\" else n\"0x0000400000000000\") +\n//                          (if ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") n\"0\" else n\"0x0000800000000000\") +\n//                          (if ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") n\"0\" else n\"0x0001000000000000\") +\n//                          (if ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") n\"0\" else n\"0x0002000000000000\") +\n//                          (if ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") n\"0\" else n\"0x0004000000000000\") +\n//                          (if ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") n\"0\" else n\"0x0008000000000000\") +\n//                          (if ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") n\"0\" else n\"0x0010000000000000\") +\n//                          (if ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") n\"0\" else n\"0x0020000000000000\") +\n//                          (if ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") n\"0\" else n\"0x0040000000000000\") +\n//                          (if ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") n\"0\" else n\"0x0080000000000000\") +\n//                          (if ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") n\"0\" else n\"0x0100000000000000\") +\n//                          (if ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") n\"0\" else n\"0x0200000000000000\") +\n//                          (if ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") n\"0\" else n\"0x0400000000000000\") +\n//                          (if ((n & u64\"0x0800000000000000\") ≠ u64\"0x0800000000000000\") n\"0\" else n\"0x0800000000000000\") +\n//                          (if ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") n\"0\" else n\"0x1000000000000000\") +\n//                          (if ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") n\"0\" else n\"0x2000000000000000\") +\n//                          (if ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") n\"0\" else n\"0x4000000000000000\") +\n//                          (if ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\") n\"0\" else n\"0x8000000000000000\")   \"\"\"\n\n  @pure def toN8(n: U64): N8 =\n    $ // l\"\"\" requires n ≤ u64\"255\"\n         // ensures  N8.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN16(n: U64): N16 =\n    $ // l\"\"\" requires n ≤ u64\"65535\"\n         // ensures  N16.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN32(n: U64): N32 =\n    $ // l\"\"\" requires n ≤ u64\"4294967295\"\n         // ensures  N32.toN(result) ≡ toN(n) \"\"\"\n\n  @pure def toN64(n: U64): N64 =\n    $ // l\"\"\" ensures N64.toN(result) ≡ toN(n) \"\"\"\n\n  /* @first */\n  @pure def toS8(n: U64): S8 =\n    $ // l\"\"\" requires n ≤ u64\"127\" \"\"\"\n\n  /* @first */\n  @pure def toS16(n: U64): S16 =\n    $ // l\"\"\" requires n ≤ u64\"32767\" \"\"\"\n\n  /* @first */\n  @pure def toS32(n: U64): S32 =\n    $ // l\"\"\" requires n ≤ u64\"2147483647\" \"\"\"\n\n  /* @first */\n  @pure def toS64(n: U64): S64 =\n    $ // l\"\"\" requires n ≤ u64\"9223372036854775807\" \"\"\"\n\n  /* @first */\n  @pure def toRawS64(n: U64): S64 = $\n\n  /* @first */\n  @pure def toU8(n: U64): U8 =\n    $ // l\"\"\" requires n ≤ u64\"255\" \"\"\"\n\n  /* @first */\n  @pure def toU16(n: U64): U16 =\n    $ // l\"\"\" requires n ≤ u64\"65535\" \"\"\"\n\n  /* @first */\n  @pure def toU32(n: U64): U32 =\n    $ // l\"\"\" requires n ≤ u64\"4294967295\" \"\"\"\n\n  @pure def toU33(n: U64): U33 = $\n\n  @pure def toU34(n: U64): U34 = $\n\n  @pure def toU35(n: U64): U35 = $\n\n  @pure def toU36(n: U64): U36 = $\n\n  @pure def toU37(n: U64): U37 = $\n\n  @pure def toU38(n: U64): U38 = $\n\n  @pure def toU39(n: U64): U39 = $\n\n  @pure def toU40(n: U64): U40 = $\n\n  @pure def toU41(n: U64): U41 = $\n\n  @pure def toU42(n: U64): U42 = $\n\n  @pure def toU43(n: U64): U43 = $\n\n  @pure def toU44(n: U64): U44 = $\n\n  @pure def toU45(n: U64): U45 = $\n\n  @pure def toU46(n: U64): U46 = $\n\n  @pure def toU47(n: U64): U47 = $\n\n  @pure def toU48(n: U64): U48 = $\n\n  @pure def toU49(n: U64): U49 = $\n\n  @pure def toU50(n: U64): U50 = $\n\n  @pure def toU51(n: U64): U51 = $\n\n  @pure def toU52(n: U64): U52 = $\n\n  @pure def toU53(n: U64): U53 = $\n\n  @pure def toU54(n: U64): U54 = $\n\n  @pure def toU55(n: U64): U55 = $\n\n  @pure def toU56(n: U64): U56 = $\n\n  @pure def toU57(n: U64): U57 = $\n\n  @pure def toU58(n: U64): U58 = $\n\n  @pure def toU59(n: U64): U59 = $\n\n  @pure def toU60(n: U64): U60 = $\n\n  @pure def toU61(n: U64): U61 = $\n\n  @pure def toU62(n: U64): U62 = $\n\n  @pure def toU63(n: U64): U63 = $\n\n  /* @first */\n  @pure def toU64(n: U64): U64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  /* @first */\n  @pure def toRawF64(n: U64): F64 = $\n}\n\n@ext object F32 {\n\n  @pure def toB(n: F32): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ f32\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toRawU32(n: F32): U32 = $\n\n  @pure def toF32(n: F32): F32 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toR(n: F32): R = $\n}\n\n@ext object F64 {\n\n  @pure def toB(n: F64): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ f64\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toRawU64(n: F64): U64 = $\n\n  @pure def toF64(n: F64): F64 =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n\n  @pure def toR(n: F64): R = $\n}\n\n@ext object R {\n\n  @pure def toB(n: R): B =\n    $ // l\"\"\" ensures result ≡ (n ≠ r\"0.0\") \"\"\"\n\n  /* @first */\n  @pure def toZ(n: R): Z = $\n\n  /* @first */\n  @pure def toN(n: R): N =\n    $ // l\"\"\" requires n ≥ r\"0.0\" \"\"\"\n\n  @pure def toR(n: R): R =\n    $ // l\"\"\" ensures result ≡ n \"\"\"\n}\n\n@ext object String {\n\n  @pure def fromBase64(s: String): Either[IS[Z, U8], String] = $\n\n  @pure def toBase64(data: IS[Z, U8]): String = $\n\n  @pure def fromCis[I](cs: IS[I, C]): String = $\n\n  @pure def fromCms[I](cs: MS[I, C]): String = $\n\n  @pure def fromU8is(u8s: IS[Z, U8]): String = $\n\n  @pure def fromU8ms(u8s: MS[Z, U8]): String = $\n\n  @pure def toCis(s: String): IS[Z, C] = $\n\n  @pure def toCStream(s: String): Jen[C] = $\n\n  @pure def toCms(s: String): MS[Z, C] = $\n\n  @pure def toU8is(s: String): IS[Z, U8] = $\n\n  @pure def toU8ms(s: String): MS[Z, U8] = $\n}\n\n@ext object ISB {\n  @pure def fromISU8[I](s: IS[I, U8]): IS[I, B] = $\n  @pure def toISU8[I](s: IS[I, B]): IS[I, U8] = $\n  @pure def toMSU8[I](s: IS[I, B]): MS[I, U8] = $\n}\n\n@ext object MSB {\n  @pure def fromMSU8[I](s: MS[I, U8]): MS[I, B] = $\n  @pure def toISU8[I](s: MS[I, B]): IS[I, U8] = $\n  @pure def toMSU8[I](s: MS[I, B]): MS[I, U8] = $\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$18();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #646                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashMap {\n\n  @pure def empty[K, T]: HashMap[K, T] = {\n    return emptyInit[K, T](12)\n  }\n\n  @pure def emptyInit[K, T](initialCapacity: Z): HashMap[K, T] = {\n    val sz: Z = if (initialCapacity <= 0) 4 else initialCapacity * 4 / 3 + 1\n    return HashMap[K, T](ISZ.create(sz, Map.empty), 0)\n  }\n\n  @pure def ++[I, K, T](s: IS[I, (K, T)]): HashMap[K, T] = {\n    return HashMap.emptyInit[K, T](s.size) ++ s\n  }\n\n}\n\n@datatype class HashMap[K, T](val mapEntries: ISZ[Map[K, T]], val size: Z) {\n\n  @pure def entries: ISZ[(K, T)] = {\n    var r = ISZ[(K, T)]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.entries\n      }\n    }\n    return r\n  }\n\n  @pure def keys: ISZ[K] = {\n    var r = ISZ[K]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.keys\n      }\n    }\n    return r\n  }\n\n  @pure def values: ISZ[T] = {\n    var r = ISZ[T]()\n    for (ms <- mapEntries) {\n      if (ms.nonEmpty) {\n        r = r ++ ms.values\n      }\n    }\n    return r\n  }\n\n  @pure def keySet: Set[K] = {\n    return Set.empty[K] ++ keys\n  }\n\n  @pure def valueSet: Set[T] = {\n    return Set.empty[T] ++ values\n  }\n\n  @pure def +(p: (K, T)): HashMap[K, T] = {\n    val (key, value) = p\n    val r = ensureCapacity(size + 1)\n    val i = r.hashIndex(key)\n    val m = r.mapEntries(i)\n    val newSize: Z = if (m.contains(key)) size else size + 1\n    return r(mapEntries = r.mapEntries(i ~> (m + key ~> value)), size = newSize)\n  }\n\n  @pure def ++[I](entries: IS[I, (K, T)]): HashMap[K, T] = {\n    if (entries.isEmpty) {\n      return this\n    }\n    var r = ensureCapacity(size + entries.size)\n    for (kv <- entries) {\n      r = r + kv._1 ~> kv._2\n    }\n    return r\n  }\n\n  @pure def ensureCapacity(sz: Z): HashMap[K, T] = {\n    if (mapEntries.size * 3 / 4 >= sz) {\n      return this\n    }\n    val init = sz * 2\n    var r = HashMap.emptyInit[K, T](init)\n    for (ms <- mapEntries) {\n      for (kv <- ms.entries) {\n        r = r + kv._1 ~> kv._2\n      }\n    }\n    return r\n  }\n\n  @pure def hashIndex(key: K): Z = {\n    val sz = mapEntries.size\n    val i = key.hash % sz\n    return if (i < 0) i + sz else i\n  }\n\n  @pure def get(key: K): Option[T] = {\n    val m = mapEntries(hashIndex(key))\n    return m.get(key)\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    val m = mapEntries(hashIndex(key))\n    return m.entry(key)\n  }\n\n  @pure def --[I](keys: IS[I, K]): HashMap[K, T] = {\n    var r = this\n    for (k <- keys) {\n      r.get(k) match {\n        case Some(v) => r = r - k ~> v\n        case _ =>\n      }\n    }\n    return r\n  }\n\n  @pure def -(p: (K, T)): HashMap[K, T] = {\n    val (key, value) = p\n    val i = hashIndex(key)\n    return this(mapEntries(i ~> (mapEntries(i) - key ~> value)), size - 1)\n  }\n\n  @pure def contains(key: K): B = {\n    return get(key).nonEmpty\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: HashMap[K, T]): B = {\n    if (size != other.size) {\n      return F\n    }\n\n    var comparedKeys = ISZ[K]()\n    for (ms <- mapEntries) {\n      for (kv <- ms.entries) {\n        val k = kv._1\n        comparedKeys = comparedKeys :+ k\n        other.get(k) match {\n          case Some(v) =>\n            if (kv._2 != v) {\n              return F\n            }\n          case _ => return F\n        }\n      }\n    }\n    for (ms <- (other -- comparedKeys).mapEntries) {\n      for (kv <- ms.entries) {\n        val k = kv._1\n        get(k) match {\n          case Some(v) =>\n            if (kv._2 != v) {\n              return F\n            }\n          case _ => return F\n        }\n      }\n    }\n\n    return T\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$19();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #648                // String // #Sireum\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Li Haoyi (haoyi.sg@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n */\n\npackage org.sireum\n\n// Adapted from https://github.com/lihaoyi/geny\n\n@sig trait Jen[T] {\n\n  def generate(f: T => Jen.Action): Jen.Action\n\n  def foreach[V](f: T => V): Unit = {\n    def ap(o: T): Jen.Action = {\n      f(o)\n      return Jen.Continue\n    }\n\n    generate(ap _)\n  }\n\n  def find(f: T => B): Option[T] = {\n    var result: Option[T] = None()\n\n    def ap(o: T): Jen.Action = {\n      val r = f(o)\n      if (!r) {\n        return Jen.Continue\n      } else {\n        result = Some(o)\n        return Jen.End\n      }\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  def exists(f: T => B): B = {\n    val r = find(f)\n    return r.nonEmpty\n  }\n\n  @pure def contains(o: T): B = {\n    return exists(e => e == o)\n  }\n\n  def forall(f: T => B): B = {\n    def ap(o: T): B = {\n      val r = f(o)\n      return !r\n    }\n    val r = exists(ap _)\n    return !r\n  }\n\n  @pure def count(): Z = {\n    return countIf(_ => T)\n  }\n\n  def countIf(p: T => B): Z = {\n    var result = 0\n\n    def ap(o: T): Jen.Action = {\n      val r = p(o)\n      if (r) {\n        result = result + 1\n      }\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  @pure def fold[U](initial: U, f: (U, T) => U@pure): U = {\n    return foldLeft(initial, f)\n  }\n\n  @pure def foldLeft[U](initial: U, f: (U, T) => U@pure): U = {\n    var r = initial\n\n    def ap(o: T): Jen.Action = {\n      r = f(r, o)\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def reduce(f: (T, T) => T@pure): Option[T] = {\n    return reduceLeft(f)\n  }\n\n  @pure def reduceLeft(f: (T, T) => T@pure): Option[T] = {\n    var r: Option[T] = None()\n\n    def ap(o: T): Jen.Action = {\n      r = r match {\n        case Some(prev) => Some(f(prev, o))\n        case _ => Some(o)\n      }\n      return Jen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def filter(p: T => B@pure): Jen[T] = {\n    return Jen.Internal.Filtered(this, p)\n  }\n\n  def withFilter(p: T => B): Jen[T] = {\n    return Jen.Internal.Filtered(this, p)\n  }\n\n  @pure def map[U](f: T => U@pure): Jen[U] = {\n    return Jen.Internal.Mapped(this, f)\n  }\n\n  @pure def flatMap[U](f: T => Jen[U]@pure): Jen[U] = {\n    return Jen.Internal.FlatMapped(this, f)\n  }\n\n  @pure def flatten[U](f: T => Jen[U]@pure): Jen[U] = {\n    return this.flatMap(o => f(o))\n  }\n\n  @pure def slice(start: Z, end: Z): Jen[T] = {\n    return Jen.Internal.Sliced(this, start, end)\n  }\n\n  @pure def take(n: Z): Jen[T] = {\n    return slice(0, n)\n  }\n\n  @pure def drop(n: Z): Jen[T] = {\n    return slice(n, -1)\n  }\n\n  @pure def takeWhile(p: T => B): Jen[T] = {\n    return Jen.Internal.TakeWhile(this, p)\n  }\n\n  @pure def dropWhile(p: T => B): Jen[T] = {\n    return Jen.Internal.DropWhile(this, p)\n  }\n\n  @pure def zipWithIndex: Jen[(T, Z)] = {\n    return Jen.Internal.ZipWithIndexed(this)\n  }\n\n  @pure def zip[U](other: Jen[U]): Jen[(T, U)] = {\n    return Jen.Internal.Zipped(this, other)\n  }\n\n  @pure def product[U](other: Jen[U]): Jen[(T, U)] = {\n    return Jen.Internal.Product(this, other)\n  }\n\n  @pure def ++(other: Jen[T]): Jen[T] = {\n    return Jen.Internal.Concat(this, other)\n  }\n\n  @pure def head: T = {\n    return take(1).toISZ(0)\n  }\n\n  @pure def headOption: Option[T] = {\n    val s = take(1).toISZ\n    return if (s.isEmpty) None() else Some(s(0))\n  }\n\n  @pure def toISZ: ISZ[T] = {\n    val r = toIS(ISZ[T]())\n    return r\n  }\n\n  @pure def toIS[I](init: IS[I, T]): IS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def toMSZ: MSZ[T] = {\n    val r = toMS(MSZ[T]())\n    return r\n  }\n\n  @pure def toMS[I](init: MS[I, T]): MS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def mkStringWrap(start: String, sep: String, end: String): String = {\n    return st\"$start${(toISZ, sep)}$end\".render\n  }\n\n  @pure def mkString(sep: String): String = {\n    return mkStringWrap(\"\", sep, \"\")\n  }\n\n}\n\nobject Jen {\n\n  type Action = B\n  val Continue: Action = T\n  val End: Action = F\n\n  object Internal {\n\n    @datatype class ISImpl[I, T](val s: IS[I, T]) extends Jen[T] {\n      override def generate(f: T => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return Jen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($s)\"\n      }\n    }\n\n    @datatype class MapImpl[K, T](val m: Map[K, T]) extends Jen[(K, T)] {\n      override def generate(f: ((K, T)) => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (e <- m.entries) {\n          last = f(e)\n          if (!last) {\n            return Jen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($m)\"\n      }\n    }\n\n    @datatype class HashMapImpl[K, T](val m: HashMap[K, T]) extends Jen[(K, T)] {\n      override def generate(f: ((K, T)) => Jen.Action): Jen.Action = {\n        var last = Jen.Continue\n        for (ms <- m.mapEntries) {\n          if (ms.nonEmpty) {\n            for (e <- ms.entries) {\n              last = f(e)\n              if (!last) {\n                return Jen.End\n              }\n            }\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"Jen($m)\"\n      }\n    }\n\n    @datatype class Filtered[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      override def generate(f: T => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return Jen.Continue\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.filter($p)\"\n      }\n    }\n\n    @datatype class Mapped[U, T](val gen: Jen[T], val f: T => U@pure) extends Jen[U] {\n      override def generate(g: U => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          val r = g(f(o))\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.map($f)\"\n      }\n    }\n\n    @datatype class FlatMapped[U, T](val gen: Jen[T], val f: T => Jen[U]@pure) extends Jen[U] {\n      override def generate(g: U => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          def ap2(o2: U): Jen.Action = {\n            val r = g(o2)\n            return r\n          }\n\n          val r = f(o).generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.flatMap($f)\"\n      }\n    }\n\n    @datatype class Sliced[T](val gen: Jen[T], val start: Z, val end: Z) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var count = 0\n\n        def ap(o: T): Jen.Action = {\n          if (count < start) {\n            count = count + 1\n            return Jen.Continue\n          } else if (count < end || end < 0) {\n            count = count + 1\n            if (count != end) {\n              return f(o)\n            } else {\n              f(o)\n              return Jen.End\n            }\n          } else {\n            return Jen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return if (end < 0) s\"$gen.slice($start, ~)\" else s\"$gen.slice($start, $end)\"\n      }\n    }\n\n    @datatype class TakeWhile[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return Jen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.takeWhile($p)\"\n      }\n    }\n\n    @datatype class DropWhile[T](val gen: Jen[T], val p: T => B) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var started = F\n\n        def ap(o: T): Jen.Action = {\n          if (!started) {\n            var r = p(o)\n            if (r) {\n              return Jen.Continue\n            } else {\n              started = T\n              r = f(o)\n              return r\n            }\n          } else {\n            val r = f(o)\n            return r\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.dropWhile($p)\"\n      }\n    }\n\n    @datatype class ZipWithIndexed[T](val gen: Jen[T]) extends Jen[(T, Z)] {\n      def generate(f: ((T, Z)) => Jen.Action): Jen.Action = {\n        var i = 0\n\n        def ap(o: T): Jen.Action = {\n          val r = f((o, i))\n          i = i + 1\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zipWithIndex\"\n      }\n    }\n\n    @datatype class Zipped[T, U](val gen: Jen[T], val gen2: Jen[U]) extends Jen[(T, U)] {\n      def generate(f: ((T, U)) => Jen.Action): Jen.Action = {\n        var g = gen\n        var g2 = gen2\n        var i = 1\n        while (true) {\n          (g.headOption, g2.headOption) match {\n            case (Some(h), Some(h2)) =>\n              val r = f((h, h2))\n              if (r) {\n                g = gen.drop(i)\n                g2 = gen2.drop(i)\n              } else {\n                return Jen.End\n              }\n            case _ => return Jen.End\n          }\n          i = i + 1\n        }\n        return Jen.End\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n    @datatype class Concat[T](val gen: Jen[T], val gen2: Jen[T]) extends Jen[T] {\n      def generate(f: T => Jen.Action): Jen.Action = {\n        var r = gen.generate(f)\n        if (!r) {\n          return Jen.End\n        }\n        r = gen2.generate(f)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen ++ $gen2\"\n      }\n    }\n\n    @datatype class Product[T, U](val gen: Jen[T], val gen2: Jen[U]) extends Jen[(T, U)] {\n      def generate(f: ((T, U)) => Jen.Action): Jen.Action = {\n        def ap(o: T): Jen.Action = {\n          def ap2(o2: U): Jen.Action = {\n            val r = f((o, o2))\n            return r\n          }\n\n          val r = gen2.generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n  }\n\n  @pure def IS[I, T](s: IS[I, T]): Jen[T] = {\n    return Internal.ISImpl(s)\n  }\n\n  @pure def Map[K, T](m: Map[K, T]): Jen[(K, T)] = {\n    return Internal.MapImpl(m)\n  }\n\n  @pure def Set[T](s: Set[T]): Jen[T] = {\n    return Internal.ISImpl(s.elements)\n  }\n\n  @pure def HashMap[K, T](m: HashMap[K, T]): Jen[(K, T)] = {\n    return Internal.HashMapImpl(m)\n  }\n\n  @pure def HashSet[T](s: HashSet[T]): Jen[T] = {\n    return Internal.HashMapImpl(s.map).map(p => p._1)\n  }\n\n  @pure def HashSMap[K, T](m: HashSMap[K, T]): Jen[(K, T)] = {\n    return IS(m.keys).map(k => (k, m.get(k).get))\n  }\n\n  @pure def HashSSet[T](s: HashSSet[T]): Jen[T] = {\n    return HashSMap(s.map).map(p => p._1)\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$20();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #650                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject MOption {\n\n  @strictpure def some[T](value: T): MOption[T] = MSome(value)\n\n  @strictpure def none[T](): MOption[T] = MNone()\n\n}\n\n@record trait MOption[T] {\n\n  @pure def isEmpty: B = Contract.Only(\n    Ensures(Res == (this == MNone[T]()))\n  )\n\n  @pure def nonEmpty: B = Contract.Only(\n    Ensures(Res == !isEmpty)\n  )\n\n  @pure def map[T2](f: T => T2 @pure): MOption[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MNone[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == MSome(f(get)))\n    )\n  )\n\n  @pure def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MNone[T2]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def forall(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == T)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def exists(f: T => B @pure): B = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == F)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == f(get))\n    )\n  )\n\n  @pure def get: T = Contract.Only(\n    Requires(nonEmpty),\n    Ensures(MSome(Res) == this)\n  )\n\n  @pure def getOrElse(default: => T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(MSome(Res) == this)\n    )\n  )\n\n  @pure def getOrElseEager(default: T): T = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == default)\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(MSome(Res) == this)\n    )\n  )\n\n  @pure def toMS: MSZ[T] = Contract.Only(\n    Case(\n      \"Empty\",\n      Requires(isEmpty),\n      Ensures(Res == MSZ[T]())\n    ),\n    Case(\n      \"Non-empty\",\n      Requires(nonEmpty),\n      Ensures(Res == MSZ[T](get))\n    )\n  )\n\n  def foreach[V](f: T => V): Unit\n}\n\n@record class MNone[T] extends MOption[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): MOption[T2] = {\n    Contract(Ensures(Res == MNone[T2]()))\n    return MNone[T2]()\n  }\n\n  @pure override def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = {\n    Contract(Ensures(Res == MNone[T2]()))\n    return MNone[T2]()\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == default))\n    return default\n  }\n\n  @pure override def get: T = {\n    Contract(Requires(F))\n    halt(\"Invalid \'MNone\' operation \'get\'.\")\n  }\n\n  @pure override def toMS: MS[Z, T] = {\n    Contract(Ensures(Res[MSZ[T]].size == 0))\n    return MS[Z, T]()\n  }\n\n  def foreach[V](f: T => V): Unit = {}\n}\n\n@record class MSome[T](val value: T) extends MOption[T] {\n\n  @pure override def isEmpty: B = {\n    Contract(Ensures(!Res[B]))\n    return F\n  }\n\n  @pure override def nonEmpty: B = {\n    Contract(Ensures(Res))\n    return T\n  }\n\n  @pure override def map[T2](f: T => T2 @pure): MOption[T2] = {\n    Contract(Ensures(Res == MSome(f(value))))\n    return MSome(f(value))\n  }\n\n  @pure override def flatMap[T2](f: T => MOption[T2] @pure): MOption[T2] = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def forall(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def exists(f: T => B @pure): B = {\n    Contract(Ensures(Res == f(value)))\n    return f(value)\n  }\n\n  @pure override def getOrElse(default: => T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def getOrElseEager(default: T): T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def get: T = {\n    Contract(Ensures(Res == value))\n    return value\n  }\n\n  @pure override def toMS: MS[Z, T] = {\n    Contract(Ensures(Res == MSZ(value)))\n    return MSZ(value)\n  }\n\n  override def foreach[V](f: T => V): Unit = {\n    f(value)\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$21();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #652                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSet {\n\n  @pure def empty[T]: HashSet[T] = {\n    return HashSet(HashMap.empty[T, B])\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSet[T] = {\n    return HashSet(HashMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSet[T] = {\n    return HashSet.emptyInit[T](s.size) ++ s\n  }\n}\n\n@datatype class HashSet[T](val map: HashMap[T, B]) {\n\n  @pure def +(e: T): HashSet[T] = {\n    return HashSet(map + e ~> T)\n  }\n\n  @pure def ++[I](is: IS[I, T]): HashSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSet[T] = {\n    return HashSet(map - e ~> T)\n  }\n\n  @pure def --[I](is: IS[I, T]): HashSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    return map.contains(e)\n  }\n\n  @pure def union(other: HashSet[T]): HashSet[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSet[T]): HashSet[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSet[T]): HashSet[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSet[T]): HashSet[T] = {\n    var r = HashSet.emptyInit[T](size)\n    for (e <- other.map.keys) {\n      if (contains(e)) {\n        r = r + e\n      }\n    }\n    return r\n  }\n\n  @pure def \\(other: HashSet[T]): HashSet[T] = {\n    return this -- other.elements\n  }\n\n  @pure def isEqual(other: HashSet[T]): B = {\n    return map.isEqual(other.map)\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    return map.size\n  }\n\n  @pure def elements: ISZ[T] = {\n    return map.keys\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$22();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #654                // String /*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n\n@ext object B {\n\n  def random: B = $\n\n}\n\n@ext trait B {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def &(other: B): B\n\n  @pure def |(other: B): B\n\n  @pure def |^(other: B): B\n\n  @pure def imply_:(other: B): B\n\n  @pure def ->:(other: B): B\n\n  @pure def =!=(other: B): B\n\n  @pure def ===(other: B): B\n\n  @pure def &&(other: => B): B\n\n  @pure def ||(other: => B): B\n\n  @pure def simply_:(other: => B): B\n\n  @pure def -->:(other: => B): B\n\n  @pure def unary_! : B\n\n  @pure def unary_~ : B\n\n}\n\n\n@ext object C {\n\n  def random: C = $\n\n}\n\n@ext trait C {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: C): B\n\n  @pure def <=(other: C): B\n\n  @pure def >(other: C): B\n\n  @pure def >=(other: C): B\n\n  @pure def ===(other: C): B\n\n  @pure def =!=(other: C): B\n\n  @pure def >>>(other: C): C\n\n  @pure def <<(other: C): C\n\n  @pure def &(other: C): C\n\n  @pure def |(other: C): C\n\n  @pure def |^(other: C): C\n\n  @pure def isWhitespace: B\n}\n\n\n@ext object Z {\n\n  def random: Z = $\n\n}\n\n@ext trait Z {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: Z): B\n\n  @pure def <=(other: Z): B\n\n  @pure def >(other: Z): B\n\n  @pure def >=(other: Z): B\n\n  @pure def ===(other: Z): B\n\n  @pure def =!=(other: Z): B\n\n  @pure def +(other: Z): Z\n\n  @pure def -(other: Z): Z\n\n  @pure def *(other: Z): Z\n\n  @pure def /(other: Z): Z\n\n  @pure def %(other: Z): Z\n\n  @pure def unary_- : Z\n\n  @pure def increase: Z\n\n  @pure def decrease: Z\n\n}\n\n\n@ext object F32 {\n\n  def random: F32 = $\n\n}\n\n@ext trait F32 {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: F32): B\n\n  @pure def <=(other: F32): B\n\n  @pure def >(other: F32): B\n\n  @pure def >=(other: F32): B\n\n  @pure def +(other: F32): F32\n\n  @pure def -(other: F32): F32\n\n  @pure def *(other: F32): F32\n\n  @pure def /(other: F32): F32\n\n  @pure def %(other: F32): F32\n\n  @pure def unary_- : F32\n\n}\n\n\n@ext object F64 {\n\n  def random: F64 = $\n\n}\n\n@ext trait F64 {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: F64): B\n\n  @pure def <=(other: F64): B\n\n  @pure def >(other: F64): B\n\n  @pure def >=(other: F64): B\n\n  @pure def +(other: F64): F64\n\n  @pure def -(other: F64): F64\n\n  @pure def *(other: F64): F64\n\n  @pure def /(other: F64): F64\n\n  @pure def %(other: F64): F64\n\n  @pure def unary_- : F64\n\n}\n\n\n@ext object R {\n\n  def random: R = $\n\n}\n\n@ext trait R {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def <(other: R): B\n\n  @pure def <=(other: R): B\n\n  @pure def >(other: R): B\n\n  @pure def >=(other: R): B\n\n  @pure def ===(other: R): B\n\n  @pure def =!=(other: R): B\n\n  @pure def +(other: R): R\n\n  @pure def -(other: R): R\n\n  @pure def *(other: R): R\n\n  @pure def /(other: R): R\n\n  @pure def unary_- : R\n\n}\n\n@ext object String {\n\n  def random: String = $\n\n}\n\n@ext trait String {\n\n  @pure def ===(other: String): B\n\n  @pure def =!=(other: String): B\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def size: Z\n\n}\n\n\n@ext trait ST {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def render: String\n\n  @pure def renderCompact: String\n\n}\n\n\n@ext object IS {\n\n  @pure def create[I, E](size: Z, default: E): IS[I, E] =\n    Contract.Only(\n      Requires(seqIndexValidSize[I](size)),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext trait IS[I, E] {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def isEmpty: B\n\n  @pure def nonEmpty: B\n\n  @pure def isInBound(i: I): B\n\n  @pure def :+(e: E): IS[I, E]\n\n  @pure def +:(e: E): IS[I, E]\n\n  @pure def ++[I2](other: IS[I2, E]): IS[I, E]\n\n  @pure def --[I2](other: IS[I2, E]): IS[I, E]\n\n  @pure def -(e: E): IS[I, E]\n\n  @pure def map[E2](f: E => E2 @pure): IS[I, E2]\n\n  @pure def flatMap[E2](f: E => IS[I, E2] @pure): IS[I, E2]\n\n  @pure def filter(p: E => B @pure): IS[I, E]\n\n  def foreach[V](p: E => V): Unit\n\n  @pure def size: Z\n\n  @pure def firstIndex: I\n\n  @pure def lastIndex: I\n\n  @pure def indices: ISZ[I]\n\n  @pure def atZ(index: Z): E\n\n  @pure def toMS: MS[I, E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(Res.indices)(i => Res(i) == this(i))\n      )\n    )\n\n  @pure def toISZ: ISZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n\n  @pure def toMSZ: MSZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n}\n\n@ext object ISZ {\n\n  @pure def create[E](size: Z, default: E): ISZ[E] =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext object MS {\n\n  @pure def create[I, E](size: Z, default: E): MS[I, E] =\n    Contract.Only(\n      Requires(seqIndexValidSize[I](size)),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext trait MS[I, E] {\n\n  @pure def hash: Z\n\n  @pure def string: String\n\n  @pure def isEmpty: B\n\n  @pure def nonEmpty: B\n\n  @pure def isInBound(i: I): B\n\n  @pure def :+(e: E): MS[I, E]\n\n  @pure def +:(e: E): MS[I, E]\n\n  @pure def ++[I2](other: MS[I2, E]): MS[I, E]\n\n  @pure def --[I2](other: MS[I2, E]): MS[I, E]\n\n  @pure def -(e: E): MS[I, E]\n\n  @pure def map[E2](f: E => E2 @pure): MS[I, E2]\n\n  @pure def flatMap[E2](f: E => MS[I, E2] @pure): MS[I, E2]\n\n  @pure def filter(p: E => B @pure): MS[I, E]\n\n  def foreach[V](p: E => V): Unit\n\n  @pure def size: Z\n\n  @pure def firstIndex: I\n\n  @pure def lastIndex: I\n\n  @pure def indices: ISZ[I]\n\n  @pure def atZ(index: Z): E\n\n  @pure def toIS: IS[I, E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(Res.indices)(i => Res(i) == this(i))\n      )\n    )\n\n  @pure def toISZ: ISZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n\n  @pure def toMSZ: MSZ[E] =\n    Contract.Only(\n      Ensures(\n        Res.size == this.size,\n        ∀(this)(e => ∃(Res.indices)(i => Res(i) == e))\n      )\n    )\n}\n\n@ext object MSZ {\n\n  @pure def create[E](size: Z, default: E): MSZ[E] =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n\n}\n\n@ext object ZS {\n\n  def random: ZS = $\n\n  @pure def create(size: Z, default: Z): ZS =\n    Contract.Only(\n      Requires(0 <= size),\n      Ensures(\n        Res.size == size,\n        ∀(Res.indices)(i => Res(i) == default)\n      )\n    )\n}\n\n@ext object Sireum {\n\n  def run(args: ISZ[String]): Z = $\n\n  def initRuntimeLibrary(): Unit = $\n\n}
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$23();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #656                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.message\n\nimport org.sireum._\nimport org.sireum.U64._\n\n@enum object Level {\n  \"InternalError\"\n  \"Error\"\n  \"Warning\"\n  \"Info\"\n}\n\n@datatype class Message(val level: Level.Type, val posOpt: Option[Position], val kind: String, val text: String) {\n\n  def isInternalError: B = {\n    return level == Level.InternalError\n  }\n\n  def isError: B = {\n    return level == Level.Error\n  }\n\n  def isWarning: B = {\n    return level == Level.Warning\n  }\n\n  def isInfo: B = {\n    return level == Level.Info\n  }\n\n  def fileUriOpt: Option[String] = {\n    posOpt match {\n      case Some(pos) => return pos.uriOpt\n      case _ => return None()\n    }\n  }\n}\n\nimport org.sireum.U32._\n\nobject Position {\n  val none: Position = FlatPos(None(), u32\"1\", u32\"1\", u32\"1\", u32\"1\", u32\"0\", u32\"0\")\n}\n\n@datatype trait Position {\n\n//  l\"\"\" invariant LinePos:            beginLine ≥ 1\n//                 ColumnPos:          beginColumn ≥ 1\n//                 EndLinePos:         endLine ≥ 1\n//                 EncColumnPos:       endColumn ≥ 1\n//                 OffsetNonNegative:  offset ≥ 0\n//                 LengthNonNegative:  length ≥ 0 \"\"\"\n\n  @pure def uriOpt: Option[String]\n\n  @pure def beginLine: Z\n\n  @pure def beginColumn: Z\n\n  @pure def endLine: Z\n\n  @pure def endColumn: Z\n\n  @pure def offset: Z\n\n  @pure def length: Z\n\n  @pure override def hash: Z = {\n    return (uriOpt, beginLine, endLine, endColumn, offset, length).hash\n  }\n\n  @pure def isEqual(other: Position): B = {\n    return uriOpt == other.uriOpt && beginLine == other.beginLine && beginColumn == other.beginColumn &&\n      endLine == other.endLine && endColumn == other.endColumn && offset == other.offset && length == other.length\n  }\n\n  @pure override def string: String = {\n    uriOpt match {\n      case Some(fileUri) =>\n        var i = ops.StringOps(fileUri).lastIndexOf(\'/\')\n        if (i < 0) {\n          i = 0\n        }\n        return s\"[${ops.StringOps(fileUri).substring(i, fileUri.size)}, $beginLine, $beginColumn]\"\n      case _ => return s\"[$beginLine, $beginColumn]\"\n    }\n\n  }\n\n  @pure def to(other: Position): Position = {\n    val pos1 = this\n    val pos2 = other\n    var docInfoOpt: Option[message.DocInfo] = None()\n    pos1 match {\n      case pos1: PosInfo => docInfoOpt = Some(pos1.info)\n      case _ =>\n        pos2 match {\n          case pos2: PosInfo => docInfoOpt = Some(pos2.info)\n          case _ =>\n        }\n    }\n    docInfoOpt match {\n      case Some(info) =>\n        return PosInfo(info, (conversions.Z.toU64(pos1.offset) << u64\"32\") |\n          conversions.Z.toU64(pos2.offset + pos2.length - pos1.offset))\n      case _ =>\n        return FlatPos(\n          uriOpt = pos1.uriOpt,\n          beginLine32 = conversions.Z.toU32(pos1.beginLine),\n          beginColumn32 = conversions.Z.toU32(pos1.beginColumn),\n          endLine32 = conversions.Z.toU32(pos2.endLine),\n          endColumn32 = conversions.Z.toU32(pos2.endColumn),\n          offset32 = conversions.Z.toU32(pos1.offset),\n          length32 = conversions.Z.toU32(pos2.offset + pos2.length - pos1.offset)\n        )\n    }\n  }\n\n}\n\n@datatype class FlatPos(\n  val uriOpt: Option[String],\n  val beginLine32: U32,\n  val beginColumn32: U32,\n  val endLine32: U32,\n  val endColumn32: U32,\n  val offset32: U32,\n  val length32: U32\n) extends Position {\n\n  @pure override def beginLine: Z = {\n    return conversions.U32.toZ(beginLine32)\n  }\n\n  @pure override def beginColumn: Z = {\n    return conversions.U32.toZ(beginColumn32)\n  }\n\n  @pure override def endLine: Z = {\n    return conversions.U32.toZ(endLine32)\n  }\n\n  @pure override def endColumn: Z = {\n    return conversions.U32.toZ(endColumn32)\n  }\n\n  @pure override def offset: Z = {\n    return conversions.U32.toZ(offset32)\n  }\n\n  @pure override def length: Z = {\n    return conversions.U32.toZ(length32)\n  }\n}\n\n@datatype class PosInfo(val info: DocInfo, val offsetLength: U64) extends Position {\n\n  @pure override def uriOpt: Option[String] = {\n    return info.uriOpt\n  }\n\n  @pure override def beginLine: Z = {\n    return conversions.U64.toZ(info.lineColumn(offsetLength) >>> u64\"32\")\n  }\n\n  @pure override def beginColumn: Z = {\n    return conversions.U64.toZ(info.lineColumn(offsetLength) & u64\"0xFFFFFFFF\")\n  }\n\n  @pure override def endLine: Z = {\n    val endOffset = offsetLength + ((offsetLength - u64\"1\") << u64\"32\")\n    return conversions.U64.toZ(info.lineColumn(endOffset) >>> u64\"32\")\n  }\n\n  @pure override def endColumn: Z = {\n    val endOffset = offsetLength + ((offsetLength - u64\"1\") << u64\"32\")\n    return conversions.U64.toZ(info.lineColumn(endOffset) & u64\"0xFFFFFFFF\")\n  }\n\n  @pure override def offset: Z = {\n    return conversions.U64.toZ(offsetLength >>> u64\"32\")\n  }\n\n  @pure override def length: Z = {\n    return conversions.U64.toZ(offsetLength & u64\"0xFFFFFFFF\")\n  }\n}\n\n@datatype class DocInfo(val uriOpt: Option[String], val lineOffsets: ISZ[U32]) {\n\n  @pure def lineColumn(offsetLength: U64): U64 = {\n    val offsetLine = conversions.U64.toU32(offsetLength >>> u64\"32\")\n    @pure def computeLC(i: Z): U64 = {\n      val line = conversions.Z.toU64(i + 1) << u64\"32\"\n      val column = conversions.U32.toU64(offsetLine - lineOffsets(i)) + u64\"1\"\n      return line | column\n    }\n    val size = lineOffsets.size\n    var i = size / 2\n    var max = size - 1\n    var min = z\"0\"\n    while (min < i && i <= max) {\n      val lineOffsetsI = lineOffsets(i)\n      if (offsetLine < lineOffsetsI) {\n        if (lineOffsets(i - 1) <= offsetLine) {\n          return computeLC(i - 1)\n        }\n        max = i\n        i = i - ((i - min) / 2)\n      } else if (offsetLine == lineOffsetsI) {\n        return computeLC(i)\n      } else {\n        min = i\n        i = i + (max - i) / 2\n      }\n    }\n    return if (i <= min) computeLC(min) else computeLC(max)\n  }\n}\n\nobject DocInfo {\n\n  @pure def create(uriOpt: Option[String], input: String): DocInfo = {\n    val inputOps = ops.StringOps(input)\n    var i = inputOps.indexOf(\'\\n\')\n    var lineOffsets = ISZ[U32](u32\"0\")\n    while (0 <= i && i < input.size) {\n      lineOffsets = lineOffsets :+ conversions.Z.toU32(i + 1)\n      i = inputOps.indexOfFrom(\'\\n\', i + 1)\n    }\n    return DocInfo(uriOpt, lineOffsets)\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$24();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #658                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.message\n\nimport org.sireum._\n\nobject Reporter {\n\n  @pure def create: Reporter = {\n    return ReporterImpl(ISZ())\n  }\n\n  @pure def combine(r1: Reporter, r2: Reporter): Reporter = {\n    return ReporterImpl(r1.messages ++ r2.messages)\n  }\n}\n\n@msig trait Reporter {\n  def messages: ISZ[Message]\n  def ignore: B\n  def setIgnore(newIgnore: B): Unit\n  def setMessages(newMessages: ISZ[Message]): Unit\n  def timing(desc: String, timeInMs: Z): Unit\n\n  def hasInternalError: B = {\n    for (m <- messages) {\n      m.level match {\n        case Level.InternalError => return T\n        case _ =>\n      }\n    }\n    return F\n  }\n\n  def hasError: B = {\n    for (m <- messages if m.isError || m.isInternalError) {\n      return T\n    }\n    return F\n  }\n\n  def hasWarning: B = {\n    for (m <- messages if m.isWarning) {\n      return T\n    }\n    return F\n  }\n\n  def hasIssue: B = {\n    for (m <- messages if m.isError || m.isWarning || m.isInternalError) {\n      return T\n    }\n    return F\n  }\n\n  def hasInfo: B = {\n    for (m <- messages if m.isInfo) {\n      return T\n    }\n    return F\n  }\n\n  def hasMessage: B = {\n    return messages.nonEmpty\n  }\n\n  def internalErrors: ISZ[Message] = {\n    return for (m <- messages if m.isInternalError) yield m\n  }\n\n  def errors: ISZ[Message] = {\n    return for (m <- messages if m.isError) yield m\n  }\n\n  def warnings: ISZ[Message] = {\n    return for (m <- messages if m.isWarning) yield m\n  }\n\n  def issues: ISZ[Message] = {\n    return for (m <- messages if m.isError || m.isWarning || m.isInternalError) yield m\n  }\n\n  def infos: ISZ[Message] = {\n    return for (m <- messages if m.isInfo) yield m\n  }\n\n  def report(m: Message): Unit = {\n    //assert(m.fileUriOpt.isEmpty || !ops.ISZOps(messages).contains(m))\n    if (!ignore) {\n      setMessages(messages :+ m)\n    }\n  }\n\n  def messagesByFileUri: HashSMap[Option[String], ISZ[Message]] = {\n    var r = HashSMap.empty[Option[String], ISZ[Message]]\n    for (m <- messages) {\n      val key: Option[String] = m.fileUriOpt\n      r.get(key) match {\n        case Some(ms) => r = r + key ~> (ms :+ m)\n        case _ => r = r + key ~> ISZ(m)\n      }\n    }\n    return r\n  }\n\n  def printMessages(): Unit = {\n    @pure def sortMessages(ms: ISZ[Message]): ISZ[Message] = {\n      return ops\n        .ISZOps(ms)\n        .sortWith((m1, m2) => {\n          (m1.posOpt, m2.posOpt) match {\n            case (Some(m1pos), Some(m2pos)) =>\n              if (m1pos.beginLine < m2pos.beginLine) T\n              else if (m1pos.beginLine > m2pos.beginLine) F\n              else if (m1pos.beginColumn < m2pos.beginColumn) T\n              else if (m1pos.beginColumn > m2pos.beginColumn) F\n              else false\n            case _ => false\n          }\n        })\n    }\n    val map = messagesByFileUri\n    val err = hasError\n    var first = T\n    for (kv <- map.entries) {\n      if (!first) {\n        cprintln(err, \"\")\n      }\n      first = F\n      val fileUriOpt = kv._1\n      val ms = kv._2\n      fileUriOpt match {\n        case Some(fileUri) =>\n          cprintln(err, s\"* $fileUri\")\n          for (m <- sortMessages(ms)) {\n            cprint(err, \"  \")\n            val int: String = if (m.level == Level.InternalError) \"INTERNAL ERROR -- \" else \"\"\n            val mText: String = m.posOpt match {\n              case Some(pos) => s\"- [${pos.beginLine}, ${pos.beginColumn}] $int${m.text}\"\n              case _ => s\"- ${m.text}\"\n            }\n            cprintln(err, mText)\n          }\n        case _ =>\n          for (m <- sortMessages(ms)) {\n            val int: String = if (m.level == Level.InternalError) \"INTERNAL ERROR -- \" else \"\"\n            val mText: String = m.posOpt match {\n              case Some(pos) => s\"- [${pos.beginLine}, ${pos.beginColumn}] $int${m.text}\"\n              case _ => s\"- ${m.text}\"\n            }\n            cprintln(err, mText)\n          }\n      }\n    }\n  }\n\n  def internalError(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.InternalError, posOpt, kind, message))\n    }\n  }\n\n  def error(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Error, posOpt, kind, message))\n    }\n  }\n\n  def warn(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Warning, posOpt, kind, message))\n    }\n  }\n\n  def info(posOpt: Option[Position], kind: String, message: String): Unit = {\n    if (!ignore) {\n      report(Message(Level.Info, posOpt, kind, message))\n    }\n  }\n\n  def reports(ms: ISZ[Message]): Unit = {\n    for (m <- ms) {\n      report(m)\n    }\n  }\n}\n\n@record class ReporterImpl(var _messages: ISZ[Message]) extends Reporter {\n\n  var ignore: B = F\n\n  def setIgnore(newIgnore: B): Unit = {\n    ignore = newIgnore\n  }\n\n  def messages: ISZ[Message] = {\n    return _messages\n  }\n\n  def setMessages(newMessages: ISZ[Message]): Unit = {\n    _messages = newMessages\n  }\n\n  def timing(desc: String, timeInMs: Z): Unit = {}\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$25();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #660                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject ObjPrinter {\n  val stTrue: ST = st\"true\"\n  val stFalse: ST = st\"false\"\n  val stZ: ST = st\"Z\"\n  val stZ8: ST = st\"Z8\"\n  val stZ16: ST = st\"Z16\"\n  val stZ32: ST = st\"Z32\"\n  val stZ64: ST = st\"Z64\"\n  val stN: ST = st\"N\"\n  val stN8: ST = st\"N8\"\n  val stN16: ST = st\"N16\"\n  val stN32: ST = st\"N32\"\n  val stN64: ST = st\"N64\"\n  val stS8: ST = st\"S8\"\n  val stS16: ST = st\"S16\"\n  val stS32: ST = st\"S32\"\n  val stS64: ST = st\"S64\"\n  val stU8: ST = st\"U8\"\n  val stU16: ST = st\"U16\"\n  val stU32: ST = st\"U32\"\n  val stU64: ST = st\"U64\"\n  val stString: ST = st\"String\"\n  val stDocInfo: ST = st\"message.DocInfo\"\n  val stPosition: ST = st\"message.Position\"\n  val stMessage: ST = st\"message.Message\"\n\n  val sGroupMax: Z = 10\n\n  @strictpure def printB(b: B): ST = if (b) stTrue else stFalse\n\n  @strictpure def printC(c: C): ST = st\"\'${ops.COps(c).escapeString}\'\"\n\n  @strictpure def printZ(n: Z): ST = printNumber(\"z\", n.string)\n\n  @strictpure def printZ8(n: Z8): ST = printNumber(\"z8\", n.string)\n\n  @strictpure def printZ16(n: Z16): ST = printNumber(\"z16\", n.string)\n\n  @strictpure def printZ32(n: Z32): ST = printNumber(\"z32\", n.string)\n\n  @strictpure def printZ64(n: Z64): ST = printNumber(\"z64\", n.string)\n\n  @strictpure def printN(n: N): ST = printNumber(\"n\", n.string)\n\n  @strictpure def printN8(n: N8): ST = printNumber(\"n8\", n.string)\n\n  @strictpure def printN16(n: N16): ST = printNumber(\"n16\", n.string)\n\n  @strictpure def printN32(n: N32): ST = printNumber(\"n32\", n.string)\n\n  @strictpure def printN64(n: N64): ST = printNumber(\"n64\", n.string)\n\n  @strictpure def printS8(n: S8): ST = printNumber(\"s8\", n.string)\n\n  @strictpure def printS16(n: S16): ST = printNumber(\"s16\", n.string)\n\n  @strictpure def printS32(n: S32): ST = printNumber(\"s32\", n.string)\n\n  @strictpure def printS64(n: S64): ST = printNumber(\"s64\", n.string)\n\n  @strictpure def printU8(n: U8): ST = printNumber(\"u8\", conversions.U8.toZ(n).string)\n\n  @strictpure def printU16(n: U16): ST = printNumber(\"u16\", conversions.U16.toZ(n).string)\n\n  @strictpure def printU32(n: U32): ST = printNumber(\"u32\", conversions.U32.toZ(n).string)\n\n  @strictpure def printU64(n: U64): ST = printNumber(\"u64\", conversions.U64.toZ(n).string)\n\n  @strictpure def printF32(n: F32): ST = printNumber(\"f32\", n.string)\n\n  @strictpure def printF64(n: F64): ST = printNumber(\"f64\", n.string)\n\n  @strictpure def printR(n: R): ST = printNumber(\"r\", n.string)\n\n  @strictpure def printNumber(prefix: String, s: String): ST = st\"\"\"$prefix\"$s\"\"\"\"\n\n  @strictpure def printString(s: String): ST = st\"\"\"\"${ops.StringOps(s).escapeST}\"\"\"\"\n\n  @pure def printOption[T](eType: ST, o: Option[T], f: T => ST): ST = {\n    o match {\n      case Some(v) => return st\"Option.some(${f(v)})\"\n      case _ => return st\"Option.none()\"\n    }\n  }\n\n  @pure def printMOption[T](eType: ST, o: MOption[T], f: T => ST): ST = {\n    o match {\n      case MSome(v) => return st\"MOption.some(${f(v)})\"\n      case _ => return st\"MOption.none()\"\n    }\n  }\n\n  @pure def printEither[L, R](lType: ST, rType: ST, o: Either[L, R], f0: L => ST, f1: R => ST): ST = {\n    o match {\n      case Either.Left(v) => return st\"Either.left(${f0(v)})\"\n      case Either.Right(v) => return st\"Either.right(${f1(v)})\"\n    }\n  }\n\n  @pure def printMEither[L, R](lType: ST, rType: ST, o: MEither[L, R], f0: L => ST, f1: R => ST): ST = {\n    o match {\n      case MEither.Left(v) => return st\"MEither.left(${f0(v)})\"\n      case MEither.Right(v) => return st\"MEither.right(${f1(v)})\"\n    }\n  }\n\n}\n\nimport ObjPrinter._\n\n@msig trait ObjPrinter {\n\n  def freshNum(): Z\n\n  def write(content: ST): Unit\n\n  def cache[T](o: T, f: () => ST): ST\n\n  def addMethod(tipe: ST, isStrictPure: B, body: ST): ST = {\n    val num = freshNum()\n    val ann: String = if (isStrictPure) \"@strictpure\" else \"@pure\"\n    val name = st\"object$num\"\n    write(\n      st\"\"\"  $ann def $name: $tipe =\n          |    $body\"\"\")\n    return name\n  }\n\n  def printISZ[E](elementType: ST, s: ISZ[E], e: E => ST): ST = {\n    return printIS(stZ, elementType, s, printZ _, e)\n  }\n\n  def printIS[I, E](indexType: ST, elementType: ST, s: IS[I, E], i: I => ST, e: E => ST): ST = {\n    val f: () => ST = { () =>\n      val t = st\"IS[$indexType, $elementType]\"\n      val elements = s.map(e)\n      if (elements.isEmpty) {\n        return st\"$t()\"\n      }\n      var ll = ISZ[ST]()\n      var l = ISZ[ST]()\n      for (e <- elements) {\n        l = l :+ e\n        if (l.size == sGroupMax) {\n          ll = ll :+ st\"${(l, \", \")}\"\n          l = ISZ()\n        }\n      }\n      if (l.size > 0) {\n        ll = ll :+ st\"${(l, \", \")}\"\n      }\n      addMethod(t, T,\n        if (ll.isEmpty) st\"$t()\"\n        else if (ll.size === 1) st\"$t(${(ll(0), \", \")})\"\n        else\n          st\"\"\"$t(\n              |  ${(ll, \",\\n\")})\"\"\")\n    }\n    return cache(s, f)\n  }\n\n  def printMS[I, E](indexType: ST, elementType: ST, s: MS[I, E], i: I => ST, e: E => ST): ST = {\n    val f: () => ST = { () =>\n      val t = st\"MS[$indexType, $elementType]\"\n      val elements = s.map(e)\n      if (elements.isEmpty) {\n        return st\"$t()\"\n      }\n      var ll = ISZ[ST]()\n      var l = ISZ[ST]()\n      for (e <- elements) {\n        l = l :+ e\n        if (l.size == sGroupMax) {\n          ll = ll :+ st\"${(l, \", \")}\"\n          l = ISZ()\n        }\n      }\n      if (l.size > 0) {\n        ll = ll :+ st\"${(l, \", \")}\"\n      }\n      addMethod(t, T,\n        if (ll.isEmpty) st\"$t()\"\n        else if (ll.size === 1) st\"$t(${(ll(0), \", \")})\"\n        else\n          st\"\"\"$t(\n              |  ${(ll, \",\\n\")}\"\"\")\n    }\n    return cache(s, f)\n  }\n\n  def printMap[K, V](keyType: ST, valueType: ST, o: Map[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"Map.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(Map ++ $entries)\"\n  }\n\n  def printSet[T](elementType: ST, o: Set[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"Set.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(Set ++ $elements)\"\n  }\n\n  def printHashMap[K, V](keyType: ST, valueType: ST, o: HashMap[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashMap.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(HashMap ++ $entries)\"\n  }\n\n  def printHashSet[T](elementType: ST, o: HashSet[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSet.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(HashSet ++ $elements)\"\n  }\n\n  def printHashSMap[K, V](keyType: ST, valueType: ST, o: HashSMap[K, V], k: K => ST, v: V => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSMap.empty[$keyType, $valueType]\"\n    }\n    val entries = printISZ[(K, V)](st\"($keyType, $valueType)\", o.entries, (p: (K, V)) => st\"(${k(p._1)}, ${v(p._2)})\")\n    return st\"(HashSMap ++ $entries)\"\n  }\n\n  def printHashSSet[T](elementType: ST, o: HashSSet[T], f: T => ST): ST = {\n    if (o.isEmpty) {\n      return st\"HashSSet.empty[$elementType]\"\n    }\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"(HashSSet ++ $elements)\"\n  }\n\n  def printStack[T](elementType: ST, o: Stack[T], f: T => ST): ST = {\n    val elements = printISZ[T](elementType, o.elements, f)\n    return st\"Stack($elements)\"\n  }\n\n  def printBag[T](elementType: ST, o: Bag[T], f: T => ST): ST = {\n    val map = printMap(elementType, stZ, o.map, f, printZ _)\n    return st\"Bag($map)\"\n  }\n\n  def printHashBag[T](elementType: ST, o: HashBag[T], f: T => ST): ST = {\n    val map = printHashMap(elementType, stZ, o.map, f, printZ _)\n    return st\"HashBag($map)\"\n  }\n\n  def printHashSBag[T](elementType: ST, o: HashSBag[T], f: T => ST): ST = {\n    val map = printHashSMap(elementType, stZ, o.map, f, printZ _)\n    return st\"HashSBag($map)\"\n  }\n\n  def printPoset[T](elementType: ST, o: Poset[T], e: T => ST): ST = {\n    if (o.nodesInverse.isEmpty) {\n      return st\"Poset.empty[$elementType]\"\n    }\n    val f = () => addMethod(st\"Poset[$elementType]\", F,\n      st\"\"\"{\n          |  var r = Poset.empty[$elementType]\n          |  for (n <- o.nodesInverse) {\n          |    r = r.addNode(n)\n          |  }\n          |  for (i <- 0 until o.nodesInverse.size) {\n          |    o.parents.get(i) match {\n          |      case Some(v) => r = Poset.Internal.addParents(r, i, v.elements)\n          |      case _ =>\n          |    }\n          |  }\n          |  return r\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printGraph[V, E](vType: ST, eType: ST, o: Graph[V, E], v: V => ST, e: E => ST): ST = {\n    if (o.nodesInverse.isEmpty) {\n      return st\"Graph.empty${if (o.multi) \"Multi\" else \"\"}[$vType, $eType]\"\n    }\n\n    def printEdge(edge: Graph.Internal.Edge[E]): ST = {\n      edge match {\n        case Graph.Internal.Edge.Plain(source, dest) => return st\"Graph.Internal.Edge.Plain($source, $dest)\"\n        case Graph.Internal.Edge.Data(source, dest, data) => return st\"Graph.Internal.Edge.Data($source, $dest, ${e(data)})\"\n      }\n    }\n\n    val f = () => addMethod(st\"Graph[$vType, $eType]\", F,\n      st\"\"\"{\n          |  var r = Graph.empty${if (o.multi) \"Multi\" else \"\"}[$vType, $eType]\n          |  ${(for (n <- o.nodesInverse) yield st\"r = r * ${v(n)}\", \"\\n\")}\n          |  ${(for (es <- o.outgoingEdges.values; e <- es.elements) yield st\"r = Graph.Internal.addEdge(r, ${printEdge(e)})\", \"\\n\")}\n          |  return r\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printUnionFind[E](eType: ST, o: UnionFind[E], e: E => ST): ST = {\n    if (o.size === 0) {\n      return st\"UnionFind.create[$eType](ISZ())\"\n    }\n    val f = () => addMethod(st\"UnionFind[$eType]\", F,\n      st\"\"\"{\n          |  val elementsInverse = ${printISZ(eType, o.elementsInverse, e)}\n          |  var elements = HashSMap.empty[T, UnionFind.Index]\n          |  for (i <- z\"0\" until elementsInverse.size) {\n          |    elements = elements + elementsInverse(i) ~> i\n          |  }\n          |  val parentsOf = ${printISZ(stZ, o.parentOf, printZ _)}\n          |  val sizeOf = ${printISZ(stZ, o.sizeOf, printZ _)}\n          |  return UnionFind[$eType](elements, elementsInverse, parentsOf, sizeOf)\n          |}\"\"\")\n    return cache(o, f)\n  }\n\n  def printMessage(o: message.Message): ST = {\n    val f = () => addMethod(stMessage, T,\n      st\"\"\"message.Message(\n          |  message.Level.${o.level},\n          |  ${printOption(stPosition, o.posOpt, printPosition _)},\n          |  ${printString(o.kind)},\n          |  ${printString(o.text)})\"\"\")\n    return cache(o, f)\n  }\n\n  def printPosition(o: message.Position): ST = {\n    o match {\n      case o: message.FlatPos =>\n        val f = () => addMethod(stPosition, T,\n          st\"\"\"message.FlatPos(\n              |  uriOpt = ${printOption(stString, o.uriOpt, printString _)},\n              |  beginLine32 = ${printU32(o.beginLine32)},\n              |  beginColumn32 = ${printU32(o.beginColumn32)},\n              |  endLine32 = ${printU32(o.endLine32)},\n              |  endColumn32 = ${printU32(o.endColumn32)},\n              |  offset32 = ${printU32(o.offset32)},\n              |  length32 = ${printU32(o.length32)})\"\"\")\n        return cache(o, f)\n      case o: message.PosInfo =>\n        val f = () => st\"message.PosInfo(${printDocInfo(o.info)}, ${printU64(o.offsetLength)})\"\n        return cache(o, f)\n    }\n  }\n\n  def printDocInfo(o: message.DocInfo): ST = {\n    val f = () => addMethod(stDocInfo, T,\n      st\"\"\"message.DocInfo(\n          |  ${printOption[String](stString, o.uriOpt, printString _)},\n          |  ${printISZ(stU32, o.lineOffsets, printU32 _)})\"\"\")\n    return cache(o, f)\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$26();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #662                // String // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from CliOpt.scala\n\npackage org.sireum.cli\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printCliOpt(o: CliOpt): ST = {\n      o match {\n        case o: CliOpt.Group => return printCliOptGroup(o)\n        case o: CliOpt.Tool => return printCliOptTool(o)\n      }\n    }\n\n    @pure def printCliOptGroup(o: CliOpt.Group): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Group\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"description\", printString(o.description)),\n        (\"header\", printString(o.header)),\n        (\"unlisted\", printB(o.unlisted)),\n        (\"subs\", printISZ(F, o.subs, printCliOpt _))\n      ))\n    }\n\n    @pure def printCliOptTool(o: CliOpt.Tool): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Tool\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"command\", printString(o.command)),\n        (\"description\", printString(o.description)),\n        (\"header\", printString(o.header)),\n        (\"usage\", printString(o.usage)),\n        (\"usageDescOpt\", printOption(T, o.usageDescOpt, printString _)),\n        (\"opts\", printISZ(F, o.opts, printCliOptOpt _)),\n        (\"groups\", printISZ(F, o.groups, printCliOptOptGroup _))\n      ))\n    }\n\n    @pure def printCliOptOptGroup(o: CliOpt.OptGroup): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.OptGroup\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"opts\", printISZ(F, o.opts, printCliOptOpt _))\n      ))\n    }\n\n    @pure def printCliOptOpt(o: CliOpt.Opt): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Opt\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"longKey\", printString(o.longKey)),\n        (\"shortKey\", printOption(T, o.shortKey, printC _)),\n        (\"tpe\", printCliOptType(o.tpe)),\n        (\"description\", printString(o.description))\n      ))\n    }\n\n    @pure def printCliOptType(o: CliOpt.Type): ST = {\n      o match {\n        case o: CliOpt.Type.Flag => return printCliOptTypeFlag(o)\n        case o: CliOpt.Type.Num => return printCliOptTypeNum(o)\n        case o: CliOpt.Type.NumFlag => return printCliOptTypeNumFlag(o)\n        case o: CliOpt.Type.NumChoice => return printCliOptTypeNumChoice(o)\n        case o: CliOpt.Type.Str => return printCliOptTypeStr(o)\n        case o: CliOpt.Type.Choice => return printCliOptTypeChoice(o)\n        case o: CliOpt.Type.Path => return printCliOptTypePath(o)\n      }\n    }\n\n    @pure def printCliOptTypeFlag(o: CliOpt.Type.Flag): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Flag\"\"\"\"),\n        (\"default\", printB(o.default))\n      ))\n    }\n\n    @pure def printCliOptTypeNum(o: CliOpt.Type.Num): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Num\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"default\", printZ(o.default)),\n        (\"min\", printOption(T, o.min, printZ _)),\n        (\"max\", printOption(T, o.max, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeNumFlag(o: CliOpt.Type.NumFlag): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.NumFlag\"\"\"\"),\n        (\"default\", printZ(o.default)),\n        (\"min\", printOption(T, o.min, printZ _)),\n        (\"max\", printOption(T, o.max, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeNumChoice(o: CliOpt.Type.NumChoice): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.NumChoice\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"choices\", printISZ(T, o.choices, printZ _))\n      ))\n    }\n\n    @pure def printCliOptTypeStr(o: CliOpt.Type.Str): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Str\"\"\"\"),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"default\", printOption(T, o.default, printString _))\n      ))\n    }\n\n    @pure def printCliOptTypeChoice(o: CliOpt.Type.Choice): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Choice\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"sep\", printOption(T, o.sep, printC _)),\n        (\"elements\", printISZ(T, o.elements, printString _))\n      ))\n    }\n\n    @pure def printCliOptTypePath(o: CliOpt.Type.Path): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"CliOpt.Type.Path\"\"\"\"),\n        (\"multiple\", printB(o.multiple)),\n        (\"default\", printOption(T, o.default, printString _))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parseCliOpt(): CliOpt = {\n      val t = parser.parseObjectTypes(ISZ(\"CliOpt.Group\", \"CliOpt.Tool\"))\n      t.native match {\n        case \"CliOpt.Group\" => val r = parseCliOptGroupT(T); return r\n        case \"CliOpt.Tool\" => val r = parseCliOptToolT(T); return r\n        case _ => val r = parseCliOptToolT(T); return r\n      }\n    }\n\n    def parseCliOptGroup(): CliOpt.Group = {\n      val r = parseCliOptGroupT(F)\n      return r\n    }\n\n    def parseCliOptGroupT(typeParsed: B): CliOpt.Group = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Group\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"header\")\n      val header = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"unlisted\")\n      val unlisted = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"subs\")\n      val subs = parser.parseISZ(parseCliOpt _)\n      parser.parseObjectNext()\n      return CliOpt.Group(name, description, header, unlisted, subs)\n    }\n\n    def parseCliOptTool(): CliOpt.Tool = {\n      val r = parseCliOptToolT(F)\n      return r\n    }\n\n    def parseCliOptToolT(typeParsed: B): CliOpt.Tool = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Tool\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"command\")\n      val command = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"header\")\n      val header = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"usage\")\n      val usage = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"usageDescOpt\")\n      val usageDescOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"opts\")\n      val opts = parser.parseISZ(parseCliOptOpt _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"groups\")\n      val groups = parser.parseISZ(parseCliOptOptGroup _)\n      parser.parseObjectNext()\n      return CliOpt.Tool(name, command, description, header, usage, usageDescOpt, opts, groups)\n    }\n\n    def parseCliOptOptGroup(): CliOpt.OptGroup = {\n      val r = parseCliOptOptGroupT(F)\n      return r\n    }\n\n    def parseCliOptOptGroupT(typeParsed: B): CliOpt.OptGroup = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.OptGroup\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"opts\")\n      val opts = parser.parseISZ(parseCliOptOpt _)\n      parser.parseObjectNext()\n      return CliOpt.OptGroup(name, opts)\n    }\n\n    def parseCliOptOpt(): CliOpt.Opt = {\n      val r = parseCliOptOptT(F)\n      return r\n    }\n\n    def parseCliOptOptT(typeParsed: B): CliOpt.Opt = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Opt\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"longKey\")\n      val longKey = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"shortKey\")\n      val shortKey = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"tpe\")\n      val tpe = parseCliOptType()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      return CliOpt.Opt(name, longKey, shortKey, tpe, description)\n    }\n\n    def parseCliOptType(): CliOpt.Type = {\n      val t = parser.parseObjectTypes(ISZ(\"CliOpt.Type.Flag\", \"CliOpt.Type.Num\", \"CliOpt.Type.NumFlag\", \"CliOpt.Type.NumChoice\", \"CliOpt.Type.Str\", \"CliOpt.Type.Choice\", \"CliOpt.Type.Path\"))\n      t.native match {\n        case \"CliOpt.Type.Flag\" => val r = parseCliOptTypeFlagT(T); return r\n        case \"CliOpt.Type.Num\" => val r = parseCliOptTypeNumT(T); return r\n        case \"CliOpt.Type.NumFlag\" => val r = parseCliOptTypeNumFlagT(T); return r\n        case \"CliOpt.Type.NumChoice\" => val r = parseCliOptTypeNumChoiceT(T); return r\n        case \"CliOpt.Type.Str\" => val r = parseCliOptTypeStrT(T); return r\n        case \"CliOpt.Type.Choice\" => val r = parseCliOptTypeChoiceT(T); return r\n        case \"CliOpt.Type.Path\" => val r = parseCliOptTypePathT(T); return r\n        case _ => val r = parseCliOptTypePathT(T); return r\n      }\n    }\n\n    def parseCliOptTypeFlag(): CliOpt.Type.Flag = {\n      val r = parseCliOptTypeFlagT(F)\n      return r\n    }\n\n    def parseCliOptTypeFlagT(typeParsed: B): CliOpt.Type.Flag = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Flag\")\n      }\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseB()\n      parser.parseObjectNext()\n      return CliOpt.Type.Flag(default)\n    }\n\n    def parseCliOptTypeNum(): CliOpt.Type.Num = {\n      val r = parseCliOptTypeNumT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumT(typeParsed: B): CliOpt.Type.Num = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Num\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"min\")\n      val min = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"max\")\n      val max = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Num(sep, default, min, max)\n    }\n\n    def parseCliOptTypeNumFlag(): CliOpt.Type.NumFlag = {\n      val r = parseCliOptTypeNumFlagT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumFlagT(typeParsed: B): CliOpt.Type.NumFlag = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.NumFlag\")\n      }\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"min\")\n      val min = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"max\")\n      val max = parser.parseOption(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.NumFlag(default, min, max)\n    }\n\n    def parseCliOptTypeNumChoice(): CliOpt.Type.NumChoice = {\n      val r = parseCliOptTypeNumChoiceT(F)\n      return r\n    }\n\n    def parseCliOptTypeNumChoiceT(typeParsed: B): CliOpt.Type.NumChoice = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.NumChoice\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"choices\")\n      val choices = parser.parseISZ(parser.parseZ _)\n      parser.parseObjectNext()\n      return CliOpt.Type.NumChoice(sep, choices)\n    }\n\n    def parseCliOptTypeStr(): CliOpt.Type.Str = {\n      val r = parseCliOptTypeStrT(F)\n      return r\n    }\n\n    def parseCliOptTypeStrT(typeParsed: B): CliOpt.Type.Str = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Str\")\n      }\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Str(sep, default)\n    }\n\n    def parseCliOptTypeChoice(): CliOpt.Type.Choice = {\n      val r = parseCliOptTypeChoiceT(F)\n      return r\n    }\n\n    def parseCliOptTypeChoiceT(typeParsed: B): CliOpt.Type.Choice = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Choice\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"sep\")\n      val sep = parser.parseOption(parser.parseC _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"elements\")\n      val elements = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Choice(name, sep, elements)\n    }\n\n    def parseCliOptTypePath(): CliOpt.Type.Path = {\n      val r = parseCliOptTypePathT(F)\n      return r\n    }\n\n    def parseCliOptTypePathT(typeParsed: B): CliOpt.Type.Path = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"CliOpt.Type.Path\")\n      }\n      parser.parseObjectKey(\"multiple\")\n      val multiple = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"default\")\n      val default = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return CliOpt.Type.Path(multiple, default)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromCliOpt(o: CliOpt, isCompact: B): String = {\n    val st = Printer.printCliOpt(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOpt(s: String): Either[CliOpt, Json.ErrorMsg] = {\n    def fCliOpt(parser: Parser): CliOpt = {\n      val r = parser.parseCliOpt()\n      return r\n    }\n    val r = to(s, fCliOpt _)\n    return r\n  }\n\n  def fromCliOptGroup(o: CliOpt.Group, isCompact: B): String = {\n    val st = Printer.printCliOptGroup(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptGroup(s: String): Either[CliOpt.Group, Json.ErrorMsg] = {\n    def fCliOptGroup(parser: Parser): CliOpt.Group = {\n      val r = parser.parseCliOptGroup()\n      return r\n    }\n    val r = to(s, fCliOptGroup _)\n    return r\n  }\n\n  def fromCliOptTool(o: CliOpt.Tool, isCompact: B): String = {\n    val st = Printer.printCliOptTool(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTool(s: String): Either[CliOpt.Tool, Json.ErrorMsg] = {\n    def fCliOptTool(parser: Parser): CliOpt.Tool = {\n      val r = parser.parseCliOptTool()\n      return r\n    }\n    val r = to(s, fCliOptTool _)\n    return r\n  }\n\n  def fromCliOptOptGroup(o: CliOpt.OptGroup, isCompact: B): String = {\n    val st = Printer.printCliOptOptGroup(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptOptGroup(s: String): Either[CliOpt.OptGroup, Json.ErrorMsg] = {\n    def fCliOptOptGroup(parser: Parser): CliOpt.OptGroup = {\n      val r = parser.parseCliOptOptGroup()\n      return r\n    }\n    val r = to(s, fCliOptOptGroup _)\n    return r\n  }\n\n  def fromCliOptOpt(o: CliOpt.Opt, isCompact: B): String = {\n    val st = Printer.printCliOptOpt(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptOpt(s: String): Either[CliOpt.Opt, Json.ErrorMsg] = {\n    def fCliOptOpt(parser: Parser): CliOpt.Opt = {\n      val r = parser.parseCliOptOpt()\n      return r\n    }\n    val r = to(s, fCliOptOpt _)\n    return r\n  }\n\n  def fromCliOptType(o: CliOpt.Type, isCompact: B): String = {\n    val st = Printer.printCliOptType(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptType(s: String): Either[CliOpt.Type, Json.ErrorMsg] = {\n    def fCliOptType(parser: Parser): CliOpt.Type = {\n      val r = parser.parseCliOptType()\n      return r\n    }\n    val r = to(s, fCliOptType _)\n    return r\n  }\n\n  def fromCliOptTypeFlag(o: CliOpt.Type.Flag, isCompact: B): String = {\n    val st = Printer.printCliOptTypeFlag(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeFlag(s: String): Either[CliOpt.Type.Flag, Json.ErrorMsg] = {\n    def fCliOptTypeFlag(parser: Parser): CliOpt.Type.Flag = {\n      val r = parser.parseCliOptTypeFlag()\n      return r\n    }\n    val r = to(s, fCliOptTypeFlag _)\n    return r\n  }\n\n  def fromCliOptTypeNum(o: CliOpt.Type.Num, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNum(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNum(s: String): Either[CliOpt.Type.Num, Json.ErrorMsg] = {\n    def fCliOptTypeNum(parser: Parser): CliOpt.Type.Num = {\n      val r = parser.parseCliOptTypeNum()\n      return r\n    }\n    val r = to(s, fCliOptTypeNum _)\n    return r\n  }\n\n  def fromCliOptTypeNumFlag(o: CliOpt.Type.NumFlag, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNumFlag(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNumFlag(s: String): Either[CliOpt.Type.NumFlag, Json.ErrorMsg] = {\n    def fCliOptTypeNumFlag(parser: Parser): CliOpt.Type.NumFlag = {\n      val r = parser.parseCliOptTypeNumFlag()\n      return r\n    }\n    val r = to(s, fCliOptTypeNumFlag _)\n    return r\n  }\n\n  def fromCliOptTypeNumChoice(o: CliOpt.Type.NumChoice, isCompact: B): String = {\n    val st = Printer.printCliOptTypeNumChoice(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeNumChoice(s: String): Either[CliOpt.Type.NumChoice, Json.ErrorMsg] = {\n    def fCliOptTypeNumChoice(parser: Parser): CliOpt.Type.NumChoice = {\n      val r = parser.parseCliOptTypeNumChoice()\n      return r\n    }\n    val r = to(s, fCliOptTypeNumChoice _)\n    return r\n  }\n\n  def fromCliOptTypeStr(o: CliOpt.Type.Str, isCompact: B): String = {\n    val st = Printer
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$2();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #664                // String .printCliOptTypeStr(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeStr(s: String): Either[CliOpt.Type.Str, Json.ErrorMsg] = {\n    def fCliOptTypeStr(parser: Parser): CliOpt.Type.Str = {\n      val r = parser.parseCliOptTypeStr()\n      return r\n    }\n    val r = to(s, fCliOptTypeStr _)\n    return r\n  }\n\n  def fromCliOptTypeChoice(o: CliOpt.Type.Choice, isCompact: B): String = {\n    val st = Printer.printCliOptTypeChoice(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypeChoice(s: String): Either[CliOpt.Type.Choice, Json.ErrorMsg] = {\n    def fCliOptTypeChoice(parser: Parser): CliOpt.Type.Choice = {\n      val r = parser.parseCliOptTypeChoice()\n      return r\n    }\n    val r = to(s, fCliOptTypeChoice _)\n    return r\n  }\n\n  def fromCliOptTypePath(o: CliOpt.Type.Path, isCompact: B): String = {\n    val st = Printer.printCliOptTypePath(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toCliOptTypePath(s: String): Either[CliOpt.Type.Path, Json.ErrorMsg] = {\n    def fCliOptTypePath(parser: Parser): CliOpt.Type.Path = {\n      val r = parser.parseCliOptTypePath()\n      return r\n    }\n    val r = to(s, fCliOptTypePath _)\n    return r\n  }\n\n}
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$27();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #666                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.cli\n\nimport org.sireum._\n\n@datatype trait CliOpt {\n  @pure def name: String\n\n  @pure def command: String\n\n  @pure def description: String\n\n  @pure def header: String\n\n  @pure def unlisted: B\n}\n\nobject CliOpt {\n\n  val tqs: String = \"\\\"\\\"\\\"\"\n\n  @datatype class Group(\n    val name: String,\n    val description: String,\n    val header: String,\n    val unlisted: B,\n    val subs: ISZ[CliOpt]\n  ) extends CliOpt {\n\n    @pure def command: String = {\n      return name\n    }\n  }\n\n  @datatype class Tool(\n    val name: String,\n    val command: String,\n    val description: String,\n    val header: String,\n    val usage: String,\n    val usageDescOpt: Option[String],\n    val opts: ISZ[Opt],\n    val groups: ISZ[OptGroup]\n  ) extends CliOpt {\n    override def unlisted: B = {\n      return F\n    }\n  }\n\n  @datatype class OptGroup(val name: String, val opts: ISZ[Opt])\n\n  @datatype class Opt(val name: String, val longKey: String, val shortKey: Option[C], val tpe: Type, val description: String)\n\n  @datatype trait Type\n\n  object Type {\n\n    @datatype class Flag(val default: B) extends Type\n\n    @datatype class Num(val sep: Option[C], val default: Z, val min: Option[Z], val max: Option[Z]) extends Type\n\n    @datatype class NumFlag(val default: Z, val min: Option[Z], val max: Option[Z]) extends Type\n\n    @datatype class NumChoice(val sep: Option[C], val choices: ISZ[Z]) extends Type\n\n    @datatype class Str(val sep: Option[C], val default: Option[String]) extends Type\n\n    @datatype class Choice(val name: String, val sep: Option[C], val elements: ISZ[String]) extends Type\n\n    @datatype class Path(val multiple: B, val default: Option[String]) extends Type\n\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$28();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #668                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@record trait MEither[L, R] {\n\n  @pure def isLeft: B = Contract.Only(Ensures(Res == ∃{e: L => MEither.Left[L, R](e) == this}))\n\n  @pure def isRight: B = Contract.Only(Ensures(!isLeft))\n\n  @pure def leftOpt: MOption[L] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(MEither.Left[L, R](Res[MOption[L]].get) == this)\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(Res == MNone[L]())\n    ),\n  )\n\n  @pure def left: L = Contract.Only(\n    Requires(isLeft),\n    Ensures(MEither.Left[L, R](Res) == this)\n  )\n\n  @pure def rightOpt: MOption[R] = Contract.Only(\n    Case(\n      \"Left\",\n      Requires(isLeft),\n      Ensures(Res == MNone[R]())\n    ),\n    Case(\n      \"Right\",\n      Requires(isRight),\n      Ensures(MEither.Right[L, R](Res[MOption[R]].get) == this)\n    )\n  )\n\n  @pure def right: R\n}\n\nobject MEither {\n\n  @record class Left[L, R](val value: L) extends MEither[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def leftOpt: MOption[L] = {\n      Contract(Ensures(Res == MSome(value)))\n      return MSome(value)\n    }\n\n    @pure override def left: L = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n    @pure override def rightOpt: MOption[R] = {\n      Contract(Ensures(Res == MNone[R]()))\n      return MNone()\n    }\n\n    @pure override def right: R = {\n      Contract(Requires(F))\n      halt(\"Invalid \'MEither.Left\' operation \'right\'.\")\n    }\n\n  }\n\n  @record class Right[L, R](val value: R) extends MEither[L, R] {\n\n    @pure override def isLeft: B = {\n      Contract(Ensures(!Res[B]))\n      return F\n    }\n\n    @pure override def isRight: B = {\n      Contract(Ensures(Res))\n      return T\n    }\n\n    @pure override def leftOpt: MOption[L] = {\n      Contract(Ensures(Res == MNone[L]()))\n      return MNone()\n    }\n\n    @pure override def left: L = {\n      Contract(Requires(F))\n      halt(\"Invalid \'MEither.Right\' operation \'left\'.\")\n    }\n\n    @pure override def rightOpt: MOption[R] = {\n      Contract(Ensures(Res == MSome(value)))\n      return MSome(value)\n    }\n\n    @pure override def right: R = {\n      Contract(Ensures(Res == value))\n      return value\n    }\n\n  }\n\n  @strictpure def left[L, R](value: L): MEither[L, R] = Left(value)\n\n  @strictpure def right[L, R](value: R): MEither[L, R] = Right(value)\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$29();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #670                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Use (patched) AntlrWorks at https://github.com/sireum/antlrworks to generate the parser/lexer\n\npackage org.sireum.parser\n\nimport org.sireum._\nimport org.sireum.U32._\nimport org.sireum.message.Position\n\n@datatype trait ParseTree {\n  @pure def ruleName: String\n  @pure def toST: ST\n  @pure def tipe: U32\n\n  override def string: String = {\n    return toST.render\n  }\n}\n\nobject ParseTree {\n\n  @datatype class Leaf(val text: String,\n                       @hidden val ruleName: String,\n                       @hidden val tipe: U32,\n                       @hidden val isHidden: B,\n                       @hidden val posOpt: Option[Position]) extends ParseTree {\n    @pure override def toST: ST = {\n      return if (ops.StringOps(ruleName).startsWith(\"\'\")) st\"\"\"\"${ops.StringOps(text).escapeST}\"\"\"\"\n      else st\"\"\"$ruleName[\"${ops.StringOps(text).escapeST}\"]\"\"\"\n    }\n  }\n\n  @datatype class Node(val children: ISZ[ParseTree],\n                       @hidden val ruleName: String,\n                       @hidden val tipe: U32) extends ParseTree {\n    @strictpure override def toST: ST = st\"\"\"$ruleName(${(for (child <- children) yield child.toST, \", \")})\"\"\"\n  }\n\n  @record class DotGenerator {\n    var fresh: Z = -1\n    var nodes: ISZ[ST] = ISZ()\n    var edges: ISZ[ST] = ISZ()\n\n    def toDot(root: ParseTree): ST = {\n      def rec(tree: ParseTree): ST = {\n        fresh = fresh + 1\n        val name = st\"n$fresh\"\n        tree match {\n          case tree: Node =>\n            nodes = nodes :+ st\"\"\"$name [label = \"${tree.ruleName}\"]\"\"\"\n            for (child <- tree.children) {\n              val childName = rec(child)\n              edges = edges :+ st\"\"\"$name -> $childName\"\"\"\n            }\n          case tree: Leaf =>\n            nodes = nodes :+ st\"\"\"$name [label = ${tree.toST}]\"\"\"\n        }\n        return name\n      }\n\n      rec(root)\n      val r =\n        st\"\"\"digraph G {\n            |  node [shape = \"rect\"]\n            |\n            |  ${(nodes, \"\\n\")}\n            |\n            |  ${(edges, \"\\n\")}\n            |}\"\"\"\n      return r\n    }\n  }\n\n  object Node {\n    @strictpure def empty: Node = Node(ISZ(), \"Tree\", u32\"-1\")\n  }\n\n  @sig trait BinaryPrecedenceOps[Builder, T1, T2] {\n    @pure def messageKind: String\n\n    @pure def isBinary(t: T2): B\n\n    @pure def isRightAssoc(t: T2): B\n\n    @pure def isHigherPrecedence(n1: Z, n2: Z): B\n\n    @pure def lowestPrecedence: Z\n\n    @pure def shouldParenthesizeOperands(t: T2): B\n\n    @pure def precedence(t: T2): Option[Z]\n\n    @pure def posOpt(t: T2): Option[message.Position]\n\n    @pure def parenthesize(builder: Builder, t: T2): T2\n\n    @pure def binary(builder: Builder, left: T2, op: T2, right: T2): T2\n\n    @pure def transform(builder: Builder, tree: T1): T2\n\n    @pure def toString(t: T2): String\n  }\n\n\n  // T1[exp] ( T1[op] T1[exp] )* => T2[exp]\n  def rewriteBinary[Builder, T1, T2](builder: Builder,\n                                     bp: BinaryPrecedenceOps[Builder, T1, T2],\n                                     trees: ISZ[T1],\n                                     reporter: message.Reporter): T2 = {\n    def construct(ts: ISZ[T2], rightAssoc: B, start: Z, stop: Z): T2 = {\n      if (rightAssoc) {\n        var r = ts(stop)\n        for (i <- stop - 2 to start by -2) {\n          val op = ts(i + 1)\n          var l = ts(i)\n          if (bp.shouldParenthesizeOperands(op)) {\n            if (bp.isBinary(l)) {\n              l = bp.parenthesize(builder, l)\n            }\n            if (bp.shouldParenthesizeOperands(op)) {\n              r = bp.parenthesize(builder, r)\n            }\n          }\n          r = bp.binary(builder, l, op, r)\n        }\n        return r\n      } else {\n        var l = ts(start)\n        for (i <- start + 2 to stop by 2) {\n          val op = ts(i - 1)\n          var r = ts(i)\n          if (bp.shouldParenthesizeOperands(op)) {\n            if (bp.isBinary(l)) {\n              l = bp.parenthesize(builder, l)\n            }\n            if (bp.shouldParenthesizeOperands(op)) {\n              r = bp.parenthesize(builder, r)\n            }\n          }\n          l = bp.binary(builder, l, op, r)\n        }\n        return l\n      }\n    }\n\n    def maxPrecedence(ts: ISZ[T2]): Z = {\n      var max = bp.lowestPrecedence\n      for (e <- ts) {\n        bp.precedence(e) match {\n          case Some(n) if bp.isHigherPrecedence(n, max) => max = n\n          case _ =>\n        }\n      }\n      return max\n    }\n\n    def reduceHighestPrecedence(acs: ISZ[T2]): ISZ[T2] = {\n      val max = maxPrecedence(acs)\n      val maxOpt: Option[Z] = Some(max)\n\n      def findMaxPrecedenceIndex(from: Z): Z = {\n        for (i <- from until acs.size if bp.precedence(acs(i)) == maxOpt) {\n          return i\n        }\n        return acs.size\n      }\n\n      var newAcs = ISZ[T2]()\n      var start = findMaxPrecedenceIndex(1)\n      for (j <- 0 to start - 2) {\n        newAcs = newAcs :+ acs(j)\n      }\n      while (start < acs.size) {\n        val startOp = acs(start)\n        var i = start + 2\n        var found = false\n        while (!found && i < acs.size) {\n          val op = acs(i)\n          if (bp.precedence(op) == bp.precedence(startOp)) {\n            if (bp.isRightAssoc(op) != bp.isRightAssoc(op)) {\n              reporter.error(bp.posOpt(op), bp.messageKind,\n                s\"Could not mix right/left associative operators with the same precedence: ${bp.toString(op)}, ${bp.toString(startOp)}\")\n            }\n            i = i + 2\n          } else {\n            found = true\n          }\n        }\n        if (i - start >= 2) {\n          newAcs = newAcs :+ construct(acs, bp.isRightAssoc(startOp), start - 1, i - 1)\n        } else {\n          for (j <- start - 1 until i) {\n            newAcs = newAcs :+ acs(j)\n          }\n        }\n\n        start = findMaxPrecedenceIndex(i + 2)\n        if (start < acs.size) {\n          for (j <- i to start - 2) {\n            newAcs = newAcs :+ acs(j)\n          }\n        } else {\n          for (j <- i until acs.size) {\n            newAcs = newAcs :+ acs(j)\n          }\n        }\n      }\n      return newAcs\n    }\n\n    var acs: ISZ[T2] = for (t <- trees) yield bp.transform(builder, t)\n    while (acs.size != 1) {\n      acs = reduceHighestPrecedence(acs)\n    }\n    return acs(0)\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$30();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #672                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from JSON.g\n\npackage org.sireum.parser\n\n\nimport org.sireum._\nimport org.sireum.U32._\nimport org.sireum.U64._\nimport org.sireum.conversions.U32.toC\n\nobject Json {\n  @range(min = 0, max = 9) class State\n}\n\nimport Json.State\nimport Json.State._\n\nobject JsonParser {\n\n  @datatype class Result(val kind: Result.Kind.Type, val tree: ParseTree, val newIndex: Z) {\n    def leaf: ParseTree.Leaf = {\n      return tree.asInstanceOf[ParseTree.Leaf]\n    }\n  }\n\n  object Result {\n\n    @enum object Kind {\n      \'Normal\n      \'LexicalError\n      \'GrammaticalError\n    }\n\n    @strictpure def create(tree: ParseTree, newIndex: Z): Result =\n      Result(Result.Kind.Normal, tree, newIndex)\n\n    @strictpure def error(isLexical: B, index: Z): Result =\n      Result(if (isLexical) Result.Kind.LexicalError else Result.Kind.GrammaticalError, errorLeaf, index)\n\n  }\n\n  @record class Context(val ruleName: String,\n                        val ruleType: U32,\n                        val accepting: IS[State, B],\n                        var state: State,\n                        var resOpt: Option[Result],\n                        var j: Z,\n                        var max: Z,\n                        var initial: B,\n                        var trees: ISZ[ParseTree],\n                        var found: B,\n                        var failIndex: Z,\n                        var isLexical: B) {\n\n    def updateTerminal(token: ParseTree.Leaf, newState: State): Unit = {\n      found = T\n      j = j + 1\n      initial = F\n      state = newState\n      trees = trees :+ token\n      if (accepting(state)) {\n        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))\n      }\n    }\n\n    def updateNonTerminal(r: Result, newState: State): Unit = {\n      found = T\n      initial = F\n      j = r.newIndex\n      state = newState\n      trees = trees :+ r.tree\n      if (accepting(state)) {\n        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))\n      }\n    }\n  }\n\n  object Context {\n    @pure def create(ruleName: String, ruleType: U32, accepts: ISZ[State], i: Z): Context = {\n      val accepting = MS.create[State, B](10, F)\n      for (accept <- accepts) {\n        accepting(accept) = T\n      }\n      return Context(\n        ruleName = ruleName,\n        ruleType = ruleType,\n        accepting = accepting.toIS,\n        state = state\"0\",\n        resOpt = None(),\n        trees = ISZ[ParseTree](),\n        j = i,\n        max = i,\n        initial = T,\n        found = F,\n        failIndex = 0,\n        isLexical = F\n      )\n    }\n  }\n\n  @record class LContext(val accepting: IS[State, B], var state: State, var j: Z, var afterAcceptIndex: Z, var found: B) {\n    def update(newState: State): Unit = {\n      state = newState\n      found = T\n      if (accepting(state)) {\n        afterAcceptIndex = j + 1\n      }\n    }\n  }\n\n  object LContext {\n    @pure def create(accepts: ISZ[State], i: Z): LContext = {\n      val accepting = MS.create[State, B](10, F)\n      for (accept <- accepts) {\n        accepting(accept) = T\n      }\n      return LContext(accepting = accepting.toIS, state = state\"0\", j = i, afterAcceptIndex = -1, found = F)\n    }\n  }\n\n  @datatype class IndexableToken(val input: Indexable.Pos[C], val skipHidden: B) extends Indexable[Result] {\n    val lexer: JsonLexer = JsonLexer(input)\n\n    override def at(i: Z): Result = {\n      return _at(i)\n    }\n\n    override def has(i: Z): B = {\n      return _has(i)\n    }\n\n    @memoize def _has(i: Z): B = {\n      assert(i >= 0)\n      if (i == 0) {\n        return T\n      }\n      if (!_has(i - 1)) {\n        return F\n      }\n      val prev = _at(i - 1)\n      return prev.kind == Result.Kind.Normal && prev.newIndex != -1\n    }\n\n    @memoize def _at(i: Z): Result = {\n      if (i == 0) {\n        if (input.has(0)) {\n          lexer.tokenize(0, skipHidden) match {\n            case Some(result) => return result\n            case _ =>\n          }\n        }\n      } else {\n        val prev = _at(i - 1)\n        if (input.has(prev.newIndex)) {\n          lexer.tokenize(prev.newIndex, skipHidden) match {\n            case Some(result) => return result\n            case _ =>\n          }\n        }\n      }\n      return Result(Result.Kind.Normal, eofLeaf, -1)\n    }\n\n  }\n\n  val kind: String = \"JsonParser\"\n\n  val minChar: C = \'\\u0000\'\n  val maxChar: C = toC(u32\"0x0010FFFF\")\n\n  val T_AFEF039D: U32 = u32\"0xAFEF039D\" /* \"true\" */\n  val T_D8AFD1B9: U32 = u32\"0xD8AFD1B9\" /* \"false\" */\n  val T_3EA44541: U32 = u32\"0x3EA44541\" /* \"null\" */\n  val T_FDCE65E5: U32 = u32\"0xFDCE65E5\" /* \"{\" */\n  val T_763C38BE: U32 = u32\"0x763C38BE\" /* \":\" */\n  val T_45445E21: U32 = u32\"0x45445E21\" /* \",\" */\n  val T_5BF60471: U32 = u32\"0x5BF60471\" /* \"}\" */\n  val T_A44269E9: U32 = u32\"0xA44269E9\" /* \"[\" */\n  val T_9977908D: U32 = u32\"0x9977908D\" /* \"]\" */\n  val T_STRING: U32 = u32\"0xA7CF0FE0\"\n  val T_NUMBER: U32 = u32\"0x28C20CF1\"\n  val T_WS: U32 = u32\"0x0E3F5D1E\"\n  val T_valueFile: U32 = u32\"0x94F3E412\"\n  val T_value: U32 = u32\"0x82EEA07A\"\n  val T_object: U32 = u32\"0x5ED5358F\"\n  val T_array: U32 = u32\"0xB11A9723\"\n\n  val errorLeaf: ParseTree.Leaf = ParseTree.Leaf(\"<ERROR>\", \"<ERROR>\", u32\"0xE3CDEDDA\", F, None())\n  val eofLeaf: ParseTree.Leaf = ParseTree.Leaf(\"<EOF>\", \"EOF\", u32\"0xFC5CB374\", F, None())\n\n  def parse(uriOpt: Option[String], input: String, reporter: message.Reporter): Option[ParseTree] = {\n    val docInfo = message.DocInfo.create(uriOpt, input)\n    val tokens = lex(input, docInfo, T, T, reporter)\n    if (reporter.hasError) {\n      return None()\n    }\n    val r = JsonParser(Indexable.fromIsz(tokens)).parseValueFile(0)\n    r.kind match {\n      case Result.Kind.Normal => return Some(r.tree)\n      case Result.Kind.LexicalError =>\n        reporter.error(Some(message.PosInfo(docInfo, offsetLength(r.newIndex, 1))), kind, s\"Could not recognize token\")\n        return None()\n      case Result.Kind.GrammaticalError =>\n        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex\n        if (idx < tokens.size) {\n          val token = tokens(idx).leaf\n          reporter.error(token.posOpt, kind, s\"Could not parse token: \\\"${ops.StringOps(token.text).escapeST.render}\\\"\")\n        } else {\n          val token = tokens(idx - 1).leaf\n          reporter.error(token.posOpt, kind, \"Expecting more input but reached the end\")\n        }\n        return None()\n    }\n  }\n\n  def parseIndexable(input: Indexable.Pos[C], reporter: message.Reporter): Option[ParseTree] = {\n    val it = IndexableToken(input, T)\n    val r = JsonParser(it).parseValueFile(0)\n    r.kind match {\n      case Result.Kind.Normal => return Some(r.tree)\n      case Result.Kind.LexicalError =>\n        reporter.error(input.posOpt(r.newIndex, 1), kind, s\"Could not recognize token\")\n        return None()\n      case Result.Kind.GrammaticalError =>\n        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex\n        if (it.has(idx)) {\n          val token = it.at(idx).leaf\n          reporter.error(token.posOpt, kind, s\"Could not parse token: \\\"${ops.StringOps(token.text).escapeST.render}\\\"\")\n        } else {\n          val token = it.at(idx - 1).leaf\n          reporter.error(token.posOpt, kind, \"Expecting more input but reached the end\")\n        }\n        return None()\n    }\n  }\n\n  def lex(input: String, docInfo: message.DocInfo, skipHidden: B, stopAtError: B,\n          reporter: message.Reporter): ISZ[Result] = {\n    return JsonLexer(Indexable.fromIszDocInfo(conversions.String.toCis(input), docInfo)).tokenizeAll(skipHidden, stopAtError, reporter)\n  }\n\n  @strictpure def offsetLength(offset: Z, length: Z): U64 =\n    (conversions.Z.toU64(offset) << u64\"32\") | (conversions.Z.toU64(length) & u64\"0xFFFFFFFF\")\n\n}\n\nimport JsonParser._\n\n@datatype class JsonParser(tokens: Indexable[Result]) {\n\n  @pure def parseValueFile(i: Z): Result = {\n    val ctx = Context.create(\"valueFile\", u32\"0x94F3E412\", ISZ(state\"2\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"1\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xFC5CB374\" /* EOF */ => ctx.updateTerminal(token, state\"2\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseValue(i: Z): Result = {\n    val ctx = Context.create(\"value\", u32\"0x82EEA07A\", ISZ(state\"1\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          val n_object = predictObject(ctx.j)\n          val n_array = predictArray(ctx.j)\n          for (n <- 1 to 1 by -1 if !ctx.found) {\n            if (n_object == n && parseObjectH(ctx, state\"1\")) {\n              return Result.error(ctx.isLexical, ctx.failIndex)\n            } else if (n_array == n && parseArrayH(ctx, state\"1\")) {\n              return Result.error(ctx.isLexical, ctx.failIndex)\n            }\n          }\n          if (!ctx.found) {\n            token.tipe match {\n              case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0x28C20CF1\" /* NUMBER */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0xAFEF039D\" /* \"true\" */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0xD8AFD1B9\" /* \"false\" */ => ctx.updateTerminal(token, state\"1\")\n              case u32\"0x3EA44541\" /* \"null\" */ => ctx.updateTerminal(token, state\"1\")\n              case _ =>\n            }\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseObject(i: Z): Result = {\n    val ctx = Context.create(\"object\", u32\"0x5ED5358F\", ISZ(state\"8\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xFDCE65E5\" /* \"{\" */ => ctx.updateTerminal(token, state\"1\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"2\")\n            case u32\"0x5BF60471\" /* \"}\" */ => ctx.updateTerminal(token, state\"8\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x763C38BE\" /* \":\" */ => ctx.updateTerminal(token, state\"3\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"3\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"4\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"4\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x45445E21\" /* \",\" */ => ctx.updateTerminal(token, state\"5\")\n            case u32\"0x5BF60471\" /* \"}\" */ => ctx.updateTerminal(token, state\"8\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"5\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA7CF0FE0\" /* STRING */ => ctx.updateTerminal(token, state\"6\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"6\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x763C38BE\" /* \":\" */ => ctx.updateTerminal(token, state\"7\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"7\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"4\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"8\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  @pure def parseArray(i: Z): Result = {\n    val ctx = Context.create(\"array\", u32\"0xB11A9723\", ISZ(state\"4\"), i)\n\n    while (tokens.has(ctx.j)) {\n      val token: ParseTree.Leaf = {\n        val result = tokens.at(ctx.j)\n        if (result.kind != Result.Kind.Normal) {\n          return result\n        }\n        result.leaf\n      }\n      ctx.state match {\n        case state\"0\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0xA44269E9\" /* \"[\" */ => ctx.updateTerminal(token, state\"1\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"1\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"2\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            token.tipe match {\n              case u32\"0x9977908D\" /* \"]\" */ => ctx.updateTerminal(token, state\"4\")\n              case _ =>\n            }\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"2\" =>\n          ctx.found = F\n          token.tipe match {\n            case u32\"0x45445E21\" /* \",\" */ => ctx.updateTerminal(token, state\"3\")\n            case u32\"0x9977908D\" /* \"]\" */ => ctx.updateTerminal(token, state\"4\")\n            case _ =>\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"3\" =>\n          ctx.found = F\n          val n_value = predictValue(ctx.j)\n          if (n_value > 0 && parseValueH(ctx, state\"2\")) {\n            return Result.error(ctx.isLexical, ctx.failIndex)\n          }\n          if (!ctx.found) {\n            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n          }\n        case state\"4\" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)\n        case _ => halt(\"Infeasible\")\n      }\n      if (ctx.max < ctx.j) {\n        ctx.max = ctx.j\n      }\n    }\n\n    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)\n  }\n\n  def parseValueH(ctx: Context, nextState: State): B = {\n    val r = parseValue(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  def parseObjectH(ctx: Context, nextState: State): B = {\n    val r = parseObject(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  def parseArrayH(ctx: Context, nextState: State): B = {\n    val r = parseArray(ctx.j)\n    r.kind match {\n      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)\n      case Result.Kind.LexicalError =>\n        ctx.failIndex = r.newIndex\n        ctx.isLexical = T\n        return T\n      case Result.Kind.GrammaticalError =>\n        val index = r.newIndex\n        if (index < 0) {\n          ctx.failIndex = index\n          return T\n        } else if (ctx.max < index) {\n          ctx.max = index\n        }\n    }\n    return F\n  }\n\n  @pure def predictValueFile(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xA7CF0FE0\" /* STRING */ => return 1\n        case u32\"0x28C20CF1\" /* NUMBER */ => return 1\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case u32\"0xAFEF039D\" /* \"true\" */ => return 1\n        case u32\"0xD8AFD1B9\" /* \"false\" */ => return 1\n        case u32\"0x3EA44541\" /* \"null\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictArray(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictValue(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tip
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$3();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #674                // String e match {\n        case u32\"0xA7CF0FE0\" /* STRING */ => return 1\n        case u32\"0x28C20CF1\" /* NUMBER */ => return 1\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case u32\"0xA44269E9\" /* \"[\" */ => return 1\n        case u32\"0xAFEF039D\" /* \"true\" */ => return 1\n        case u32\"0xD8AFD1B9\" /* \"false\" */ => return 1\n        case u32\"0x3EA44541\" /* \"null\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  @pure def predictObject(j: Z): Z = {\n    val tokenJ = tokens.at(j)\n    if (tokenJ.kind == Result.Kind.Normal) {\n      tokenJ.leaf.tipe match {\n        case u32\"0xFDCE65E5\" /* \"{\" */ => return 1\n        case _ =>\n      }\n    }\n    return 0\n  }\n\n  def retVal(n: Z, resOpt: Option[Result], initial: B, noBacktrack: B): Result = {\n    resOpt match {\n      case Some(res) => return res\n      case _ => return Result.error(F, if (noBacktrack && !initial) -n else n)\n    }\n  }\n\n  @pure def posOpts(docInfo: message.DocInfo,\n                    posOpt1: Option[message.Position],\n                    posOpt2: Option[message.Position]): Option[message.Position] = {\n    val pos1 = posOpt1.get\n    val pos2 = posOpt2.get\n    return Some(message.PosInfo(docInfo, offsetLength(pos1.offset,\n      pos2.offset + pos2.length - pos1.offset)))\n  }\n\n}\n\n@datatype class JsonLexer(cis: Indexable.Pos[C]) {\n\n  def tokenizeAll(skipHidden: B, stopAtError: B, reporter: message.Reporter): ISZ[Result] = {\n    var i: Z = 0\n    var r = ISZ[Result]()\n    var done = F\n    while (!done && cis.has(i)) {\n      tokenize(i, skipHidden) match {\n        case Some(result) =>\n          if (result.kind == Result.Kind.Normal) {\n            i = result.newIndex\n            r = r :+ result\n          } else {\n            val posOpt = cis.posOpt(i, 1)\n            reporter.error(posOpt, kind, s\"Could not recognize token\")\n            if (stopAtError) {\n              return r\n            }\n            r = r :+ result(tree = errorLeaf(text = conversions.String.fromCis(ISZ(cis.at(i))), posOpt = posOpt))\n            i = i + 1\n          }\n        case _ => done = T\n      }\n    }\n    r = r :+ Result.create(eofLeaf, -1)\n    return r\n  }\n\n  @pure def tokenize(i: Z, skipHidden: B): Option[Result] = {\n    val r = MBox(Result.error(T, i))\n    tokenizeH(r, i)\n    while (skipHidden && r.value.leaf.isHidden && cis.has(r.value.newIndex)) {\n      tokenizeH(r, r.value.newIndex)\n    }\n    return if (skipHidden && r.value.leaf.isHidden) None() else Some(r.value)\n  }\n\n  def tokenizeH(r: MBox[Result], i: Z): Unit = {\n    updateToken(r, lex_true(i))\n    updateToken(r, lex_false(i))\n    updateToken(r, lex_null(i))\n    updateToken(r, lex_u007B(i))\n    updateToken(r, lex_u003A(i))\n    updateToken(r, lex_u002C(i))\n    updateToken(r, lex_u007D(i))\n    updateToken(r, lex_u005B(i))\n    updateToken(r, lex_u005D(i))\n    updateToken(r, lex_STRING(i))\n    updateToken(r, lex_NUMBER(i))\n    updateToken(r, lex_WS(i))\n  }\n\n  def updateToken(r: MBox[Result], rOpt: Option[Result]): Unit = {\n    rOpt match {\n      case Some(newR) if newR.newIndex > r.value.newIndex => r.value = newR\n      case _ =>\n    }\n  }\n\n  @pure def lit_true(i: Z): Z = {\n    if (!cis.has(i + 4)) {\n      return -1\n    }\n    if (cis.at(i) === \'t\' && cis.at(i + 1) === \'r\' && cis.at(i + 2) === \'u\' && cis.at(i + 3) === \'e\') {\n      return i + 4\n    }\n    return -1\n  }\n\n  @strictpure def lex_true(index: Z): Option[Result] = lexH(index, lit_true(index), \"\"\"\'true\'\"\"\", u32\"0xAFEF039D\" /* \"true\" */, F)\n\n  @pure def lit_false(i: Z): Z = {\n    if (!cis.has(i + 5)) {\n      return -1\n    }\n    if (cis.at(i) === \'f\' && cis.at(i + 1) === \'a\' && cis.at(i + 2) === \'l\' && cis.at(i + 3) === \'s\' && cis.at(i + 4) === \'e\') {\n      return i + 5\n    }\n    return -1\n  }\n\n  @strictpure def lex_false(index: Z): Option[Result] = lexH(index, lit_false(index), \"\"\"\'false\'\"\"\", u32\"0xD8AFD1B9\" /* \"false\" */, F)\n\n  @pure def lit_null(i: Z): Z = {\n    if (!cis.has(i + 4)) {\n      return -1\n    }\n    if (cis.at(i) === \'n\' && cis.at(i + 1) === \'u\' && cis.at(i + 2) === \'l\' && cis.at(i + 3) === \'l\') {\n      return i + 4\n    }\n    return -1\n  }\n\n  @strictpure def lex_null(index: Z): Option[Result] = lexH(index, lit_null(index), \"\"\"\'null\'\"\"\", u32\"0x3EA44541\" /* \"null\" */, F)\n\n  @pure def lit_u007B(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'{\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u007B(index: Z): Option[Result] = lexH(index, lit_u007B(index), \"\"\"\'{\'\"\"\", u32\"0xFDCE65E5\" /* \"{\" */, F)\n\n  @pure def lit_u003A(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \':\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u003A(index: Z): Option[Result] = lexH(index, lit_u003A(index), \"\"\"\':\'\"\"\", u32\"0x763C38BE\" /* \":\" */, F)\n\n  @pure def lit_u002C(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \',\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u002C(index: Z): Option[Result] = lexH(index, lit_u002C(index), \"\"\"\',\'\"\"\", u32\"0x45445E21\" /* \",\" */, F)\n\n  @pure def lit_u007D(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'}\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u007D(index: Z): Option[Result] = lexH(index, lit_u007D(index), \"\"\"\'}\'\"\"\", u32\"0x5BF60471\" /* \"}\" */, F)\n\n  @pure def lit_u005B(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \'[\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u005B(index: Z): Option[Result] = lexH(index, lit_u005B(index), \"\"\"\'[\'\"\"\", u32\"0xA44269E9\" /* \"[\" */, F)\n\n  @pure def lit_u005D(i: Z): Z = {\n    if (cis.has(i) && cis.at(i) === \']\') {\n      return i + 1\n    }\n    return -1\n  }\n\n  @strictpure def lex_u005D(index: Z): Option[Result] = lexH(index, lit_u005D(index), \"\"\"\']\'\"\"\", u32\"0x9977908D\" /* \"]\" */, F)\n\n  @pure def dfa_STRING(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"2\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'\"\') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\' \' <= c && c <= \'!\' || \'#\' <= c && c <= \'[\' || \']\' <= c && c <= maxChar) {\n            ctx.update(state\"1\")\n          } else if (c === \'\"\') {\n            ctx.update(state\"2\")\n          } else if (c === \'\\\\\') {\n            ctx.update(state\"3\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"2\" => return ctx.afterAcceptIndex\n        case state\"3\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'\"\' || c === \'/\' || c === \'\\\\\' || c === \'b\' || c === \'f\' || c === \'n\' || c === \'r\' || c === \'t\') {\n            ctx.update(state\"1\")\n          } else if (c === \'u\') {\n            ctx.update(state\"4\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"4\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"5\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"6\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"6\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"7\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"7\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\' || \'A\' <= c && c <= \'F\' || \'a\' <= c && c <= \'f\') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_STRING(index: Z): Option[Result] = lexH(index, dfa_STRING(index), \"\"\"STRING\"\"\", u32\"0xA7CF0FE0\", F)\n\n  @pure def dfa_NUMBER(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"2\", state\"4\", state\"7\", state\"8\", state\"9\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'-\') {\n            ctx.update(state\"1\")\n          } else if (c === \'0\') {\n            ctx.update(state\"2\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'0\') {\n            ctx.update(state\"2\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"2\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'.\') {\n            ctx.update(state\"3\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"3\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"4\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"4\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"4\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"5\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'+\' || c === \'-\') {\n            ctx.update(state\"6\")\n          } else if (c === \'0\') {\n            ctx.update(state\"7\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"6\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'0\') {\n            ctx.update(state\"7\")\n          } else if (\'1\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"7\" => return ctx.afterAcceptIndex\n        case state\"8\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"8\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"9\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (c === \'.\') {\n            ctx.update(state\"3\")\n          } else if (\'0\' <= c && c <= \'9\') {\n            ctx.update(state\"9\")\n          } else if (c === \'E\' || c === \'e\') {\n            ctx.update(state\"5\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_NUMBER(index: Z): Option[Result] = lexH(index, dfa_NUMBER(index), \"\"\"NUMBER\"\"\", u32\"0x28C20CF1\", F)\n\n  @pure def dfa_WS(i: Z): Z = {\n    val ctx = LContext.create(ISZ(state\"1\"), i)\n\n    while (cis.has(ctx.j)) {\n      ctx.state match {\n        case state\"0\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'\\u0009\' <= c && c <= \'\\u000A\' || c === \'\\u000D\' || c === \' \') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case state\"1\" =>\n          val c = cis.at(ctx.j)\n          ctx.found = F\n          if (\'\\u0009\' <= c && c <= \'\\u000A\' || c === \'\\u000D\' || c === \' \') {\n            ctx.update(state\"1\")\n          }\n          if (!ctx.found) {\n            return ctx.afterAcceptIndex\n          }\n        case _ => halt(\"Infeasible\")\n      }\n      ctx.j = ctx.j + 1\n    }\n    return ctx.afterAcceptIndex\n  }\n\n  @strictpure def lex_WS(index: Z): Option[Result] = lexH(index, dfa_WS(index), \"\"\"WS\"\"\", u32\"0x0E3F5D1E\", T)\n\n  @pure def hidden(i: Z): Z = {\n     var j: Z = -1\n     j = dfa_WS(i)\n     if (j > 0) {\n       return j\n     }\n     return -1\n  }\n\n  @pure def lexH(index: Z, newIndex: Z, name: String, tipe: U32, isHidden: B): Option[Result] = {\n    if (newIndex > 0) {\n      return Some(Result.create(ParseTree.Leaf(conversions.String.fromCis(for (i <- index until newIndex) yield cis.at(i)),\n        name, tipe, isHidden, cis.posOpt(index, newIndex - index)), newIndex))\n    } else {\n      return None()\n    }\n  }\n\n}
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$31();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #676                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.ops._\nimport Z8._\nimport Z16._\nimport Z32._\nimport Z64._\nimport N._\nimport N8._\nimport N16._\nimport N32._\nimport N64._\nimport S8._\nimport S16._\nimport S32._\nimport S64._\nimport U8._\nimport U16._\nimport U32._\nimport U64._\n\nobject Json {\n\n  @sig trait JsonAstBinding[T] {\n    @pure def toObject(fields: ISZ[(String, T)]): T\n\n    @pure def toArray(elements: ISZ[T]): T\n\n    @pure def toNumber(s: String): T\n\n    @pure def toString(s: String): T\n\n    @pure def toNull: T\n\n    @pure def toBoolean(b: B): T\n\n    @pure def kind(o: T): ValueKind.Type\n\n    @pure def fromObject(o: T): ISZ[(String, T)]\n\n    @pure def fromArray(o: T): ISZ[T]\n\n    @pure def fromNumber(o: T): String\n\n    @pure def fromString(o: T): String\n\n    @pure def fromBoolean(o: T): B\n  }\n\n  @datatype class ErrorMsg(val line: Z, val column: Z, val message: String)\n\n  @enum object ValueKind {\n    \"String\"\n    \"Number\"\n    \"Object\"\n    \"Array\"\n    \"True\"\n    \"False\"\n    \"Null\"\n  }\n\n  object Printer {\n    val trueSt: ST = st\"true\"\n    val falseSt: ST = st\"false\"\n    val nullSt: ST = st\"null\"\n\n    @pure def printB(b: B): ST = {\n      if (b) {\n        return trueSt\n      } else {\n        return falseSt\n      }\n    }\n\n    @pure def printC(c: C): ST = {\n      return printString(c.string)\n    }\n\n    @pure def printZ(n: Z): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ8(n: Z8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ16(n: Z16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ32(n: Z32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printZ64(n: Z64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN(n: N): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN8(n: N8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN16(n: N16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN32(n: N32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printN64(n: N64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS8(n: S8): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS16(n: S16): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS32(n: S32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printS64(n: S64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printU8(n: U8): ST = {\n      return printNumber(conversions.U8.toZ(n).string)\n    }\n\n    @pure def printU16(n: U16): ST = {\n      return printNumber(conversions.U16.toZ(n).string)\n    }\n\n    @pure def printU32(n: U32): ST = {\n      return printNumber(conversions.U32.toZ(n).string)\n    }\n\n    @pure def printU64(n: U64): ST = {\n      return printNumber(conversions.U64.toZ(n).string)\n    }\n\n    @pure def printF32(n: F32): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printF64(n: F64): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printR(n: R): ST = {\n      return printNumber(n.string)\n    }\n\n    @pure def printISZ[T](isSimple: B, s: IS[Z, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ8[T](isSimple: B, s: IS[Z8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ16[T](isSimple: B, s: IS[Z16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ32[T](isSimple: B, s: IS[Z32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISZ64[T](isSimple: B, s: IS[Z64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN[T](isSimple: B, s: IS[N, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN8[T](isSimple: B, s: IS[N8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN16[T](isSimple: B, s: IS[N16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN32[T](isSimple: B, s: IS[N32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISN64[T](isSimple: B, s: IS[N64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS8[T](isSimple: B, s: IS[S8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS16[T](isSimple: B, s: IS[S16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS32[T](isSimple: B, s: IS[S32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISS64[T](isSimple: B, s: IS[S64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU8[T](isSimple: B, s: IS[U8, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU16[T](isSimple: B, s: IS[U16, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU32[T](isSimple: B, s: IS[U32, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printISU64[T](isSimple: B, s: IS[U64, T], f: T => ST): ST = {\n      return printIS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ[T](isSimple: B, s: MS[Z, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ8[T](isSimple: B, s: MS[Z8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ16[T](isSimple: B, s: MS[Z16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ32[T](isSimple: B, s: MS[Z32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSZ64[T](isSimple: B, s: MS[Z64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN[T](isSimple: B, s: MS[N, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN8[T](isSimple: B, s: MS[N8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN16[T](isSimple: B, s: MS[N16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN32[T](isSimple: B, s: MS[N32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSN64[T](isSimple: B, s: MS[N64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS8[T](isSimple: B, s: MS[S8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS16[T](isSimple: B, s: MS[S16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS32[T](isSimple: B, s: MS[S32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSS64[T](isSimple: B, s: MS[S64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU8[T](isSimple: B, s: MS[U8, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU16[T](isSimple: B, s: MS[U16, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU32[T](isSimple: B, s: MS[U32, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printMSU64[T](isSimple: B, s: MS[U64, T], f: T => ST): ST = {\n      return printMS(isSimple, s.map(f))\n    }\n\n    @pure def printZS(isSimple: B, s: ZS): ST = {\n      return printMS(isSimple, s.map(printZ _))\n    }\n\n    @pure def printOption[T](isSimple: B, o: Option[T], f: T => ST): ST = {\n      o match {\n        case Some(t) =>\n          return printObject(ISZ((\"type\", printString(\"Some\")), (\"value\", f(t))))\n        case _ => return printObject(ISZ((\"type\", printString(\"None\"))))\n      }\n    }\n\n    @pure def printMOption[T](isSimple: B, o: MOption[T], f: T => ST): ST = {\n      o match {\n        case MSome(t) =>\n          return printObject(ISZ((\"type\", printString(\"Some\")), (\"value\", f(t))))\n        case _ => return printObject(ISZ((\"type\", printString(\"None\"))))\n      }\n    }\n\n    @pure def printEither[L, R](isSimple: B, o: Either[L, R], f0: L => ST, f1: R => ST): ST = {\n      o match {\n        case Either.Left(l) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(0)), (\"value\", f0(l))))\n        case Either.Right(r) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(1)), (\"value\", f1(r))))\n        case _ => assume(F); return nullSt\n      }\n    }\n\n    @pure def printMEither[L, R](isSimple: B, o: MEither[L, R], f0: L => ST, f1: R => ST): ST = {\n      o match {\n        case MEither.Left(l) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(0)), (\"value\", f0(l))))\n        case MEither.Right(r) =>\n          return printObject(ISZ((\"type\", printString(\"Or\")), (\"i\", printZ(1)), (\"value\", f1(r))))\n        case _ => assume(F); return nullSt\n      }\n    }\n\n    @pure def printMap[K, T](isSimple: B, o: Map[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"Map\")), (\"entries\", entries)))\n    }\n\n    @pure def printSet[T](isSimple: B, o: Set[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Set\")),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printHashMap[K, T](isSimple: B, o: HashMap[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"HashMap\")), (\"size\", printZ(o.size)), (\"entries\", entries)))\n    }\n\n    @pure def printHashSet[T](isSimple: B, o: HashSet[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"HashSet\")),\n          (\"size\", printZ(o.size)),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printHashSMap[K, T](isSimple: B, o: HashSMap[K, T], k: K => ST, v: T => ST): ST = {\n      val entries: ST = if (isSimple) {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+ st\"\"\"[ $key, $value ]\"\"\"\n        }\n        st\"\"\"[ ${(es, \",\")} ]\"\"\"\n      } else {\n        var es = ISZ[ST]()\n        for (e <- o.entries) {\n          val key = k(e._1)\n          val value = v(e._2)\n          es = es :+\n            st\"\"\"[\n            |  $key,\n            |  $value\n            |]\"\"\"\n        }\n        st\"\"\"[\n        |  ${(es, \",\\n\")}\n        |]\"\"\"\n      }\n      return printObject(ISZ((\"type\", printString(\"HashSMap\")), (\"size\", printZ(o.size)), (\"entries\", entries)))\n    }\n\n    @pure def printHashSSet[T](isSimple: B, o: HashSSet[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"HashSSet\")),\n          (\"size\", printZ(o.size)),\n          (\n            \"elements\",\n            if (isSimple) st\"[${(o.elements.map(f), \", \")}]\"\n            else st\"\"\"[\n            |  ${(o.elements.map(f), \",\\n\")}\n            |]\"\"\"\n          )\n        )\n      )\n    }\n\n    @pure def printStack[T](isSimple: B, o: Stack[T], f: T => ST): ST = {\n      return printISZ(isSimple, o.elements, f)\n    }\n\n    @pure def printBag[T](isSimple: B, o: Bag[T], f: T => ST): ST = {\n      return printMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printHashBag[T](isSimple: B, o: HashBag[T], f: T => ST): ST = {\n      return printHashMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printHashSBag[T](isSimple: B, o: HashSBag[T], f: T => ST): ST = {\n      return printHashSMap(isSimple, o.map, f, printZ _)\n    }\n\n    @pure def printPoset[T](isSimple: B, o: Poset[T], f: T => ST): ST = {\n      val g: HashSSet[Poset.Index] => ST = s => printHashSSet(isSimple, s, printZ _)\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Poset\")),\n          (\"nodes\", printISZ(isSimple, o.nodesInverse, f)),\n          (\"parents\", printHashSMap(isSimple, o.parents, printZ _, g))\n        )\n      )\n    }\n\n    @pure def printGraph[W, E](isSimple: B, o: Graph[W, E], f: W => ST, g: E => ST): ST = {\n      @pure def printEdge(edge: Graph.Internal.Edge[E]): ST = {\n        edge match {\n          case Graph.Internal.Edge.Plain(src, dest) =>\n            return printObject(ISZ((\"src\", printZ(src)), (\"dest\", printZ(dest))))\n          case Graph.Internal.Edge.Data(src, dest, data) =>\n            return printObject(ISZ((\"src\", printZ(src)), (\"dest\", printZ(dest)), (\"data\", g(data))))\n        }\n      }\n      val edges: ISZ[Graph.Internal.Edge[E]] =\n        for (es <- o.outgoingEdges.values; e <- es.elements) yield e\n      return printObject(\n        ISZ(\n          (\"type\", printString(if (o.multi) \"MultiGraph\" else \"Graph\")),\n          (\"nodes\", printISZ(isSimple, o.nodesInverse, f)),\n          (\"edges\", printISZ(isSimple, edges, printEdge _))\n        )\n      )\n    }\n\n    @pure def printUnionFind[T](isSimple: B, o: UnionFind[T], f: T => ST): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"UnionFind\")),\n          (\"elements\", printISZ(isSimple, o.elementsInverse, f)),\n          (\"parentOf\", printISZ(T, o.parentOf, printZ _)),\n          (\"sizeOf\", printISZ(T, o.sizeOf, printZ _))\n        )\n      )\n    }\n\n    @pure def printMessage(o: message.Message): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Message\")),\n          (\"level\", printZ(o.level.ordinal)),\n          (\"message\", printString(o.text)),\n          (\"posOpt\", printOption(F, o.posOpt, printPosition _)),\n          (\"kind\", printString(o.kind))\n        )\n      )\n    }\n\n    @pure def printPosition(o: message.Position): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Position\")),\n          (\"uriOpt\", printOption(T, o.uriOpt, printString _)),\n          (\"beginLine\", printZ(o.beginLine)),\n          (\"beginColumn\", printZ(o.beginColumn)),\n          (\"endLine\", printZ(o.endLine)),\n          (\"endColumn\", printZ(o.endColumn)),\n          (\"offset\", printZ(o.offset)),\n          (\"length\", printZ(o.length))\n        )\n      )\n    }\n\n    @pure def printDocInfo(o: message.DocInfo): ST = {\n      return printObject(\n        ISZ(\n          (\"type\", printString(\"Position\")),\n          (\"uriOpt\", printOption(T, o.uriOpt, printString _)),\n          (\"lineOffsets\", printISZ(T, o.lineOffsets, printU32 _))\n        )\n      )\n    }\n\n    @pure def printString(s: String): ST = {\n      var r = ISZ[C]()\n      for (c <- conversions.String.toCis(s)) {\n        c.native match {\n          case \'\"\' => r = r :+ \'\\\\\' :+ \'\\\"\'\n          case \'\\\\\' => r = r :+ \'\\\\\' :+ \'\\\\\'\n          case \'/\' => r = r :+ \'\\\\\' :+ \'/\'\n          case \'\\b\' => r = r :+ \'\\\\\' :+ \'b\'\n          case \'\\f\' => r = r :+ \'\\\\\' :+ \'f\'\n          case \'\\n\' => r = r :+ \'\\\\\' :+ \'n\'\n          case \'\\r\' => r = r :+ \'\\\\\' :+ \'r\'\n          case \'\\t\' => r = r :+ \'\\\\\' :+ \'t\'\n          case _ if \'\\u0020\' <= c && c < \'\\u00FF\' && c != \'\\u007f\' => r = r :+ c\n          case _ =>\n            val q = COps(c).toUnicodeHex\n            r = r :+ \'\\\\\' :+ \'u\' :+ q._1 :+ q._2 :+ q._3 :+ q._4\n        }\n      }\n      return st\"\"\"\"${conversions.String.fromCis(r)}\"\"\"\"\n    }\n\n    @pure def printConstant(s: String): ST = {\n      s.native match {\n        case \"true\" => return trueSt\n        case \"false\" => return falseSt\n        case \"null\" => return nullSt\n      }\n    }\n\n    @pure def printNumber(s: String): ST = {\n      return st\"$s\"\n    }\n\n    @pure def printObject(fields: ISZ[(String, ST)]): ST = {\n      val fs: ISZ[ST] = for (p <- fields) yield st\"\"\"\"${p._1}\" : ${p._2}\"\"\"\n      return st\"\"\"{\n      |  ${(fs, \",\\n\")}\n      |}\"\"\"\n    }\n\n    @pure def printIS[I](isSimple: B, elements: IS[I, ST]): ST = {\n      return if (isSimple) st\"[${(elements, \", \")}]\"\n      else st\"\"\"[\n      |  ${(elements, \",\\n\")}\n      |]\"\"\"\n    }\n\n    @pure def printMS[I](isSimple: B, elements: MS[I, ST]): ST = {\n      return if (isSimple) st\"[${(elements, \", \")}]\"\n      else st\"\"\"[\n      |  ${(elements, \",\\n\")}\n      |]\"\"\"\n    }\n  }\n\n  object Parser {\n\n    @pure def create(input: String): Parser = {\n      return Parser(conversions.String.toCis(input), 0, None())\n    }\n  }\n\n  @record class Parser(val input: ISZ[C], var offset: Z, var errorOpt: Option[ErrorMsg]) {\n\n    val typesOption: ISZ[String] = ISZ(\"Some\", \"None\")\n\n    def errorMessage: String = {\n      errorOpt match {\n        case Some(e) => return s\"[${e.line}, ${e.column}] ${e.message}\"\n        case _ => return \"\"\n      }\n    }\n\n    def eof(): B = {\n      if (input.size != offset) {\n        if (errorOpt.nonEmpty) {\n          return F\n        }\n        val p = computeLineColumn(offset)\n        errorOpt = Some(ErrorMsg(p._1, p._2, s\"Expected end-of-file, but \'${input(offset)}\' found.\"))\n        return F\n      } else {\n        return T\n      }\n    }\n\n    def parseB(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'t\' => parseConstant(\"true\"); return T\n        case \'f\' => parseConstant(\"false\"); return F\n        case c => parseException(offset, s\"Expected \'true\' or \'false\', but \'$c...\' found.\"); return F\n      }\n    }\n\n    def parseC(): C = {\n      val i = offset\n      val s = conversions.String.toCis(parseString(
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$4();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #678                // String ))\n      if (s.size != 1) {\n        parseException(i, s\"Expected a C, but \'$s\' found.\")\n        return \' \'\n      } else {\n        return s(0)\n      }\n    }\n\n    def parseZ(): Z = {\n      val i = offset\n      val s = parseNumber()\n      Z(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z, but \'$s\' found.\")\n          return 0\n      }\n    }\n\n    def parseZ8(): Z8 = {\n      val i = offset\n      val s = parseNumber()\n      Z8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z8, but \'$s\' found.\")\n          return z8\"0\"\n      }\n    }\n\n    def parseZ16(): Z16 = {\n      val i = offset\n      val s = parseNumber()\n      Z16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z16, but \'$s\' found.\")\n          return z16\"0\"\n      }\n    }\n\n    def parseZ32(): Z32 = {\n      val i = offset\n      val s = parseNumber()\n      Z32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z32, but \'$s\' found.\")\n          return z32\"0\"\n      }\n    }\n\n    def parseZ64(): Z64 = {\n      val i = offset\n      val s = parseNumber()\n      Z64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a Z64, but \'$s\' found.\")\n          return z64\"0\"\n      }\n    }\n\n    def parseN(): N = {\n      val i = offset\n      val s = parseNumber()\n      N(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N, but \'$s\' found.\")\n          return n\"0\"\n      }\n    }\n\n    def parseN8(): N8 = {\n      val i = offset\n      val s = parseNumber()\n      N8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N8, but \'$s\' found.\")\n          return n8\"0\"\n      }\n    }\n\n    def parseN16(): N16 = {\n      val i = offset\n      val s = parseNumber()\n      N16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N16, but \'$s\' found.\")\n          return n16\"0\"\n      }\n    }\n\n    def parseN32(): N32 = {\n      val i = offset\n      val s = parseNumber()\n      N32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N32, but \'$s\' found.\")\n          return n32\"0\"\n      }\n    }\n\n    def parseN64(): N64 = {\n      val i = offset\n      val s = parseNumber()\n      N64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a N64, but \'$s\' found.\")\n          return n64\"0\"\n      }\n    }\n\n    def parseS8(): S8 = {\n      val i = offset\n      val s = parseNumber()\n      S8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S8, but \'$s\' found.\")\n          return s8\"0\"\n      }\n    }\n\n    def parseS16(): S16 = {\n      val i = offset\n      val s = parseNumber()\n      S16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S16, but \'$s\' found.\")\n          return s16\"0\"\n      }\n    }\n\n    def parseS32(): S32 = {\n      val i = offset\n      val s = parseNumber()\n      S32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S32, but \'$s\' found.\")\n          return s32\"0\"\n      }\n    }\n\n    def parseS64(): S64 = {\n      val i = offset\n      val s = parseNumber()\n      S64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a S64, but \'$s\' found.\")\n          return s64\"0\"\n      }\n    }\n\n    def parseU8(): U8 = {\n      val i = offset\n      val s = parseNumber()\n      U8(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U8, but \'$s\' found.\")\n          return u8\"0\"\n      }\n    }\n\n    def parseU16(): U16 = {\n      val i = offset\n      val s = parseNumber()\n      U16(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U16, but \'$s\' found.\")\n          return u16\"0\"\n      }\n    }\n\n    def parseU32(): U32 = {\n      val i = offset\n      val s = parseNumber()\n      U32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U32, but \'$s\' found.\")\n          return u32\"0\"\n      }\n    }\n\n    def parseU64(): U64 = {\n      val i = offset\n      val s = parseNumber()\n      U64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a U64, but \'$s\' found.\")\n          return u64\"0\"\n      }\n    }\n\n    def parseF32(): F32 = {\n      val i = offset\n      val s = parseNumber()\n      F32(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a F32, but \'$s\' found.\")\n          return 0f\n      }\n    }\n\n    def parseF64(): F64 = {\n      val i = offset\n      val s = parseNumber()\n      F64(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a F64, but \'$s\' found.\")\n          return 0.0\n      }\n    }\n\n    def parseR(): R = {\n      val i = offset\n      val s = parseNumber()\n      R(s) match {\n        case Some(n) => return n\n        case _ =>\n          parseException(i, s\"Expected a R, but \'$s\' found.\")\n          return r\"0\"\n      }\n    }\n\n    def parseISZ[T](f: () => T): IS[Z, T] = {\n      if (!parseArrayBegin()) {\n        return IS()\n      }\n      var e = f()\n      var r = IS[Z, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ8[T](f: () => T): IS[Z8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z8, T]()\n      }\n      var e = f()\n      var r = IS[Z8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ16[T](f: () => T): IS[Z16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z16, T]()\n      }\n      var e = f()\n      var r = IS[Z16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ32[T](f: () => T): IS[Z32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z32, T]()\n      }\n      var e = f()\n      var r = IS[Z32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISZ64[T](f: () => T): IS[Z64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[Z64, T]()\n      }\n      var e = f()\n      var r = IS[Z64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN[T](f: () => T): IS[N, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N, T]()\n      }\n      var e = f()\n      var r = IS[N, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN8[T](f: () => T): IS[N8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N8, T]()\n      }\n      var e = f()\n      var r = IS[N8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN16[T](f: () => T): IS[N16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N16, T]()\n      }\n      var e = f()\n      var r = IS[N16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN32[T](f: () => T): IS[N32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N32, T]()\n      }\n      var e = f()\n      var r = IS[N32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISN64[T](f: () => T): IS[N64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[N64, T]()\n      }\n      var e = f()\n      var r = IS[N64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS8[T](f: () => T): IS[S8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S8, T]()\n      }\n      var e = f()\n      var r = IS[S8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS16[T](f: () => T): IS[S16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S16, T]()\n      }\n      var e = f()\n      var r = IS[S16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS32[T](f: () => T): IS[S32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S32, T]()\n      }\n      var e = f()\n      var r = IS[S32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISS64[T](f: () => T): IS[S64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[S64, T]()\n      }\n      var e = f()\n      var r = IS[S64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU8[T](f: () => T): IS[U8, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U8, T]()\n      }\n      var e = f()\n      var r = IS[U8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU16[T](f: () => T): IS[U16, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U16, T]()\n      }\n      var e = f()\n      var r = IS[U16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU32[T](f: () => T): IS[U32, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U32, T]()\n      }\n      var e = f()\n      var r = IS[U32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseISU64[T](f: () => T): IS[U64, T] = {\n      if (!parseArrayBegin()) {\n        return IS[U64, T]()\n      }\n      var e = f()\n      var r = IS[U64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ[T](f: () => T): MS[Z, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z, T]()\n      }\n      var e = f()\n      var r = MS[Z, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ8[T](f: () => T): MS[Z8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z8, T]()\n      }\n      var e = f()\n      var r = MS[Z8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ16[T](f: () => T): MS[Z16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z16, T]()\n      }\n      var e = f()\n      var r = MS[Z16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ32[T](f: () => T): MS[Z32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z32, T]()\n      }\n      var e = f()\n      var r = MS[Z32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSZ64[T](f: () => T): MS[Z64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[Z64, T]()\n      }\n      var e = f()\n      var r = MS[Z64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN[T](f: () => T): MS[N, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N, T]()\n      }\n      var e = f()\n      var r = MS[N, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN8[T](f: () => T): MS[N8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N8, T]()\n      }\n      var e = f()\n      var r = MS[N8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN16[T](f: () => T): MS[N16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N16, T]()\n      }\n      var e = f()\n      var r = MS[N16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN32[T](f: () => T): MS[N32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N32, T]()\n      }\n      var e = f()\n      var r = MS[N32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSN64[T](f: () => T): MS[N64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[N64, T]()\n      }\n      var e = f()\n      var r = MS[N64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS8[T](f: () => T): MS[S8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S8, T]()\n      }\n      var e = f()\n      var r = MS[S8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS16[T](f: () => T): MS[S16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S16, T]()\n      }\n      var e = f()\n      var r = MS[S16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS32[T](f: () => T): MS[S32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S32, T]()\n      }\n      var e = f()\n      var r = MS[S32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSS64[T](f: () => T): MS[S64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[S64, T]()\n      }\n      var e = f()\n      var r = MS[S64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU8[T](f: () => T): MS[U8, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U8, T]()\n      }\n      var e = f()\n      var r = MS[U8, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU16[T](f: () => T): MS[U16, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U16, T]()\n      }\n      var e = f()\n      var r = MS[U16, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU32[T](f: () => T): MS[U32, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U32, T]()\n      }\n      var e = f()\n      var r = MS[U32, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseMSU64[T](f: () => T): MS[U64, T] = {\n      if (!parseArrayBegin()) {\n        return MS[U64, T]()\n      }\n      var e = f()\n      var r = MS[U64, T](e)\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r :+ e\n        continue = parseArrayNext()\n      }\n      return r\n    }\n\n    def parseZS(): ZS = {\n      val r = parseMSZ(parseZ _)\n      return r\n    }\n\n    def parseOption[T](f: () => T): Option[T] = {\n      val tpe = parseObjectTypes(typesOption)\n      tpe.native match {\n        case \"Some\" =>\n          parseObjectKey(\"value\")\n          val v = f()\n          parseObjectNext()\n          return Some(v)\n        case _ =>\n          return None()\n      }\n    }\n\n    def parseMOption[T](f: () => T): MOption[T] = {\n      val tpe = parseObjectTypes(typesOption)\n      tpe.native match {\n        case \"Some\" =>\n          parseObjectKey(\"value\")\n          val v = f()\n          parseObjectNext()\n          return MSome(v)\n        case _ =>\n          return MNone()\n      }\n    }\n\n    def parseEither[L, R](f0: () => L, f1: () => R): Either[L, R] = {\n      parseObjectType(\"Or\")\n      parseObjectKey(\"i\")\n      val o = offset\n      val i = parseZ()\n      parseObjectNext()\n      parseObjectKey(\"value\")\n      if (i == 1) {\n        val r = f1()\n        parseObjectNext()\n        return Either.Right(r)\n      } else {\n        if (i != 0) {\n          parseException(o, s\"Expecting 0 or 1, but found $i\")\n        }\n        val l = f0()\n        parseObjectNext()\n        return Either.Left(l)\n      }\n    }\n\n    def parseMEither[L, R](f0: () => L, f1: () => R): MEither[L, R] = {\n      parseObjectType(\"Or\")\n      parseObjectKey(\"i\")\n      val o = offset\n      val i = parseZ()\n      parseObjectNext()\n      parseObjectKey(\"value\")\n      if (i == 1) {\n        val r = f1()\n        parseObjectNext()\n        return MEither.Right(r)\n      } else {\n        if (i != 0) {\n          parseException(o, s\"Expecting 0 or 1, but found $i\")\n        }\n        val l = f0()\n        parseObjectNext()\n        return MEither.Left(l)\n      }\n    }\n\n    def parseMap[K, T](k: () => K, v: () => T): Map[K, T] = {\n      parseObjectType(\"Map\")\n\n      var r = Map.empty[K, T]\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseSet[T](f: () => T): Set[T] = {\n      parseObjectType(\"Set\")\n\n      var r = Set.empty[T]\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashMap[K, T](k: () => K, v: () => T): HashM
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f2$2();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #680                // String ap[K, T] = {\n      parseObjectType(\"HashMap\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashMap.emptyInit[K, T](size)\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSet[T](f: () => T): HashSet[T] = {\n      parseObjectType(\"HashSet\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSet.emptyInit[T](size)\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSMap[K, T](k: () => K, v: () => T): HashSMap[K, T] = {\n      parseObjectType(\"HashSMap\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSMap.emptyInit[K, T](size)\n      parseObjectKey(\"entries\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      def parseEntry(): Unit = {\n        parseArrayBegin()\n        val key = k()\n        parseArrayNext()\n        val value = v()\n        parseArrayNext()\n        r = r + key ~> value\n      }\n\n      parseEntry()\n      var continue = parseArrayNext()\n      while (continue) {\n        parseEntry()\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseHashSSet[T](f: () => T): HashSSet[T] = {\n      parseObjectType(\"HashSSet\")\n      parseObjectKey(\"size\")\n      val size = parseZ()\n      parseObjectNext()\n\n      var r = HashSSet.emptyInit[T](size)\n      parseObjectKey(\"elements\")\n      if (!parseArrayBegin()) {\n        parseObjectNext()\n        return r\n      }\n\n      var e = f()\n      r = r + e\n      var continue = parseArrayNext()\n      while (continue) {\n        e = f()\n        r = r + e\n        continue = parseArrayNext()\n      }\n      parseObjectNext()\n      return r\n    }\n\n    def parseStack[T](f: () => T): Stack[T] = {\n      val is = parseISZ(f)\n      return Stack(is)\n    }\n\n    def parseBag[T](f: () => T): Bag[T] = {\n      val map = parseMap(f, parseZ _)\n      return Bag(map)\n    }\n\n    def parseHashBag[T](f: () => T): HashBag[T] = {\n      val map = parseHashMap(f, parseZ _)\n      return HashBag(map)\n    }\n\n    def parseHashSBag[T](f: () => T): HashSBag[T] = {\n      val map = parseHashSMap(f, parseZ _)\n      return HashSBag(map)\n    }\n\n    def parsePoset[T](f: () => T): Poset[T] = {\n      def g(): HashSSet[Poset.Index] = {\n        val r = parseHashSSet(parseZ _)\n        return r\n      }\n      parseObjectType(\"Poset\")\n      parseObjectKey(\"nodes\")\n      val nodesInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"parents\")\n      val map = parseHashSMap(parseZ _, g _)\n      parseObjectNext()\n      val size = nodesInverse.size\n      var nodes = HashSMap.emptyInit[T, Poset.Index](size)\n      var parents = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var children = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var i: Z = 0\n      for (node <- nodesInverse) {\n        nodes = nodes + node ~> nodes.size\n        parents = parents + i ~> Poset.Internal.emptySet\n        children = children + i ~> Poset.Internal.emptySet\n        i = i + 1\n      }\n      var r = Poset[T](nodes, nodesInverse, parents, children)\n      for (e <- map.entries) {\n        val (n, s) = e\n        r = Poset.Internal.addParents(r, n, s.elements)\n      }\n      return r\n    }\n\n    def parseGraph[W, E](f: () => W, g: () => E): Graph[W, E] = {\n      def parseEdge(): Graph.Internal.Edge[E] = {\n        parseObjectBegin()\n        parseObjectKey(\"src\")\n        val src = parseZ()\n        parseObjectNext()\n        parseObjectKey(\"dest\")\n        val dest = parseZ()\n        val hasData = parseObjectNext()\n        if (hasData) {\n          val data = g()\n          return Graph.Internal.Edge.Data(src, dest, data)\n        } else {\n          return Graph.Internal.Edge.Plain(src, dest)\n        }\n      }\n\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val tipe = parseString()\n      parseObjectNext()\n      val multi = tipe == \"Graph\"\n      parseObjectKey(\"nodes\")\n      val nodesInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"edges\")\n      val edges = parseISZ(parseEdge _)\n      parseObjectNext()\n      var r: Graph[W, E] = if (multi) Graph.emptyMulti else Graph.empty\n      for (node <- nodesInverse) {\n        r = r * node\n      }\n      for (e <- edges) {\n        r = Graph.Internal.addEdge(r, e)\n      }\n      return r\n    }\n\n    def parseUnionFind[T](f: () => T): UnionFind[T] = {\n      parseObjectType(\"UnionFind\")\n      parseObjectKey(\"elements\")\n      val elementsInverse = parseISZ(f)\n      parseObjectNext()\n      parseObjectKey(\"parentOf\")\n      val parentOf = parseISZ(parseZ _)\n      parseObjectNext()\n      parseObjectKey(\"sizeOf\")\n      val sizeOf = parseISZ(parseZ _)\n      parseObjectNext()\n      var elements = HashSMap.emptyInit[T, UnionFind.Index](elementsInverse.size)\n      for (e <- elementsInverse) {\n        elements = elements + e ~> elements.size\n      }\n      return UnionFind(elements, elementsInverse, parentOf, sizeOf)\n    }\n\n    def parseMessage(): message.Message = {\n      parseObjectType(\"Message\")\n      parseObjectKey(\"level\")\n      val level = message.Level.byOrdinal(parseZ()).getOrElse(message.Level.InternalError)\n      parseObjectNext()\n      parseObjectKey(\"message\")\n      val msg = parseString()\n      parseObjectNext()\n      parseObjectKey(\"posOpt\")\n      val posOpt = parseOption(parsePosition _)\n      parseObjectNext()\n      parseObjectKey(\"kind\")\n      val kind = parseString()\n      parseObjectNext()\n      return message.Message(level, posOpt, kind, msg)\n    }\n\n    def parsePosition(): message.Position = {\n      parseObjectType(\"Position\")\n      parseObjectKey(\"uriOpt\")\n      val uriOpt = parseOption(parseString _)\n      parseObjectNext()\n      parseObjectKey(\"beginLine\")\n      val beginLine = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"beginColumn\")\n      val beginColumn = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"endLine\")\n      val endLine = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"endColumn\")\n      val endColumn = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"offset\")\n      val offset = parseU32()\n      parseObjectNext()\n      parseObjectKey(\"length\")\n      val length = parseU32()\n      parseObjectNext()\n      return message.FlatPos(uriOpt, beginLine, beginColumn, endLine, endColumn, offset, length)\n    }\n\n    def parseDocInfo(): message.DocInfo = {\n      parseObjectType(\"Position\")\n      parseObjectKey(\"uriOpt\")\n      val uriOpt = parseOption(parseString _)\n      parseObjectNext()\n      parseObjectKey(\"lineOffsets\")\n      val lineOffsets = parseISZ(parseU32 _)\n      parseObjectNext()\n      return message.DocInfo(uriOpt, lineOffsets)\n    }\n\n    def at(i: Z): C = {\n      if (0 <= i && i < input.size && errorOpt.isEmpty) {\n        return input(i)\n      }\n      return \'\\u0000\'\n    }\n\n    def detect(): ValueKind.Type = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'\"\' => return ValueKind.String\n        case \'{\' => return ValueKind.Object\n        case \'[\' => return ValueKind.Array\n        case \'t\' => return ValueKind.True\n        case \'f\' => return ValueKind.False\n        case \'n\' => return ValueKind.Null\n        case \'-\' => return ValueKind.Number\n        case \'0\' => return ValueKind.Number\n        case \'1\' => return ValueKind.Number\n        case \'2\' => return ValueKind.Number\n        case \'3\' => return ValueKind.Number\n        case \'4\' => return ValueKind.Number\n        case \'5\' => return ValueKind.Number\n        case \'6\' => return ValueKind.Number\n        case \'7\' => return ValueKind.Number\n        case \'8\' => return ValueKind.Number\n        case \'9\' => return ValueKind.Number\n        case _ =>\n          parseException(offset, \"Unexpected end-of-file.\")\n          return ValueKind.Null\n      }\n    }\n\n    def parseObjectType(expectedType: String): String = {\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val i = offset + 1\n      val value = parseString()\n      parseObjectNext()\n      if (value != expectedType) {\n        parseException(i, s\"Expected \'$expectedType\', but \'$value\' found.\")\n      }\n      return value\n    }\n\n    def parseObjectTypes(expectedTypes: ISZ[String]): String = {\n      parseObjectBegin()\n      parseObjectKey(\"type\")\n      val i = offset + 1\n      val value = parseString()\n      parseObjectNext()\n      if (expectedTypes.nonEmpty && !ISZOps(expectedTypes).contains(value)) {\n        expectedTypes.size match {\n          case z\"1\" =>\n            parseException(i, s\"Expected \'${expectedTypes(0)}\', but \'$value\' found.\")\n          case z\"2\" =>\n            parseException(i, s\"Expected \'${expectedTypes(0)}\' or \'${expectedTypes(1)}\' , but \'$value\' found.\")\n          case _ =>\n            parseException(\n              i,\n              s\"Expected ${st\"\'${(ISZOps(expectedTypes).dropRight(1), \"\', \'\")}\', or \'${expectedTypes(expectedTypes.size - 1)}\'\".render} , but \'$value\' found.\"\n            )\n        }\n      }\n      return value\n    }\n\n    def parseObjectKey(expectedKey: String): String = {\n      errorIfEof(offset)\n      val i = offset + 1\n      val key = parseString()\n      if (key != expectedKey) {\n        parseException(i, s\"Expected \'$expectedKey\', but \'$key\' found.\")\n      }\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \':\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return key\n        case c =>\n          parseException(offset, s\"Expected \':\', but \'$c\' found.\")\n          return \"\"\n      }\n    }\n\n    def parseObjectKeys(expectedKeys: ISZ[String]): String = {\n      errorIfEof(offset)\n      val i = offset + 1\n      val key = parseString()\n      if (expectedKeys.nonEmpty && !ISZOps(expectedKeys).contains(key)) {\n        expectedKeys.size match {\n          case z\"1\" =>\n            parseException(i, s\"Expected \'${expectedKeys(0)}\', but \'$key\' found.\")\n          case z\"2\" =>\n            parseException(i, s\"Expected \'${expectedKeys(0)}\' or \'${expectedKeys(1)}\' , but \'$key\' found.\")\n          case _ =>\n            parseException(\n              i,\n              s\"Expected ${st\"\'${(ISZOps(expectedKeys).dropRight(1), \"\', \'\")}\', or \'${expectedKeys(expectedKeys.size - 1)}\'\".render} , but \'$key\' found.\"\n            )\n        }\n      }\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \':\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return key\n        case c =>\n          parseException(offset, s\"Expected \':\', but \'$c\' found.\")\n          return \"\"\n      }\n    }\n\n    def parseObjectBegin(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'{\' =>\n          offset = offset + 1\n          parseWhitespace()\n          errorIfEof(offset)\n          at(offset).native match {\n            case \'}\' =>\n              offset = offset + 1\n              return F\n            case _ =>\n              return T\n          }\n        case c =>\n          parseException(offset, s\"Expected \'{\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseObjectNext(): B = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \',\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return T\n        case \'}\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return F\n        case c =>\n          parseException(offset, s\"Expected \',\' or \'}\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseArrayBegin(): B = {\n      errorIfEof(offset)\n      at(offset).native match {\n        case \'[\' =>\n          offset = offset + 1\n          parseWhitespace()\n          errorIfEof(offset)\n          at(offset).native match {\n            case \']\' =>\n              offset = offset + 1\n              return F\n            case _ =>\n              return T\n          }\n        case c =>\n          parseException(offset, s\"Expected \'[\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseArrayNext(): B = {\n      parseWhitespace()\n      errorIfEof(offset)\n      at(offset).native match {\n        case \',\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return T\n        case \']\' =>\n          offset = offset + 1\n          parseWhitespace()\n          return F\n        case c =>\n          parseException(offset, s\"Expected \',\' or \']\', but \'$c\' found.\")\n          return F\n      }\n    }\n\n    def parseNumber(): String = {\n      var r = ISZ[C]()\n\n      errorIfEof(offset)\n\n      var c = at(offset)\n      c.native match {\n        case \'-\' =>\n          r = r :+ c\n          c = incOffset(1)\n        case _ =>\n          if (!isDigit(c)) {\n            parseException(offset, s\"\"\"Expected a \'-\' or a digit but \'$c\' found.\"\"\")\n          }\n      }\n\n      c.native match {\n        case \'0\' =>\n          r = r :+ c\n          if (offset + 1 == input.size) {\n            offset = offset + 1\n            return conversions.String.fromCis(r)\n          }\n          c = incOffset(1)\n        case _ =>\n          r = r :+ c\n          if (offset + 1 == input.size) {\n            offset = offset + 1\n            return conversions.String.fromCis(r)\n          }\n          c = incOffset(1)\n          while (isDigit(c)) {\n            r = r :+ c\n            if (offset + 1 == input.size) {\n              offset = offset + 1\n              return conversions.String.fromCis(r)\n            }\n            c = incOffset(1)\n          }\n      }\n\n      c.native match {\n        case \'.\' =>\n          r = r :+ c\n          c = incOffset(1)\n          while (isDigit(c)) {\n            r = r :+ c\n            if (offset + 1 == input.size) {\n              offset = offset + 1\n              return conversions.String.fromCis(r)\n            }\n            c = incOffset(1)\n          }\n        case _ =>\n      }\n\n      c.native match {\n        case \'e\' =>\n        case \'E\' =>\n        case _ => return conversions.String.fromCis(r)\n      }\n      r = r :+ c\n      c = incOffset(1)\n      val hasPlusMinus: B = c.native match {\n        case \'+\' => T\n        case \'-\' => T\n        case _ => F\n      }\n      if (hasPlusMinus) {\n        r = r :+ c\n        c = incOffset(1)\n      }\n      while (isDigit(c)) {\n        r = r :+ c\n        if (offset + 1 == input.size) {\n          offset = offset + 1\n          return conversions.String.fromCis(r)\n        }\n        c = incOffset(1)\n      }\n      return conversions.String.fromCis(r)\n    }\n\n    def parseString(): String = {\n      errorIfEof(offset)\n\n      var r = ISZ[C]()\n\n      var c = at(offset)\n      c.native match {\n        case \'\"\' =>\n          c = incOffset(1)\n          while (c != \'\"\') {\n            c.native match {\n              case \'\\\\\' =>\n                c = incOffset(1)\n                c.native match {\n                  case \'\"\' => r = r :+ \'\"\'\n                  case \'\\\\\' => r = r :+ \'\\\\\'\n                  case \'/\' => r = r :+ \'/\'\n                  case \'b\' => r = r :+ \'\\b\'\n                  case \'f\' => r = r :+ \'\\f\'\n                  case \'n\' => r = r :+ \'\\n\'\n                  case \'r\' => r = r :+ \'\\r\'\n                  case \'t\' => r = r :+ \'\\t\'\n                  case \'u\' =>\n                    incOffset(4)\n                    val hex = slice(offset - 3, offset + 1)\n                    COps.fromUnicodeHex(hex) match {\n                      case Some(ch) => r = r :+ ch\n                      case _ =>\n                        parseException(offset - 3, s\"Expected a character hex but \'$hex\' found.\")\n                    }\n                  case _ =>\n                    parseException(offset, s\"Expected an escaped character but \'$c\' found.\")\n                }\n              case _ => r = r :+ c\n            }\n            c = incOffset(1)\n          }\n          offset = offset + 1\n          return conversions.String.fromCis(r)\n        case _ =>\n          parseException(offset, s\"\"\"Expected \'\"\' but \'$c\' found.\"\"\")\n          return \"\"\n      }\n    }\n\n    def parseConstant(text: String): Unit = {\n      errorIfEof(offset + text.size - 1)\n      val t = conversions.String.fromCis(slice(offset, offset + text.size))\n      if (t != text) {\n        parseException(offset, s\"Expected \'$text\', but \'$t\' found.\")\n      }\n      offset = offset + text.size\n      text.native match {\n        case \"true\" =>\n        case \"false\" =>\n        case \"null\" =>\n        case _ => parseException(offset, s\"Invalid constant value \'$text\'.\")\n      }\n    }\n\n    def computeLineColumn(i: Z): (Z, Z) = {\n      var line: Z = 1\n      var column: Z = 1\n      var j: Z = 0\n      while (j != i) {\n        at(j).native match {\n          case \'\\n\' =>\n            line = line + 1\n            column = 1\n          case _ => column = column + 1\n        }\n        j = j + 1\n      }\n      return (line, column)\n    }\n\n    def parseException(i: Z, msg: String): Unit = {\n      if (errorOpt.nonEmpty) {\n        return\n      }\n      val p = computeLineColumn(i)\n      errorOpt = Some(ErrorMsg(p._1, p._2, msg))\n      offset = input.size\n    }\n\n    def errorIfEof(i: Z): Unit = {\n      if (i >= input.size || errorOpt.nonEmpty) {\n        parseException(offset, \"Unexpected end-of-file.\")\n      }\n    }\n\n    def incOffset(n: Z): C = {\n      offset = offset + n\n      errorIfEof(offset)\n      return at(offset)\n    }\n\n    def parseWhitespace(): Unit = {\n      if (errorOpt.nonEmpty) {\n        return\n      }\n      if (offset >= input.size) {\n        return\n      }\n      var c = at(offset)\n      while (isWhitespace(c)) {\n        offset = offset + 1\n        if (offset >= input.size) {\n          return\n        }\n        c = at(offset)\n      }\n    }\n\n    @pure def isDigit(c: C): B = {\n      c.native match {\n        case \'0\' => return T\n        case \'1\' => return T\n        case \'2\' => return T\n        case \'3\' => return T\n        case \'4\' => return T\n        case \'5\' => return T\n        case \'6\' => return T\n        case \'7\' => return T\n        case \'8\' => return T\n        case \'9\' => return T\n        case _ => return F\n      }\n    }\n\n    @pure def isWhitespace(c: C): B = {\n      c.native match {\n        case \' \' => return T\n        case \'\\n\' => return T\n        case \'\\r\' => return T\n        case \'\\t\' => return T\n        case _ => return F\n      }\n    }\n\n    @pure def slice(start: Z, til: Z): ISZ[C] = {\n      var r = ISZ[C]()\n      for (i <- start until til) {\n        r = r :+ at(i)\n      }\n      return r\n    }\n  }\n\n  def parseAst[T](binding: JsonAstBinding[T], input: String): Either[T, ErrorMsg] = {\n    val parser = Parser.create(input)\n    val emptyKeys = ISZ[String]()\n\n    def parseString(): T = {\n      val s = parser.parseString()\n      return binding.toString(s)\n    }\n\n    def parseNumber(): T = {\n      val n = parser.parseNumber()\n      return binding.toNumber(n)\n    }\n\n    def parseTrue(): T = {\n      parser.parseConstant(\"true\")\n      return binding.toBoolean(T)\n    }\n\n    def parseFalse(): T = {\n      parser.parseConstant(\"false\")\n      return binding.toBoolean(F)\n    }\n\n    def parseNull(): T = {\n      parser.parseConstant(\"null\")\n      return binding.toNull\n    }\n\n    def parseArray(): T = {\n      var continue = parser.parseArrayBegin()\n      if (!continue) {\n        return binding.toArray(ISZ())\n      }\n      var v = parseValue()\n      var values =
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f3$2();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #682                // String  ISZ[T](v)\n      continue = parser.parseArrayNext()\n      while (continue) {\n        v = parseValue()\n        values = values :+ v\n        continue = parser.parseArrayNext()\n      }\n      return binding.toArray(values)\n    }\n\n    def parseObject(): T = {\n      var continue = parser.parseObjectBegin()\n      if (!continue) {\n        return binding.toObject(ISZ())\n      }\n      var key = parser.parseObjectKeys(emptyKeys)\n      var value = parseValue()\n      var fields = ISZ[(String, T)]((key, value))\n      continue = parser.parseObjectNext()\n      while (continue) {\n        key = parser.parseObjectKeys(emptyKeys)\n        value = parseValue()\n        fields = fields :+ ((key, value))\n        continue = parser.parseObjectNext()\n      }\n      return binding.toObject(fields)\n    }\n\n    def parseValue(): T = {\n      val k = parser.detect()\n      k match {\n        case ValueKind.String => val r = parseString(); return r\n        case ValueKind.Object => val r = parseObject(); return r\n        case ValueKind.Array => val r = parseArray(); return r\n        case ValueKind.True => val r = parseTrue(); return r\n        case ValueKind.False => val r = parseFalse(); return r\n        case ValueKind.Null => val r = parseNull(); return r\n        case ValueKind.Number => val r = parseNumber(); return r\n      }\n    }\n\n    val r = parseValue()\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def printAst[T](binding: JsonAstBinding[T], v: T): ST = {\n    @pure def isSimple(o: T): B = {\n      binding.kind(o) match {\n        case ValueKind.Object => return F\n        case ValueKind.Array => return F\n        case _ => return T\n      }\n    }\n\n    @pure def printValue(o: T): ST = {\n      binding.kind(o) match {\n        case ValueKind.String =>\n          return Printer.printString(binding.fromString(o))\n        case ValueKind.Number =>\n          return Printer.printNumber(binding.fromNumber(o))\n        case ValueKind.Object =>\n          return Printer.printObject(for (p <- binding.fromObject(o)) yield (p._1, printValue(p._2)))\n        case ValueKind.Array =>\n          val es = binding.fromArray(o)\n          return Printer.printIS(ISZOps(es).forall(isSimple), es.map(printValue _))\n        case ValueKind.True => return Printer.trueSt\n        case ValueKind.False => return Printer.falseSt\n        case ValueKind.Null => return Printer.nullSt\n      }\n    }\n\n    return printValue(v)\n  }\n\n  @ext(\"JsonFun_Ext\") object Fun {\n    def printPure0[R](f: () => R @pure): String = $\n    def parsePure0[R](parser: Parser, f: String): () => R @pure = $\n\n    def print0[R](f: () => R): String = $\n    def parse0[R](parser: Parser, f: String): () => R = $\n\n    def printPure1[T1, R](f: T1 => R @pure): String = $\n    def parsePure1[T1, R](parser: Parser, f: String): T1 => R @pure = $\n\n    def print1[T1, R](f: T1 => R): String = $\n    def parse1[T1, R](parser: Parser, f: String): T1 => R = $\n    def printPure2[T1, T2, R](f: (T1, T2) => R @pure): String = $\n    def parsePure2[T1, T2, R](parser: Parser, f: String): (T1, T2) => R @pure = $\n\n    def print2[T1, T2, R](f: (T1, T2) => R): String = $\n    def parse2[T1, T2, R](parser: Parser, f: String): (T1, T2) => R = $\n\n    def printPure3[T1, T2, T3, R](f: (T1, T2, T3) => R @pure): String = $\n    def parsePure3[T1, T2, T3, R](parser: Parser, f: String): (T1, T2, T3) => R @pure = $\n\n    def print3[T1, T2, T3, R](f: (T1, T2, T3) => R): String = $\n    def parse3[T1, T2, T3, R](parser: Parser, f: String): (T1, T2, T3) => R = $\n\n    def printPure4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R @pure): String = $\n    def parsePure4[T1, T2, T3, T4, R](parser: Parser, f: String): (T1, T2, T3, T4) => R @pure = $\n\n    def print4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R): String = $\n    def parse4[T1, T2, T3, T4, R](parser: Parser, f: String): (T1, T2, T3, T4) => R = $\n\n    def printPure5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R @pure): String = $\n    def parsePure5[T1, T2, T3, T4, T5, R](parser: Parser, f: String): (T1, T2, T3, T4, T5) => R @pure = $\n\n    def print5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R): String = $\n    def parse5[T1, T2, T3, T4, T5, R](parser: Parser, f: String): (T1, T2, T3, T4, T5) => R = $\n\n    def printPure6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R @pure): String = $\n    def parsePure6[T1, T2, T3, T4, T5, T6, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6) => R @pure = $\n\n    def print6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R): String = $\n    def parse6[T1, T2, T3, T4, T5, T6, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6) => R = $\n\n    def printPure7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R @pure): String = $\n    def parsePure7[T1, T2, T3, T4, T5, T6, T7, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7) => R @pure = $\n\n    def print7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R): String = $\n    def parse7[T1, T2, T3, T4, T5, T6, T7, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7) => R = $\n\n    def printPure8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure): String = $\n    def parsePure8[T1, T2, T3, T4, T5, T6, T7, T8, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure = $\n\n    def print8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R): String = $\n    def parse8[T1, T2, T3, T4, T5, T6, T7, T8, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8) => R = $\n\n    def printPure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure): String = $\n    def parsePure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure = $\n\n    def print9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R): String = $\n    def parse9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R = $\n\n    def printPure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure): String = $\n    def parsePure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure = $\n\n    def print10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R): String = $\n    def parse10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R = $\n\n    def printPure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure): String = $\n    def parsePure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure = $\n\n    def print11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R): String = $\n    def parse11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R = $\n\n    def printPure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure): String = $\n    def parsePure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure = $\n\n    def print12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R): String = $\n    def parse12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R = $\n\n    def printPure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure): String = $\n    def parsePure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure = $\n\n    def print13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R): String = $\n    def parse13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R = $\n\n    def printPure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure): String = $\n    def parsePure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure = $\n\n    def print14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R): String = $\n    def parse14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R = $\n\n    def printPure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure): String = $\n    def parsePure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure = $\n\n    def print15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R): String = $\n    def parse15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R = $\n\n    def printPure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure): String = $\n    def parsePure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure = $\n\n    def print16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R): String = $\n    def parse16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R = $\n\n    def printPure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure): String = $\n    def parsePure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure = $\n\n    def print17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R): String = $\n    def parse17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R = $\n\n    def printPure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure): String = $\n    def parsePure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure = $\n\n    def print18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R): String = $\n    def parse18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R = $\n\n    def printPure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure): String = $\n    def parsePure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure = $\n\n    def print19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R): String = $\n    def parse19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R = $\n\n    def printPure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure): String = $\n    def parsePure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure = $\n\n    def print20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R): String = $\n    def parse20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R = $\n\n    def printPure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure): String = $\n    def parsePure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure = $\n\n    def print21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R): String = $\n    def parse21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R = $\n\n    def printPure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure): String = $\n    def parsePure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure = $\n\n    def print22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R): String = $\n    def parse22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](parser: Parser, f: String): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R = $\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$32();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #684                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\n@record class MBox[T](var value: T)\n\n@record class MBox2[T1, T2](var value1: T1, var value2: T2)\n\n@record class MBox3[T1, T2, T3](var value1: T1, var value2: T2, var value3: T3)\n\n@record class MBox4[T1, T2, T3, T4](var value1: T1, var value2: T2, var value3: T3, var value4: T4)\n\n@record class MBox5[T1, T2, T3, T4, T5](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5)\n\n@record class MBox6[T1, T2, T3, T4, T5, T6](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6)\n\n@record class MBox7[T1, T2, T3, T4, T5, T6, T7](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7)\n\n@record class MBox8[T1, T2, T3, T4, T5, T6, T7, T8](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8)\n\n@record class MBox9[T1, T2, T3, T4, T5, T6, T7, T8, T9](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9)\n\n@record class MBox10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10)\n\n@record class MBox11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11)\n\n@record class MBox12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12)\n\n@record class MBox13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13)\n\n@record class MBox14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14)\n\n@record class MBox15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15)\n\n@record class MBox16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16)\n\n@record class MBox17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17)\n\n@record class MBox18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18)\n\n@record class MBox19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19)\n\n@record class MBox20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20)\n\n@record class MBox21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20, var value21: T21)\n\n@record class MBox22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22](var value1: T1, var value2: T2, var value3: T3, var value4: T4, var value5: T5, var value6: T6, var value7: T7, var value8: T8, var value9: T9, var value10: T10, var value11: T11, var value12: T12, var value13: T13, var value14: T14, var value15: T15, var value16: T16, var value17: T17, var value18: T18, var value19: T19, var value20: T20, var value21: T21, var value22: T22)\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$33();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #686                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Graph {\n\n  type Index = Z\n\n  @datatype trait Edge[W, E] {\n    @pure def source: W\n    @pure def dest: W\n    @pure def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E]\n  }\n\n  object Edge {\n\n    @datatype class Plain[W, E](val source: W, val dest: W) extends Edge[W, E] {\n\n      @pure override def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E] = {\n        return Internal.Edge.Plain(map.get(source).get, map.get(dest).get)\n      }\n\n    }\n\n    @datatype class Data[W, E](val source: W, val dest: W, val data: E) extends Edge[W, E] {\n\n      @pure override def toInternal(map: HashSMap[W, Graph.Index]): Internal.Edge[E] = {\n        return Internal.Edge.Data(map.get(source).get, map.get(dest).get, data)\n      }\n\n    }\n\n  }\n\n  object Internal {\n\n    @datatype trait Edge[E] {\n      @pure def source: Graph.Index\n      @pure def dest: Graph.Index\n      @pure def toEdge[W](map: ISZ[W]): Graph.Edge[W, E]\n    }\n\n    @datatype trait Edges[E] {\n      @pure def elements: ISZ[Internal.Edge[E]]\n      @pure def size: Z\n      @pure def +(e: Internal.Edge[E]): Edges[E]\n      @pure def ++(es: ISZ[Internal.Edge[E]]): Edges[E]\n      @pure def -#(p: (Internal.Edge[E], Z)): Edges[E]\n    }\n\n    object Edges {\n\n      @datatype class Set[E](val set: HashSSet[Internal.Edge[E]]) extends Edges[E] {\n\n        @pure override def elements: ISZ[Internal.Edge[E]] = {\n          return set.elements\n        }\n\n        @pure override def size: Z = {\n          return set.size\n        }\n\n        @pure override def +(e: Graph.Internal.Edge[E]): Edges[E] = {\n          return this(set + e)\n        }\n\n        @pure override def ++(es: ISZ[Internal.Edge[E]]): Edges[E] = {\n          return this(set ++ es)\n        }\n\n        @pure override def -#(p: (Internal.Edge[E], Z)): Edges[E] = {\n          return this(set - p._1)\n        }\n      }\n\n      @datatype class Bag[E](val set: HashSBag[Internal.Edge[E]]) extends Edges[E] {\n\n        @pure override def elements: ISZ[Internal.Edge[E]] = {\n          return set.elements\n        }\n\n        @pure override def size: Z = {\n          return set.size\n        }\n\n        @pure override def +(e: Internal.Edge[E]): Edges[E] = {\n          return this(set + e)\n        }\n\n        @pure override def ++(es: ISZ[Internal.Edge[E]]): Edges[E] = {\n          return this(set ++ es)\n        }\n\n        @pure override def -#(p: (Internal.Edge[E], Z)): Edges[E] = {\n          return this(set -# p)\n        }\n      }\n\n      @pure def empty[E](multi: B): Edges[E] = {\n        return if (multi) Bag(HashSBag.empty) else Set(HashSSet.empty)\n      }\n\n    }\n\n    object Edge {\n\n      @datatype class Plain[E](val source: Graph.Index, val dest: Graph.Index) extends Edge[E] {\n\n        @pure override def toEdge[W](map: ISZ[W]): Graph.Edge[W, E] = {\n          return Graph.Edge.Plain(map(source), map(dest))\n        }\n\n      }\n\n      @datatype class Data[E](val source: Graph.Index, val dest: Graph.Index, val data: E) extends Edge[E] {\n\n        @pure override def toEdge[W](map: ISZ[W]): Graph.Edge[W, E] = {\n          return Graph.Edge.Data(map(source), map(dest), data)\n        }\n\n      }\n\n    }\n\n    @pure def addEdge[W, E](g: Graph[W, E], e: Internal.Edge[E]): Graph[W, E] = {\n      return g(\n        incomingEdges = g.incomingEdges + e.dest ~> (g.incomingEdges\n          .get(e.dest)\n          .getOrElse(Edges.empty[E](g.multi)) + e),\n        outgoingEdges = g.outgoingEdges + e.source ~> (g.outgoingEdges\n          .get(e.source)\n          .getOrElse(Edges.empty[E](g.multi)) + e)\n      )\n    }\n\n    @pure def addPlainEdge[W, E](g: Graph[W, E], src: Graph.Index, dst: Graph.Index): Graph[W, E] = {\n      return addEdge(g, Graph.Internal.Edge.Plain[E](src, dst))\n    }\n\n    @pure def addDataEdge[W, E](g: Graph[W, E], data: E, src: Graph.Index, dst: Graph.Index): Graph[W, E] = {\n      return addEdge(g, Graph.Internal.Edge.Data(src, dst, data))\n    }\n\n    @pure def removeEdge[W, E](g: Graph[W, E], e: Graph.Internal.Edge[E], n: Z): Graph[W, E] = {\n      if (g.incomingEdges.get(e.dest).isEmpty) {\n        return g\n      }\n      return g(\n        incomingEdges = g.incomingEdges + e.dest ~> (g.incomingEdges.get(e.dest).get -# e ~> n),\n        outgoingEdges = g.outgoingEdges + e.source ~> (g.outgoingEdges.get(e.source).get -# e ~> n)\n      )\n    }\n\n    @pure def incoming[W, E](g: Graph[W, E], dst: Graph.Index): ISZ[Graph.Internal.Edge[E]] = {\n      g.incomingEdges.get(dst) match {\n        case Some(s) => return s.elements\n        case _ => return ISZ()\n      }\n    }\n\n    @pure def outgoing[W, E](g: Graph[W, E], src: Graph.Index): ISZ[Graph.Internal.Edge[E]] = {\n      g.outgoingEdges.get(src) match {\n        case Some(s) => return s.elements\n        case _ => return ISZ()\n      }\n    }\n\n  }\n\n  @pure def empty[W, E]: Graph[W, E] = {\n    return Graph(HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty, 0, F)\n  }\n\n  @pure def emptyMulti[W, E]: Graph[W, E] = {\n    return Graph(HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty, 0, T)\n  }\n}\n\n@datatype class Graph[W, E](\n  val nodes: HashSMap[W, Graph.Index],\n  val nodesInverse: IS[Graph.Index, W],\n  val incomingEdges: HashSMap[Graph.Index, Graph.Internal.Edges[E]],\n  val outgoingEdges: HashSMap[Graph.Index, Graph.Internal.Edges[E]],\n  val nextNodeId: Graph.Index,\n  val multi: B\n) {\n\n  @pure def *(node: W): Graph[W, E] = {\n    nodes.get(node) match {\n      case Some(_) => return this\n      case _ =>\n        return this(\n          nodes + node ~> nextNodeId,\n          nodesInverse :+ node,\n          incomingEdges,\n          outgoingEdges,\n          nextNodeId + 1,\n          multi\n        )\n    }\n  }\n\n  @pure def --*[I](ns: IS[I, W]): Graph[W, E] = {\n    var r: Graph[W, E] = if (multi) Graph.emptyMulti[W, E] else Graph.empty[W, E]\n    val ins = HashSet ++ ns.map[Z](n => nodes.get(n).get)\n    for (es <- incomingEdges.values) {\n      for (e <- es.elements) {\n        if (ins.contains(e.source) && ins.contains(e.dest)) {\n          r = r.addEdge(e.toEdge(nodesInverse))\n        }\n      }\n    }\n    return r\n  }\n\n  @pure def +(edge: (W, W)): Graph[W, E] = {\n    return addPlainEdge(edge._1, edge._2)\n  }\n\n  @pure def +@(edge: ((W, W), E)): Graph[W, E] = {\n    return addDataEdge(edge._2, edge._1._1, edge._1._2)\n  }\n\n  @pure def -(edge: Graph.Edge[W, E]): Graph[W, E] = {\n    return removeEdgeN(edge, 1)\n  }\n\n  @pure def -#(p: (Graph.Edge[W, E], Z)): Graph[W, E] = {\n    return removeEdgeN(p._1, p._2)\n  }\n\n  @pure def --[I](edges: IS[I, Graph.Edge[W, E]]): Graph[W, E] = {\n    var r = this\n    for (e <- edges) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def incoming(dest: W): ISZ[Graph.Edge[W, E]] = {\n    nodes.get(dest) match {\n      case Some(dst) => return Graph.Internal.incoming(this, dst).map(e => e.toEdge(nodesInverse))\n      case _ => return ISZ()\n    }\n  }\n\n  @pure def outgoing(source: W): ISZ[Graph.Edge[W, E]] = {\n    nodes.get(source) match {\n      case Some(src) => Graph.Internal.outgoing(this, src).map[Graph.Edge[W, E]](e => e.toEdge(nodesInverse))\n      case _ => return ISZ()\n    }\n  }\n\n  @pure def addEdge(edge: Graph.Edge[W, E]): Graph[W, E] = {\n    return Graph.Internal.addEdge(this * edge.source * edge.dest, edge.toInternal(nodes))\n  }\n\n  @pure def addPlainEdge(source: W, dest: W): Graph[W, E] = {\n    val r = this * source * dest\n    return Graph.Internal.addPlainEdge(r, r.nodes.get(source).get, r.nodes.get(dest).get)\n  }\n\n  @pure def addDataEdge(data: E, source: W, dest: W): Graph[W, E] = {\n    val r = this * source * dest\n    return Graph.Internal.addDataEdge(r, data, r.nodes.get(source).get, r.nodes.get(dest).get)\n  }\n\n  @pure def allEdges: ISZ[Graph.Edge[W, E]] = {\n    return for (es <- incomingEdges.values; e <- es.elements) yield e.toEdge(nodesInverse)\n  }\n\n  @pure def removeEdgeN(edge: Graph.Edge[W, E], n: Z): Graph[W, E] = {\n    return Graph.Internal.removeEdge(this, edge.toInternal(nodes), n)\n  }\n\n  @pure def edges(source: W, dest: W): ISZ[Graph.Edge[W, E]] = {\n    return outgoing(source).filter(e => e.dest == dest)\n  }\n\n  @pure def numOfNodes: Z = {\n    return nodes.size\n  }\n\n  @pure def numOfEdges: Z = {\n    var r = z\"0\"\n    for (n <- incomingEdges.values.map[Z](s => s.size)) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure override def hash: Z = {\n    return (numOfNodes, numOfEdges).hash\n  }\n\n  @pure def isEqual(other: Graph[W, E]): B = {\n    if (nodes.size != other.nodes.size || incomingEdges.size != incomingEdges.size) {\n      return F\n    }\n    if (nodes.keySet != other.nodes.keySet) {\n      return F\n    }\n    val thisEdges: ISZ[Graph.Edge[W, E]] =\n      for (ess <- incomingEdges.values; es <- ess.elements) yield es.toEdge(nodesInverse)\n    val otherEdges: ISZ[Graph.Edge[W, E]] =\n      for (ess <- other.incomingEdges.values; es <- ess.elements) yield es.toEdge(other.nodesInverse)\n    return (HashSet ++ thisEdges ++ otherEdges).size == thisEdges.size\n  }\n\n  @pure def toST(attributes: ISZ[ST], f: W => ST @pure, g: E => ST @pure): ST = {\n    @pure def e2st(e: Graph.Internal.Edge[E]): ST = {\n      e match {\n        case Graph.Internal.Edge.Data(source, dest, data) => return st\"\"\"n$source -> n$dest ${g(data)}\"\"\"\n        case Graph.Internal.Edge.Plain(source, dest) => return st\"\"\"n$source -> n$dest\"\"\"\n      }\n    }\n    val nodes: ISZ[ST] = for (e <- this.nodes.entries) yield st\"\"\"n${e._2} ${f(e._1)}\"\"\"\n    val edges: ISZ[ST] = for (es <- incomingEdges.values; e <- es.elements) yield e2st(e)\n    val r =\n      st\"\"\"digraph G {\n      |\n      |  ${(attributes, \"\\n\")}\n      |\n      |  ${(nodes, \"\\n\")}\n      |\n      |  ${(edges, \"\\n\")}\n      |\n      |}\"\"\"\n    return r\n\n  }\n\n  @pure override def string: String = {\n    return toST(ISZ(), v => st\"\"\"[label=\"$v\"]\"\"\", e => st\"\"\"[label=\"$e\"]\"\"\").render\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$34();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #688                // String // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from Project.scala\n\npackage org.sireum.project\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printProject(o: Project): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Project\"\"\"\"),\n        (\"modules\", printHashSMap(F, o.modules, printString _, printModule _)),\n        (\"poset\", printPoset(T, o.poset, printString _)),\n        (\"mavenRepoUrls\", printISZ(T, o.mavenRepoUrls, printString _))\n      ))\n    }\n\n    @pure def printTargetType(o: Target.Type): ST = {\n      val value: String = o match {\n        case Target.Jvm => \"Jvm\"\n        case Target.Js => \"Js\"\n      }\n      return printObject(ISZ(\n        (\"type\", printString(\"Target\")),\n        (\"value\", printString(value))\n      ))\n    }\n\n    @pure def printModule(o: Module): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Module\"\"\"\"),\n        (\"id\", printString(o.id)),\n        (\"basePath\", printString(o.basePath)),\n        (\"subPathOpt\", printOption(T, o.subPathOpt, printString _)),\n        (\"deps\", printISZ(T, o.deps, printString _)),\n        (\"targets\", printISZ(F, o.targets, printTargetType _)),\n        (\"ivyDeps\", printISZ(T, o.ivyDeps, printString _)),\n        (\"sources\", printISZ(T, o.sources, printString _)),\n        (\"resources\", printISZ(T, o.resources, printString _)),\n        (\"testSources\", printISZ(T, o.testSources, printString _)),\n        (\"testResources\", printISZ(T, o.testResources, printString _)),\n        (\"publishInfoOpt\", printOption(F, o.publishInfoOpt, printPublishInfo _))\n      ))\n    }\n\n    @pure def printPublishInfo(o: PublishInfo): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo\"\"\"\"),\n        (\"description\", printString(o.description)),\n        (\"url\", printString(o.url)),\n        (\"licenses\", printISZ(F, o.licenses, printPublishInfoLicense _)),\n        (\"developers\", printISZ(F, o.developers, printPublishInfoDeveloper _))\n      ))\n    }\n\n    @pure def printPublishInfoLicense(o: PublishInfo.License): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo.License\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"url\", printString(o.url)),\n        (\"distribution\", printString(o.distribution))\n      ))\n    }\n\n    @pure def printPublishInfoDeveloper(o: PublishInfo.Developer): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"PublishInfo.Developer\"\"\"\"),\n        (\"id\", printString(o.id)),\n        (\"name\", printString(o.name))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parseProject(): Project = {\n      val r = parseProjectT(F)\n      return r\n    }\n\n    def parseProjectT(typeParsed: B): Project = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Project\")\n      }\n      parser.parseObjectKey(\"modules\")\n      val modules = parser.parseHashSMap(parser.parseString _, parseModule _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"poset\")\n      val poset = parser.parsePoset(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"mavenRepoUrls\")\n      val mavenRepoUrls = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      return Project(modules, poset, mavenRepoUrls)\n    }\n\n    def parseTargetType(): Target.Type = {\n      val r = parseTargetT(F)\n      return r\n    }\n\n    def parseTargetT(typeParsed: B): Target.Type = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Target\")\n      }\n      parser.parseObjectKey(\"value\")\n      var i = parser.offset\n      val s = parser.parseString()\n      parser.parseObjectNext()\n      Target.byName(s) match {\n        case Some(r) => return r\n        case _ =>\n          parser.parseException(i, s\"Invalid element name \'$s\' for Target.\")\n          return Target.byOrdinal(0).get\n      }\n    }\n\n    def parseModule(): Module = {\n      val r = parseModuleT(F)\n      return r\n    }\n\n    def parseModuleT(typeParsed: B): Module = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Module\")\n      }\n      parser.parseObjectKey(\"id\")\n      val id = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"basePath\")\n      val basePath = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"subPathOpt\")\n      val subPathOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"deps\")\n      val deps = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"targets\")\n      val targets = parser.parseISZ(parseTargetType _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"ivyDeps\")\n      val ivyDeps = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"sources\")\n      val sources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"resources\")\n      val resources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"testSources\")\n      val testSources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"testResources\")\n      val testResources = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"publishInfoOpt\")\n      val publishInfoOpt = parser.parseOption(parsePublishInfo _)\n      parser.parseObjectNext()\n      return Module(id, basePath, subPathOpt, deps, targets, ivyDeps, sources, resources, testSources, testResources, publishInfoOpt)\n    }\n\n    def parsePublishInfo(): PublishInfo = {\n      val r = parsePublishInfoT(F)\n      return r\n    }\n\n    def parsePublishInfoT(typeParsed: B): PublishInfo = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo\")\n      }\n      parser.parseObjectKey(\"description\")\n      val description = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"url\")\n      val url = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"licenses\")\n      val licenses = parser.parseISZ(parsePublishInfoLicense _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"developers\")\n      val developers = parser.parseISZ(parsePublishInfoDeveloper _)\n      parser.parseObjectNext()\n      return PublishInfo(description, url, licenses, developers)\n    }\n\n    def parsePublishInfoLicense(): PublishInfo.License = {\n      val r = parsePublishInfoLicenseT(F)\n      return r\n    }\n\n    def parsePublishInfoLicenseT(typeParsed: B): PublishInfo.License = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo.License\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"url\")\n      val url = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"distribution\")\n      val distribution = parser.parseString()\n      parser.parseObjectNext()\n      return PublishInfo.License(name, url, distribution)\n    }\n\n    def parsePublishInfoDeveloper(): PublishInfo.Developer = {\n      val r = parsePublishInfoDeveloperT(F)\n      return r\n    }\n\n    def parsePublishInfoDeveloperT(typeParsed: B): PublishInfo.Developer = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"PublishInfo.Developer\")\n      }\n      parser.parseObjectKey(\"id\")\n      val id = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      return PublishInfo.Developer(id, name)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromProject(o: Project, isCompact: B): String = {\n    val st = Printer.printProject(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toProject(s: String): Either[Project, Json.ErrorMsg] = {\n    def fProject(parser: Parser): Project = {\n      val r = parser.parseProject()\n      return r\n    }\n    val r = to(s, fProject _)\n    return r\n  }\n\n  def fromModule(o: Module, isCompact: B): String = {\n    val st = Printer.printModule(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toModule(s: String): Either[Module, Json.ErrorMsg] = {\n    def fModule(parser: Parser): Module = {\n      val r = parser.parseModule()\n      return r\n    }\n    val r = to(s, fModule _)\n    return r\n  }\n\n  def fromPublishInfo(o: PublishInfo, isCompact: B): String = {\n    val st = Printer.printPublishInfo(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfo(s: String): Either[PublishInfo, Json.ErrorMsg] = {\n    def fPublishInfo(parser: Parser): PublishInfo = {\n      val r = parser.parsePublishInfo()\n      return r\n    }\n    val r = to(s, fPublishInfo _)\n    return r\n  }\n\n  def fromPublishInfoLicense(o: PublishInfo.License, isCompact: B): String = {\n    val st = Printer.printPublishInfoLicense(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfoLicense(s: String): Either[PublishInfo.License, Json.ErrorMsg] = {\n    def fPublishInfoLicense(parser: Parser): PublishInfo.License = {\n      val r = parser.parsePublishInfoLicense()\n      return r\n    }\n    val r = to(s, fPublishInfoLicense _)\n    return r\n  }\n\n  def fromPublishInfoDeveloper(o: PublishInfo.Developer, isCompact: B): String = {\n    val st = Printer.printPublishInfoDeveloper(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPublishInfoDeveloper(s: String): Either[PublishInfo.Developer, Json.ErrorMsg] = {\n    def fPublishInfoDeveloper(parser: Parser): PublishInfo.Developer = {\n      val r = parser.parsePublishInfoDeveloper()\n      return r\n    }\n    val r = to(s, fPublishInfoDeveloper _)\n    return r\n  }\n\n}
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$35();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #690                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\npackage org.sireum.project\n\nimport org.sireum._\n\nobject Project {\n  @strictpure def empty: Project = Project(HashSMap.empty, Poset.empty, ISZ())\n}\n\n@datatype class Project(val modules: HashSMap[String, Module],\n                        val poset: Poset[String],\n                        val mavenRepoUrls: ISZ[String]) {\n\n  @strictpure def +(module: Module): Project = Project(\n    modules = modules + module.id ~> module,\n    poset = poset.addParents(module.id, module.deps),\n    mavenRepoUrls = mavenRepoUrls\n  )\n\n  @strictpure def addMavenRepository(url: String): Project = Project(\n    modules = modules, poset = poset, mavenRepoUrls = mavenRepoUrls :+ url\n  )\n\n  @strictpure def addMavenRepositories(urls: ISZ[String]): Project = Project(\n    modules = modules, poset = poset, mavenRepoUrls = mavenRepoUrls ++ urls\n  )\n\n  @strictpure override def hash: Z = modules.hash\n\n  @strictpure def isEqual(other: Project): B = modules == other.modules\n\n  @strictpure def <=(other: Project): B = modules == (other.modules -- (other.modules.keys -- modules.keys))\n\n  @strictpure def >=(other: Project): B = (modules -- (modules.keys -- other.modules.keys)) == other.modules\n\n  @pure def ++(other: Project): Project = {\n    var r = this\n    var names = other.poset.rootNodes\n    while (names.nonEmpty) {\n      var newNames = HashSSet.empty[String]\n      for (name <- names) {\n        other.modules.get(name) match {\n          case Some(m) => r = r + m\n          case _ =>\n        }\n        newNames = newNames.union(other.poset.childrenOf(name))\n      }\n      names = newNames.elements\n    }\n    r = r(mavenRepoUrls = (HashSSet ++ r.mavenRepoUrls ++ other.mavenRepoUrls).elements)\n    return r\n  }\n\n  @pure def stripPubInfo: Project = {\n    var r = Project.empty\n    for (m <- modules.values) {\n      r = r + m(publishInfoOpt = None())\n    }\n    return r\n  }\n\n  @pure def slice(mids: ISZ[String]): Project = {\n    if (mids.isEmpty) {\n      return this\n    }\n    var tmids = HashSet.empty[String]\n    def rec(mid: String): Unit = {\n      tmids = tmids + mid\n      modules.get(mid) match {\n        case Some(m) =>\n          for (mDep <- m.deps) {\n            rec(mDep)\n          }\n        case _ =>\n      }\n    }\n    for (mid <- mids) {\n      rec(mid)\n    }\n    var r = Project.empty\n    for (p <- modules.entries if tmids.contains(p._1)) {\n      r = r + p._2\n    }\n    return r\n  }\n\n  @pure def openDeps: Map[String, ISZ[String]] = {\n    val mids = modules.keys\n    var r = Map.empty[String, ISZ[String]]\n    for (m <- modules.values) {\n      val diff = m.deps -- mids\n      if (diff.nonEmpty) {\n        r = r + m.id ~> diff\n      }\n    }\n    return r\n  }\n\n  @pure def illTargets: Map[String, Map[String, ISZ[Target.Type]]] = {\n    var r = Map.empty[String, Map[String, ISZ[Target.Type]]]\n    for (m <- modules.values) {\n      var map = Map.empty[String, ISZ[Target.Type]]\n      for (mDep <- m.deps) {\n        modules.get(mDep) match {\n          case Some(m2) =>\n            val diff = m.targets -- m2.targets\n            if (diff.nonEmpty) {\n              map = map + m2.id ~> diff\n            }\n          case _ =>\n        }\n      }\n      if (map.nonEmpty) {\n        r = r + m.id ~> map\n      }\n    }\n    return r\n  }\n\n}\n\n@enum object Target {\n  \"Jvm\"\n  \"Js\"\n}\n\n@datatype class Module(val id: String,\n                       val basePath: String,\n                       val subPathOpt: Option[String],\n                       val deps: ISZ[String],\n                       val targets: ISZ[Target.Type],\n                       val ivyDeps: ISZ[String],\n                       val sources: ISZ[String],\n                       val resources: ISZ[String],\n                       val testSources: ISZ[String],\n                       val testResources: ISZ[String],\n                       val publishInfoOpt: Option[PublishInfo]) {\n\n  @strictpure def hasTarget(target: Target.Type): B = ops.ISZOps(targets).contains(target)\n\n}\n\nobject Module {\n  val allTargets: ISZ[Target.Type] = ISZ(Target.Jvm, Target.Js)\n}\n\n@datatype class PublishInfo(val description: String,\n                            val url: String,\n                            val licenses: ISZ[PublishInfo.License],\n                            val developers: ISZ[PublishInfo.Developer])\n\nobject PublishInfo {\n\n  @datatype class License(val name: String,\n                          val url: String,\n                          val distribution: String)\n\n  @datatype class Developer(val id: String,\n                            val name: String)\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$36();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #692                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject Bag {\n\n  @pure def empty[T]: Bag[T] = {\n    return Bag(Map.empty[T, Z])\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): Bag[T] = {\n    return Bag.empty[T] ++ s\n  }\n\n}\n\n@datatype class Bag[T](val map: Map[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): Bag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def addN(e: T, n: Z): Bag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def +#(p: (T, Z)): Bag[T] = {\n    val (e, n) = p\n    return addN(e, n)\n  }\n\n  @pure def ++[I](es: IS[I, T]): Bag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): Bag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](es: IS[I, T]): Bag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def \\(other: Bag[T]): Bag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def -#(p: (T, Z)): Bag[T] = {\n    val (e, n) = p\n    return removeN(e, n)\n  }\n\n  @pure def removeN(e: T, n: Z): Bag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: Bag[T]): Bag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: Bag[T]): Bag[T] = {\n    var r = this\n    for (e <- other.entries) {\n      r = r +# e._1 ~> e._2\n    }\n    return r\n  }\n\n  @pure def intersect(other: Bag[T]): Bag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: Bag[T]): Bag[T] = {\n    var r = Bag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r +# e._1 ~> n\n      } else {\n        r = r +# e._1 ~> m\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$37();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #694                // String // #Sireum\n// @formatter:off\n\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This file is auto-generated from Presentation.scala\n\npackage org.sireum.presentasi\n\nimport org.sireum._\nimport org.sireum.Json.Printer._\n\nobject JSON {\n\n  object Printer {\n\n    @pure def printPresentationEntry(o: Presentation.Entry): ST = {\n      o match {\n        case o: Presentation.SlideEntry => return printPresentationSlideEntry(o)\n        case o: Presentation.VideoEntry => return printPresentationVideoEntry(o)\n      }\n    }\n\n    @pure def printPresentationSlideEntry(o: Presentation.SlideEntry): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation.SlideEntry\"\"\"\"),\n        (\"path\", printString(o.path)),\n        (\"delay\", printZ(o.delay)),\n        (\"text\", printString(o.text))\n      ))\n    }\n\n    @pure def printPresentationVideoEntry(o: Presentation.VideoEntry): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation.VideoEntry\"\"\"\"),\n        (\"path\", printString(o.path)),\n        (\"delay\", printZ(o.delay)),\n        (\"volume\", printF64(o.volume)),\n        (\"rate\", printF64(o.rate)),\n        (\"start\", printF64(o.start)),\n        (\"end\", printF64(o.end)),\n        (\"useVideoDuration\", printB(o.useVideoDuration)),\n        (\"textOpt\", printOption(T, o.textOpt, printString _))\n      ))\n    }\n\n    @pure def printPresentation(o: Presentation): ST = {\n      return printObject(ISZ(\n        (\"type\", st\"\"\"\"Presentation\"\"\"\"),\n        (\"name\", printString(o.name)),\n        (\"args\", printISZ(T, o.args, printString _)),\n        (\"delay\", printZ(o.delay)),\n        (\"vseekDelay\", printZ(o.vseekDelay)),\n        (\"textVolume\", printF64(o.textVolume)),\n        (\"trailing\", printZ(o.trailing)),\n        (\"granularity\", printZ(o.granularity)),\n        (\"entries\", printISZ(F, o.entries, printPresentationEntry _))\n      ))\n    }\n\n  }\n\n  @record class Parser(val input: String) {\n    val parser: Json.Parser = Json.Parser.create(input)\n\n    def errorOpt: Option[Json.ErrorMsg] = {\n      return parser.errorOpt\n    }\n\n    def parsePresentationEntry(): Presentation.Entry = {\n      val t = parser.parseObjectTypes(ISZ(\"Presentation.SlideEntry\", \"Presentation.VideoEntry\"))\n      t.native match {\n        case \"Presentation.SlideEntry\" => val r = parsePresentationSlideEntryT(T); return r\n        case \"Presentation.VideoEntry\" => val r = parsePresentationVideoEntryT(T); return r\n        case _ => val r = parsePresentationVideoEntryT(T); return r\n      }\n    }\n\n    def parsePresentationSlideEntry(): Presentation.SlideEntry = {\n      val r = parsePresentationSlideEntryT(F)\n      return r\n    }\n\n    def parsePresentationSlideEntryT(typeParsed: B): Presentation.SlideEntry = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation.SlideEntry\")\n      }\n      parser.parseObjectKey(\"path\")\n      val path = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"text\")\n      val text = parser.parseString()\n      parser.parseObjectNext()\n      return Presentation.SlideEntry(path, delay, text)\n    }\n\n    def parsePresentationVideoEntry(): Presentation.VideoEntry = {\n      val r = parsePresentationVideoEntryT(F)\n      return r\n    }\n\n    def parsePresentationVideoEntryT(typeParsed: B): Presentation.VideoEntry = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation.VideoEntry\")\n      }\n      parser.parseObjectKey(\"path\")\n      val path = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"volume\")\n      val volume = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"rate\")\n      val rate = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"start\")\n      val start = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"end\")\n      val end = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"useVideoDuration\")\n      val useVideoDuration = parser.parseB()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"textOpt\")\n      val textOpt = parser.parseOption(parser.parseString _)\n      parser.parseObjectNext()\n      return Presentation.VideoEntry(path, delay, volume, rate, start, end, useVideoDuration, textOpt)\n    }\n\n    def parsePresentation(): Presentation = {\n      val r = parsePresentationT(F)\n      return r\n    }\n\n    def parsePresentationT(typeParsed: B): Presentation = {\n      if (!typeParsed) {\n        parser.parseObjectType(\"Presentation\")\n      }\n      parser.parseObjectKey(\"name\")\n      val name = parser.parseString()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"args\")\n      val args = parser.parseISZ(parser.parseString _)\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"delay\")\n      val delay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"vseekDelay\")\n      val vseekDelay = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"textVolume\")\n      val textVolume = parser.parseF64()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"trailing\")\n      val trailing = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"granularity\")\n      val granularity = parser.parseZ()\n      parser.parseObjectNext()\n      parser.parseObjectKey(\"entries\")\n      val entries = parser.parseISZ(parsePresentationEntry _)\n      parser.parseObjectNext()\n      return Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries)\n    }\n\n    def eof(): B = {\n      val r = parser.eof()\n      return r\n    }\n\n  }\n\n  def to[T](s: String, f: Parser => T): Either[T, Json.ErrorMsg] = {\n    val parser = Parser(s)\n    val r = f(parser)\n    parser.eof()\n    parser.errorOpt match {\n      case Some(e) => return Either.Right(e)\n      case _ => return Either.Left(r)\n    }\n  }\n\n  def fromPresentationEntry(o: Presentation.Entry, isCompact: B): String = {\n    val st = Printer.printPresentationEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationEntry(s: String): Either[Presentation.Entry, Json.ErrorMsg] = {\n    def fPresentationEntry(parser: Parser): Presentation.Entry = {\n      val r = parser.parsePresentationEntry()\n      return r\n    }\n    val r = to(s, fPresentationEntry _)\n    return r\n  }\n\n  def fromPresentationSlideEntry(o: Presentation.SlideEntry, isCompact: B): String = {\n    val st = Printer.printPresentationSlideEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationSlideEntry(s: String): Either[Presentation.SlideEntry, Json.ErrorMsg] = {\n    def fPresentationSlideEntry(parser: Parser): Presentation.SlideEntry = {\n      val r = parser.parsePresentationSlideEntry()\n      return r\n    }\n    val r = to(s, fPresentationSlideEntry _)\n    return r\n  }\n\n  def fromPresentationVideoEntry(o: Presentation.VideoEntry, isCompact: B): String = {\n    val st = Printer.printPresentationVideoEntry(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentationVideoEntry(s: String): Either[Presentation.VideoEntry, Json.ErrorMsg] = {\n    def fPresentationVideoEntry(parser: Parser): Presentation.VideoEntry = {\n      val r = parser.parsePresentationVideoEntry()\n      return r\n    }\n    val r = to(s, fPresentationVideoEntry _)\n    return r\n  }\n\n  def fromPresentation(o: Presentation, isCompact: B): String = {\n    val st = Printer.printPresentation(o)\n    if (isCompact) {\n      return st.renderCompact\n    } else {\n      return st.render\n    }\n  }\n\n  def toPresentation(s: String): Either[Presentation, Json.ErrorMsg] = {\n    def fPresentation(parser: Parser): Presentation = {\n      val r = parser.parsePresentation()\n      return r\n    }\n    val r = to(s, fPresentation _)\n    return r\n  }\n\n}
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$38();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #696                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.presentasi\n\nimport org.sireum._\n\nobject Presentation {\n\n  @datatype trait Entry {\n    @pure def path: String\n    @pure def delay: Z\n  }\n\n  @datatype class SlideEntry(val path: String,\n                             val delay: Z,\n                             val text: String) extends Entry\n\n  @datatype class VideoEntry(val path: String,\n                             val delay: Z,\n                             val volume: F64,\n                             val rate: F64,\n                             val start: F64,\n                             val end: F64,\n                             val useVideoDuration: B,\n                             val textOpt: Option[String]) extends Entry\n\n  type Slide = SlideEntry\n  type Video = VideoEntry\n\n  val empty: Presentation = Presentation(\"Presentasi\", ISZ(), 2000, 250, 1.0, 2000, 1, ISZ())\n\n  val Slide: Slide = SlideEntry(\"\", 0, \"\")\n\n  val Video: Video = VideoEntry(\"\", 0, 1.0, 1.0, 0.0, 0.0, F, None())\n\n}\n\n@datatype class Presentation(val name: String,\n                             val args: ISZ[String],\n                             val delay: Z,\n                             val vseekDelay: Z,\n                             val textVolume: F64,\n                             val trailing: Z,\n                             val granularity: Z,\n                             val entries: ISZ[Presentation.Entry]) {\n\n  @strictpure def +(entry: Presentation.Entry): Presentation =\n    Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries :+ entry)\n\n  @strictpure def ++(es: ISZ[Presentation.Entry]): Presentation =\n    Presentation(name, args, delay, vseekDelay, textVolume, trailing, granularity, entries ++ es)\n\n  def cli(args: ISZ[String]): Unit = {\n    val thisL = this\n    println(JSON.fromPresentation(thisL(args = args), T))\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$39();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #698                // String // #Sireum\n/*\nAdapted from: https://github.com/msgpack4z/msgpack4z-native with the following license:\n\nCopyright (c) 2015 msgpack4z-core contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\npackage org.sireum\n\nimport U8._\nimport U16._\nimport U32._\nimport U64._\nimport S8._\nimport S16._\nimport S32._\nimport S64._\n\nobject MessagePack {\n\n  @enum object Kind {\n    \"NIL\"\n    \"BOOLEAN\"\n    \"INTEGER\"\n    \"FLOAT\"\n    \"STRING\"\n    \"ARRAY\"\n    \"MAP\"\n    \"BINARY\"\n    \"EXTENSION\"\n    \"NONE\"\n  }\n\n  val TimestampExtType: S8 = s8\"-1\"\n  val StringPoolExtType: S8 = s8\"0\"\n  val DocInfoExtType: S8 = s8\"1\"\n  val LastExtType: S8 = DocInfoExtType\n\n  object Code {\n    val POSFIXINT_MASK: U8 = u8\"0x80\"\n    val FIXMAP_PREFIX: U8 = u8\"0x80\"\n    val FIXARRAY_PREFIX: U8 = u8\"0x90\"\n    val FIXSTR_PREFIX: U8 = u8\"0xA0\"\n    val NIL: U8 = u8\"0xC0\"\n    val FALSE: U8 = u8\"0xC2\"\n    val TRUE: U8 = u8\"0xC3\"\n    val BIN8: U8 = u8\"0xC4\"\n    val BIN16: U8 = u8\"0xC5\"\n    val BIN32: U8 = u8\"0xC6\"\n    val EXT8: U8 = u8\"0xC7\"\n    val EXT16: U8 = u8\"0xC8\"\n    val EXT32: U8 = u8\"0xC9\"\n    val FLOAT32: U8 = u8\"0xCA\"\n    val FLOAT64: U8 = u8\"0xCB\"\n    val UINT8: U8 = u8\"0xCC\"\n    val UINT16: U8 = u8\"0xCD\"\n    val UINT32: U8 = u8\"0xCE\"\n    val UINT64: U8 = u8\"0xCF\"\n    val INT8: U8 = u8\"0xD0\"\n    val INT16: U8 = u8\"0xD1\"\n    val INT32: U8 = u8\"0xD2\"\n    val INT64: U8 = u8\"0xD3\"\n    val FIXEXT1: U8 = u8\"0xD4\"\n    val FIXEXT2: U8 = u8\"0xD5\"\n    val FIXEXT4: U8 = u8\"0xD6\"\n    val FIXEXT8: U8 = u8\"0xD7\"\n    val FIXEXT16: U8 = u8\"0xD8\"\n    val STR8: U8 = u8\"0xD9\"\n    val STR16: U8 = u8\"0xDA\"\n    val STR32: U8 = u8\"0xDB\"\n    val ARRAY16: U8 = u8\"0xDC\"\n    val ARRAY32: U8 = u8\"0xDD\"\n    val MAP16: U8 = u8\"0xDE\"\n    val MAP32: U8 = u8\"0xDF\"\n    val NEGFIXINT_PREFIX: U8 = u8\"0xE0\"\n\n    val formatTable: IS[U8, Kind.Type] = {\n      @pure def getType0(n: U8): Kind.Type = {\n        if (isPosFixInt(n) || isNegFixInt(n)) {\n          return Kind.INTEGER\n        } else if (Code.isFixStr(n)) {\n          return Kind.STRING\n        } else if (Code.isFixedArray(n)) {\n          return Kind.ARRAY\n        } else if (Code.isFixedMap(n)) {\n          return Kind.MAP\n        } else {\n          n match {\n            case Code.NIL => return Kind.NIL\n            case Code.FALSE => return Kind.BOOLEAN\n            case Code.TRUE => return Kind.BOOLEAN\n            case Code.BIN8 => return Kind.BINARY\n            case Code.BIN16 => return Kind.BINARY\n            case Code.BIN32 => return Kind.BINARY\n            case Code.FLOAT32 => return Kind.FLOAT\n            case Code.FLOAT64 => return Kind.FLOAT\n            case Code.UINT8 => return Kind.INTEGER\n            case Code.UINT16 => return Kind.INTEGER\n            case Code.UINT32 => return Kind.INTEGER\n            case Code.UINT64 => return Kind.INTEGER\n            case Code.INT8 => return Kind.INTEGER\n            case Code.INT16 => return Kind.INTEGER\n            case Code.INT32 => return Kind.INTEGER\n            case Code.INT64 => return Kind.INTEGER\n            case Code.STR8 => return Kind.STRING\n            case Code.STR16 => return Kind.STRING\n            case Code.STR32 => return Kind.STRING\n            case Code.ARRAY16 => return Kind.ARRAY\n            case Code.ARRAY32 => return Kind.ARRAY\n            case Code.MAP16 => return Kind.MAP\n            case Code.MAP32 => return Kind.MAP\n            case Code.FIXEXT1 => return Kind.EXTENSION\n            case Code.FIXEXT2 => return Kind.EXTENSION\n            case Code.FIXEXT4 => return Kind.EXTENSION\n            case Code.FIXEXT8 => return Kind.EXTENSION\n            case Code.FIXEXT16 => return Kind.EXTENSION\n            case Code.EXT8 => return Kind.EXTENSION\n            case Code.EXT16 => return Kind.EXTENSION\n            case Code.EXT32 => return Kind.EXTENSION\n            case _ => return Kind.NONE\n          }\n        }\n      }\n\n      var a = IS[U8, Kind.Type]()\n      var n = 0\n      var i = u8\"0\"\n      while (n <= 256) {\n        a = a :+ getType0(i)\n        n = n + 1\n        i = i + u8\"1\"\n      }\n      a\n    }\n\n    @pure def getType(n: U8): Kind.Type = {\n      return formatTable(n)\n    }\n\n    @pure def isFixInt(n: U8): B = {\n      val v = n & u8\"0xFF\"\n      return v <= u8\"0x7F\" || v >= u8\"0xE0\"\n    }\n\n    @pure def isPosFixInt(n: U8): B = {\n      return (n & POSFIXINT_MASK) == u8\"0\"\n    }\n\n    @pure def isNegFixInt(n: U8): B = {\n      return (n & NEGFIXINT_PREFIX) == NEGFIXINT_PREFIX\n    }\n\n    @pure def isFixStr(n: U8): B = {\n      return (n & u8\"0xE0\") == Code.FIXSTR_PREFIX\n    }\n\n    @pure def isFixedArray(n: U8): B = {\n      return (n & u8\"0xF0\") == Code.FIXARRAY_PREFIX\n    }\n\n    @pure def isFixedMap(n: U8): B = {\n      return (n & u8\"0xF0\") == Code.FIXMAP_PREFIX\n    }\n\n    @pure def isFixedRaw(n: U8): B = {\n      return (n & u8\"0xE0\") == Code.FIXSTR_PREFIX\n    }\n\n    @pure def isExt(n: U8): B = {\n      n match {\n        case Code.EXT8 => return T\n        case Code.EXT16 => return T\n        case Code.EXT32 => return T\n        case Code.FIXEXT1 => return T\n        case Code.FIXEXT2 => return T\n        case Code.FIXEXT4 => return T\n        case Code.FIXEXT8 => return T\n        case Code.FIXEXT16 => return T\n        case _ => return F\n      }\n    }\n\n  }\n\n  @record trait Writer {\n\n    def result: ISZ[U8]\n\n    def writeB(b: B): Unit\n\n    def writeC(c: C): Unit = {\n      writeU32(conversions.C.toU32(c))\n    }\n\n    def writeZ(n: Z): Unit\n\n    def writeZ8(n: Z8): Unit = {\n      writeS8(conversions.Z8.toS8(n))\n    }\n\n    def writeZ16(n: Z16): Unit = {\n      writeS16(conversions.Z16.toS16(n))\n    }\n\n    def writeZ32(n: Z32): Unit = {\n      writeS32(conversions.Z32.toS32(n))\n    }\n\n    def writeZ64(n: Z64): Unit = {\n      writeS64(conversions.Z64.toS64(n))\n    }\n\n    def writeN(n: N): Unit = {\n      writeZ(conversions.N.toZ(n))\n    }\n\n    def writeN8(n: N8): Unit = {\n      writeU8(conversions.N8.toU8(n))\n    }\n\n    def writeN16(n: N16): Unit = {\n      writeU16(conversions.N16.toU16(n))\n    }\n\n    def writeN32(n: N32): Unit = {\n      writeU32(conversions.N32.toU32(n))\n    }\n\n    def writeN64(n: N64): Unit = {\n      writeU64(conversions.N64.toU64(n))\n    }\n\n    def writeS8(n: S8): Unit\n\n    def writeS16(n: S16): Unit\n\n    def writeS32(n: S32): Unit\n\n    def writeS64(n: S64): Unit\n\n    def writeU8(n: U8): Unit\n\n    def writeU16(n: U16): Unit\n\n    def writeU32(n: U32): Unit\n\n    def writeU64(n: U64): Unit\n\n    def writeR(n: R): Unit = {\n      writeString(n.string)\n    }\n\n    def writeF32(n: F32): Unit\n\n    def writeF64(n: F64): Unit\n\n    def writeString(s: String): Unit\n\n    def writeOption[T](o: Option[T], f: T => Unit): Unit = {\n      o match {\n        case Some(e) => f(e)\n        case _ => writeNil()\n      }\n    }\n\n    def writeMOption[T](o: MOption[T], f: T => Unit): Unit = {\n      o match {\n        case MSome(e) => f(e)\n        case _ => writeNil()\n      }\n    }\n\n    def writeEither[L, R](o: Either[L, R], l: L => Unit, r: R => Unit): Unit = {\n      o match {\n        case Either.Left(e) => l(e)\n        case Either.Right(e) =>\n          writeNil()\n          r(e)\n      }\n    }\n\n    def writeMEither[L, R](o: MEither[L, R], l: L => Unit, r: R => Unit): Unit = {\n      o match {\n        case MEither.Left(e) => l(e)\n        case MEither.Right(e) =>\n          writeNil()\n          r(e)\n      }\n    }\n\n    def writeISZ[E](s: IS[Z, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ8[E](s: IS[Z8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ16[E](s: IS[Z16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ32[E](s: IS[Z32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISZ64[E](s: IS[Z64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN[E](s: IS[N, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN8[E](s: IS[N8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN16[E](s: IS[N16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN32[E](s: IS[N32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISN64[E](s: IS[N64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS8[E](s: IS[S8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS16[E](s: IS[S16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS32[E](s: IS[S32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISS64[E](s: IS[S64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU8[E](s: IS[U8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU16[E](s: IS[U16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU32[E](s: IS[U32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeISU64[E](s: IS[U64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ[E](s: MS[Z, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ8[E](s: MS[Z8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ16[E](s: MS[Z16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ32[E](s: MS[Z32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSZ64[E](s: MS[Z64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN[E](s: MS[N, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN8[E](s: MS[N8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN16[E](s: MS[N16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN32[E](s: MS[N32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSN64[E](s: MS[N64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS8[E](s: MS[S8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS16[E](s: MS[S16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS32[E](s: MS[S32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSS64[E](s: MS[S64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU8[E](s: MS[U8, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU16[E](s: MS[U16, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU32[E](s: MS[U32, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeMSU64[E](s: MS[U64, E], f: E => Unit): Unit = {\n      writeArrayHeader(s.size)\n      for (e <- s) {\n        f(e)\n      }\n    }\n\n    def writeZS(s: ZS): Unit = {\n      writeMSZ(s, writeZ _)\n    }\n\n    def writeMap[K, T](o: Map[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeSet[T](o: Set[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeHashMap[K, T](o: HashMap[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeHashSet[T](o: HashSet[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeHashSMap[K, T](o: HashSMap[K, T], f: K => Unit, g: T => Unit): Unit = {\n      writeMapHeader(o.size)\n      for (e <- o.entries) {\n        f(e._1)\n        g(e._2)\n      }\n    }\n\n    def writeHashSSet[T](o: HashSSet[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeStack[T](o: Stack[T], f: T => Unit): Unit = {\n      writeISZ(o.elements, f)\n    }\n\n    def writeBag[T](o: Bag[T], f: T => Unit): Unit = {\n      writeMap(o.map, f, writeZ _)\n    }\n\n    def writeHashBag[T](o: HashBag[T], f: T => Unit): Unit = {\n      writeHashMap(o.map, f, writeZ _)\n    }\n\n    def writeHashSBag[T](o: HashSBag[T], f: T => Unit): Unit = {\n      writeHashSMap(o.map, f, writeZ _)\n    }\n\n    def writePoset[T](o: Poset[T], f: T => Unit): Unit = {\n      def g(s: HashSSet[Poset.Index]): Unit = {\n        writeHashSSet(s, writeZ _)\n      }\n      writeISZ(o.nodesInverse, f)\n      writeHashSMap(o.parents, writeZ _, g _)\n    }\n\n    def writeGraph[W, E](o: Graph[W, E], f: W => Unit, g: E => Unit): Unit = {\n      def writeEdge(edge: Graph.Internal.Edge[E]): Unit = {\n        edge match {\n          case Graph.Internal.Edge.Plain(src, dest) =>\n            writeZ(src)\n            writeZ(dest)\n            writeNil()\n          case Graph.Internal.Edge.Data(src, dest, data) =>\n            writeZ(src)\n            writeZ(dest)\n            g(data)\n        }\n      }\n      val edges: ISZ[Graph.Internal.Edge[E]] =\n        for (es <- o.outgoingEdges.values; e <- es.elements) yield e\n      writeB(o.multi)\n      writeISZ(o.nodesInverse, f)\n      writeISZ(edges, writeEdge _)\n    }\n\n    def writeUnionFind[T](o: UnionFind[T], f: T => Unit): Unit = {\n      writeISZ(o.elementsInverse, f)\n      writeISZ(o.parentOf, writeZ _)\n      writeISZ(o.sizeOf, writeZ _)\n    }\n\n    def writeMessage(o: message.Message): Unit = {\n      writeZ(o.level.ordinal)\n      writeOption(o.posOpt, writePosition _)\n      writeString(o.kind)\n      writeString(o.text)\n    }\n\n    def writePosition(o: message.Position): Unit\n\n    def writeDocInfo(o: message.DocInfo): Unit\n\n    def writeArrayHeader(n: Z): Unit\n\n    def writeBinary(array: ISZ[U8]): Unit\n\n    def writeNil(): Unit\n\n    def writeMapHeader(n: Z): Unit\n\n    def writeExtTypeHeader(extType: S8, payloadLen: Z): Unit\n\n    def writePayload(data: ISZ[U8]): Unit\n  }\n\n  object Writer {\n\n    @record class Impl(val pooling: B, var buf: MSZ[U8], var size: Z) extends Writer {\n\n      var stringPool: HashSMap[String, Z] = HashSMap.emptyInit(1024)\n      var docInfoPool: HashSMap[message.DocInfo, Z] = HashSMap.emptyInit(1024)\n\n      def result: ISZ[U8] = {\n        if (pooling) {\n          val strings = stringPool.keys\n          val poolBufferSize: Z = {\n            var r: Z = 0\n            for (s <- strings) {\n              r = r + s.size * 2\n            }\n            r + 4\n          }\n          val (poolBuf, poolBufSize): (MSZ[U8], Z) = {\n            val r = Impl(F, MSZ.create(poolBufferSize, u8\"0\"), 0)\n            r.writeExtTypeHeader(StringPoolExtType, strings.size)\n            for (s <- strings) {\n              r.writeStringNoPool(s)\n            }\n            r.writeExtTypeHeader(DocInfoExtType, docInfoPool.size)\n            for (di <- docInfoPool.keys) {\n              r.writeDocInfoNoPool(di)\n            }\n            (r.buf, r.size)\n          }\n\n          val r = MSZ.create(poolBufSize + size, u8\"0\")\n          var i = 0\n          while (i < poolBufSize) {\n            r(i) = poolBuf(i)\n            i = i + 1\n          }\n          i = 0\n          while (i < size) {\n            r(i + poolBufSize) = buf(i)\n            i = i + 1\n          }\n          return r.toIS\n        } else {\n          val r = MSZ.create(size, u8\"0\")\n          var i = 0\n          while (i < size) {\n            r(i) = buf(i)\n            i = i + 1\n          }\n          return r.toIS\n        }\n      }\n\n      def addString(s: String): Z = {\n        stringPool.get(s) match {\n          case Some(i) => return i\n          case _ =>\n            val i = stringPool.size\n            stringPool = stringPool + s ~> i\n            return i\n        }\n      }\n\n      def addU8(n: U8): Unit = {\n        if (size == buf.size) {\n          val newBuf = MSZ.create(buf.size * 2 + 1, u8\"0\")\n          for (i <- z\"0\" until buf.size) {\n            newBuf(i) = buf(i)\n          }\n          buf = newBuf\n        }\n        buf(size) = n\n        size = size + 1\n      }\n\n      def addU16(n: U16): Unit = {\n        addU8(conversions.U16.toU8((n >>> u16\"8\") & u16\"0xFF\"))\n        addU8(conversions.U16.toU8(n & u16\"0xFF\"))\n      }\n\n      def addU32(n: U32): Unit = {\n        addU8(conversions.U32.toU8((n >>> u32\"24\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8((n >>> u32\"16\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8((n >>> u32\"8\") & u32\"0xFF\"))\n        addU8(conversions.U32.toU8(n & u32\"0xFF\"))\n      }\n\n      def addU64(n: U64): Unit = {\n        addU8(conversions.U64.toU8((n >>> u64\"56\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"48\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"40\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"32\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"24\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"16\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8((n >>> u64\"8\") & u64\"0xFF\"))\n        addU8(conversions.U64.toU8(n & u64\"0xFF\"))\n      }\n\n      def addS8(n: S8): Unit = {\n        addU8(conversions.S8.toRawU8(n))\n      }\n\n      def addS16(n: S16): Unit = {\n        addU8(conversions.S16.toU8((n >>> s16\"8\") & s16\"0xFF\"))\n        addU8(conversions.S16.toU8(n & s16\"0xFF\"))\n      }\n\n      def addS32(n: S32): Unit = {\n        addU8(conversions.S32.toU8((n >>> s32\"24\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8((n >>> s32\"16\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8((n >>> s32\"8\") & s32\"0xFF\"))\n        addU8(conversions.S32.toU8(n & s32\"0xFF\"))\n      }\n\n      def addS64(n: S64): Unit = {\n        addU8(conversions.S64.toU8((n >>> s64\"56\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"48\") & s64\"0xFF\"))\n        addU8(conver
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$5();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #700                // String sions.S64.toU8((n >>> s64\"40\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"32\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"24\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"16\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8((n >>> s64\"8\") & s64\"0xFF\"))\n        addU8(conversions.S64.toU8(n & s64\"0xFF\"))\n      }\n\n      def writeU8(n: U8): Unit = {\n        if (n > u8\"127\") {\n          addU8(Code.UINT8)\n          addU8(n)\n        } else {\n          writeS8(conversions.U8.toS8(n))\n        }\n      }\n\n      def writeS8(n: S8): Unit = {\n        if (n < -(s8\"1\" << s8\"5\")) {\n          addU8(Code.INT8)\n          addS8(n)\n        } else {\n          addS8(n)\n        }\n      }\n\n      def writeU16(n: U16): Unit = {\n        if (n > u16\"32767\") {\n          addU8(Code.UINT16)\n          addU16(n)\n        } else {\n          writeS16(conversions.U16.toS16(n))\n        }\n      }\n\n      def writeS16(n: S16): Unit = {\n        if (n < -(s16\"1\" << s16\"5\")) {\n          if (n < -(s16\"1\" << s16\"7\")) {\n            addU8(Code.INT16)\n            addS16(n)\n          } else {\n            addU8(Code.INT8)\n            addS8(conversions.S16.toS8(n))\n          }\n        } else if (n < (s16\"1\" << s16\"7\")) {\n          addS8(conversions.S16.toS8(n))\n        } else {\n          if (n < (s16\"1\" << s16\"8\")) {\n            addU8(Code.UINT8)\n            addU8(conversions.S16.toU8(n))\n          } else {\n            addU8(Code.UINT16)\n            addU16(conversions.S16.toU16(n))\n          }\n        }\n      }\n\n      def writeU32(n: U32): Unit = {\n        if (n > u32\"2147483647\") {\n          addU8(Code.UINT32)\n          addU32(n)\n        } else {\n          writeS32(conversions.U32.toS32(n))\n        }\n      }\n\n      def writeS32(n: S32): Unit = {\n        if (n < -(s32\"1\" << s32\"5\")) {\n          if (n < -(s32\"1\" << s32\"15\")) {\n            addU8(Code.INT32)\n            addS32(n)\n          } else if (n < -(s32\"1\" << s32\"7\")) {\n            addU8(Code.INT16)\n            addS16(conversions.S32.toS16(n))\n          } else {\n            addU8(Code.INT8)\n            addS8(conversions.S32.toS8(n))\n          }\n        } else if (n < (s32\"1\" << s32\"7\")) {\n          addS8(conversions.S32.toS8(n))\n        } else {\n          if (n < (s32\"1\" << s32\"8\")) {\n            addU8(Code.UINT8)\n            addU8(conversions.S32.toU8(n))\n          } else if (n < (s32\"1\" << s32\"16\")) {\n            addU8(Code.UINT16)\n            addU16(conversions.S32.toU16(n))\n          } else {\n            addU8(Code.UINT32)\n            addU32(conversions.S32.toU32(n))\n          }\n        }\n      }\n\n      def writeU64(n: U64): Unit = {\n        if (n > u64\"9223372036854775807\") {\n          addU8(Code.UINT64)\n          addU64(n)\n        } else {\n          writeS64(conversions.U64.toS64(n))\n        }\n      }\n\n      def writeS64(n: S64): Unit = {\n        if (n < -(s64\"1\" << s64\"5\")) {\n          if (n < -(s64\"1\" << s64\"15\")) {\n            if (n < -(s64\"1\" << s64\"31\")) {\n              addU8(Code.INT64)\n              addS64(n)\n            } else {\n              addU8(Code.INT32)\n              addS32(conversions.S64.toS32(n))\n            }\n          } else {\n            if (n < -(s64\"1\" << s64\"7\")) {\n              addU8(Code.INT16)\n              addS16(conversions.S64.toS16(n))\n            } else {\n              addU8(Code.INT8)\n              addS8(conversions.S64.toS8(n))\n            }\n          }\n        } else if (n < (s64\"1\" << s64\"7\")) {\n          addS8(conversions.S64.toS8(n))\n        } else {\n          if (n < (s64\"1\" << s64\"16\")) {\n            if (n < (s64\"1\" << s64\"8\")) {\n              addU8(Code.UINT8)\n              addU8(conversions.S64.toU8(n))\n            } else {\n              addU8(Code.UINT16)\n              addU16(conversions.S64.toU16(n))\n            }\n          } else {\n            if (n < (s64\"1\" << s64\"32\")) {\n              addU8(Code.UINT32)\n              addU32(conversions.S64.toU32(n))\n            } else {\n              addU8(Code.UINT64)\n              addU64(conversions.S64.toU64(n))\n            }\n          }\n        }\n      }\n\n      def writeZ(n: Z): Unit = {\n        if (-9223372036854775808L <= n && n <= 9223372036854775807L) {\n          writeS64(conversions.Z.toS64(n))\n        } else if (0 <= n && n <= z\"18446744073709551615\") {\n          writeU64(conversions.Z.toU64(n))\n        } else {\n          writeBinary(conversions.Z.toBinary(n))\n        }\n      }\n\n      def writeF32(n: F32): Unit = {\n        addU8(Code.FLOAT32)\n        addU32(conversions.F32.toRawU32(n))\n      }\n\n      def writeF64(n: F64): Unit = {\n        addU8(Code.FLOAT64)\n        addU64(conversions.F64.toRawU64(n))\n      }\n\n      def writeArrayHeader(n: Z): Unit = {\n        Contract(Requires(0 <= n, n <= z\"4294967295\"))\n\n        if (n < 16 /* 1 << 4 */ ) {\n          addU8(Code.FIXARRAY_PREFIX | conversions.Z.toU8(n))\n        } else if (n < 65536 /* 1 << 16 */ ) {\n          addU8(Code.ARRAY16)\n          addS16(conversions.Z.toS16(n))\n        } else {\n          addU8(Code.ARRAY32)\n          addS32(conversions.Z.toS32(n))\n        }\n      }\n\n      def writeBinary(array: ISZ[U8]): Unit = {\n        Contract(Requires(0 <= array.size, array.size <= z\"4294967295\"))\n\n        val len = array.size\n        if (len < 256 /* 1 << 8 */ ) {\n          addU8(Code.BIN8)\n          addU8(conversions.Z.toU8(len))\n        } else if (len < 65536 /* 1 << 16 */ ) {\n          addU8(Code.BIN16)\n          addU16(conversions.Z.toU16(len))\n        } else {\n          addU8(Code.BIN32)\n          addU32(conversions.Z.toU32(len))\n        }\n        for (e <- array) {\n          addU8(e)\n        }\n      }\n\n      def writeNil(): Unit = {\n        addU8(Code.NIL)\n      }\n\n      def writeMapHeader(n: Z): Unit = {\n        Contract(Requires(0 <= n, n <= z\"4294967295\"))\n        if (n < 16 /* 1 << 4 */ ) {\n          addU8(Code.FIXMAP_PREFIX | conversions.Z.toU8(n))\n        } else if (n < 65536 /* 1 << 16 */ ) {\n          addU8(Code.MAP16)\n          addU16(conversions.Z.toU16(n))\n        } else {\n          addU8(Code.MAP32)\n          addU32(conversions.Z.toU32(n))\n        }\n      }\n\n      def writeB(b: B): Unit = {\n        addU8(if (b) Code.TRUE else Code.FALSE)\n      }\n\n      def writeStringNoPool(s: String): Unit = {\n        val size = s.size\n        writeZ(size)\n        val cis = conversions.String.toCis(s)\n        for (i <- z\"0\" until size) {\n          writeU32(conversions.C.toU32(cis(i)))\n        }\n      }\n\n      /*\n      def writeStringNoPool(s: String): Unit = {\n        val bis = conversions.String.toBis(s)\n        val len = bis.size\n        if (len < 32 /* 1 << 5 */ ) {\n          addU8(Code.FIXSTR_PREFIX | conversions.Z.toU8(len))\n        } else if (len < 256 /* 1 << 8 */ ) {\n          addU8(Code.STR8)\n          addU8(conversions.Z.toU8(len))\n        } else if (len < 65536 /* 1 << 16 */ ) {\n          addU8(Code.STR16)\n          addU16(conversions.Z.toU16(len))\n        } else {\n          addU8(Code.STR32)\n          addU32(conversions.Z.toU32(len))\n        }\n        for (e <- bis) {\n          addU8(e)\n        }\n      }\n       */\n\n      def writeString(s: String): Unit = {\n        Contract(Requires(0 <= s.size * 2, s.size * 2 <= z\"4294967295\"))\n\n        if (pooling) {\n          val i = addString(s)\n          writeZ(i)\n        } else {\n          writeStringNoPool(s)\n        }\n      }\n\n      def writeExtTypeHeader(extType: S8, payloadLen: Z): Unit = {\n        Contract(Requires(extType >= s8\"0\", 0 <= payloadLen, payloadLen <= z\"4294967295\"))\n\n        if (payloadLen < 256 /* 1 << 8 */ ) {\n          payloadLen match {\n            case z\"1\" =>\n              addU8(Code.FIXEXT1)\n              addS8(extType)\n            case z\"2\" =>\n              addU8(Code.FIXEXT2)\n              addS8(extType)\n            case z\"4\" =>\n              addU8(Code.FIXEXT4)\n              addS8(extType)\n            case z\"8\" =>\n              addU8(Code.FIXEXT8)\n              addS8(extType)\n            case z\"16\" =>\n              addU8(Code.FIXEXT16)\n              addS8(extType)\n            case _ =>\n              addU8(Code.EXT8)\n              addU8(conversions.Z.toU8(payloadLen))\n              addS8(extType)\n          }\n        } else if (payloadLen < 65536 /* 1 << 16 */ ) {\n          addU8(Code.EXT16)\n          addU16(conversions.Z.toU16(payloadLen))\n          addS8(extType)\n        } else {\n          addU8(Code.EXT32)\n          addU32(conversions.Z.toU32(payloadLen))\n          addS8(extType)\n        }\n      }\n\n      def writePayload(data: ISZ[U8]): Unit = {\n        for (e <- data) {\n          addU8(e)\n        }\n      }\n\n      def writePosition(o: message.Position): Unit = {\n        o match {\n          case o: message.PosInfo if pooling =>\n            writeB(T)\n            writeDocInfo(o.info)\n            writeU64(o.offsetLength)\n          case _ =>\n            writeB(F)\n            writeOption(o.uriOpt, writeString _)\n            writeU32(conversions.Z.toU32(o.beginLine))\n            writeU32(conversions.Z.toU32(o.beginColumn))\n            writeU32(conversions.Z.toU32(o.endLine))\n            writeU32(conversions.Z.toU32(o.endColumn))\n            writeU32(conversions.Z.toU32(o.offset))\n            writeU32(conversions.Z.toU32(o.length))\n        }\n      }\n\n      def writeDocInfoNoPool(o: message.DocInfo): Unit = {\n        writeOption(o.uriOpt, writeString _)\n        writeISZ(o.lineOffsets, writeU32 _)\n      }\n\n      def writeDocInfo(o: message.DocInfo): Unit = {\n        if (pooling) {\n          val n: Z = docInfoPool.get(o) match {\n            case Some(m) => m\n            case _ =>\n              val m = docInfoPool.size\n              docInfoPool = docInfoPool + o ~> m\n              m\n          }\n          writeZ(n)\n        } else {\n          writeDocInfoNoPool(o)\n        }\n      }\n\n    }\n\n  }\n\n  @record trait Reader {\n\n    def init(): Unit\n\n    def error(offset: Z, msg: String): Unit\n\n    def curr: Z\n\n    def readB(): B\n\n    def readC(): C = {\n      val n = readU32()\n      return conversions.U32.toC(n)\n    }\n\n    def readZ(): Z\n\n    def expectZ(n: Z): Unit\n\n    @pure def fix8(n: Z): Z = {\n      if (n > 127) {\n        return n - 256\n      }\n      return n\n    }\n\n    def readZ8(): Z8 = {\n      val n = readZ()\n      return conversions.Z.toZ8(fix8(n))\n    }\n\n    def readZ16(): Z16 = {\n      val n = readZ()\n      return conversions.Z.toZ16(n)\n    }\n\n    def readZ32(): Z32 = {\n      val n = readZ()\n      return conversions.Z.toZ32(n)\n    }\n\n    def readZ64(): Z64 = {\n      val n = readZ()\n      return conversions.Z.toZ64(n)\n    }\n\n    def readN(): N = {\n      val n = readZ()\n      return conversions.Z.toN(n)\n    }\n\n    def readN8(): N8 = {\n      val n = readZ()\n      return conversions.Z.toN8(n)\n    }\n\n    def readN16(): N16 = {\n      val n = readZ()\n      return conversions.Z.toN16(n)\n    }\n\n    def readN32(): N32 = {\n      val n = readZ()\n      return conversions.Z.toN32(n)\n    }\n\n    def readN64(): N64 = {\n      val n = readZ()\n      return conversions.Z.toN64(n)\n    }\n\n    def readS8(): S8 = {\n      val n = readZ()\n      return conversions.Z.toS8(fix8(n))\n    }\n\n    def readS16(): S16 = {\n      val n = readZ()\n      return conversions.Z.toS16(n)\n    }\n\n    def readS32(): S32 = {\n      val n = readZ()\n      return conversions.Z.toS32(n)\n    }\n\n    def readS64(): S64 = {\n      val n = readZ()\n      return conversions.Z.toS64(n)\n    }\n\n    def readU8(): U8 = {\n      val n = readZ()\n      return conversions.Z.toU8(n)\n    }\n\n    def readU16(): U16 = {\n      val n = readZ()\n      return conversions.Z.toU16(n)\n    }\n\n    def readU32(): U32 = {\n      val n = readZ()\n      return conversions.Z.toU32(n)\n    }\n\n    def readU64(): U64 = {\n      val n = readZ()\n      return conversions.Z.toU64(n)\n    }\n\n    def readR(): R\n\n    def readF32(): F32\n\n    def readF64(): F64\n\n    def readString(): String\n\n    def readOption[T](f: () => T): Option[T] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        return None[T]()\n      } else {\n        val o = f()\n        return Some[T](o)\n      }\n    }\n\n    def readMOption[T](f: () => T): MOption[T] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        return MNone[T]()\n      } else {\n        val o = f()\n        return MSome[T](o)\n      }\n    }\n\n    def readEither[L, R](l: () => L, r: () => R): Either[L, R] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        val o = r()\n        return Either.Right(o)\n      } else {\n        val o = l()\n        return Either.Left(o)\n      }\n    }\n\n    def readMEither[L, R](l: () => L, r: () => R): MEither[L, R] = {\n      val isNil = skipIfNil()\n      if (isNil) {\n        val o = r()\n        return MEither.Right(o)\n      } else {\n        val o = l()\n        return MEither.Left(o)\n      }\n    }\n\n    def readISZ[E](f: () => E): IS[Z, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ8[E](f: () => E): IS[Z8, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ16[E](f: () => E): IS[Z16, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ32[E](f: () => E): IS[Z32, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISZ64[E](f: () => E): IS[Z64, E] = {\n      val size = readArrayHeader()\n      var r = IS[Z64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN[E](f: () => E): IS[N, E] = {\n      val size = readArrayHeader()\n      var r = IS[N, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN8[E](f: () => E): IS[N8, E] = {\n      val size = readArrayHeader()\n      var r = IS[N8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN16[E](f: () => E): IS[N16, E] = {\n      val size = readArrayHeader()\n      var r = IS[N16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN32[E](f: () => E): IS[N32, E] = {\n      val size = readArrayHeader()\n      var r = IS[N32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISN64[E](f: () => E): IS[N64, E] = {\n      val size = readArrayHeader()\n      var r = IS[N64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS8[E](f: () => E): IS[S8, E] = {\n      val size = readArrayHeader()\n      var r = IS[S8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS16[E](f: () => E): IS[S16, E] = {\n      val size = readArrayHeader()\n      var r = IS[S16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS32[E](f: () => E): IS[S32, E] = {\n      val size = readArrayHeader()\n      var r = IS[S32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISS64[E](f: () => E): IS[S64, E] = {\n      val size = readArrayHeader()\n      var r = IS[S64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU8[E](f: () => E): IS[U8, E] = {\n      val size = readArrayHeader()\n      var r = IS[U8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU16[E](f: () => E): IS[U16, E] = {\n      val size = readArrayHeader()\n      var r = IS[U16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU32[E](f: () => E): IS[U32, E] = {\n      val size = readArrayHeader()\n      var r = IS[U32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readISU64[E](f: () => E): IS[U64, E] = {\n      val size = readArrayHeader()\n      var r = IS[U64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ[E](f: () => E): MS[Z, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ8[E](f: () => E): MS[Z8, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ16[E](f: () => E): MS[Z16, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ32[E](f: () => E): MS[Z32, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSZ64[E](f: () => E): MS[Z64, E] = {\n      val size = readArrayHeader()\n      var r = MS[Z64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN[E](f: () => E): MS[N, E] = {\n      val size = readArrayHeader()\n      var r = MS[N, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN8[E](f: () => E): MS[N8, E] = {\n      val size = readArrayHeader()\n      var r = MS[N8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN16[E](f: () => E): MS[N16, E] = {\n      val size = readArrayHeader()\n      var r = MS[N16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN32[E](f: () => E): MS[N32, E] = {\n      val size = readArrayHeader()\n      var r = MS[N32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSN64[E](f: () => E): MS[N64, E] = {\n      val size = readArrayHeader()\n      var r = MS[N64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS8[E](f: () => E): MS[S8, E] = {\n      val size = readArrayHeader()\n      var r = MS[S8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS16[E](f: () => E): MS[S16, E] = {\n      val size = readArrayHeader()\n      var r = MS[S16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSS32[E](f: () => E): MS[S32, E] = {\n      val size = readArrayHeader()\n      var r = MS[S32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i =
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f2$3();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #702                // String  i + 1\n      }\n      return r\n    }\n\n    def readMSS64[E](f: () => E): MS[S64, E] = {\n      val size = readArrayHeader()\n      var r = MS[S64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU8[E](f: () => E): MS[U8, E] = {\n      val size = readArrayHeader()\n      var r = MS[U8, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU16[E](f: () => E): MS[U16, E] = {\n      val size = readArrayHeader()\n      var r = MS[U16, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU32[E](f: () => E): MS[U32, E] = {\n      val size = readArrayHeader()\n      var r = MS[U32, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readMSU64[E](f: () => E): MS[U64, E] = {\n      val size = readArrayHeader()\n      var r = MS[U64, E]()\n      var i = 0\n      while (i < size) {\n        val o = f()\n        r = r :+ o\n        i = i + 1\n      }\n      return r\n    }\n\n    def readZS(): ZS = {\n      val r = readMSZ(readZ _)\n      return r\n    }\n\n    def readMap[K, T](f: () => K, g: () => T): Map[K, T] = {\n      val size = readMapHeader()\n      var r = Map.empty[K, T]\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readSet[T](f: () => T): Set[T] = {\n      val size = readArrayHeader()\n      var r = Set.empty[T]\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashMap[K, T](f: () => K, g: () => T): HashMap[K, T] = {\n      val size = readMapHeader()\n      var r = HashMap.emptyInit[K, T](size)\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSet[T](f: () => T): HashSet[T] = {\n      val size = readArrayHeader()\n      var r = HashSet.emptyInit[T](size)\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSMap[K, T](f: () => K, g: () => T): HashSMap[K, T] = {\n      val size = readMapHeader()\n      var r = HashSMap.emptyInit[K, T](size)\n      var i = 0\n      while (i < size) {\n        val key = f()\n        val value = g()\n        r = r + key ~> value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readHashSSet[T](f: () => T): HashSSet[T] = {\n      val size = readArrayHeader()\n      var r = HashSSet.emptyInit[T](size)\n      var i = 0\n      while (i < size) {\n        val value = f()\n        r = r + value\n        i = i + 1\n      }\n      return r\n    }\n\n    def readStack[T](f: () => T): Stack[T] = {\n      val s = readISZ(f)\n      return Stack(s)\n    }\n\n    def readBag[T](f: () => T): Bag[T] = {\n      val map = readMap(f, readZ _)\n      return Bag(map)\n    }\n\n    def readHashBag[T](f: () => T): HashBag[T] = {\n      val map = readHashMap(f, readZ _)\n      return HashBag(map)\n    }\n\n    def readHashSBag[T](f: () => T): HashSBag[T] = {\n      val map = readHashSMap(f, readZ _)\n      return HashSBag(map)\n    }\n\n    def readPoset[T](f: () => T): Poset[T] = {\n      def g(): HashSSet[Poset.Index] = {\n        val r = readHashSSet(readZ _)\n        return r\n      }\n      val nodesInverse = readISZ(f)\n      val map = readHashSMap(readZ _, g _)\n      val size = nodesInverse.size\n      var nodes = HashSMap.emptyInit[T, Poset.Index](size)\n      var parents = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var children = HashSMap.emptyInit[Poset.Index, HashSSet[Poset.Index]](size)\n      var i: Z = 0\n      for (node <- nodesInverse) {\n        nodes = nodes + node ~> nodes.size\n        parents = parents + i ~> Poset.Internal.emptySet\n        children = children + i ~> Poset.Internal.emptySet\n        i = i + 1\n      }\n      var r = Poset[T](nodes, nodesInverse, parents, children)\n      for (e <- map.entries) {\n        val (n, s) = e\n        r = Poset.Internal.addParents(r, n, s.elements)\n      }\n      return r\n    }\n\n    def readGraph[W, E](f: () => W, g: () => E): Graph[W, E] = {\n      def readEdge(): Graph.Internal.Edge[E] = {\n        val src = readZ()\n        val dest = readZ()\n        val isPlain = skipIfNil()\n        if (isPlain) {\n          return Graph.Internal.Edge.Plain(src, dest)\n        } else {\n          val data = g()\n          return Graph.Internal.Edge.Data(src, dest, data)\n        }\n      }\n      val multi = readB()\n      val nodesInverse = readISZ(f)\n      val edges = readISZ(readEdge _)\n      var r: Graph[W, E] = if (multi) Graph.emptyMulti else Graph.empty\n      for (node <- nodesInverse) {\n        r = r * node\n      }\n      for (e <- edges) {\n        r = Graph.Internal.addEdge(r, e)\n      }\n      return r\n    }\n\n    def readUnionFind[T](f: () => T): UnionFind[T] = {\n      val elementsInverse = readISZ(f)\n      val parentOf = readISZ(readZ _)\n      val sizeOf = readISZ(readZ _)\n      var elements = HashSMap.emptyInit[T, UnionFind.Index](elementsInverse.size)\n      for (e <- elementsInverse) {\n        elements = elements + e ~> elements.size\n      }\n      return UnionFind(elements, elementsInverse, parentOf, sizeOf)\n    }\n\n    def readMessage(): message.Message = {\n      val level = message.Level.byOrdinal(readZ()).getOrElse(message.Level.InternalError)\n      val posOpt = readOption(readPosition _)\n      val kind = readString()\n      val text = readString()\n      return message.Message(level, posOpt, kind, text)\n    }\n\n    def readPosition(): message.Position = {\n      val isPosInfo = readB()\n      if (isPosInfo) {\n        val info = readDocInfo()\n        val offsetLength = readU64()\n        return message.PosInfo(info, offsetLength)\n      } else {\n        val uriOpt = readOption(readString _)\n        val beginLine = readU32()\n        val beginColumn = readU32()\n        val endLine = readU32()\n        val endColumn = readU32()\n        val offset = readU32()\n        val length = readU32()\n        return message.FlatPos(uriOpt, beginLine, beginColumn, endLine, endColumn, offset, length)\n      }\n    }\n\n    def readDocInfo(): message.DocInfo\n\n    def readArrayHeader(): Z\n\n    def readBinary(): ISZ[U8]\n\n    def skipIfNil(): B\n\n    def readMapHeader(): Z\n\n    def readExtTypeHeader(): Option[(S8, Z)]\n\n    def readPayload(n: Z): ISZ[U8]\n\n    def skip(n: Z): Unit\n  }\n\n  @datatype class ErrorMsg(val offset: Z, val message: String)\n\n  object Reader {\n\n    @record class Impl(val buf: ISZ[U8], var curr: Z) extends Reader {\n      var pooling: B = F\n      var stringPool: MSZ[String] = MSZ()\n      var docInfoPool: MSZ[message.DocInfo] = MSZ()\n\n      var errorOpt: Option[ErrorMsg] = None()\n\n      var initialized: B = F\n\n      def init(): Unit = {\n        initialized = T\n        val r = peek()\n        pooling = Code.isExt(r)\n        if (pooling) {\n          var pOpt = readExtTypeHeader()\n          pOpt match {\n            case Some((t, size)) =>\n              assert(t == StringPoolExtType)\n              stringPool = MSZ.create(size, \"\")\n              var i = 0\n              while (i < size) {\n                val s = readStringNoPool()\n                stringPool(i) = s\n                i = i + 1\n              }\n            case _ =>\n          }\n          pOpt = readExtTypeHeader()\n          pOpt match {\n            case Some((t, size)) =>\n              assert(t == DocInfoExtType)\n              docInfoPool = MSZ.create(size, message.DocInfo(None(), ISZ()))\n              var i = 0\n              while (i < size) {\n                val docInfo = readDocInfoNoPool()\n                docInfoPool(i) = docInfo\n                i = i + 1\n              }\n            case _ =>\n          }\n        }\n      }\n\n      def peek(): U8 = {\n        if (errorOpt.nonEmpty) {\n          return u8\"0\"\n        }\n        if (curr >= buf.size) {\n          error(curr, \"Attempted to read more byte than available.\")\n          return u8\"0\"\n        }\n        return buf(curr)\n      }\n\n      def read8(): U8 = {\n        assert(initialized, \"MessagePack.Reader.init() has not been called.\")\n        val r = peek()\n        skip(1)\n        return r\n      }\n\n      def read16(): U16 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        return (conversions.U8.toU16(ch1) << u16\"8\") +\n          conversions.U8.toU16(ch2)\n      }\n\n      def read32(): U32 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        val ch3 = read8()\n        val ch4 = read8()\n        return (conversions.U8.toU32(ch1) << u32\"24\") +\n          (conversions.U8.toU32(ch2) << u32\"16\") +\n          (conversions.U8.toU32(ch3) << u32\"8\") +\n          conversions.U8.toU32(ch4)\n      }\n\n      def read64(): U64 = {\n        val ch1 = read8()\n        val ch2 = read8()\n        val ch3 = read8()\n        val ch4 = read8()\n        val ch5 = read8()\n        val ch6 = read8()\n        val ch7 = read8()\n        val ch8 = read8()\n        return (conversions.U8.toU64(ch1) << u64\"56\") +\n          (conversions.U8.toU64(ch2) << u64\"48\") +\n          (conversions.U8.toU64(ch3) << u64\"40\") +\n          (conversions.U8.toU64(ch4) << u64\"32\") +\n          (conversions.U8.toU64(ch5) << u64\"24\") +\n          (conversions.U8.toU64(ch6) << u64\"16\") +\n          (conversions.U8.toU64(ch7) << u64\"8\") +\n          conversions.U8.toU64(ch8)\n      }\n\n      def error(offset: Z, msg: String): Unit = {\n        errorOpt match {\n          case Some(_) =>\n          case _ => errorOpt = Some(ErrorMsg(offset, msg))\n        }\n      }\n\n      def readB(): B = {\n        val code = read8()\n        code match {\n          case Code.TRUE => return T\n          case Code.FALSE => return F\n          case _ => error(curr - 1, s\"Expecting a B, but found code $code.\"); return F\n        }\n      }\n\n      def readZ(): Z = {\n        val code = read8()\n        if (Code.isFixInt(code)) {\n          return conversions.S8.toZ(conversions.U8.toRawS8(code))\n        }\n        code match {\n          case Code.INT8 =>\n            val n = read8()\n            return conversions.S8.toZ(conversions.U8.toRawS8(n))\n          case Code.INT16 =>\n            val n = read16()\n            return conversions.S16.toZ(conversions.U16.toRawS16(n))\n          case Code.INT32 =>\n            val n = read32()\n            return conversions.S32.toZ(conversions.U32.toRawS32(n))\n          case Code.INT64 =>\n            val n = read64()\n            return conversions.S64.toZ(conversions.U64.toRawS64(n))\n          case Code.UINT8 =>\n            val n = read8()\n            return conversions.U8.toZ(n)\n          case Code.UINT16 =>\n            val n = read16()\n            return conversions.U16.toZ(n)\n          case Code.UINT32 =>\n            val n = read32()\n            return conversions.U32.toZ(n)\n          case Code.UINT64 =>\n            val n = read64()\n            return conversions.U64.toZ(n)\n          case _ =>\n            if (code == Code.BIN8 || code == Code.BIN16 || code == Code.BIN32) {\n              skip(-1)\n              val bin = readBinary()\n              return conversions.Z.fromBinary(bin)\n            } else {\n              error(curr - 1, s\"Expecting an integer, but found code $code.\")\n              return 0\n            }\n        }\n      }\n\n      def expectZ(n: Z): Unit = {\n        val start = curr\n        val m = readZ()\n        if (n != m) {\n          error(start, s\"Expecting $n, but found $m.\")\n        }\n      }\n\n      def readR(): R = {\n        val start = curr\n        val s = readString()\n        R(s) match {\n          case Some(r) => return r\n          case _ => error(start, s\"Expecting a R, but found $s.\"); return r\"0\"\n        }\n      }\n\n      def readF32(): F32 = {\n        val code = read8()\n        code match {\n          case Code.FLOAT32 =>\n          case _ => error(curr - 1, s\"Expecting a F32, but found code $code.\"); return 0f\n        }\n        val n = read32()\n        return conversions.U32.toRawF32(n)\n      }\n\n      def readF64(): F64 = {\n        val code = read8()\n        code match {\n          case Code.FLOAT64 =>\n          case _ => error(curr - 1, s\"Expecting a F64, but found code $code.\"); return 0d\n        }\n        val n = read64()\n        return conversions.U64.toRawF64(n)\n      }\n\n      def readStringNoPool(): String = {\n        val size = readZ()\n        val ms = MSZ.create[C](size, \'\\u0000\')\n        for (i <- z\"0\" until size) {\n          val c = readU32()\n          ms(i) = conversions.U32.toC(c)\n        }\n        return conversions.String.fromCms(ms)\n      }\n\n      /*\n      def readStringNoPool(): String = {\n        val code = read8()\n        val len: Z = {\n          var r: Z = 0\n          if (Code.isFixStr(code)) {\n            r = conversions.U8.toZ(u8\"0x1F\" & code)\n          } else {\n            code match {\n              case Code.STR8 =>\n                val n = read8()\n                r = conversions.U8.toZ(n)\n              case Code.STR16 =>\n                val n = read16()\n                r = conversions.U16.toZ(n)\n              case Code.STR32 =>\n                val n = read32()\n                r = conversions.U32.toZ(n)\n              case _ => halt(s\"Expecting a String, but found $code\")\n            }\n          }\n          r\n        }\n        val a = MSZ.create(len, u8\"0\")\n        var i = 0\n        while (i < len) {\n          a(i) = read8()\n          i = i + 1\n        }\n        return conversions.String.fromBms(a)\n      }\n       */\n\n      def readDocInfo(): message.DocInfo = {\n        if (pooling) {\n          val n = readZ()\n          return docInfoPool(n)\n        } else {\n          val r = readDocInfoNoPool()\n          return r\n        }\n      }\n\n      def readDocInfoNoPool(): message.DocInfo = {\n        val uriOpt = readOption(readString _)\n        val lineOffsets = readISZ(readU32 _)\n        return message.DocInfo(uriOpt, lineOffsets)\n      }\n\n      def readString(): String = {\n        if (pooling) {\n          val index = readZ()\n          return stringPool(index)\n        } else {\n          val r = readStringNoPool()\n          return r\n        }\n      }\n\n      def readArrayHeader(): Z = {\n        val code = read8()\n        if (Code.isFixedArray(code)) {\n          return conversions.U8.toZ(code & u8\"0x0F\")\n        } else {\n          code match {\n            case Code.ARRAY16 =>\n              val r = read16()\n              return conversions.U16.toZ(r)\n            case Code.ARRAY32 =>\n              val r = read32()\n              return conversions.U32.toZ(r)\n            case _ => error(curr - 1, s\"Expecting an array, but found code $code\"); return 0\n          }\n        }\n      }\n\n      def readBinary(): ISZ[U8] = {\n        val code = read8()\n        val len: Z = {\n          var r: Z = 0\n          if (Code.isFixedRaw(code)) {\n            r = conversions.U8.toZ(u8\"0x1F\" & code)\n          } else {\n            code match {\n              case Code.BIN8 =>\n                val n = read8()\n                r = conversions.U8.toZ(n)\n              case Code.BIN16 =>\n                val n = read16()\n                r = conversions.U16.toZ(n)\n              case Code.BIN32 =>\n                val n = read32()\n                r = conversions.U32.toZ(n)\n              case _ => error(curr - 1, s\"Expecting a binary, but found $code\"); return ISZ()\n            }\n          }\n          r\n        }\n        val a = MSZ.create(len, u8\"0\")\n        var i = 0\n        while (i < len) {\n          a(i) = read8()\n          i = i + 1\n        }\n        return a.toIS\n      }\n\n      def skipIfNil(): B = {\n        if (errorOpt.nonEmpty) {\n          return T\n        }\n        val n = peek()\n        val r = n == Code.NIL\n        if (r) {\n          skip(1)\n        }\n        return r\n      }\n\n      def readMapHeader(): Z = {\n        val code = read8()\n        if (Code.isFixedMap(code)) {\n          return conversions.U8.toZ(code & u8\"0x0F\")\n        } else {\n          code match {\n            case Code.MAP16 =>\n              val r = read16()\n              return conversions.U16.toZ(r)\n            case Code.MAP32 =>\n              val r = read32()\n              return conversions.U32.toZ(r)\n            case _ => error(curr - 1, s\"Expecting a map, but found code $code\"); return 0\n          }\n        }\n      }\n\n      def readExtTypeHeader(): Option[(S8, Z)] = {\n        val code = read8()\n        code match {\n          case Code.FIXEXT1 =>\n            val extType = readS8()\n            return Some((extType, 1))\n          case Code.FIXEXT2 =>\n            val extType = readS8()\n            return Some((extType, 2))\n          case Code.FIXEXT4 =>\n            val extType = readS8()\n            return Some((extType, 4))\n          case Code.FIXEXT8 =>\n            val extType = readS8()\n            return Some((extType, 8))\n          case Code.FIXEXT16 =>\n            val extType = readS8()\n            return Some((extType, 16))\n          case Code.EXT8 =>\n            val n = read8()\n            val length = conversions.U8.toZ(n & u8\"0xFF\")\n            val extType = readS8()\n            return Some((extType, length))\n          case Code.EXT16 =>\n            val n = read16()\n            val length = conversions.U16.toZ(n & u16\"0xFFFF\")\n            val extType = readS8()\n            return Some((extType, length))\n          case Code.EXT32 =>\n            val length = conversions.U32.toZ(read32())\n            val extType = readS8()\n            return Some((extType, length))\n          case _ => error(curr - 1, s\"Expecting an ext type, but found code $code\"); return None()\n        }\n      }\n\n      def readPayload(n: Z): ISZ[U8] = {\n        val r = MSZ.create(n, u8\"0\")\n        var i = 0\n        while (i < n) {\n          r(i) = read8()\n          i = i + 1\n        }\n        return r.toIS\n      }\n\n      def skip(n: Z): Unit = {\n        Contract(Requires(0 <= curr + n, curr + n <= buf.size))\n        curr = curr + n\n      }\n    }\n\n  }\n\n  def writer(pooling: B): Writer.Impl = {\n    return Writer.Impl(pooling, MS.create(1024, u8\"0\"), 0)\n  }\n\n  def reader(data: ISZ[U8]): Reader.Impl = {\n    return Reader.Impl(data, 0)\n  }\n\n  @ext(\"MessagePackFun_Ext\") object Fun {\n    def writePure0[R](f: () => R @pure): ISZ[U8] = $\n    def readPure0[R](reader: Reader.Impl, f: ISZ[U8]): () => R @pure = $\n\n    def write0[R](f: () => R): ISZ[U8] = $\n    def read0[R](reader: Reader.Impl, f: ISZ[U8]): () => R = $\n\n    def writePure1[T1, R](f: T1 => R @pure): ISZ[U8] = $\n    def readPure1[T1, R](reader: Reader.Impl, f: ISZ[U8]): T1 => R @pure = $\n\n    def write1[T1, R](f: T1 => R): ISZ[U8] = $\n    def read1[T1, R](reader: Reader.Impl, f: ISZ[U8]): T1 => R = $\n    def writePure2[T1, T2, R](f: (T1, T2) => R @pure): ISZ[U8] = $\n    def readPure2[T1, T2, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2) => R @pure = $\n\n    def write2[T1, T2, R](f: (T1, T2) => R): ISZ[U8] = $\n    def read2[T1, T2, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2) => R = $\n\n    def writePure3[T1, T2, T3, R](f: (T1, T2, T3) => R @pure): ISZ[U8] = $\n    def readPure3[T1, T2, T3, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3) => R @pure = $\n\n    def write3[T1, T2, T3, R](f: (T1, T2, T3) => R): ISZ[U8] = $\n    def read3[T1, T2, T3, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3) => R = $\n\n    def writePure4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R @pure): ISZ[U8] = $\n    def readPure4[T1, T2, T3, T4, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4) => R @pure = $\n\n    def write4[T1, T2, T3, T4, R](f: (T1, T2, T3, T4) => R): ISZ[U8] = $\n    def read4[T1, T2, T3, T4, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4) => R = $\n\n    def writePure5[T1, T2, T3, T4, T5, R](f: (T1, T2, T3, T4, T5) => R @pure): ISZ[U8] = $\n    def readPure5[T1, T2, T3, T4, T5, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5) => R @pure = $\n\n    def write5[T1, T2, T3, T4, T5, R](
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f3$3();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #704                // String f: (T1, T2, T3, T4, T5) => R): ISZ[U8] = $\n    def read5[T1, T2, T3, T4, T5, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5) => R = $\n\n    def writePure6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R @pure): ISZ[U8] = $\n    def readPure6[T1, T2, T3, T4, T5, T6, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6) => R @pure = $\n\n    def write6[T1, T2, T3, T4, T5, T6, R](f: (T1, T2, T3, T4, T5, T6) => R): ISZ[U8] = $\n    def read6[T1, T2, T3, T4, T5, T6, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6) => R = $\n\n    def writePure7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R @pure): ISZ[U8] = $\n    def readPure7[T1, T2, T3, T4, T5, T6, T7, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7) => R @pure = $\n\n    def write7[T1, T2, T3, T4, T5, T6, T7, R](f: (T1, T2, T3, T4, T5, T6, T7) => R): ISZ[U8] = $\n    def read7[T1, T2, T3, T4, T5, T6, T7, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7) => R = $\n\n    def writePure8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure): ISZ[U8] = $\n    def readPure8[T1, T2, T3, T4, T5, T6, T7, T8, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8) => R @pure = $\n\n    def write8[T1, T2, T3, T4, T5, T6, T7, T8, R](f: (T1, T2, T3, T4, T5, T6, T7, T8) => R): ISZ[U8] = $\n    def read8[T1, T2, T3, T4, T5, T6, T7, T8, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8) => R = $\n\n    def writePure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure): ISZ[U8] = $\n    def readPure9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R @pure = $\n\n    def write9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R): ISZ[U8] = $\n    def read9[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9) => R = $\n\n    def writePure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure): ISZ[U8] = $\n    def readPure10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R @pure = $\n\n    def write10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R): ISZ[U8] = $\n    def read10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => R = $\n\n    def writePure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure): ISZ[U8] = $\n    def readPure11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R @pure = $\n\n    def write11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R): ISZ[U8] = $\n    def read11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => R = $\n\n    def writePure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure): ISZ[U8] = $\n    def readPure12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R @pure = $\n\n    def write12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R): ISZ[U8] = $\n    def read12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => R = $\n\n    def writePure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure): ISZ[U8] = $\n    def readPure13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R @pure = $\n\n    def write13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R): ISZ[U8] = $\n    def read13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => R = $\n\n    def writePure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure): ISZ[U8] = $\n    def readPure14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R @pure = $\n\n    def write14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R): ISZ[U8] = $\n    def read14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => R = $\n\n    def writePure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure): ISZ[U8] = $\n    def readPure15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R @pure = $\n\n    def write15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R): ISZ[U8] = $\n    def read15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => R = $\n\n    def writePure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure): ISZ[U8] = $\n    def readPure16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R @pure = $\n\n    def write16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R): ISZ[U8] = $\n    def read16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => R = $\n\n    def writePure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure): ISZ[U8] = $\n    def readPure17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R @pure = $\n\n    def write17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R): ISZ[U8] = $\n    def read17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) => R = $\n\n    def writePure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure): ISZ[U8] = $\n    def readPure18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R @pure = $\n\n    def write18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R): ISZ[U8] = $\n    def read18[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) => R = $\n\n    def writePure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure): ISZ[U8] = $\n    def readPure19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R @pure = $\n\n    def write19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R): ISZ[U8] = $\n    def read19[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) => R = $\n\n    def writePure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure): ISZ[U8] = $\n    def readPure20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R @pure = $\n\n    def write20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R): ISZ[U8] = $\n    def read20[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) => R = $\n\n    def writePure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure): ISZ[U8] = $\n    def readPure21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R @pure = $\n\n    def write21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R): ISZ[U8] = $\n    def read21[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) => R = $\n\n    def writePure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure): ISZ[U8] = $\n    def readPure22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R @pure = $\n\n    def write22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](f: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R): ISZ[U8] = $\n    def read22[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R](reader: Reader.Impl, f: ISZ[U8]): (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) => R = $\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$40();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #706                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject justification {\n\n  @just def Premise: Unit = $\n\n  @just def Auto(stepNumbers: ISZ[StepId]): Unit = $\n\n  @just def Lift(app: Unit): Unit = $\n\n  object natded {\n\n    object prop {\n\n      @just(\"andI\") def AndI(p: StepId, q: StepId): Unit = $\n\n      @just(\"andE1\") def AndE1(pAndQ: StepId): Unit = $\n\n      @just(\"andE2\") def AndE2(pAndQ: StepId): Unit = $\n\n      @just(\"orI1\") def OrI1(p: StepId): Unit = $\n\n      @just(\"orI2\") def OrI2(q: StepId): Unit = $\n\n      @just def OrE(pOrQ: StepId, pToRSub: StepId, qToRSub: StepId): Unit = $\n\n      @just def ImplyI(assumePToQSub: StepId): Unit = $\n\n      @just(\"implyE\") def ImplyE(pImplyQ: StepId, q: StepId): Unit = $\n\n      @just def NegI(assumePToBottomSub: StepId): Unit = $\n\n      @just(\"negE\") def NegE(p: StepId, notP: StepId): Unit = $\n\n      @just def BottomE(bottom: StepId): Unit = $\n\n      @just def PbC(assumeNotRToBottom: StepId): Unit = $\n\n      @pure def andI(p: B, q: B): Unit = {\n        Deduce((p, q) |- (p & q))\n      }\n\n      @pure def andE1(p: B, q: B): Unit = {\n        Deduce((p & q) |- p)\n      }\n\n      @pure def andE2(p: B, q: B): Unit = {\n        Deduce((p & q) |- q)\n      }\n\n      @pure def orI1(p: B, q: B): Unit = {\n        Deduce(p |- (p | q))\n      }\n\n      @pure def orI2(p: B, q: B): Unit = {\n        Deduce(q |- (p | q))\n      }\n\n      @pure def implyE(p: B, q: B): Unit = {\n        Deduce((p ->: q, p) |- q)\n      }\n\n      @pure def negE(p: B): Unit = {\n        Deduce((p, !p) |- F)\n      }\n    }\n\n    object pred {\n\n      @just def AllI(assumeAToAllSub: StepId): Unit = $\n\n      @just(\"allE\") def AllE[T](allP: StepId): Unit = $\n\n      @just(\"existsI\") def ExistsI[T](PE: StepId): Unit = $\n\n      @just def ExistsE[T](existsP: StepId, aPaToQSub: StepId): Unit = $\n\n      @pure def allE[T](P: T => B@pure, E: T): Unit = {\n        Deduce(All { (x: T) => P(x) } |- P(E))\n      }\n\n      @pure def existsI[T](P: T => B@pure, E: T): Unit = {\n        Deduce(P(E) |- Exists { (x: T) => P(x) })\n      }\n\n    }\n\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$41();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #708                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSMap {\n\n  @pure def empty[K, T]: HashSMap[K, T] = {\n    return HashSMap(HashMap.empty, ISZ())\n  }\n\n  @pure def emptyInit[K, T](initialCapacity: Z): HashSMap[K, T] = {\n    return HashSMap(HashMap.emptyInit(initialCapacity), ISZ())\n  }\n\n  @pure def ++[I, K, T](s: IS[I, (K, T)]): HashSMap[K, T] = {\n    return HashSMap.emptyInit[K, T](s.size) ++ s\n  }\n\n}\n\n@datatype class HashSMap[K, T](val map: HashMap[K, T], val keys: ISZ[K]) {\n\n  @pure def size: Z = {\n    return keys.size\n  }\n\n  @pure def entries: ISZ[(K, T)] = {\n    return for (k <- keys) yield (k, map.get(k).get)\n  }\n\n  @pure def values: ISZ[T] = {\n    return for (k <- keys) yield map.get(k).get\n  }\n\n  @pure def keySet: ISZ[K] = {\n    return keys\n  }\n\n  @pure def valueSet: Set[T] = {\n    return Set.empty[T] ++ values\n  }\n\n  @pure def +(p: (K, T)): HashSMap[K, T] = {\n    val newMap = map + p\n    return HashSMap(newMap, if (newMap.size == map.size) keys else keys :+ p._1)\n  }\n\n  @pure def ++[I](entries: IS[I, (K, T)]): HashSMap[K, T] = {\n    if (entries.isEmpty) {\n      return this\n    }\n    var newMap = map\n    var newKeys = keys\n    for (kv <- entries) {\n      val oldNewMapSize = newMap.size\n      newMap = newMap + kv\n      if (newMap.size != oldNewMapSize) {\n        newKeys = newKeys :+ kv._1\n      }\n    }\n    return HashSMap(newMap, newKeys)\n  }\n\n  @pure def get(key: K): Option[T] = {\n    return map.get(key)\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    return map.entry(key)\n  }\n\n  @pure def --(keys: ISZ[K]): HashSMap[K, T] = {\n    return HashSMap(map -- keys, this.keys -- keys)\n  }\n\n  @pure def -(p: (K, T)): HashSMap[K, T] = {\n    return HashSMap(map - p, keys - p._1)\n  }\n\n  @pure def contains(key: K): B = {\n    return map.contains(key)\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEqual(other: HashSMap[K, T]): B = {\n    return map.isEqual(other.map)\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$42();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #710                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n ∀ rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject SeqUtil {\n\n  object IS {\n\n    @strictpure def sizeEq[I, T](s: IS[I, T], size: Z): B = s.size == size\n\n    @strictpure def unique[I, T](s: IS[I, T]): B = ∀(s.indices)(i => ∀(s.indices)(j => (i != j) ->: (s(i) != s(j))))\n\n    @strictpure def pair1Eq[I, T1, T2](s1: IS[I, (T1, T2)], s2: IS[I, T1]): B =\n      sizeEq(s1, s2.size) && ∀(s1.indices)(i => s1(i)._1 == s2(i))\n\n    @strictpure def pair2Eq[I, T1, T2](s1: IS[I, (T1, T2)], s2: IS[I, T2]): B =\n      sizeEq(s1, s2.size) && ∀(s1.indices)(i => s1(i)._2 == s2(i))\n  }\n\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$43();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #712                // String // #Sireum\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Li Haoyi (haoyi.sg@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n */\n\npackage org.sireum\n\n// Adapted from https://github.com/lihaoyi/geny\n\n@msig trait MJen[T] {\n\n  def generate(f: T => MJen.Action): MJen.Action\n\n  def foreach[V](f: T => V): Unit = {\n    def ap(o: T): MJen.Action = {\n      f(o)\n      return MJen.Continue\n    }\n\n    generate(ap _)\n  }\n\n  def find(f: T => B): MOption[T] = {\n    var result: MOption[T] = MNone()\n\n    def ap(o: T): MJen.Action = {\n      val r = f(o)\n      if (!r) {\n        return MJen.Continue\n      } else {\n        result = MSome(o)\n        return MJen.End\n      }\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  def exists(f: T => B): B = {\n    val r = find(f)\n    return r.nonEmpty\n  }\n\n  @pure def contains(o: T): B = {\n    return exists(e => e == o)\n  }\n\n  def forall(f: T => B): B = {\n    def ap(o: T): B = {\n      val r = f(o)\n      return !r\n    }\n    val r = exists(ap _)\n    return !r\n  }\n\n  @pure def count(): Z = {\n    return countIf(_ => T)\n  }\n\n  def countIf(p: T => B): Z = {\n    var result = 0\n\n    def ap(o: T): MJen.Action = {\n      val r = p(o)\n      if (r) {\n        result = result + 1\n      }\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return result\n  }\n\n  @pure def fold[U](initial: U, f: (U, T) => U@pure): U = {\n    return foldLeft(initial, f)\n  }\n\n  @pure def foldLeft[U](initial: U, f: (U, T) => U@pure): U = {\n    var r = initial\n\n    def ap(o: T): MJen.Action = {\n      r = f(r, o)\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def reduce(f: (T, T) => T@pure): MOption[T] = {\n    return reduceLeft(f)\n  }\n\n  @pure def reduceLeft(f: (T, T) => T@pure): MOption[T] = {\n    var r: MOption[T] = MNone()\n\n    def ap(o: T): MJen.Action = {\n      r = r match {\n        case MSome(prev) => MSome(f(prev, o))\n        case _ => MSome(o)\n      }\n      return MJen.Continue\n    }\n\n    generate(ap _)\n    return r\n  }\n\n  @pure def filter(p: T => B@pure): MJen[T] = {\n    return MJen.Internal.Filtered(this, p)\n  }\n\n  def withFilter(p: T => B): MJen[T] = {\n    return MJen.Internal.Filtered(this, p)\n  }\n\n  @pure def map[U](f: T => U@pure): MJen[U] = {\n    return MJen.Internal.Mapped(this, f)\n  }\n\n  @pure def flatMap[U](f: T => MJen[U]@pure): MJen[U] = {\n    return MJen.Internal.FlatMapped(this, f)\n  }\n\n  @pure def flatten[U](f: T => MJen[U]@pure): MJen[U] = {\n    return this.flatMap(o => f(o))\n  }\n\n  @pure def slice(start: Z, end: Z): MJen[T] = {\n    return MJen.Internal.Sliced(this, start, end)\n  }\n\n  @pure def take(n: Z): MJen[T] = {\n    return slice(0, n)\n  }\n\n  @pure def drop(n: Z): MJen[T] = {\n    return slice(n, -1)\n  }\n\n  @pure def takeWhile(p: T => B): MJen[T] = {\n    return MJen.Internal.TakeWhile(this, p)\n  }\n\n  @pure def dropWhile(p: T => B): MJen[T] = {\n    return MJen.Internal.DropWhile(this, p)\n  }\n\n  @pure def zipWithIndex: MJen[(T, Z)] = {\n    return MJen.Internal.ZipWithIndexed(this)\n  }\n\n  @pure def zip[U](other: MJen[U]): MJen[(T, U)] = {\n    return MJen.Internal.Zipped(this, other)\n  }\n\n  @pure def product[U](other: MJen[U]): MJen[(T, U)] = {\n    return MJen.Internal.Product(this, other)\n  }\n\n  @pure def ++(other: MJen[T]): MJen[T] = {\n    return MJen.Internal.Concat(this, other)\n  }\n\n  @pure def head: T = {\n    return take(1).toMSZ(0)\n  }\n\n  @pure def headOption: MOption[T] = {\n    val s = take(1).toMSZ\n    return if (s.isEmpty) MNone() else MSome(s(0))\n  }\n\n  @pure def toMSZ: MSZ[T] = {\n    val r = toMS(MSZ[T]())\n    return r\n  }\n\n  @pure def toMS[I](init: MS[I, T]): MS[I, T] = {\n    var r = init\n\n    def append(o: T): Unit = {\n      r = r :+ o\n    }\n\n    foreach(append _)\n    return r\n  }\n\n  @pure def mkStringWrap(start: String, sep: String, end: String): String = {\n    return st\"$start${(toMSZ, sep)}$end\".render\n  }\n\n  @pure def mkString(sep: String): String = {\n    return mkStringWrap(\"\", sep, \"\")\n  }\n\n}\n\nobject MJen {\n\n  type Action = B\n  val Continue: Action = T\n  val End: Action = F\n\n  object Internal {\n\n    @record class ISImpl[I, T](val s: IS[I, T]) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($s)\"\n      }\n    }\n\n    @record class MSImpl[I, T](val s: MS[I, T]) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- s) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($s)\"\n      }\n    }\n\n    @record class MapImpl[K, T](val m: Map[K, T]) extends MJen[(K, T)] {\n      override def generate(f: ((K, T)) => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (e <- m.entries) {\n          last = f(e)\n          if (!last) {\n            return MJen.End\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($m)\"\n      }\n    }\n\n    @record class HashMapImpl[K, T](val m: HashMap[K, T]) extends MJen[(K, T)] {\n      override def generate(f: ((K, T)) => MJen.Action): MJen.Action = {\n        var last = MJen.Continue\n        for (ms <- m.mapEntries) {\n          if (ms.nonEmpty) {\n            for (e <- ms.entries) {\n              last = f(e)\n              if (!last) {\n                return MJen.End\n              }\n            }\n          }\n        }\n        return last\n      }\n\n      override def string: String = {\n        return s\"MJen($m)\"\n      }\n    }\n\n    @record class Filtered[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      override def generate(f: T => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return MJen.Continue\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.filter($p)\"\n      }\n    }\n\n    @record class Mapped[U, T](val gen: MJen[T], val f: T => U@pure) extends MJen[U] {\n      override def generate(g: U => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          val r = g(f(o))\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.map($f)\"\n      }\n    }\n\n    @record class FlatMapped[U, T](val gen: MJen[T], val f: T => MJen[U]@pure) extends MJen[U] {\n      override def generate(g: U => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          def ap2(o2: U): MJen.Action = {\n            val r = g(o2)\n            return r\n          }\n\n          val r = f(o).generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.flatMap($f)\"\n      }\n    }\n\n    @record class Sliced[T](val gen: MJen[T], val start: Z, val end: Z) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var count = 0\n\n        def ap(o: T): MJen.Action = {\n          if (count < start) {\n            count = count + 1\n            return MJen.Continue\n          } else if (count < end || end < 0) {\n            count = count + 1\n            if (count != end) {\n              return f(o)\n            } else {\n              f(o)\n              return MJen.End\n            }\n          } else {\n            return MJen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return if (end < 0) s\"$gen.slice($start, ~)\" else s\"$gen.slice($start, $end)\"\n      }\n    }\n\n    @record class TakeWhile[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          var r = p(o)\n          if (r) {\n            r = f(o)\n            return r\n          } else {\n            return MJen.End\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.takeWhile($p)\"\n      }\n    }\n\n    @record class DropWhile[T](val gen: MJen[T], val p: T => B) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var started = F\n\n        def ap(o: T): MJen.Action = {\n          if (!started) {\n            var r = p(o)\n            if (r) {\n              return MJen.Continue\n            } else {\n              started = T\n              r = f(o)\n              return r\n            }\n          } else {\n            val r = f(o)\n            return r\n          }\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.dropWhile($p)\"\n      }\n    }\n\n    @record class ZipWithIndexed[T](val gen: MJen[T]) extends MJen[(T, Z)] {\n      def generate(f: ((T, Z)) => MJen.Action): MJen.Action = {\n        var i = 0\n\n        def ap(o: T): MJen.Action = {\n          val r = f((o, i))\n          i = i + 1\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zipWithIndex\"\n      }\n    }\n\n    @record class Zipped[T, U](val gen: MJen[T], val gen2: MJen[U]) extends MJen[(T, U)] {\n      def generate(f: ((T, U)) => MJen.Action): MJen.Action = {\n        var g = gen\n        var g2 = gen2\n        var i = 1\n        while (true) {\n          (g.headOption, g2.headOption) match {\n            case (MSome(h), MSome(h2)) =>\n              val r = f((h, h2))\n              if (r) {\n                g = gen.drop(i)\n                g2 = gen2.drop(i)\n              } else {\n                return MJen.End\n              }\n            case _ => return MJen.End\n          }\n          i = i + 1\n        }\n        return MJen.End\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n    @record class Concat[T](val gen: MJen[T], val gen2: MJen[T]) extends MJen[T] {\n      def generate(f: T => MJen.Action): MJen.Action = {\n        var r = gen.generate(f)\n        if (!r) {\n          return MJen.End\n        }\n        r = gen2.generate(f)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen ++ $gen2\"\n      }\n    }\n\n    @record class Product[T, U](val gen: MJen[T], val gen2: MJen[U]) extends MJen[(T, U)] {\n      def generate(f: ((T, U)) => MJen.Action): MJen.Action = {\n        def ap(o: T): MJen.Action = {\n          def ap2(o2: U): MJen.Action = {\n            val r = f((o, o2))\n            return r\n          }\n\n          val r = gen2.generate(ap2 _)\n          return r\n        }\n\n        val r = gen.generate(ap _)\n        return r\n      }\n\n      override def string: String = {\n        return s\"$gen.zip($gen2)\"\n      }\n    }\n\n  }\n\n  @pure def IS[I, T](s: IS[I, T]): MJen[T] = {\n    return Internal.ISImpl(s)\n  }\n\n  @pure def MS[I, T](s: MS[I, T]): MJen[T] = {\n    return Internal.MSImpl(s)\n  }\n\n  @pure def Map[K, T](m: Map[K, T]): MJen[(K, T)] = {\n    return Internal.MapImpl(m)\n  }\n\n  @pure def Set[T](s: Set[T]): MJen[T] = {\n    return Internal.ISImpl(s.elements)\n  }\n\n  @pure def HashMap[K, T](m: HashMap[K, T]): MJen[(K, T)] = {\n    return Internal.HashMapImpl(m)\n  }\n\n  @pure def HashSet[T](s: HashSet[T]): MJen[T] = {\n    return Internal.HashMapImpl(s.map).map(p => p._1)\n  }\n\n  @pure def HashSMap[K, T](m: HashSMap[K, T]): MJen[(K, T)] = {\n    return IS(m.keys).map(k => (k, m.get(k).get))\n  }\n\n  @pure def HashSSet[T](s: HashSSet[T]): MJen[T] = {\n    return HashSMap(s.map).map(p => p._1)\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$44();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #714                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject HashSSet {\n\n  @pure def empty[T]: HashSSet[T] = {\n    return HashSSet(HashSMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSSet[T] = {\n    return HashSSet(HashSMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSSet[T] = {\n    return HashSSet.emptyInit[T](s.size) ++ s\n  }\n}\n\n@datatype class HashSSet[T](val map: HashSMap[T, B]) {\n\n  @pure def +(e: T): HashSSet[T] = {\n    return HashSSet(map + e ~> T)\n  }\n\n  @pure def ++[I](is: IS[I, T]): HashSSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSSet[T] = {\n    return HashSSet(map - e ~> T)\n  }\n\n  @pure def --[I](is: IS[I, T]): HashSSet[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    return map.contains(e)\n  }\n\n  @pure def union(other: HashSSet[T]): HashSSet[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSSet[T]): HashSSet[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSSet[T]): HashSSet[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSSet[T]): HashSSet[T] = {\n    var r = HashSSet.emptyInit[T](size)\n    for (e <- other.map.keys) {\n      if (contains(e)) {\n        r = r + e\n      }\n    }\n    return r\n  }\n\n  @pure def \\(other: HashSSet[T]): HashSSet[T] = {\n    return this -- other.elements\n  }\n\n  @pure def isEqual(other: HashSSet[T]): B = {\n    return map.isEqual(other.map)\n  }\n\n  @pure override def hash: Z = {\n    return map.hash\n  }\n\n  @pure def isEmpty: B = {\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    return map.size\n  }\n\n  @pure def elements: ISZ[T] = {\n    return map.keys\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$45();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #716                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.bitcodec\n\nimport org.sireum._\nimport org.sireum.ops.Bits.Context\n\nobject Runtime {\n\n  @msig trait Composite {\n\n    def wellFormed: Z\n\n    def decode(input: ISZ[B], context: Context): Unit\n\n    def encode(output: MSZ[B], context: Context): Unit\n\n  }\n\n  @msig trait MComposite {\n\n    def wellFormed: Z\n\n    def decode(input: MSZ[B], context: Context): Unit\n\n    def encode(output: MSZ[B], context: Context): Unit\n\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$46();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #718                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum.bitcodec\n\nimport org.sireum._\n\n\n@datatype trait Spec {\n\n  def name: String\n\n  def isScalar: B\n\n  def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z]\n\n  @memoize def maxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n    return computeMaxSizeOpt(enumMaxSize)\n  }\n\n  def toJSON(isCompact: B): String = {\n    return Spec.Ext.toJSON(this, isCompact)\n  }\n\n}\n\nobject Spec {\n\n  type Concat = ConcatImpl\n  type Union[T] = UnionImpl[T]\n  type PredUnion = PredUnionImpl\n  type GenUnion = GenUnionImpl\n\n  @datatype trait Base extends Spec\n\n  @datatype trait Composite extends Base {\n    @strictpure def isScalar: B = F\n\n    @pure def as(name: String): Composite\n\n    @pure def asOpt: Option[String]\n  }\n\n  @datatype class Boolean(val name: String) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(1)\n    }\n    @strictpure def isScalar: B = T\n  }\n\n  @datatype class Bits(val name: String, val size: Z) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size)\n    }\n    @strictpure def isScalar: B = size <= 64\n  }\n\n  @datatype class BytesImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 8)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Byte(name: String): BytesImpl = {\n    return BytesImpl(name, 1, T, None(), None())\n  }\n\n  @pure def ByteConst(name: String, value: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(value))\n    return BytesImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def ByteRange(name: String, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(min) && conversions.Z.isInRangeSigned8(max) && min <= max)\n    return BytesImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UByte(name: String): BytesImpl = {\n    return BytesImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UByteConst(name: String, value: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(value))\n    return BytesImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UByteRange(name: String, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(min) && conversions.Z.isInRangeUnsigned8(max) && min <= max)\n    return BytesImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Bytes(name: String, size: Z): BytesImpl = {\n    return BytesImpl(name, size, T, None(), None())\n  }\n\n  @pure def BytesRange(name: String, size: Z, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeSigned8(min) && conversions.Z.isInRangeSigned8(max) && min <= max)\n    return BytesImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UBytes(name: String, size: Z): BytesImpl = {\n    return BytesImpl(name, size, F, None(), None())\n  }\n\n  @pure def UBytesRange(name: String, size: Z, min: Z, max: Z): BytesImpl = {\n    assert(conversions.Z.isInRangeUnsigned8(min) && conversions.Z.isInRangeUnsigned8(max) && min <= max)\n    return BytesImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class ShortsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 16)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Short(name: String): ShortsImpl = {\n    return ShortsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def ShortConst(name: String, value: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(value))\n    return ShortsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def ShortRange(name: String, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(min) && conversions.Z.isInRangeSigned16(max) && min <= max)\n    return ShortsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UShort(name: String): ShortsImpl = {\n    return ShortsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UShortConst(name: String, value: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(value))\n    return ShortsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UShortRange(name: String, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(min) && conversions.Z.isInRangeUnsigned16(max) && min <= max)\n    return ShortsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Shorts(name: String, size: Z): ShortsImpl = {\n    return ShortsImpl(name, size, T, None(), None())\n  }\n\n  @pure def ShortsRange(name: String, size: Z, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeSigned16(min) && conversions.Z.isInRangeSigned16(max) && min <= max)\n    return ShortsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UShorts(name: String, size: Z): ShortsImpl = {\n    return ShortsImpl(name, size, F, None(), None())\n  }\n\n  @pure def UShortsRange(name: String, size: Z, min: Z, max: Z): ShortsImpl = {\n    assert(conversions.Z.isInRangeUnsigned16(min) && conversions.Z.isInRangeUnsigned16(max) && min <= max)\n    return ShortsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class IntsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 32)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Int(name: String): IntsImpl = {\n    return IntsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def IntConst(name: String, value: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(value))\n    return IntsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def IntRange(name: String, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(min) && conversions.Z.isInRangeSigned32(max) && min <= max)\n    return IntsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def UInt(name: String): IntsImpl = {\n    return IntsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def UIntConst(name: String, value: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(value))\n    return IntsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def UIntRange(name: String, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(min) && conversions.Z.isInRangeUnsigned32(max) && min <= max)\n    return IntsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Ints(name: String, size: Z): IntsImpl = {\n    return IntsImpl(name, size, T, None(), None())\n  }\n\n  @pure def IntsRange(name: String, size: Z, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeSigned32(min) && conversions.Z.isInRangeSigned32(max) && min <= max)\n    return IntsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def UInts(name: String, size: Z): IntsImpl = {\n    return IntsImpl(name, size, F, None(), None())\n  }\n\n  @pure def UIntsRange(name: String, size: Z, min: Z, max: Z): IntsImpl = {\n    assert(conversions.Z.isInRangeUnsigned32(min) && conversions.Z.isInRangeUnsigned32(max) && min <= max)\n    return IntsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class LongsImpl(val name: String, val size: Z, val signed: B, val minOpt: Option[Z], val maxOpt: Option[Z]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 64)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Long(name: String): LongsImpl = {\n    return LongsImpl(name, 1, T, None(), None())\n  }\n\n  @pure def LongConst(name: String, value: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(value))\n    return LongsImpl(name, 1, T, Some(value), Some(value))\n  }\n\n  @pure def LongRange(name: String, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(min) && conversions.Z.isInRangeSigned64(max) && min <= max)\n    return LongsImpl(name, 1, T, Some(min), Some(max))\n  }\n\n  @pure def ULong(name: String): LongsImpl = {\n    return LongsImpl(name, 1, F, None(), None())\n  }\n\n  @pure def ULongConst(name: String, value: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(value))\n    return LongsImpl(name, 1, F, Some(value), Some(value))\n  }\n\n  @pure def ULongRange(name: String, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(min) && conversions.Z.isInRangeUnsigned64(max) && min <= max)\n    return LongsImpl(name, 1, F, Some(min), Some(max))\n  }\n\n  @pure def Longs(name: String, size: Z): LongsImpl = {\n    return LongsImpl(name, size, T, None(), None())\n  }\n\n  @pure def LongsRange(name: String, size: Z, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeSigned64(min) && conversions.Z.isInRangeSigned64(max) && min <= max)\n    return LongsImpl(name, size, T, Some(min), Some(max))\n  }\n\n  @pure def ULongs(name: String, size: Z): LongsImpl = {\n    return LongsImpl(name, size, F, None(), None())\n  }\n\n  @pure def ULongsRange(name: String, size: Z, min: Z, max: Z): LongsImpl = {\n    assert(conversions.Z.isInRangeUnsigned64(min) && conversions.Z.isInRangeUnsigned64(max) && min <= max)\n    return LongsImpl(name, size, F, Some(min), Some(max))\n  }\n\n  @datatype class FloatsImpl(val name: String, val size: Z, val minOpt: Option[F32], val maxOpt: Option[F32]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 32)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Float(name: String): FloatsImpl = {\n    return FloatsImpl(name, 1, None(), None())\n  }\n\n  @pure def FloatRange(name: String, min: F32, max: F32): FloatsImpl = {\n    return FloatsImpl(name, 1, Some(min), Some(max))\n  }\n\n  @pure def Floats(name: String, size: Z): FloatsImpl = {\n    return FloatsImpl(name, size, None(), None())\n  }\n\n  @pure def FloatsRange(name: String, size: Z, min: F32, max: F32): FloatsImpl = {\n    return FloatsImpl(name, size, Some(min), Some(max))\n  }\n\n  @datatype class DoublesImpl(val name: String, val size: Z, val minOpt: Option[F64], val maxOpt: Option[F64]) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size * 64)\n    }\n    @strictpure def isScalar: B = size == 1\n  }\n\n  @pure def Double(name: String): DoublesImpl = {\n    return DoublesImpl(name, 1, None(), None())\n  }\n\n  @pure def DoubleRange(name: String, min: F64, max: F64): DoublesImpl = {\n    return DoublesImpl(name, 1, Some(min), Some(max))\n  }\n\n  @pure def Doubles(name: String, size: Z): DoublesImpl = {\n    return DoublesImpl(name, size, None(), None())\n  }\n\n  @pure def DoublesRange(name: String, size: Z, min: F64, max: F64): DoublesImpl = {\n    return DoublesImpl(name, size, Some(min), Some(max))\n  }\n\n  @datatype class Enum(val name: String, val objectName: String) extends Base {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(enumMaxSize(objectName))\n    }\n    @strictpure def isScalar: B = T\n  }\n\n  @strictpure def Concat(name: String, elements: ISZ[Spec]): ConcatImpl = ConcatImpl(name, elements, None())\n\n  @datatype class ConcatImpl(val name: String, val elements: ISZ[Spec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var r: Z = 0\n      for (e <- elements) {\n        e.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(maxSize) => r = r + maxSize\n          case _ => return None()\n        }\n      }\n      return Some(r)\n    }\n\n    @strictpure def as(name: String): ConcatImpl = this(asOpt = Some(name))\n  }\n\n  @datatype trait Poly {\n    def polyDesc: Spec.PolyDesc\n  }\n\n  @datatype class PolyDesc(val compName: String, val name: String, val max: Z, val dependsOn: ISZ[String], val elementsOpt: Option[ISZ[Spec]], val asOpt: Option[String])\n\n  @strictpure def Union[T](name: String, dependsOn: ISZ[String], choice: T => Z@pure, subs: ISZ[Spec]): UnionImpl[T] =\n    UnionImpl[T](name, dependsOn, choice, subs, None())\n\n  @datatype class UnionImpl[T](val name: String,\n                               val dependsOn: ISZ[String],\n                               @hidden val choice: T => Z@pure,\n                               val subs: ISZ[Spec],\n                               @hidden val asOpt: Option[String]) extends Composite with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Union\", name, -1, dependsOn, Some(subs), asOpt)\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n\n    @strictpure def as(name: String): UnionImpl[T] = this(asOpt = Some(name))\n  }\n\n  @datatype class RepeatImpl[T](val name: String,\n                                val maxElements: Z,\n                                val dependsOn: ISZ[String],\n                                @hidden val size: T => Z@pure,\n                                val element: Base) extends Spec with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Repeat\", name, maxElements, dependsOn, Some(ISZ(element)), None())\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def Repeat[T](name: String, dependsOn: ISZ[String], size: T => Z@pure, element: Base): RepeatImpl[T] = {\n    return RepeatImpl(name, -1, dependsOn, size, element)\n  }\n\n  @pure def BoundedRepeat[T](name: String, maxElements: Z, dependsOn: ISZ[String], size: T => Z@pure, element: Base): RepeatImpl[T] = {\n    assert(maxElements >= 0, s\"BoundedRepeat \'$name\' maxElements must be non-negative\")\n    return RepeatImpl(name, maxElements, dependsOn, size, element)\n  }\n\n  @datatype class RawImpl[T](val name: String,\n                             val maxSize: Z,\n                             val dependsOn: ISZ[String],\n                             @hidden val size: T => Z@pure) extends Spec with Poly {\n    val polyDesc: Spec.PolyDesc = PolyDesc(\"Raw\", name, maxSize, dependsOn, None(), None())\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return if (maxSize >= 0) Some(maxSize) else None()\n    }\n  }\n\n  @pure def Raw[T](name: String, dependsOn: ISZ[String], size: T => Z@pure): RawImpl[T] = {\n    return RawImpl[T](name, -1, dependsOn, size)\n  }\n\n  @pure def BoundedRaw[T](name: String, maxSize: Z, dependsOn: ISZ[String], size: T => Z@pure): RawImpl[T] = {\n    assert(maxSize >= 0, s\"BoundedRaw \'$name\' maxSize must be non-negative\")\n    return RawImpl[T](name, maxSize, dependsOn, size)\n  }\n\n  @strictpure def PredUnion(name: String, subs: ISZ[PredSpec]): PredUnionImpl = PredUnionImpl(name, subs, None())\n\n  @datatype class PredUnionImpl(val name: String, val subs: ISZ[PredSpec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.maxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n    @strictpure def as(name: String): PredUnionImpl = this(asOpt = Some(name))\n  }\n\n  @datatype class PredRepeatWhileImpl(val name: String, val maxElements: Z, val preds: ISZ[Pred], val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def FixedRepeat(name: String, numOfElements: Z, element: Base): PredRepeatWhileImpl = {\n    return PredRepeatWhileImpl(name, numOfElements, ISZ(), element)\n  }\n\n  @pure def PredRepeatWhile(name: String, preds: ISZ[Pred], element: Base): PredRepeatWhileImpl = {\n    return PredRepeatWhileImpl(name, -1, preds, element)\n  }\n\n  @pure def BoundedPredRepeatWhile(name: String, maxElements: Z, preds: ISZ[Pred], element: Base): PredRepeatWhileImpl = {\n    assert(maxElements >= 0, s\"BoundedPredRepeatWhile \'$name\' maxElements must be non-negative\")\n    return PredRepeatWhileImpl(name, maxElements, preds, element)\n  }\n\n  @datatype class PredRepeatUntilImpl(val name: String, val maxElements: Z, val preds: ISZ[Pred], val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def PredRepeatUntil(name: String, preds: ISZ[Pred], element: Base): PredRepeatUntilImpl = {\n    return PredRepeatUntilImpl(name, -1, preds, element)\n  }\n\n  @pure def BoundedPredRepeatUntil(name: String, maxElements: Z, preds: ISZ[Pred], element: Base): PredRepeatUntilImpl = {\n    assert(maxElements >= 0, s\"BoundedPredRepeatWhile \'$name\' maxElements must be non-negative\")\n    return PredRepeatUntilImpl(name, maxElements, preds, element)\n  }\n\n  @strictpure def GenUnion(name: String, subs: ISZ[Spec]): GenUnionImpl = GenUnionImpl(name, subs, None())\n\n  @datatype class GenUnionImpl(val name: String, val subs: ISZ[Spec], @hidden val asOpt: Option[String]) extends Composite {\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      var max: Z = 0\n      for (sub <- subs) {\n        sub.computeMaxSizeOpt(enumMaxSize) match {\n          case Some(subMaxSize) =>\n            if (subMaxSize > max) {\n              max = subMaxSize\n            }\n          case _ => return None()\n        }\n      }\n      return Some(max)\n    }\n    @strictpure def as(name: String): GenUnionImpl = this(asOpt = Some(name))\n  }\n\n  @datatype class GenRepeatImpl(val name: String, val maxElements: Z, val element: Base) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$6();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #720                // String     element.computeMaxSizeOpt(enumMaxSize) match {\n        case Some(elementMaxSize) if maxElements >= 0 => return Some(maxElements * elementMaxSize)\n        case _ => return None()\n      }\n    }\n  }\n\n  @pure def GenRepeat(name: String, element: Base): GenRepeatImpl = {\n    return GenRepeatImpl(name, -1, element)\n  }\n\n  @pure def BoundedGenRepeat(name: String, maxElements: Z, element: Base): GenRepeatImpl = {\n    assert(maxElements >= 0, s\"BoundedGenRepeat \'$name\' maxElements must be non-negative\")\n    return GenRepeatImpl(name, maxElements, element)\n  }\n\n  @datatype class GenRawImpl(val name: String, val maxSize: Z) extends Spec {\n    @strictpure def isScalar: B = F\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return if (maxSize >= 0) Some(maxSize) else None()\n    }\n  }\n\n  @pure def GenRaw(name: String): GenRawImpl = {\n    return GenRawImpl(name, -1)\n  }\n\n  @pure def BoundedGenRaw(name: String, maxSize: Z): GenRawImpl = {\n    assert(maxSize >= 0, s\"BoundedGenRaw \'$name\' maxSize must be non-negative\")\n    return GenRawImpl(name, maxSize)\n  }\n\n  @datatype class Pads(val size: Z) extends Spec {\n    def name: String = {\n      return \"\"\n    }\n\n    @strictpure def isScalar: B = F\n\n    override def computeMaxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return Some(size)\n    }\n  }\n\n  @datatype class PredSpec(val preds: ISZ[Pred], val spec: Spec) {\n    def maxSizeOpt(enumMaxSize: String => Z): Option[Z] = {\n      return spec.computeMaxSizeOpt(enumMaxSize)\n    }\n  }\n\n  @datatype trait Pred\n\n  object Pred {\n\n    @datatype class Boolean(val value: B) extends Pred\n\n    @datatype class Bits(val size: Z, val value: Z) extends Pred\n\n    @datatype class Bytes(val value: ISZ[Z]) extends Pred\n\n    @datatype class Shorts(val value: ISZ[Z]) extends Pred\n\n    @datatype class Ints(val value: ISZ[Z]) extends Pred\n\n    @datatype class Longs(val value: ISZ[Z]) extends Pred\n\n    @datatype class Floats(val value: ISZ[F32]) extends Pred\n\n    @datatype class Doubles(val value: ISZ[F64]) extends Pred\n\n    @datatype class Skip(val size: Z) extends Pred\n\n    @datatype class Between(val size: Z, val lo: Z, val hi: Z) extends Pred\n\n    @datatype class Not(val pred: Pred) extends Pred\n\n    @datatype class Or(val preds: ISZ[Pred]) extends Pred\n\n\n  }\n\n  @pure def boolean(value: B): Pred.Boolean = {\n    return Pred.Boolean(value)\n  }\n\n  @pure def bits(size: Z, value: Z): Pred.Bits = {\n    return Pred.Bits(size, value)\n  }\n\n  @pure def bytes(value: ISZ[Z]): Pred.Bytes = {\n    return Pred.Bytes(value)\n  }\n\n  @pure def shorts(value: ISZ[Z]): Pred.Shorts = {\n    return Pred.Shorts(value)\n  }\n\n  @pure def ints(value: ISZ[Z]): Pred.Ints = {\n    return Pred.Ints(value)\n  }\n\n  @pure def longs(value: ISZ[Z]): Pred.Longs = {\n    return Pred.Longs(value)\n  }\n\n  @pure def skip(size: Z): Pred.Skip = {\n    return Pred.Skip(size)\n  }\n\n  @pure def between(size: Z, lo: Z, hi: Z): Pred.Between = {\n    return Pred.Between(size, lo, hi)\n  }\n\n  @pure def not(pred: Pred): Pred.Not = {\n    return Pred.Not(pred)\n  }\n\n  @pure def or(preds: ISZ[Pred]): Pred.Or = {\n    return Pred.Or(preds)\n  }\n\n  @pure def fromJSON(s: String): Either[Spec, Json.ErrorMsg] = {\n    return Ext.fromJSON(s)\n  }\n\n  @ext(\"Spec_Ext\") object Ext {\n    def toJSON(o: Spec, isCompact: B): String = $\n    def fromJSON(s: String): Either[Spec, Json.ErrorMsg] = $\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$47();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #722                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\n\n@datatype class COps(val c: C) {\n\n  @pure def toUnicodeHex: (C, C, C, C) = {\n    return (COps.hex2c(c >>> \'\\u000C\'), COps.hex2c((c >>> \'\\u0008\') & \'\\u000F\'), COps.hex2c((c >>> \'\\u0004\') & \'\\u000F\'), COps.hex2c(c & \'\\u000F\'))\n  }\n\n  @pure def toUpper: C = {\n    if (\'a\' <= c && c <= \'z\') {\n      return c - \'\\u0020\'\n    } else {\n      return c\n    }\n  }\n\n  @pure def toLower: C = {\n    if (\'A\' <= c && c <= \'Z\') {\n      return c + \'\\u0020\'\n    } else {\n      return c\n    }\n  }\n\n  @pure def escapeString: String = {\n    c match {\n      case \'\\b\' => return \"\\\\b\"\n      case \'\\t\' => return \"\\\\t\"\n      case \'\\n\' => return \"\\\\n\"\n      case \'\\f\' => return \"\\\\f\"\n      case \'\\r\' => return \"\\\\r\"\n      case \'\"\' =>  return \"\\\\\\\"\"\n      case \'\\\'\' => return \"\\\\\\\'\"\n      case \'\\\\\' => return \"\\\\\\\\\"\n      case _ =>\n    }\n    if (\'\\u0020\' <= c && c <= \'\\u007e\') {\n      return c.string\n    } else if (c > \'\\uFFFF\') {\n      var r: String = \"\"\n      for (cpc <- conversions.C.toCodePoints(c)) {\n        r = s\"$r${COps(cpc).escapeString}\"\n      }\n      return r\n    } else {\n      val q = toUnicodeHex\n      return s\"\\\\u${q._1}${q._2}${q._3}${q._4}\"\n    }\n  }\n\n}\n\nobject COps {\n  @pure def c2hex(c: C): Option[C] = {\n    c.native match {\n      case \'0\' => return Some(\'\\u0000\')\n      case \'1\' => return Some(\'\\u0001\')\n      case \'2\' => return Some(\'\\u0002\')\n      case \'3\' => return Some(\'\\u0003\')\n      case \'4\' => return Some(\'\\u0004\')\n      case \'5\' => return Some(\'\\u0005\')\n      case \'6\' => return Some(\'\\u0006\')\n      case \'7\' => return Some(\'\\u0007\')\n      case \'8\' => return Some(\'\\u0008\')\n      case \'9\' => return Some(\'\\u0009\')\n      case \'a\' => return Some(\'\\u000A\')\n      case \'A\' => return Some(\'\\u000A\')\n      case \'b\' => return Some(\'\\u000B\')\n      case \'B\' => return Some(\'\\u000B\')\n      case \'c\' => return Some(\'\\u000C\')\n      case \'C\' => return Some(\'\\u000C\')\n      case \'d\' => return Some(\'\\u000D\')\n      case \'D\' => return Some(\'\\u000D\')\n      case \'e\' => return Some(\'\\u000E\')\n      case \'E\' => return Some(\'\\u000E\')\n      case \'f\' => return Some(\'\\u000F\')\n      case \'F\' => return Some(\'\\u000F\')\n      case _ => return None[C]()\n    }\n  }\n\n  @pure def hex2c(c: C): C = {\n    val r: C = (c & \'\\u000F\').native match {\n      case \'\\u0000\' => \'0\'\n      case \'\\u0001\' => \'1\'\n      case \'\\u0002\' => \'2\'\n      case \'\\u0003\' => \'3\'\n      case \'\\u0004\' => \'4\'\n      case \'\\u0005\' => \'5\'\n      case \'\\u0006\' => \'6\'\n      case \'\\u0007\' => \'7\'\n      case \'\\u0008\' => \'8\'\n      case \'\\u0009\' => \'9\'\n      case \'\\u000A\' => \'A\'\n      case \'\\u000B\' => \'B\'\n      case \'\\u000C\' => \'C\'\n      case \'\\u000D\' => \'D\'\n      case \'\\u000E\' => \'E\'\n      case \'\\u000F\' => \'F\'\n    }\n    return r\n  }\n\n  @pure def fromUnicodeHex(hex: ISZ[C]): Option[C] = {\n    if (hex.size != 4) {\n      return None[C]()\n    }\n    (c2hex(hex(0)), c2hex(hex(1)), c2hex(hex(2)), c2hex(hex(3))) match {\n      case (Some(c1), Some(c2), Some(c3), Some(c4)) =>\n        return Some((c1 << \'\\u000c\') | (c2 << \'\\u0008\') | (c3 << \'\\u0004\') | c4)\n      case _ => return None[C]()\n    }\n  }\n}
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$48();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #724                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.message.Reporter\n\nobject StringOps {\n  @pure def replace(content: ISZ[C], offsetOldNewStringMap: HashMap[Z, (String, String)]): Either[String, String] = {\n    if (offsetOldNewStringMap.isEmpty) {\n      return Either.Left(conversions.String.fromCis(content))\n    }\n    var m = offsetOldNewStringMap\n    var r = ISZ[C]()\n    val size = content.size\n    var i: Z = 0\n    while (i < size) {\n      m.get(i) match {\n        case Some(pair@(oldString, newString)) =>\n          val oldChars = conversions.String.toCis(oldString)\n          for (j <- 0 until oldChars.size) {\n            if (i + j >= size || content(i + j) != oldChars(j)) {\n              var cs = ISZ[C]()\n              for (k <- 0 until oldChars.size if i + k < size) {\n                cs = cs :+ content(i + k)\n              }\n              return Either.Right(st\"\"\"Expecting \"${(oldChars, \"\")}\" at offset $i, but found \"${(cs, \"\")}\" instead\"\"\".render)\n            }\n          }\n          r = r ++ conversions.String.toCis(newString)\n          i = i + oldString.size\n          m = m - i ~> pair\n        case _ =>\n          r = r :+ content(i)\n          i = i + 1\n      }\n    }\n    return Either.Left(conversions.String.fromCis(r))\n  }\n\n  @pure def substring(cis: ISZ[C], start: Z, until: Z): String = {\n    if (until - start <= 0) {\n      return \"\"\n    }\n    val ms = MSZ.create[C](until - start, \'\\u0000\')\n    var i = start\n    var j = 0\n    while (i < until) {\n      ms(j) = cis(i)\n      i = i + 1\n      j = j + 1\n    }\n    return conversions.String.fromCms(ms)\n  }\n\n  @pure def replaceAllLiterally(cis: ISZ[C], from: String, to: String): String = {\n    var r = ISZ[C]()\n    var i: Z = 0\n    val toSize = to.size\n    val fromSize = from.size\n    val fromCis = conversions.String.toCis(from)\n    val toCis = conversions.String.toCis(to)\n    val size = cis.size\n    while (i + fromSize < size) {\n      var j = 0\n      var found = T\n      while (i + j < size && j < fromSize && found) {\n        if (cis(i + j) != fromCis(j)) {\n          found = F\n        }\n        j = j + 1\n      }\n      if (found && j == fromSize) {\n        for (j <- 0 until toSize) {\n          r = r :+ toCis(j)\n        }\n        i = i + fromSize - 1\n      } else {\n        r = r :+ cis(i)\n      }\n      i = i + 1\n    }\n\n    var isSuffix = F\n    if(i + fromSize == size) {\n      var index = i\n      while(index < size && cis(index) == fromCis(index - i)) {\n        index = index + 1\n      }\n      isSuffix = index == size\n    }\n\n    if(isSuffix) {\n      r = r ++ toCis\n    } else {\n      while (i < size) {\n        r = r :+ cis(i)\n        i = i + 1\n      }\n    }\n    return conversions.String.fromCis(r)\n  }\n}\n\n@datatype class StringOps(val s: String) {\n\n  @pure def first: C = {\n//    l\"\"\" requires s.size > 0 \"\"\"\n    return conversions.String.toCis(s)(0)\n  }\n\n  @pure def substring(start: Z, until: Z): String = {\n//    l\"\"\" requires 0 ≤ start ∧ start < s.size\n//                  start ≤ until\n//                  until ≤ s.size\n//         ensures  result.size ≡ until - start\n//                  ∀i: [0, result.size) result(i) ≡ s(start + i) \"\"\"\n    return StringOps.substring(conversions.String.toCis(s), start, until)\n  }\n\n  @pure def startsWith(other: String): B = {\n//    l\"\"\" ensures  result ≡ ((size >= other.size) ∧\n//                            ∀i: [0, other.size) s(i) ≡ other(i)) \"\"\"\n    if (s.size < other.size) {\n      return F\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    for (i <- z\"0\" until other.size) {\n      if (otherCis(i) != cis(i)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def endsWith(other: String): B = {\n//    l\"\"\" ensures  result ≡ ((size >= other.size) ∧\n//                            ∀i: [0, other.size) s(i + other.size - s.size) ≡ other(i)) \"\"\"\n    if (s.size < other.size) {\n      return F\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    val offset = s.size - other.size\n    for (i <- other.size - 1 to 0 by -1) {\n      if (otherCis(i) != cis(offset + i)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def firstToUpper: String = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size\n//                  result(0) ≡ conversions.COps(s(0)).toUpper\n//                  ∀i: [1, s.size) result(i) ≡ s(i)   \"\"\"\n    val cms = conversions.String.toCms(s)\n    cms(0) = COps(cms(0)).toUpper\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def toUpper: String = {\n    val cms = conversions.String.toCms(s)\n    for (i <- 0 until cms.size) {\n      cms(i) = COps(cms(i)).toUpper\n    }\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def firstToLower: String = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size\n//                  result(0) ≡ conversions.COps(s(0)).toLower\n//                  ∀i: [1, s.size) result(i) ≡ s(i)   \"\"\"\n    val cms = conversions.String.toCms(s)\n    cms(0) = COps(cms(0)).toLower\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def toLower: String = {\n    val cms = conversions.String.toCms(s)\n    for (i <- 0 until cms.size) {\n      cms(i) = COps(cms(i)).toLower\n    }\n    return conversions.String.fromCms(cms)\n  }\n\n  @pure def contains(other: String): B = {\n    return stringIndexOf(other) >= 0\n  }\n\n  @pure def stringIndexOf(other: String): Z = {\n    return stringIndexOfFrom(other, 0)\n  }\n\n  @pure def stringIndexOfFrom(other: String, offset: Z): Z = {\n    val size = s.size\n    if (!(0 <= offset && offset < size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    val otherCis = conversions.String.toCis(other)\n    val otherSize = other.size\n    var i = offset\n    while (i + otherSize <= size) {\n      var j = 0\n      var found = T\n      while (j < otherSize && found) {\n        if (cis(i + j) != otherCis(j)) {\n          found = F\n        }\n        j = j + 1\n      }\n      if (found) {\n        return i\n      }\n      i = i + 1\n    }\n    return -1\n  }\n\n  @pure def indexOf(c: C): Z = {\n    return indexOfFrom(c, 0)\n  }\n\n  @pure def indexOfFrom(c: C, offset: Z): Z = {\n    if (!(0 <= offset && offset < s.size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    for (i <- offset until s.size) {\n      if (cis(i) == c) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  @pure def lastIndexOf(c: C): Z = {\n    return lastIndexOfFrom(c, s.size - 1)\n  }\n\n  @pure def lastIndexOfFrom(c: C, offset: Z): Z = {\n    if (!(0 <= offset && offset < s.size)) {\n      return -1\n    }\n    val cis = conversions.String.toCis(s)\n    for (i <- offset to 0 by -1) {\n      if (cis(i) == c) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  @pure def replaceAllChars(from: C, to: C): String = {\n    val cs = conversions.String.toCms(s)\n    for (i <- 0 until cs.size if cs(i) == from) {\n      cs(i) = to\n    }\n    return conversions.String.fromCms(cs)\n  }\n\n  @pure def replaceAllLiterally(from: String, to: String): String = {\n    return StringOps.replaceAllLiterally(conversions.String.toCis(s), from, to)\n  }\n\n  @pure def split(isSep: C => B @pure): ISZ[String] = {\n    var r = ISZ[String]()\n    val cis = conversions.String.toCis(s)\n    var last = 0\n    val size = s.size\n    while (last < size && isSep(cis(last))) {\n      last = last + 1\n    }\n    var i = last\n    while (i < size) {\n      if (isSep(cis(i)) && last != i) {\n        r = r :+ StringOps.substring(cis, last, i)\n        i = i + 1\n        while (i < size && isSep(cis(i))) {\n          i = i + 1\n        }\n        last = i\n      }\n      i = i + 1\n    }\n    if (last < size) {\n      r = r :+ StringOps.substring(cis, last, i)\n    }\n    return r\n  }\n\n  @pure def trim: String = {\n    var i = 0\n    val size = s.size\n    val cis = conversions.String.toCis(s)\n    while (i < size && cis(i).isWhitespace) {\n      i = i + 1\n    }\n    var j = size - 1\n    while (j >= 0 && cis(j).isWhitespace) {\n      j = j - 1\n    }\n    return if (i <= j) StringOps.substring(cis, i, j + 1) else \"\"\n  }\n\n  @pure def trimTrailing: String = {\n    val size = s.size\n    val cis = conversions.String.toCis(s)\n    var j = size - 1\n    while (j >= 0 && cis(j).isWhitespace) {\n      j = j - 1\n    }\n    return if (0 <= j) StringOps.substring(cis, 0, j + 1) else \"\"\n  }\n\n  @pure def size: Z = {\n    return s.size\n  }\n\n\n  def collectSections(errorKind: String,\n                      beginMarker: String,\n                      endMarker: String,\n                      reporter: Reporter): HashSMap[String, String] = {\n    var r = HashSMap.empty[String, String]\n    val lines = ops.StringOps(s).split(c => c == \'\\n\')\n    val size = lines.size\n    var i = 0\n    while (i < size) {\n      val line = lines(i)\n      val lOps = ops.StringOps(ops.StringOps(line).trim)\n      if (lOps.startsWith(beginMarker)) {\n        val name = ops.StringOps(lOps.substring(beginMarker.size, lOps.size)).trim\n        val beginLine = i\n        i = i + 1\n        var found = F\n        var code = ISZ[String]()\n        while (i < size && !found) {\n          val line2 = lines(i)\n          val lOps2 = ops.StringOps(ops.StringOps(line2).trim)\n          if (lOps2.startsWith(endMarker)) {\n            found = T\n            val name2 = ops.StringOps(lOps2.substring(endMarker.size, lOps2.size)).trim\n            if (name != name2) {\n              reporter.error(None(), errorKind,\n                s\"Mismatch marker at lines ${beginLine + 1} and ${i + 1} ($name != $name2)\")\n              return r\n            }\n            r = r + name ~> st\"${(code, \"\\n\")}\".render\n          } else {\n            code = code :+ ops.StringOps(line2).trimTrailing\n          }\n          i = i + 1\n        }\n        if (!found) {\n          reporter.error(None(), errorKind, s\"Unclosed marker at line ${beginLine + 1} for $name\")\n        }\n      }\n      i = i + 1\n    }\n    return r\n  }\n\n  @pure def escapeST: ST = {\n    return st\"\"\"${(for (c <- conversions.String.toCis(s)) yield ops.COps(c).escapeString, \"\")}\"\"\"\n  }\n\n  @pure def replaceStrings(offsetOldNewStringMap: HashMap[Z, (String, String)]): Either[String, String] = {\n    return StringOps.replace(conversions.String.toCis(s), offsetOldNewStringMap)\n  }\n\n  @pure def compareVersion(other: String): Z = {\n    @pure def removePrefix(str: String): String = {\n      val cis = conversions.String.toCis(str)\n      var i = 0\n      while (i < cis.size) {\n        val c = cis(i)\n        if (c === \'_\' || (\'a\' <= c && c <= \'z\') || (\'A\' <= c && c <= \'Z\') || c === \'$\') {\n          i = i + 1\n        } else {\n          return ops.StringOps(str).substring(i, str.size)\n        }\n      }\n      return \"\"\n    }\n    val v1Ops = ops.StringOps(removePrefix(s))\n    val v2Ops = ops.StringOps(removePrefix(other))\n    val p = (c: C) => c === \'.\'\n    val v1s = v1Ops.split(p)\n    val v2s = v2Ops.split(p)\n    val size: Z = if (v1s.size <= v2s.size) v1s.size else v2s.size\n    for (i <- 0 until size) {\n      (Z(v1s(i)), Z(v2s(i))) match {\n        case (Some(v1), Some(v2)) =>\n          if (v1 < v2) {\n            return -1\n          } else if (v1 > v2) {\n            return 1\n          }\n        case (_, _) =>\n          return 0\n      }\n    }\n    return 0\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$49();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #726                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Hariharan Thiagarajan, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.Graph\n\n@datatype class GraphOps[W, E](val graph: Graph[W, E]) {\n\n  @pure def getEdgeData(e: Graph.Edge[W, E]): Option[E] = {\n    e match {\n      case Graph.Edge.Data(_, _, ed) => return Some[E](ed)\n      case _ => return None[E]()\n    }\n  }\n\n  @pure def getAllSuccessor(v: W): Set[W] = {\n    if (graph.outgoingEdges.get(graph.nodes.get(v).get).nonEmpty) {\n      return Set.empty[W] ++ (for (es <- graph.outgoingEdges.get(graph.nodes.get(v).get).get.elements)\n        yield graph.nodesInverse(es.dest))\n    } else {\n      return Set.empty[W]\n    }\n  }\n\n  @pure def getAllPredecessor(v: W): Set[W] = {\n    if (graph.incomingEdges.get(graph.nodes.get(v).get).nonEmpty) {\n      return Set.empty[W] ++ (for (es <- graph.incomingEdges.get(graph.nodes.get(v).get).get.elements)\n        yield graph.nodesInverse(es.source))\n    } else {\n      return Set.empty[W]\n    }\n\n  }\n\n  @pure def getSCC: ISZ[HashSSet[W]] = {\n    var result = ISZ[HashSSet[W]]()\n    var discoveryMap: HashSMap[W, (B, B)] =\n      HashSMap ++ (for (v <- graph.nodes.keys) yield (v, (F, F)))\n\n    def resetDiscoveryMap(): Unit = {\n      discoveryMap = HashSMap ++ (for (e <- discoveryMap.entries) yield (e._1, (F, F)))\n    }\n\n    def setDiscovered(v: W): B = {\n      return discoveryMap.get(v).exists { cf =>\n        discoveryMap = discoveryMap + ((v, (T, cf._2)))\n        T\n      }\n    }\n\n    def setBoth(v: W): Unit = {\n      discoveryMap = discoveryMap + ((v, (T, T)))\n    }\n\n    def isAllMySuccDiscovered(v: W): B = {\n      return ISZOps(for (s <- getAllSuccessor(v).elements; e <- discoveryMap.get(s).toIS) yield e._1)\n        .foldLeft((c: B, n: B) => c & n, T)\n    }\n\n    def dfs(v: W, isFirst: B): ISZ[W] = {\n      var r = ISZ[W]()\n      var stack = Stack.empty[W]\n      stack = stack.push(v)\n\n      while (stack.nonEmpty) {\n        val current = stack.pop.get\n        stack = current._2\n        if (discoveryMap.get(current._1).nonEmpty\n          && !discoveryMap.get(current._1).get._1) {\n          setDiscovered(current._1)\n          if (!isFirst) {\n            r = r :+ current._1\n          }\n          setBoth(current._1)\n          stack = stack.push(current._1)\n\n          val nexts: Set[W] = if (isFirst) getAllSuccessor(current._1) else getAllPredecessor(current._1)\n\n          for (n <- nexts.elements) {\n            if (!discoveryMap.get(n).get._1) {\n              stack = stack.push(n)\n            }\n          }\n\n        } else if (discoveryMap.get(current._1).get._2 && isFirst) {\n          r = current._1 +: r\n        }\n      }\n      return r\n    }\n\n    var orderedNodes = ISZ[W]()\n\n    for (k <- graph.nodes.keys) {\n      if (!discoveryMap.get(k).get._1) {\n        orderedNodes = dfs(k, T) ++ orderedNodes\n      }\n    }\n    resetDiscoveryMap()\n    for (k <- orderedNodes) {\n      if (!discoveryMap.get(k).get._1) {\n        result = result :+ HashSSet.empty[W] ++ dfs(k, F)\n      }\n    }\n    return result\n  }\n\n  @pure def getCycles: ISZ[ISZ[W]] = {\n    val sccs = getSCC\n    var loops = ISZ[ISZ[W]]()\n    var bSets = HashSMap.empty[W, Set[W]]\n    var stack = Stack.empty[W]\n    var marked = Set.empty[W]\n    var removed = HashSMap.empty[W, Set[W]]\n    var position = HashSMap.empty[W, Z]\n    var reach = HashSMap.empty[W, B] ++ (for (k <- graph.nodes.keys) yield (k, F))\n\n    def cycle(v: W, tq: Z): B = {\n      var q = tq\n      var foundCycle = F\n      marked = marked + v\n      stack = stack.push(v)\n      val t = stack.size\n      position = position + ((v, t))\n      if (!reach.get(v).get) {\n        q = t\n      }\n      val avRemoved: Set[W] = removed.get(v) match {\n        case Some(r) => r\n        case _ => Set.empty[W]\n      }\n\n      for (wV <- getAllSuccessor(v).elements) {\n        if (!avRemoved.contains(wV)) {\n          if (!marked.contains(wV)) {\n            val gotCycle = cycle(wV, q)\n            if (gotCycle) {\n              foundCycle = T\n            } else {\n              noCycle(v, wV)\n            }\n          } else if (position.get(wV).nonEmpty && position.get(wV).get <= q) {\n            foundCycle = T\n            var cycle = ISZ[W]()\n            val elements = stack.elements\n            var current = stack.peek.get\n            var break = T\n            var i = 0\n            while (i < elements.size && break) {\n              current = elements(i)\n              if (wV == current) {\n                break = F\n              }\n              i = i + 1\n            }\n            cycle = cycle :+ wV\n            break = T\n            while (i < elements.size && break) {\n              current = elements(i)\n              cycle = cycle :+ current\n              if (current == v) {\n                break = F\n              }\n              i = i + 1\n            }\n            loops = loops :+ cycle\n          } else {\n            noCycle(v, wV)\n          }\n        }\n      }\n      stack = stack.pop.get._2\n      if (foundCycle) {\n        unmark(v)\n      }\n      reach = reach + ((v, T))\n      position = position + ((v, graph.nodes.size))\n      return foundCycle\n    }\n\n    def unmark(x: W): Unit = {\n      marked = marked - x\n      val temp: Set[W] = bSets.get(x) match {\n        case Some(bsx) => bsx\n        case _ => Set.empty[W]\n      }\n\n      for (y <- temp.elements) {\n        val t: Set[W] = removed.get(y) match {\n          case Some(ry) => ry - x\n          case _ => Set.empty[W] - x\n        }\n        removed = removed + ((y, t))\n        if (marked.contains(y)) {\n          unmark(y)\n        }\n      }\n      bSets = bSets + ((x, Set.empty[W]))\n    }\n\n    def noCycle(x: W, y: W): Unit = {\n      val t1: Set[W] = bSets.get(y) match {\n        case Some(bs) => bs\n        case _ => Set.empty[W]\n      }\n      bSets = bSets + ((y, t1))\n      val t2: Set[W] = removed.get(x) match {\n        case Some(rx) => rx + y\n        case _ => Set.empty[W] + y\n      }\n      removed = removed + ((x, t2))\n    }\n\n    var startNodes = ISZ[W]()\n    for (scc <- sccs) {\n      var max: Z = -1\n      var startNode = scc.elements(0)\n      for (node <- scc.elements) {\n        val inedges = graph.incomingEdges.get(graph.nodes.get(node).get)\n        val inDegree: Z = if (inedges.nonEmpty) inedges.get.size else 0\n        if (inDegree > max) {\n          max = inDegree\n          startNode = node\n        }\n      }\n      startNodes = startNodes :+ startNode\n    }\n\n    for (n <- startNodes) {\n      cycle(n, 0)\n    }\n\n    return loops\n  }\n\n  @pure def forwardReach(criteria: ISZ[W]): ISZ[W] = {\n    val r = reachable(criteria, T)\n    return r\n  }\n\n  @pure def backwardReach(criteria: ISZ[W]): ISZ[W] = {\n    val r = reachable(criteria, F)\n    return r\n  }\n\n  @pure def reachable(criteria: ISZ[W], isForward: B): ISZ[W] = {\n    var workList = ISZ[W]()\n    workList = workList ++ criteria\n    var result = HashSSet.empty[W]\n\n    while (workList.nonEmpty) {\n      val current = ISZOps(workList).first\n      if (!result.contains(current)) {\n        val next: Set[W] =\n          if (isForward)\n            getAllSuccessor(current)\n          else getAllPredecessor(current)\n        workList = workList ++ next.elements\n        result = result + current\n      }\n      workList = ISZOps(workList).tail\n    }\n    return result.elements\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$50();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #728                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\n\n@sig trait ISOps[I, T] {\n\n  @pure def contains(e: T): B\n\n  @pure def exists(p: T => B @pure): B\n\n  @pure def first: T\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def forall(p: T => B @pure): B\n\n  @pure def indexOf(e: T): I\n\n  @pure def last: T\n\n  @pure def :+(e: T): IS[I, T]\n\n  @pure def +:(e: T): IS[I, T]\n\n  @pure def ++(other: IS[I, T]): IS[I, T]\n\n  @pure def chunk(size: Z): IS[Z, IS[I, T]]\n\n  @pure def drop(size: Z): IS[I, T]\n\n  @pure def dropRight(size: Z): IS[I, T]\n\n  @pure def filter(p: T => B @pure): IS[I, T]\n\n  @pure def filterNot(p: T => B @pure): IS[Z, T]\n\n  @pure def insert(i: I, e: T): IS[I, T]\n\n  @pure def laxSlice(from: I, til: I): IS[I, T]\n\n  @pure def map[U](f: T => U @pure): IS[I, U]\n\n  @pure def remove(i: I): IS[I, T]\n\n  @pure def reverse: IS[I, T]\n\n  @pure def slice(from: I, til: I): IS[I, T]\n\n  @pure def sortWith(lt: (T, T) => B @pure): IS[I, T]\n\n  @pure def tail: IS[I, T]\n\n  @pure def take(size: Z): IS[I, T]\n\n  @pure def takeRight(size: Z): IS[Z, T]\n\n  @pure def zip[T2](other: IS[Z, T2]): IS[Z, (T, T2)]\n\n}\n\n@msig trait MSOps[I, T] {\n\n  @pure def contains(e: T): B\n\n  @pure def exists(p: T => B @pure): B\n\n  @pure def first: T\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R\n\n  @pure def forall(p: T => B @pure): B\n\n  @pure def indexOf(e: T): I\n\n  @pure def last: T\n\n  @pure def :+(e: T): MS[I, T]\n\n  @pure def +:(e: T): MS[I, T]\n\n  @pure def ++(other: MS[I, T]): MS[I, T]\n\n  @pure def chunk(size: Z): MS[Z, MS[I, T]]\n\n  @pure def drop(size: Z): MS[I, T]\n\n  @pure def dropRight(size: Z): MS[I, T]\n\n  @pure def filter(p: T => B @pure): MS[I, T]\n\n  @pure def filterNot(p: T => B @pure): MS[Z, T]\n\n  @pure def insert(i: I, e: T): MS[I, T]\n\n  @pure def laxSlice(from: I, til: I): MS[I, T]\n\n  @pure def map[U](f: T => U @pure): MS[I, U]\n\n  @pure def remove(i: I): MS[I, T]\n\n  @pure def reverse: MS[I, T]\n\n  @pure def slice(from: I, til: I): MS[I, T]\n\n  @pure def sortWith(lt: (T, T) => B @pure): MS[I, T]\n\n  @pure def tail: MS[I, T]\n\n  @pure def take(size: Z): MS[I, T]\n\n  @pure def takeRight(size: Z): MS[Z, T]\n\n  @pure def zip[T2](other: MS[Z, T2]): MS[Z, (T, T2)]\n\n}\n\n@ext object ISZOpsUtil {\n\n  @pure def parMap[V, U](s: IS[Z, V], f: V => U @pure): IS[Z, U] = $\n\n  def mParMap[V, U](s: IS[Z, V], f: V => U): IS[Z, U] = $\n\n  @pure def parMapCores[V, U](s: IS[Z, V], f: V => U @pure, numOfCores: Z): IS[Z, U] = $\n\n  def mParMapCores[V, U](s: IS[Z, V], f: V => U, numOfCores: Z): IS[Z, U] = $\n\n  @pure def sortWith[T](s: IS[Z, T], lt: (T, T) => B @pure): IS[Z, T] = $\n\n}\n\n@datatype class ISZOps[T](val s: IS[Z, T]) extends ISOps[Z, T] {\n\n  @pure def :+(e: T): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [0, result.size)  result(i) ≡ s(i)\n//                 result(result.size - 1) ≡ e            \"\"\"\n\n    return s :+ e\n  }\n\n  @pure def +:(e: T): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [1, result.size)  result(i) ≡ s(i - 1)\n//                 result(0) ≡ e                              \"\"\"\n\n    return e +: s\n  }\n\n  @pure def ++(other: IS[Z, T]): IS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + other.size\n//                 ∀i: [0, s.size)  result(i) ≡ s(i)\n//                 ∀i: [0, other.size)  result(s.size + i) ≡ other(i) \"\"\"\n\n    return s ++ other\n  }\n\n  @pure def chunk(size: Z): IS[Z, IS[Z, T]] = {\n//    l\"\"\" requires 0 < size\n//                  size <= s.size\n//         ensures  if (s.size % size ≡ 0) result.size * size ≡ s.size\n//                    else (result.size - 1) * size + s.size % size ≡ s.size\n//                  if (s.size % size ≡ 0) ∀i: [0, result.size)  result(i).size ≡ size\n//                    else ∀i: [0, result.size - 1)  result(i).size ≡ size\n//                  s.size % size ≠ 0 → result(result.size - 1).size ≡ s.size % size\n//                  ∀i: [0, result.size)\n//                    ∀j: [0, result(i).size)\n//                      s(i * result.size + j) ≡ result(i)(j)                          \"\"\"\n\n    var r = IS[Z, IS[Z, T]]()\n    var chunk = IS[Z, T]()\n    for (e <- s) {\n      if (chunk.size == size) {\n        r = r :+ chunk\n        chunk = IS[Z, T]()\n      }\n      chunk = chunk :+ e\n    }\n    if (chunk.nonEmpty) {\n      r = r :+ chunk\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) s(i) ≡ e) \"\"\"\n\n    for (v <- s) {\n      if (v == e) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def drop(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(size + i) \"\"\"\n\n    return laxSlice(size, s.size)\n  }\n\n  @pure def dropRight(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, s.size - size)\n  }\n\n  @pure def exists(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (p(e)) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def filter(p: T => B @pure): IS[Z, T] = {\n\n    var r = IS[Z, T]()\n    for (e <- s) {\n      if (p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def filterNot(p: T => B @pure): IS[Z, T] = {\n\n    var r = IS[Z, T]()\n    for (e <- s) {\n      if (!p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def first: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(0) \"\"\"\n\n    return s(0)\n  }\n\n  @pure def forall(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∀i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (!p(e)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  def mFoldLeft[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  def mFoldRight[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  @pure def insert(i: Z, e: T): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i <= s.size\n//         ensures  result.size ≡ s.size + 1\n//                  ∀j: [0, i) result(j) ≡ s(j)\n//                  result(i) ≡ e\n//                  ∀j: [j, s.size) result(j + 1) ≡ s(j) \"\"\"\n    return (laxSlice(0, i) :+ e) ++ laxSlice(i, s.size)\n  }\n\n  @pure def last: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(s.size - 1) \"\"\"\n\n    return s(s.size - 1)\n  }\n\n  @pure def indexOf(e: T): Z = {\n//    l\"\"\" ensures (0 ≤ result ∧ result < s.size) → s(result) ≡ e\n//                 (result ≡ s.size) ≡ (∀i: [0, s.size) s(i) ≠ e)\n//                 ∃i: [0, s.size) s(i) ≡ e ∧ (∀j: [0, i) s(j) ≠ e) → result ≡ i\n//                 0 ≤ result\n//                 result ≤ s.size                                \"\"\"\n    for (i <- z\"0\" until s.size if e == s(i)) {\n      return i\n    }\n    return s.size\n  }\n\n  @pure def laxSlice(from: Z, til: Z): IS[Z, T] = {\n//    l\"\"\" ensures if (til > from) result.size ≡ NO(til).min(s.size) - NO(0).max(from)\n//                   else result.size ≡ 0\n//                 ∀i: [i, result.size) result(i) ≡ s(NO(0).max(from) + i)               \"\"\"\n\n    if (from >= til || s.isEmpty) {\n      return ISZ()\n    }\n    val start: Z = if (from < 0) 0 else from\n    val until: Z = if (til <= s.size) til else s.size\n    val len = until - start\n    val r = MSZ.create(len, s(0))\n    for (i <- 0 until len) {\n      r(i) = s(start + i)\n    }\n    return r.toIS\n  }\n\n  @pure def map[U](f: T => U @pure): IS[Z, U] = {\n//    l\"\"\" ensures result.size ≡ s.size\n//                 ∀i: [0, result.size)  result(i) ≡ f(s(i)) \"\"\"\n\n    return s.map(f)\n  }\n\n  @pure def parMap[U](f: T => U @pure): IS[Z, U] = {\n    return ISZOpsUtil.parMap(s, f)\n  }\n\n  @pure def mParMap[U](f: T => U): IS[Z, U] = {\n    return ISZOpsUtil.mParMap(s, f)\n  }\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.ISZOps(parMap(f)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.ISZOps(mParMap(f)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.ISZOps(parMap(f)).foldRight(g, init)\n  }\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.ISZOps(mParMap(f)).mFoldRight(g, init)\n  }\n\n  @pure def parMapCores[U](f: T => U @pure, numOfCores: Z): IS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return ISZOpsUtil.parMapCores(s, f, numOfCores)\n    } else {\n      return map(f)\n    }\n  }\n\n  @pure def mParMapCores[U](f: T => U, numOfCores: Z): IS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return ISZOpsUtil.mParMapCores(s, f, numOfCores)\n    } else {\n      return for (e <- s) yield f(e)\n    }\n  }\n\n  @pure def parMapFoldLeftCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(parMapCores(f, numOfCores)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeftCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(mParMapCores(f, numOfCores)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRightCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(parMapCores(f, numOfCores)).foldRight(g, init)\n  }\n\n  def mParMapFoldRightCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.ISZOps(mParMapCores(f, numOfCores)).mFoldRight(g, init)\n  }\n\n  @pure def remove(i: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i < s.size\n//         ensures  result.size ≡ s.size - 1\n//                  ∀j: [0, i)  result(j) ≡ s(j)\n//                  ∀j: [i, result.size)  result(j) ≡ s(j + 1)\n//     \"\"\"\n    return laxSlice(0, i) ++ laxSlice(i + 1, s.size)\n  }\n\n  @pure def reverse: IS[Z, T] = {\n//    l\"\"\" ensures  result.size ≡ s.size\n//                  ∀i: [0, s.size)  result(i) ≡ s(s.size - 1 - i)\n//     \"\"\"\n\n    return for (i <- s.size - 1 to 0 by -1) yield s(i)\n  }\n\n\n  @pure def slice(from: Z, til: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ from\n//                  from < s.size\n//                  0 ≤ til\n//                  til ≤ s.size\n//                  from ≤ til\n//         ensures  result.size ≡ til - from\n//                  ∀i: [0, result.size) result(i) ≡ s(from + i) \"\"\"\n\n    return laxSlice(from, til)\n  }\n\n  @pure def sortWith(lt: (T, T) => B @pure): IS[Z, T] = {\n    return ISZOpsUtil.sortWith(s, lt)\n  }\n\n  @pure def tail: IS[Z, T] = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size - 1\n//                  ∀i: [0, result.size)  result(i) ≡ s(i + 1) \"\"\"\n    return drop(1)\n  }\n\n  @pure def take(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, size)\n  }\n\n  @pure def takeRight(size: Z): IS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(s.size - size + i) \"\"\"\n\n    return laxSlice(s.size - size, s.size)\n  }\n\n  @pure def zip[T2](other: IS[Z, T2]): IS[Z, (T, T2)] = {\n//    l\"\"\" requires s.size ≡ other.size\n//         ensures  result ≡ s.size\n//                  ∀i: [0, result.size)  result(i) ≡ ((s(i), other(i))) \"\"\"\n    var i = 0\n    val sz = s.size\n    var r = ISZ[(T, T2)]()\n    while (i < sz) {\n      r = r :+ ((s(i), other(i)))\n      i = i + 1\n    }\n    return r\n  }\n}\n\n\n@ext object MSZOpsUtil {\n\n  @pure def parMap[V, U](s: MS[Z, V], f: V => U @pure): MS[Z, U] = $\n\n  def mParMap[V, U](s: MS[Z, V], f: V => U): MS[Z, U] = $\n\n  @pure def parMapCores[V, U](s: MS[Z, V], f: V => U @pure, numOfCores: Z): MS[Z, U] = $\n\n  def mParMapCores[V, U](s: MS[Z, V], f: V => U, numOfCores: Z): MS[Z, U] = $\n\n  @pure def sortWith[T](s: MS[Z, T], lt: (T, T) => B @pure): MS[Z, T] = $\n\n}\n\n@record class MSZOps[T](val s: MS[Z, T]) extends MSOps[Z, T] {\n\n  @pure def :+(e: T): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [0, result.size)  result(i) ≡ s(i)\n//                 result(result.size - 1) ≡ e            \"\"\"\n\n    return s :+ e\n  }\n\n  @pure def +:(e: T): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + 1\n//                 ∀i: [1, result.size)  result(i) ≡ s(i - 1)\n//                 result(0) ≡ e                              \"\"\"\n\n    return e +: s\n  }\n\n  @pure def ++(other: MS[Z, T]): MS[Z, T] = {\n//    l\"\"\" ensures result.size ≡ s.size + other.size\n//                 ∀i: [0, s.size)  result(i) ≡ s(i)\n//                 ∀i: [0, other.size)  result(s.size + i) ≡ other(i) \"\"\"\n\n    return s ++ other\n  }\n\n  @pure def chunk(size: Z): MS[Z, MS[Z, T]] = {\n//    l\"\"\" requires 0 < size\n//                  size <= s.size\n//         ensures  if (s.size % size ≡ 0) result.size * size ≡ s.size\n//                    else (result.size - 1) * size + s.size % size ≡ s.size\n//                  if (s.size % size ≡ 0) ∀i: [0, result.size)  result(i).size ≡ size\n//                    else ∀i: [0, result.size - 1)  result(i).size ≡ size\n//                  s.size % size ≠ 0 → result(result.size - 1).size ≡ s.size % size\n//                  ∀i: [0, result.size)\n//                    ∀j: [0, result(i).size)\n//                      s(i * result.size + j) ≡ result(i)(j)                          \"\"\"\n\n    var r = MS[Z, MS[Z, T]]()\n    var chunk = MS[Z, T]()\n    for (e <- s) {\n      if (chunk.size == size) {\n        r = r :+ chunk\n        chunk = MS[Z, T]()\n      }\n      chunk = chunk :+ e\n    }\n    if (chunk.nonEmpty) {\n      r = r :+ chunk\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) s(i) ≡ e) \"\"\"\n\n    for (v <- s) {\n      if (v == e) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def drop(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(size + i) \"\"\"\n\n    return laxSlice(size, s.size)\n  }\n\n  @pure def dropRight(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ s.size - size\n//                  ∀i: [0, s.size - size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, s.size - size)\n  }\n\n  @pure def exists(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∃i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (p(e)) {\n        return T\n      }\n    }\n    return F\n  }\n\n  @pure def filter(p: T => B @pure): MS[Z, T] = {\n\n    var r = MS[Z, T]()\n    for (e <- s) {\n      if (p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def filterNot(p: T => B @pure): MS[Z, T] = {\n\n    var r = MS[Z, T]()\n    for (e <- s) {\n      if (!p(e)) {\n        r = r :+ e\n      }\n    }\n    return r\n  }\n\n  @pure def first: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(0) \"\"\"\n\n    return s(0)\n  }\n\n  @pure def forall(p: T => B @pure): B = {\n//    l\"\"\" ensures result ≡ (∀i: [0, s.size) p(i)) \"\"\"\n\n    for (e <- s) {\n      if (!p(e)) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def foldLeft[R](f: (R, T) => R @pure, init: R): R = {\n//    l\"\"\" ensures result ≡ ISOps.foldLeftSpec(s, f, init, s.size - 1) \"\"\"\n\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  @pure def foldRight[R](f: (R, T) => R @pure, init: R): R = {\n//    l\"\"\" ensures result ≡ ISOps.foldRightSpec(s, f, init, s.size - 1) \"\"\"\n\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  def mFoldLeft[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (e <- s) {\n      r = f(r, e)\n    }\n    return r\n  }\n\n  def mFoldRight[R](f: (R, T) => R, init: R): R = {\n    var r = init\n    for (i <- s.size - 1 to 0 by -1) {\n      r = f(r, s(i))\n    }\n    return r\n  }\n\n  @pure def insert(i: Z, e: T): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i <= s.size\n//         ensures  result.size ≡ s.size + 1\n//                  ∀j: [0, i) result(j) ≡ s(j)\n//                  result(i) ≡ e\n//                  ∀j: [j, s.size) result(j + 1) ≡ s(j) \"\"\"\n    return (laxSlice(0, i) :+ e) ++ laxSlice(i, s.size)\n  }\n\n  @pure def last: T = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result ≡ s(s.size - 1) \"\"\"\n\n    return s(s.size - 1)\n  }\n\n  @pure def indexOf(e: T): Z = {\n//    l\"\"\" ensures (0 ≤ result ∧ result < s.size) → s(result) ≡ e\n//                 (result ≡ s.size) ≡ (∀i: [0, s.size) s(i) ≠ e)\n//                 ∃i: [0, s.size) s(i) ≡ e ∧ (∀j: [0, i) s(j) ≠ e) → result ≡ i\n//                 0 ≤ result\n//                 result ≤ s.size                                \"\"\"\n    for (i <- z\"0\" until s.size if e == s(i)) {\n      return i\n    }\n    return s.size\n  }\n\n  @pure def laxSlice(from: Z, til: Z): MS[Z, T] = {\n//    l\"\"\" ensures if (til > from) result.size ≡ NO(til).min(s.size) - NO(0).max(from)\n//                   else result.size ≡ 0\n//                 ∀i: [i, result.size) result(i) ≡ s(NO(0).max(from) + i)               \"\"\"\n\n    var r = MS[Z, T]()\n    for (i <- from until til if 0 <= i && i < s.size) {\n      r = r :+ s(i)\n    }\n    return r\n  }\n\n  @pure def map[U](f: T => U @pure): MS[Z, U] = {\n//    l\"\"\" ensures result.size ≡ s.size\n//                 ∀i: [0, result.size)  re
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$7();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #730                // String sult(i) ≡ f(s(i)) \"\"\"\n\n    return s.map(f)\n  }\n\n  @pure def parMap[U](f: T => U @pure): MS[Z, U] = {\n    val r = MSZOpsUtil.parMap(s, f)\n    return r\n  }\n\n  def mParMap[U](f: T => U): MS[Z, U] = {\n    val r = MSZOpsUtil.mParMap(s, f)\n    return r\n  }\n\n  @pure def parMapFoldLeft[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.MSZOps(parMap(f)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeft[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.MSZOps(mParMap(f)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRight[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R): R = {\n    return ops.MSZOps(parMap(f)).foldRight(g, init)\n  }\n\n  def mParMapFoldRight[U, R](f: T => U, g: (R, U) => R, init: R): R = {\n    return ops.MSZOps(mParMap(f)).mFoldRight(g, init)\n  }\n\n  @pure def parMapCores[U](f: T => U @pure, numOfCores: Z): MS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return MSZOpsUtil.parMapCores(s, f, numOfCores)\n    } else {\n      return map(f)\n    }\n  }\n\n  def mParMapCores[U](f: T => U, numOfCores: Z): MS[Z, U] = {\n    if (numOfCores > 1 || numOfCores <= 0) {\n      return MSZOpsUtil.mParMapCores(s, f, numOfCores)\n    } else {\n      return for (e <- s) yield f(e)\n    }\n  }\n\n  @pure def parMapFoldLeftCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(parMapCores(f, numOfCores)).foldLeft(g, init)\n  }\n\n  def mParMapFoldLeftCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(mParMapCores(f, numOfCores)).mFoldLeft(g, init)\n  }\n\n  @pure def parMapFoldRightCores[U, R](f: T => U @pure, g: (R, U) => R @pure, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(parMapCores(f, numOfCores)).foldRight(g, init)\n  }\n\n  def mParMapFoldRightCores[U, R](f: T => U, g: (R, U) => R, init: R, numOfCores: Z): R = {\n    return ops.MSZOps(mParMapCores(f, numOfCores)).mFoldRight(g, init)\n  }\n\n  @pure def remove(i: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ i\n//                  i < s.size\n//         ensures  result.size ≡ s.size - 1\n//                  ∀j: [0, i)  result(j) ≡ s(j)\n//                  ∀j: [i, result.size)  result(j) ≡ s(j + 1)\n//     \"\"\"\n    return laxSlice(0, i) ++ laxSlice(i + 1, s.size)\n  }\n\n  @pure def reverse: MS[Z, T] = {\n//    l\"\"\" ensures  result.size ≡ s.size\n//                  ∀i: [0, s.size)  result(i) ≡ s(s.size - 1 - i)\n//     \"\"\"\n\n    val r = s\n    var i = 0\n    var j = s.size - 1\n    val half = s.size / 2\n    while (i < half) {\n      val t = r(i)\n      r(i) = r(j)\n      r(j) = t\n      i = i + 1\n      j = j - 1\n    }\n    return r\n  }\n\n\n  @pure def slice(from: Z, til: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ from\n//                  from < s.size\n//                  0 ≤ til\n//                  til ≤ s.size\n//                  from ≤ til\n//         ensures  result.size ≡ til - from\n//                  ∀i: [0, result.size) result(i) ≡ s(from + i) \"\"\"\n\n    return laxSlice(from, til)\n  }\n\n  @pure def sortWith(lt: (T, T) => B @pure): MS[Z, T] = {\n    return MSZOpsUtil.sortWith(s, lt)\n  }\n\n  @pure def tail: MS[Z, T] = {\n//    l\"\"\" requires s.size > 0\n//         ensures  result.size ≡ s.size - 1\n//                  ∀i: [0, result.size)  result(i) ≡ s(i + 1) \"\"\"\n    return drop(1)\n  }\n\n  @pure def take(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(i) \"\"\"\n\n    return laxSlice(0, size)\n  }\n\n  @pure def takeRight(size: Z): MS[Z, T] = {\n//    l\"\"\" requires 0 ≤ size\n//                  size ≤ s.size\n//         ensures  result.size ≡ size\n//                  ∀i: [0, result.size)  result(i) ≡ s(s.size - size + i) \"\"\"\n\n    return laxSlice(s.size - size, s.size)\n  }\n\n  @pure def zip[T2](other: MS[Z, T2]): MS[Z, (T, T2)] = {\n//    l\"\"\" requires s.size ≡ other.size\n//         ensures  result ≡ s.size\n//                  ∀i: [0, result.size)  result(i) ≡ ((s(i), other(i))) \"\"\"\n    var i = 0\n    val sz = s.size\n    var r = MSZ[(T, T2)]()\n    while (i < sz) {\n      r = r :+ ((s(i), other(i)))\n      i = i + 1\n    }\n    return r\n  }\n}\n\n@sig trait SBOps[I] {\n\n  @pure def toU8: U8\n\n  @pure def toU16: U16\n\n  @pure def toU32: U32\n\n  @pure def toU64: U64\n}\n\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\nobject ISZBOps {\n\n  @pure def fromU8(n: U8): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 8\n//                 result(0) ≡ ((n & u8\"0x01\") ≠ u8\"0x01\") ∧\n//                 result(1) ≡ ((n & u8\"0x02\") ≠ u8\"0x02\") ∧\n//                 result(2) ≡ ((n & u8\"0x04\") ≠ u8\"0x04\") ∧\n//                 result(3) ≡ ((n & u8\"0x08\") ≠ u8\"0x08\") ∧\n//                 result(4) ≡ ((n & u8\"0x10\") ≠ u8\"0x10\") ∧\n//                 result(5) ≡ ((n & u8\"0x20\") ≠ u8\"0x20\") ∧\n//                 result(6) ≡ ((n & u8\"0x40\") ≠ u8\"0x40\") ∧\n//                 result(7) ≡ ((n & u8\"0x80\") ≠ u8\"0x80\")   \"\"\"\n    return IS[Z, B](\n      (n & u8\"0x01\") != u8\"0x01\",\n      (n & u8\"0x02\") != u8\"0x02\",\n      (n & u8\"0x04\") != u8\"0x04\",\n      (n & u8\"0x08\") != u8\"0x08\",\n      (n & u8\"0x10\") != u8\"0x10\",\n      (n & u8\"0x20\") != u8\"0x20\",\n      (n & u8\"0x40\") != u8\"0x40\",\n      (n & u8\"0x80\") != u8\"0x80\"\n    )\n  }\n\n  @pure def fromU16(n: U16): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 16\n//                 result( 0) ≡ ((n & u16\"0x0001\") ≠ u16\"0x0001\") ∧\n//                 result( 1) ≡ ((n & u16\"0x0002\") ≠ u16\"0x0002\") ∧\n//                 result( 2) ≡ ((n & u16\"0x0004\") ≠ u16\"0x0004\") ∧\n//                 result( 3) ≡ ((n & u16\"0x0008\") ≠ u16\"0x0008\") ∧\n//                 result( 4) ≡ ((n & u16\"0x0010\") ≠ u16\"0x0010\") ∧\n//                 result( 5) ≡ ((n & u16\"0x0020\") ≠ u16\"0x0020\") ∧\n//                 result( 6) ≡ ((n & u16\"0x0040\") ≠ u16\"0x0040\") ∧\n//                 result( 7) ≡ ((n & u16\"0x0080\") ≠ u16\"0x0080\") ∧\n//                 result( 8) ≡ ((n & u16\"0x0100\") ≠ u16\"0x0100\") ∧\n//                 result( 9) ≡ ((n & u16\"0x0200\") ≠ u16\"0x0200\") ∧\n//                 result(10) ≡ ((n & u16\"0x0400\") ≠ u16\"0x0400\") ∧\n//                 result(11) ≡ ((n & u16\"0x0800\") ≠ u16\"0x0800\") ∧\n//                 result(12) ≡ ((n & u16\"0x1000\") ≠ u16\"0x1000\") ∧\n//                 result(13) ≡ ((n & u16\"0x2000\") ≠ u16\"0x2000\") ∧\n//                 result(14) ≡ ((n & u16\"0x4000\") ≠ u16\"0x4000\") ∧\n//                 result(15) ≡ ((n & u16\"0x8000\") ≠ u16\"0x8000\")   \"\"\"\n    return IS[Z, B](\n      (n & u16\"0x0001\") != u16\"0x0001\",\n      (n & u16\"0x0002\") != u16\"0x0002\",\n      (n & u16\"0x0004\") != u16\"0x0004\",\n      (n & u16\"0x0008\") != u16\"0x0008\",\n      (n & u16\"0x0010\") != u16\"0x0010\",\n      (n & u16\"0x0020\") != u16\"0x0020\",\n      (n & u16\"0x0040\") != u16\"0x0040\",\n      (n & u16\"0x0080\") != u16\"0x0080\",\n      (n & u16\"0x0100\") != u16\"0x0100\",\n      (n & u16\"0x0200\") != u16\"0x0200\",\n      (n & u16\"0x0400\") != u16\"0x0400\",\n      (n & u16\"0x0800\") != u16\"0x0800\",\n      (n & u16\"0x1000\") != u16\"0x1000\",\n      (n & u16\"0x2000\") != u16\"0x2000\",\n      (n & u16\"0x4000\") != u16\"0x4000\",\n      (n & u16\"0x8000\") != u16\"0x8000\"\n    )\n  }\n\n  @pure def fromU32(s: IS[Z, B], n: U32): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 32\n//                 result( 0) ≡ ((n & u32\"0x00000001\") ≠ u32\"0x00000001\") ∧\n//                 result( 1) ≡ ((n & u32\"0x00000002\") ≠ u32\"0x00000002\") ∧\n//                 result( 2) ≡ ((n & u32\"0x00000004\") ≠ u32\"0x00000004\") ∧\n//                 result( 3) ≡ ((n & u32\"0x00000008\") ≠ u32\"0x00000008\") ∧\n//                 result( 4) ≡ ((n & u32\"0x00000010\") ≠ u32\"0x00000010\") ∧\n//                 result( 5) ≡ ((n & u32\"0x00000020\") ≠ u32\"0x00000020\") ∧\n//                 result( 6) ≡ ((n & u32\"0x00000040\") ≠ u32\"0x00000040\") ∧\n//                 result( 7) ≡ ((n & u32\"0x00000080\") ≠ u32\"0x00000080\") ∧\n//                 result( 8) ≡ ((n & u32\"0x00000100\") ≠ u32\"0x00000100\") ∧\n//                 result( 9) ≡ ((n & u32\"0x00000200\") ≠ u32\"0x00000200\") ∧\n//                 result(10) ≡ ((n & u32\"0x00000400\") ≠ u32\"0x00000400\") ∧\n//                 result(11) ≡ ((n & u32\"0x00000800\") ≠ u32\"0x00000800\") ∧\n//                 result(12) ≡ ((n & u32\"0x00001000\") ≠ u32\"0x00001000\") ∧\n//                 result(13) ≡ ((n & u32\"0x00002000\") ≠ u32\"0x00002000\") ∧\n//                 result(14) ≡ ((n & u32\"0x00004000\") ≠ u32\"0x00004000\") ∧\n//                 result(15) ≡ ((n & u32\"0x00008000\") ≠ u32\"0x00008000\") ∧\n//                 result(16) ≡ ((n & u32\"0x00010000\") ≠ u32\"0x00010000\") ∧\n//                 result(17) ≡ ((n & u32\"0x00020000\") ≠ u32\"0x00020000\") ∧\n//                 result(18) ≡ ((n & u32\"0x00040000\") ≠ u32\"0x00040000\") ∧\n//                 result(19) ≡ ((n & u32\"0x00080000\") ≠ u32\"0x00080000\") ∧\n//                 result(20) ≡ ((n & u32\"0x00100000\") ≠ u32\"0x00100000\") ∧\n//                 result(21) ≡ ((n & u32\"0x00200000\") ≠ u32\"0x00200000\") ∧\n//                 result(22) ≡ ((n & u32\"0x00400000\") ≠ u32\"0x00400000\") ∧\n//                 result(23) ≡ ((n & u32\"0x00800000\") ≠ u32\"0x00800000\") ∧\n//                 result(24) ≡ ((n & u32\"0x01000000\") ≠ u32\"0x01000000\") ∧\n//                 result(25) ≡ ((n & u32\"0x02000000\") ≠ u32\"0x02000000\") ∧\n//                 result(26) ≡ ((n & u32\"0x04000000\") ≠ u32\"0x04000000\") ∧\n//                 result(27) ≡ ((n & u32\"0x08000000\") ≠ u32\"0x08000000\") ∧\n//                 result(28) ≡ ((n & u32\"0x10000000\") ≠ u32\"0x10000000\") ∧\n//                 result(29) ≡ ((n & u32\"0x20000000\") ≠ u32\"0x20000000\") ∧\n//                 result(30) ≡ ((n & u32\"0x40000000\") ≠ u32\"0x40000000\") ∧\n//                 result(31) ≡ ((n & u32\"0x80000000\") ≠ u32\"0x80000000\")   \"\"\"\n\n    return IS[Z, B](\n      (n & u32\"0x00000001\") != u32\"0x00000001\",\n      (n & u32\"0x00000002\") != u32\"0x00000002\",\n      (n & u32\"0x00000004\") != u32\"0x00000004\",\n      (n & u32\"0x00000008\") != u32\"0x00000008\",\n      (n & u32\"0x00000010\") != u32\"0x00000010\",\n      (n & u32\"0x00000020\") != u32\"0x00000020\",\n      (n & u32\"0x00000040\") != u32\"0x00000040\",\n      (n & u32\"0x00000080\") != u32\"0x00000080\",\n      (n & u32\"0x00000100\") != u32\"0x00000100\",\n      (n & u32\"0x00000200\") != u32\"0x00000200\",\n      (n & u32\"0x00000400\") != u32\"0x00000400\",\n      (n & u32\"0x00000800\") != u32\"0x00000800\",\n      (n & u32\"0x00001000\") != u32\"0x00001000\",\n      (n & u32\"0x00002000\") != u32\"0x00002000\",\n      (n & u32\"0x00004000\") != u32\"0x00004000\",\n      (n & u32\"0x00008000\") != u32\"0x00008000\",\n      (n & u32\"0x00010000\") != u32\"0x00010000\",\n      (n & u32\"0x00020000\") != u32\"0x00020000\",\n      (n & u32\"0x00040000\") != u32\"0x00040000\",\n      (n & u32\"0x00080000\") != u32\"0x00080000\",\n      (n & u32\"0x00100000\") != u32\"0x00100000\",\n      (n & u32\"0x00200000\") != u32\"0x00200000\",\n      (n & u32\"0x00400000\") != u32\"0x00400000\",\n      (n & u32\"0x00800000\") != u32\"0x00800000\",\n      (n & u32\"0x01000000\") != u32\"0x01000000\",\n      (n & u32\"0x02000000\") != u32\"0x02000000\",\n      (n & u32\"0x04000000\") != u32\"0x04000000\",\n      (n & u32\"0x08000000\") != u32\"0x08000000\",\n      (n & u32\"0x10000000\") != u32\"0x10000000\",\n      (n & u32\"0x20000000\") != u32\"0x20000000\",\n      (n & u32\"0x40000000\") != u32\"0x40000000\",\n      (n & u32\"0x80000000\") != u32\"0x80000000\"\n    )\n  }\n\n  @pure def fromU64(s: IS[Z, B], n: U64): IS[Z, B] = {\n//    l\"\"\" ensures result.size ≡ 64\n//                 result(  ) ≡ ((n & u64\"0x0000000000000001\") ≠ u64\"0x0000000000000001\") ∧\n//                 result( 1) ≡ ((n & u64\"0x0000000000000002\") ≠ u64\"0x0000000000000002\") ∧\n//                 result( 2) ≡ ((n & u64\"0x0000000000000004\") ≠ u64\"0x0000000000000004\") ∧\n//                 result( 3) ≡ ((n & u64\"0x0000000000000008\") ≠ u64\"0x0000000000000008\") ∧\n//                 result( 4) ≡ ((n & u64\"0x0000000000000010\") ≠ u64\"0x0000000000000010\") ∧\n//                 result( 5) ≡ ((n & u64\"0x0000000000000020\") ≠ u64\"0x0000000000000020\") ∧\n//                 result( 6) ≡ ((n & u64\"0x0000000000000040\") ≠ u64\"0x0000000000000040\") ∧\n//                 result( 7) ≡ ((n & u64\"0x0000000000000080\") ≠ u64\"0x0000000000000080\") ∧\n//                 result( 8) ≡ ((n & u64\"0x0000000000000100\") ≠ u64\"0x0000000000000100\") ∧\n//                 result( 9) ≡ ((n & u64\"0x0000000000000200\") ≠ u64\"0x0000000000000200\") ∧\n//                 result(10) ≡ ((n & u64\"0x0000000000000400\") ≠ u64\"0x0000000000000400\") ∧\n//                 result(11) ≡ ((n & u64\"0x0000000000000800\") ≠ u64\"0x0000000000000800\") ∧\n//                 result(12) ≡ ((n & u64\"0x0000000000001000\") ≠ u64\"0x0000000000001000\") ∧\n//                 result(13) ≡ ((n & u64\"0x0000000000002000\") ≠ u64\"0x0000000000002000\") ∧\n//                 result(14) ≡ ((n & u64\"0x0000000000004000\") ≠ u64\"0x0000000000004000\") ∧\n//                 result(15) ≡ ((n & u64\"0x0000000000008000\") ≠ u64\"0x0000000000008000\") ∧\n//                 result(16) ≡ ((n & u64\"0x0000000000010000\") ≠ u64\"0x0000000000010000\") ∧\n//                 result(17) ≡ ((n & u64\"0x0000000000020000\") ≠ u64\"0x0000000000020000\") ∧\n//                 result(18) ≡ ((n & u64\"0x0000000000040000\") ≠ u64\"0x0000000000040000\") ∧\n//                 result(19) ≡ ((n & u64\"0x0000000000080000\") ≠ u64\"0x0000000000080000\") ∧\n//                 result(20) ≡ ((n & u64\"0x0000000000100000\") ≠ u64\"0x0000000000100000\") ∧\n//                 result(21) ≡ ((n & u64\"0x0000000000200000\") ≠ u64\"0x0000000000200000\") ∧\n//                 result(22) ≡ ((n & u64\"0x0000000000400000\") ≠ u64\"0x0000000000400000\") ∧\n//                 result(23) ≡ ((n & u64\"0x0000000000800000\") ≠ u64\"0x0000000000800000\") ∧\n//                 result(24) ≡ ((n & u64\"0x0000000001000000\") ≠ u64\"0x0000000001000000\") ∧\n//                 result(25) ≡ ((n & u64\"0x0000000002000000\") ≠ u64\"0x0000000002000000\") ∧\n//                 result(26) ≡ ((n & u64\"0x0000000004000000\") ≠ u64\"0x0000000004000000\") ∧\n//                 result(27) ≡ ((n & u64\"0x0000000008000000\") ≠ u64\"0x0000000008000000\") ∧\n//                 result(28) ≡ ((n & u64\"0x0000000010000000\") ≠ u64\"0x0000000010000000\") ∧\n//                 result(29) ≡ ((n & u64\"0x0000000020000000\") ≠ u64\"0x0000000020000000\") ∧\n//                 result(30) ≡ ((n & u64\"0x0000000040000000\") ≠ u64\"0x0000000040000000\") ∧\n//                 result(31) ≡ ((n & u64\"0x0000000080000000\") ≠ u64\"0x0000000080000000\") ∧\n//                 result(32) ≡ ((n & u64\"0x0000000100000000\") ≠ u64\"0x0000000100000000\") ∧\n//                 result(33) ≡ ((n & u64\"0x0000000200000000\") ≠ u64\"0x0000000200000000\") ∧\n//                 result(34) ≡ ((n & u64\"0x0000000400000000\") ≠ u64\"0x0000000400000000\") ∧\n//                 result(35) ≡ ((n & u64\"0x0000000800000000\") ≠ u64\"0x0000000800000000\") ∧\n//                 result(36) ≡ ((n & u64\"0x0000001000000000\") ≠ u64\"0x0000001000000000\") ∧\n//                 result(37) ≡ ((n & u64\"0x0000002000000000\") ≠ u64\"0x0000002000000000\") ∧\n//                 result(38) ≡ ((n & u64\"0x0000004000000000\") ≠ u64\"0x0000004000000000\") ∧\n//                 result(39) ≡ ((n & u64\"0x0000008000000000\") ≠ u64\"0x0000008000000000\") ∧\n//                 result(40) ≡ ((n & u64\"0x0000010000000000\") ≠ u64\"0x0000010000000000\") ∧\n//                 result(41) ≡ ((n & u64\"0x0000020000000000\") ≠ u64\"0x0000020000000000\") ∧\n//                 result(42) ≡ ((n & u64\"0x0000040000000000\") ≠ u64\"0x0000040000000000\") ∧\n//                 result(43) ≡ ((n & u64\"0x0000080000000000\") ≠ u64\"0x0000080000000000\") ∧\n//                 result(44) ≡ ((n & u64\"0x0000100000000000\") ≠ u64\"0x0000100000000000\") ∧\n//                 result(45) ≡ ((n & u64\"0x0000200000000000\") ≠ u64\"0x0000200000000000\") ∧\n//                 result(46) ≡ ((n & u64\"0x0000400000000000\") ≠ u64\"0x0000400000000000\") ∧\n//                 result(47) ≡ ((n & u64\"0x0000800000000000\") ≠ u64\"0x0000800000000000\") ∧\n//                 result(48) ≡ ((n & u64\"0x0001000000000000\") ≠ u64\"0x0001000000000000\") ∧\n//                 result(49) ≡ ((n & u64\"0x0002000000000000\") ≠ u64\"0x0002000000000000\") ∧\n//                 result(50) ≡ ((n & u64\"0x0004000000000000\") ≠ u64\"0x0004000000000000\") ∧\n//                 result(51) ≡ ((n & u64\"0x0008000000000000\") ≠ u64\"0x0008000000000000\") ∧\n//                 result(52) ≡ ((n & u64\"0x0010000000000000\") ≠ u64\"0x0010000000000000\") ∧\n//                 result(53) ≡ ((n & u64\"0x0020000000000000\") ≠ u64\"0x0020000000000000\") ∧\n//                 result(54) ≡ ((n & u64\"0x0040000000000000\") ≠ u64\"0x0040000000000000\") ∧\n//                 result(55) ≡ ((n & u64\"0x0080000000000000\") ≠ u64\"0x0080000000000000\") ∧\n//                 result(56) ≡ ((n & u64\"0x0100000000000000\") ≠ u64\"0x0100000000000000\") ∧\n//                 result(57) ≡ ((n & u64\"0x0200000000000000\") ≠ u64\"0x0200000000000000\") ∧\n//                 result(58) ≡ ((n & u64\"0x0400000000000000\") ≠ u64\"0x0400000000000000\") ∧\n//                 result(59) ≡ ((n & u64\"0x0800000000000000\") ≠ u64\"0x0800000000000000\") ∧\n//                 result(60) ≡ ((n & u64\"0x1000000000000000\") ≠ u64\"0x1000000000000000\") ∧\n//                 result(61) ≡ ((n & u64\"0x2000000000000000\") ≠ u64\"0x2000000000000000\") ∧\n//                 result(62) ≡ ((n & u64\"0x4000000000000000\") ≠ u64\"0x4000000000000000\") ∧\n//                 result(63) ≡ ((n & u64\"0x8000000000000000\") ≠ u64\"0x8000000000000000\")   \"\"\"\n\n    IS[Z, B](\n      (n & u64\"0x0000000000000001\") != u64\"0x0000000000000001\",\n      (n & u64\"0x0000000000000002\") != u64\"0x0000000000000002\",\n      (n & u64\"0x0000000000000004\") != u64\"0x0000000000000004\",\n      (n & u64\"0x0000000000000008\") != u64\"0x0000000000000008\",\n      (n & u64\"0x0000000000000010\") != u64\"0x0000000000000010\",\n      (n & u64\"0x0000000000000020\") != u64\"0x0000000000000020\",\n      (n & u64\"0x0000000000000040\") != u64\"0x0000000000000040\",\n      (n & u64\"0x0000000000000080\") != u64\"0x0000000000000080\",\n      (n & u64\"0x0000000000000100\") != u64\"0x0000000000000100\",\n      (n & u64\"0x0000000000000200\") != u64\"0x0000000000000200\",\n      (n & u64\"0x0000000000000400\") != u64\"0x0000000000000400\",\n      (n & u64\"0x0000000000000800\") != u64\"0x0000000000000800\",\n      (n & u64\"0x0000000000001000\") != u64\"0x0000000000001000\",\n      (n & u64\"0x0000000000002000\") != u64\"0x0000000000002000\",\n      (n & u64\"0x0000000000004000\") != u64\"0x0000000000004000\",\n      (n & u64\"0x0000000000008000\") != u64\"0x0000000000008000\",\n      (n & u64\"0x0000000000010000\") != u64\"0x0000000000010000\",\n      (n & u64\"0x0000000000020000\") != u64\"0x0000000000020000\",\n      (n & u64\"0x0000000000040000\") != u64\"0x0000000000040000\",\n      (n & u64\"0x0000000000080000\") != u64\"0x0000000000080000\",\n      (n & u64\"0x0000000000100000\") != u64\"0x0000000000100000\",\n      (n & u64\"0x0000000000200000\") != u64\"0x0000000000200000\",\n      (n & u64\"0x0000000000400000\") != u64\"0x0000000000400000\",\n      (n & u64\"0x0000000000800000\") != u64\"0x0000000000800000\",\n      (n & u64\"0x0000000001000000\") != u64\"0x0000000001000000\",\n      (n & u64\"0x0000000002000000\") != u64\"0x0000000002000000\",\n      (n & u64\"0x0000000004000000\") != u64\"0x0000000004000000\",\n      (n & u64\"0x0000000008000000\") != u64\"0x0000000008000000\",\n      (n & u64\"0x0000000010000000\") != u64\"0x0000000010000000\",\n      (n & u64\"0x0000000020000000\") != u64\"0x0000000020000000\",\n      (n & u64\"0x0000000040000000\") != u64\"0x0000000040000000\",\n      (n & u64\"0x0000000080000000\") != u64\"0x0000000080000000\",\n      (n & u64\"0x0000000100000000\") != u64\"0x0000000100000000\",\n      (n & u64\"0x0000000200000000\") != u64\"0x0000000200000000\",\n      (n & u64\"0x0000000400000000\") != u64\"0x0000000400000000\",\n      (n & u64\"0x0000000800000000\") != u64\"0x0000000800000000\",\n      (n & u64\"0x0000001000000000\") != u64\"0x0000001000000000\",\n      (n & u64\"0x0000002000000000\") != u64\"0x0000002000000000\",\n      (n & u64\"0x0000004000000000\") != u64\"0x0000004000000000\",\n      (n & u64\"0x0000008000000000\") != u64\"0x0000008000000000\",\n      (n & u64\"0x0000010000000000\") != u64\"0x0000010000000000\",\n      (n & u64\"0x0000020000000000\") != u64\"0x0000020000000000\",\n      (n & u64\"0x0000040000000000\") != u64\"0x0000040000000000\",\n      (n & u64\"0x0000080000000000\") != u64\"0x0000
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f2$4();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #732                // String 080000000000\",\n      (n & u64\"0x0000100000000000\") != u64\"0x0000100000000000\",\n      (n & u64\"0x0000200000000000\") != u64\"0x0000200000000000\",\n      (n & u64\"0x0000400000000000\") != u64\"0x0000400000000000\",\n      (n & u64\"0x0000800000000000\") != u64\"0x0000800000000000\",\n      (n & u64\"0x0001000000000000\") != u64\"0x0001000000000000\",\n      (n & u64\"0x0002000000000000\") != u64\"0x0002000000000000\",\n      (n & u64\"0x0004000000000000\") != u64\"0x0004000000000000\",\n      (n & u64\"0x0008000000000000\") != u64\"0x0008000000000000\",\n      (n & u64\"0x0010000000000000\") != u64\"0x0010000000000000\",\n      (n & u64\"0x0020000000000000\") != u64\"0x0020000000000000\",\n      (n & u64\"0x0040000000000000\") != u64\"0x0040000000000000\",\n      (n & u64\"0x0080000000000000\") != u64\"0x0080000000000000\",\n      (n & u64\"0x0100000000000000\") != u64\"0x0100000000000000\",\n      (n & u64\"0x0200000000000000\") != u64\"0x0200000000000000\",\n      (n & u64\"0x0400000000000000\") != u64\"0x0400000000000000\",\n      (n & u64\"0x0800000000000000\") != u64\"0x0800000000000000\",\n      (n & u64\"0x1000000000000000\") != u64\"0x1000000000000000\",\n      (n & u64\"0x2000000000000000\") != u64\"0x2000000000000000\",\n      (n & u64\"0x4000000000000000\") != u64\"0x4000000000000000\",\n      (n & u64\"0x8000000000000000\") != u64\"0x8000000000000000\"\n    )\n  }\n}\n\n@datatype class ISZBOps(val s: IS[Z, B]) extends SBOps[Z] {\n\n  @pure def toU8: U8 = {\n//    l\"\"\" requires s.size ≡ 8\n//         ensures  fromU8(result) ≡ s \"\"\"\n\n    var r = u8\"0\"\n    var mask = u8\"1\"\n    for (i <- 0 until 8) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u8\"1\"\n    }\n    return r\n  }\n\n  @pure def toU16: U16 = {\n//    l\"\"\" requires s.size ≡ 16\n//         ensures  fromU16(result) ≡ s \"\"\"\n\n    var r = u16\"0\"\n    var mask = u16\"1\"\n    for (i <- 0 until 16) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u16\"1\"\n    }\n    return r\n  }\n\n  @pure def toU32: U32 = {\n//    l\"\"\" requires s.size ≡ 32\n//         ensures  fromU32(result) ≡ s \"\"\"\n\n    var r = u32\"0\"\n    var mask = u32\"1\"\n    for (i <- 0 until 32) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u32\"1\"\n    }\n    return r\n  }\n\n  @pure def toU64: U64 = {\n//    l\"\"\" requires s.size ≡ 64\n//         ensures  fromU64(result) ≡ s \"\"\"\n\n    var r = u64\"0\"\n    var mask = u64\"1\"\n    for (i <- 0 until 64) {\n      if (s(i)) {\n        r = r | mask\n      }\n      mask = mask << u64\"1\"\n    }\n    return r\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$51();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #734                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.ops\n\nimport org.sireum._\nimport org.sireum.U1._\nimport org.sireum.U2._\nimport org.sireum.U3._\nimport org.sireum.U4._\nimport org.sireum.U5._\nimport org.sireum.U6._\nimport org.sireum.U7._\nimport org.sireum.U8._\nimport org.sireum.U9._\nimport org.sireum.U10._\nimport org.sireum.U11._\nimport org.sireum.U12._\nimport org.sireum.U13._\nimport org.sireum.U14._\nimport org.sireum.U15._\nimport org.sireum.U16._\nimport org.sireum.U17._\nimport org.sireum.U18._\nimport org.sireum.U19._\nimport org.sireum.U20._\nimport org.sireum.U21._\nimport org.sireum.U22._\nimport org.sireum.U23._\nimport org.sireum.U24._\nimport org.sireum.U25._\nimport org.sireum.U26._\nimport org.sireum.U27._\nimport org.sireum.U28._\nimport org.sireum.U29._\nimport org.sireum.U30._\nimport org.sireum.U31._\nimport org.sireum.U32._\nimport org.sireum.U33._\nimport org.sireum.U34._\nimport org.sireum.U35._\nimport org.sireum.U36._\nimport org.sireum.U37._\nimport org.sireum.U38._\nimport org.sireum.U39._\nimport org.sireum.U40._\nimport org.sireum.U41._\nimport org.sireum.U42._\nimport org.sireum.U43._\nimport org.sireum.U44._\nimport org.sireum.U45._\nimport org.sireum.U46._\nimport org.sireum.U47._\nimport org.sireum.U48._\nimport org.sireum.U49._\nimport org.sireum.U50._\nimport org.sireum.U51._\nimport org.sireum.U52._\nimport org.sireum.U53._\nimport org.sireum.U54._\nimport org.sireum.U55._\nimport org.sireum.U56._\nimport org.sireum.U57._\nimport org.sireum.U58._\nimport org.sireum.U59._\nimport org.sireum.U60._\nimport org.sireum.U61._\nimport org.sireum.U62._\nimport org.sireum.U63._\nimport org.sireum.U64._\n\n\nobject Bits {\n\n  object Context {\n    def create: Context = {\n      return Context(0, 0, 0)\n    }\n  }\n\n  @record class Context(var offset: Z,\n                        var errorCode: Z,\n                        var errorOffset: Z) {\n    def hasError: B = {\n      return errorCode != 0\n    }\n\n    def signalError(code: Z): Unit = {\n      if (!hasError) {\n        errorCode = code\n        errorOffset = offset\n      }\n    }\n\n    def skip(size: Z, n: Z, errorCode: Z): Unit = {\n      if (offset + n > size) {\n        signalError(errorCode)\n        return\n      }\n      offset = offset + n\n    }\n\n    def updateErrorCode(code: Z): Unit = {\n      errorCode = code\n    }\n  }\n\n  object Reader {\n    val INCOMPLETE_INPUT: Z = 1\n\n    object IS {\n\n      def bleB(input: ISZ[B], context: Context): B = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return F\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return r\n      }\n\n      def beBS(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        bleRaw(input, context, result, size)\n      }\n\n      def leBS(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- size - 1 to 0 by -1) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleRaw(input: ISZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleU1(input: ISZ[B], context: Context): U1 = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u1\"0\"\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return if (r) u1\"1\" else u1\"0\"\n      }\n\n      def bleU2(input: ISZ[B], context: Context): U2 = {\n        val offset = context.offset\n        if (offset + 2 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u2\"0\"\n        }\n        var r = u2\"0\"\n        var mask = u2\"1\"\n        for (i <- 0 until 1) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u2\"1\"\n        }\n        if (input(offset + 1)) {\n          r = r | mask\n        }\n        context.offset = offset + 2\n        return r\n      }\n\n      def bleU3(input: ISZ[B], context: Context): U3 = {\n        val offset = context.offset\n        if (offset + 3 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u3\"0\"\n        }\n        var r = u3\"0\"\n        var mask = u3\"1\"\n        for (i <- 0 until 2) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u3\"1\"\n        }\n        if (input(offset + 2)) {\n          r = r | mask\n        }\n        context.offset = offset + 3\n        return r\n      }\n\n      def bleU4(input: ISZ[B], context: Context): U4 = {\n        val offset = context.offset\n        if (offset + 4 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u4\"0\"\n        }\n        var r = u4\"0\"\n        var mask = u4\"1\"\n        for (i <- 0 until 3) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u4\"1\"\n        }\n        if (input(offset + 3)) {\n          r = r | mask\n        }\n        context.offset = offset + 4\n        return r\n      }\n\n      def bleU5(input: ISZ[B], context: Context): U5 = {\n        val offset = context.offset\n        if (offset + 5 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u5\"0\"\n        }\n        var r = u5\"0\"\n        var mask = u5\"1\"\n        for (i <- 0 until 4) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u5\"1\"\n        }\n        if (input(offset + 4)) {\n          r = r | mask\n        }\n        context.offset = offset + 5\n        return r\n      }\n\n      def bleU6(input: ISZ[B], context: Context): U6 = {\n        val offset = context.offset\n        if (offset + 6 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u6\"0\"\n        }\n        var r = u6\"0\"\n        var mask = u6\"1\"\n        for (i <- 0 until 5) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u6\"1\"\n        }\n        if (input(offset + 5)) {\n          r = r | mask\n        }\n        context.offset = offset + 6\n        return r\n      }\n\n      def bleU7(input: ISZ[B], context: Context): U7 = {\n        val offset = context.offset\n        if (offset + 7 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u7\"0\"\n        }\n        var r = u7\"0\"\n        var mask = u7\"1\"\n        for (i <- 0 until 6) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u7\"1\"\n        }\n        if (input(offset + 6)) {\n          r = r | mask\n        }\n        context.offset = offset + 7\n        return r\n      }\n\n      def beU8S(input: ISZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        leU8S(input, context, result, size)\n      }\n\n      def beS8S(input: ISZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        leS8S(input, context, result, size)\n      }\n\n      def beU16S(input: ISZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU16(input, context)\n        }\n      }\n\n      def beS16S(input: ISZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS16(input, context)\n        }\n      }\n\n      def beU32S(input: ISZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU32(input, context)\n        }\n      }\n\n      def beS32S(input: ISZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS32(input, context)\n        }\n      }\n\n      def beU64S(input: ISZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU64(input, context)\n        }\n      }\n\n      def beS64S(input: ISZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS64(input, context)\n        }\n      }\n\n      def beF32S(input: ISZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF32(input, context)\n        }\n      }\n\n      def beF64S(input: ISZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF64(input, context)\n        }\n      }\n\n      def leU8S(input: ISZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleU8(input, context)\n        }\n      }\n\n      def leS8S(input: ISZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleS8(input, context)\n        }\n      }\n\n      def leU16S(input: ISZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU16(input, context)\n        }\n      }\n\n      def leS16S(input: ISZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS16(input, context)\n        }\n      }\n\n      def leU32S(input: ISZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU32(input, context)\n        }\n      }\n\n      def leS32S(input: ISZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS32(input, context)\n        }\n      }\n\n      def leU64S(input: ISZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU64(input, context)\n        }\n      }\n\n      def leS64S(input: ISZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS64(input, context)\n        }\n      }\n\n      def leF32S(input: ISZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF32(input, context)\n        }\n      }\n\n      def leF64S(input: ISZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF64(input, context)\n        }\n      }\n\n      def bleU8(input: ISZ[B], context: Context): U8 = {\n        val offset = context.offset\n        if (offset + 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u8\"0\"\n        }\n        var r = u8\"0\"\n        var mask = u8\"1\"\n        for (i <- 0 until 7) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u8\"1\"\n        }\n        if (input(offset + 7)) {\n          r = r | mask\n        }\n        context.offset = offset + 8\n        return r\n      }\n\n      def bleS8(input: ISZ[B], context: Context): S8 = {\n        return conversions.U8.toRawS8(bleU8(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          ret
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f1$8();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #736                // String urn u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def beU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      */\n\n      def beU9(input: ISZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def beU10(input: ISZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def beU11(input: ISZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def beU12(input: ISZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def beU13(input: ISZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def beU14(input: ISZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def beU15(input: ISZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def beU16(input: ISZ[B], context: Context): U16 = {\n        val r = (conversions.U8.toU16(bleU8(input, context)) << u16\"8\") |\n          conversions.U8.toU16(bleU8(input, context))\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def beS16(input: ISZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(beU16(input, context))\n      }\n\n      def beU17(input: ISZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def beU18(input: ISZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def beU19(input: ISZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def beU20(input: ISZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def beU21(input: ISZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def beU22(input: ISZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def beU23(input: ISZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def beU24(input: ISZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def beU25(input: ISZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def beU26(input: ISZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def beU27(input: ISZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def beU28(input: ISZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def beU29(input: ISZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def beU30(input: ISZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def beU31(input: ISZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def beU32(input: ISZ[B], context: Context): U32 = {\n        val r = (conversions.U8.toU32(bleU8(input, context)) << u32\"24\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          conversions.U8.toU32(bleU8(input, context))\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def beS32(input: ISZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(beU32(input, context))\n      }\n\n      def beU33(input: ISZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def beU34(input: ISZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def beU35(input: ISZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def beU36(input: ISZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def beU37(input: ISZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def beU38(input: ISZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def beU39(input: ISZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def beU40(input: ISZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def beU41(input: ISZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def beU42(input: ISZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def beU43(input: ISZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f2$5();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #738                // String r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def beU44(input: ISZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def beU45(input: ISZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def beU46(input: ISZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def beU47(input: ISZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def beU48(input: ISZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def beU49(input: ISZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def beU50(input: ISZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def beU51(input: ISZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def beU52(input: ISZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def beU53(input: ISZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def beU54(input: ISZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def beU55(input: ISZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def beU56(input: ISZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def beU57(input: ISZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def beU58(input: ISZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def beU59(input: ISZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def beU60(input: ISZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def beU61(input: ISZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def beU62(input: ISZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def beU63(input: ISZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def beU64(input: ISZ[B], context: Context): U64 = {\n        val r = (conversions.U8.toU64(bleU8(input, context)) << u64\"56\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          conversions.U8.toU64(bleU8(input, context))\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def beS64(input: ISZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(beU64(input, context))\n      }\n\n      def beF32(input: ISZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(beU32(input, context))\n      }\n\n      def beF64(input: ISZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(beU64(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f3$4();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #740                // String           |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      \n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def leU$i(input: ISZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n       */\n\n      def leU9(input: ISZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def leU10(input: ISZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def leU11(input: ISZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def leU12(input: ISZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def leU13(input: ISZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def leU14(input: ISZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def leU15(input: ISZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def leU16(input: ISZ[B], context: Context): U16 = {\n        val r = conversions.U8.toU16(bleU8(input, context)) |\n          (conversions.U8.toU16(bleU8(input, context)) << u16\"8\")\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def leS16(input: ISZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(leU16(input, context))\n      }\n\n      def leU17(input: ISZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def leU18(input: ISZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def leU19(input: ISZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def leU20(input: ISZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def leU21(input: ISZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def leU22(input: ISZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def leU23(input: ISZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def leU24(input: ISZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def leU25(input: ISZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def leU26(input: ISZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def leU27(input: ISZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def leU28(input: ISZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def leU29(input: ISZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def leU30(input: ISZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def leU31(input: ISZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def leU32(input: ISZ[B], context: Context): U32 = {\n        val r = conversions.U8.toU32(bleU8(input, context)) |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"24\")\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def leS32(input: ISZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(leU32(input, context))\n      }\n\n      def leU33(input: ISZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def leU34(input: ISZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def leU35(input: ISZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def leU36(input: ISZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def leU37(input: ISZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def leU38(input: ISZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def leU39(input: ISZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | (conversions.U64.toU39
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f4$2();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #742                // String (conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def leU40(input: ISZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def leU41(input: ISZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def leU42(input: ISZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def leU43(input: ISZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def leU44(input: ISZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def leU45(input: ISZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def leU46(input: ISZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def leU47(input: ISZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def leU48(input: ISZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def leU49(input: ISZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def leU50(input: ISZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def leU51(input: ISZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def leU52(input: ISZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def leU53(input: ISZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def leU54(input: ISZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def leU55(input: ISZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def leU56(input: ISZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def leU57(input: ISZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def leU58(input: ISZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def leU59(input: ISZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def leU60(input: ISZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def leU61(input: ISZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def leU62(input: ISZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def leU63(input: ISZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f5$2();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #744                // String     def leU64(input: ISZ[B], context: Context): U64 = {\n        val r = conversions.U8.toU64(bleU8(input, context)) |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"56\")\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def leS64(input: ISZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(leU64(input, context))\n      }\n\n      def leF32(input: ISZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(leU32(input, context))\n      }\n\n      def leF64(input: ISZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(leU64(input, context))\n      }\n    }\n\n    object MS {\n\n      def bleB(input: MSZ[B], context: Context): B = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return F\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return r\n      }\n\n      def beBS(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        bleRaw(input, context, result, size)\n      }\n\n      def leBS(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- size - 1 to 0 by -1) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleRaw(input: MSZ[B], context: Context, result: MSZ[B], size: Z): Unit = {\n        if (context.offset + size > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleB(input, context)\n        }\n      }\n\n      def bleU1(input: MSZ[B], context: Context): U1 = {\n        val offset = context.offset\n        if (offset + 1 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u1\"0\"\n        }\n        val r = input(offset)\n        context.offset = offset + 1\n        return if (r) u1\"1\" else u1\"0\"\n      }\n\n      def bleU2(input: MSZ[B], context: Context): U2 = {\n        val offset = context.offset\n        if (offset + 2 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u2\"0\"\n        }\n        var r = u2\"0\"\n        var mask = u2\"1\"\n        for (i <- 0 until 1) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u2\"1\"\n        }\n        if (input(offset + 1)) {\n          r = r | mask\n        }\n        context.offset = offset + 2\n        return r\n      }\n\n      def bleU3(input: MSZ[B], context: Context): U3 = {\n        val offset = context.offset\n        if (offset + 3 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u3\"0\"\n        }\n        var r = u3\"0\"\n        var mask = u3\"1\"\n        for (i <- 0 until 2) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u3\"1\"\n        }\n        if (input(offset + 2)) {\n          r = r | mask\n        }\n        context.offset = offset + 3\n        return r\n      }\n\n      def bleU4(input: MSZ[B], context: Context): U4 = {\n        val offset = context.offset\n        if (offset + 4 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u4\"0\"\n        }\n        var r = u4\"0\"\n        var mask = u4\"1\"\n        for (i <- 0 until 3) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u4\"1\"\n        }\n        if (input(offset + 3)) {\n          r = r | mask\n        }\n        context.offset = offset + 4\n        return r\n      }\n\n      def bleU5(input: MSZ[B], context: Context): U5 = {\n        val offset = context.offset\n        if (offset + 5 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u5\"0\"\n        }\n        var r = u5\"0\"\n        var mask = u5\"1\"\n        for (i <- 0 until 4) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u5\"1\"\n        }\n        if (input(offset + 4)) {\n          r = r | mask\n        }\n        context.offset = offset + 5\n        return r\n      }\n\n      def bleU6(input: MSZ[B], context: Context): U6 = {\n        val offset = context.offset\n        if (offset + 6 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u6\"0\"\n        }\n        var r = u6\"0\"\n        var mask = u6\"1\"\n        for (i <- 0 until 5) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u6\"1\"\n        }\n        if (input(offset + 5)) {\n          r = r | mask\n        }\n        context.offset = offset + 6\n        return r\n      }\n\n      def bleU7(input: MSZ[B], context: Context): U7 = {\n        val offset = context.offset\n        if (offset + 7 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u7\"0\"\n        }\n        var r = u7\"0\"\n        var mask = u7\"1\"\n        for (i <- 0 until 6) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u7\"1\"\n        }\n        if (input(offset + 6)) {\n          r = r | mask\n        }\n        context.offset = offset + 7\n        return r\n      }\n\n      def beU8S(input: MSZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        leU8S(input, context, result, size)\n      }\n\n      def beS8S(input: MSZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        leS8S(input, context, result, size)\n      }\n\n      def beU16S(input: MSZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU16(input, context)\n        }\n      }\n\n      def beS16S(input: MSZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS16(input, context)\n        }\n      }\n\n      def beU32S(input: MSZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU32(input, context)\n        }\n      }\n\n      def beS32S(input: MSZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS32(input, context)\n        }\n      }\n\n      def beU64S(input: MSZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beU64(input, context)\n        }\n      }\n\n      def beS64S(input: MSZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beS64(input, context)\n        }\n      }\n\n      def beF32S(input: MSZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF32(input, context)\n        }\n      }\n\n      def beF64S(input: MSZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = beF64(input, context)\n        }\n      }\n\n      def leU8S(input: MSZ[B], context: Context, result: MSZ[U8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleU8(input, context)\n        }\n      }\n\n      def leS8S(input: MSZ[B], context: Context, result: MSZ[S8], size: Z): Unit = {\n        if (context.offset + size * 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = bleS8(input, context)\n        }\n      }\n\n      def leU16S(input: MSZ[B], context: Context, result: MSZ[U16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU16(input, context)\n        }\n      }\n\n      def leS16S(input: MSZ[B], context: Context, result: MSZ[S16], size: Z): Unit = {\n        if (context.offset + size * 16 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS16(input, context)\n        }\n      }\n\n      def leU32S(input: MSZ[B], context: Context, result: MSZ[U32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU32(input, context)\n        }\n      }\n\n      def leS32S(input: MSZ[B], context: Context, result: MSZ[S32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS32(input, context)\n        }\n      }\n\n      def leU64S(input: MSZ[B], context: Context, result: MSZ[U64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leU64(input, context)\n        }\n      }\n\n      def leS64S(input: MSZ[B], context: Context, result: MSZ[S64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leS64(input, context)\n        }\n      }\n\n      def leF32S(input: MSZ[B], context: Context, result: MSZ[F32], size: Z): Unit = {\n        if (context.offset + size * 32 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF32(input, context)\n        }\n      }\n\n      def leF64S(input: MSZ[B], context: Context, result: MSZ[F64], size: Z): Unit = {\n        if (context.offset + size * 64 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return\n        }\n        for (i <- 0 until size) {\n          result(i) = leF64(input, context)\n        }\n      }\n\n      def bleU8(input: MSZ[B], context: Context): U8 = {\n        val offset = context.offset\n        if (offset + 8 > input.size) {\n          context.signalError(INCOMPLETE_INPUT)\n        }\n        if (context.hasError) {\n          return u8\"0\"\n        }\n        var r = u8\"0\"\n        var mask = u8\"1\"\n        for (i <- 0 until 7) {\n          if (input(offset + i)) {\n            r = r | mask\n          }\n          mask = mask << u8\"1\"\n        }\n        if (input(offset + 7)) {\n          r = r | mask\n        }\n        context.offset = offset + 8\n        return r\n      }\n\n      def bleS8(input: MSZ[B], context: Context): S8 = {\n        return conversions.U8.toRawS8(bleU8(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def beU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n      */\n\n      def beU9(i
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f6$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #746                // String nput: MSZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def beU10(input: MSZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def beU11(input: MSZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def beU12(input: MSZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def beU13(input: MSZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def beU14(input: MSZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def beU15(input: MSZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def beU16(input: MSZ[B], context: Context): U16 = {\n        val r = (conversions.U8.toU16(bleU8(input, context)) << u16\"8\") |\n          conversions.U8.toU16(bleU8(input, context))\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def beS16(input: MSZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(beU16(input, context))\n      }\n\n      def beU17(input: MSZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def beU18(input: MSZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def beU19(input: MSZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def beU20(input: MSZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def beU21(input: MSZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def beU22(input: MSZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def beU23(input: MSZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def beU24(input: MSZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def beU25(input: MSZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def beU26(input: MSZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def beU27(input: MSZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def beU28(input: MSZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def beU29(input: MSZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def beU30(input: MSZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def beU31(input: MSZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def beU32(input: MSZ[B], context: Context): U32 = {\n        val r = (conversions.U8.toU32(bleU8(input, context)) << u32\"24\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          conversions.U8.toU32(bleU8(input, context))\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def beS32(input: MSZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(beU32(input, context))\n      }\n\n      def beU33(input: MSZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def beU34(input: MSZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def beU35(input: MSZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def beU36(input: MSZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def beU37(input: MSZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def beU38(input: MSZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def beU39(input: MSZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def beU40(input: MSZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def beU41(input: MSZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def beU42(input: MSZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def beU43(input: MSZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def beU44(input: MSZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def beU45(input: MSZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def beU46(input: MSZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, contex
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f7$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #748                // String t))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def beU47(input: MSZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def beU48(input: MSZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def beU49(input: MSZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def beU50(input: MSZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def beU51(input: MSZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def beU52(input: MSZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def beU53(input: MSZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def beU54(input: MSZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def beU55(input: MSZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def beU56(input: MSZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def beU57(input: MSZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def beU58(input: MSZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def beU59(input: MSZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def beU60(input: MSZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def beU61(input: MSZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def beU62(input: MSZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def beU63(input: MSZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def beU64(input: MSZ[B], context: Context): U64 = {\n        val r = (conversions.U8.toU64(bleU8(input, context)) << u64\"56\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          conversions.U8.toU64(bleU8(input, context))\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def beS64(input: MSZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(beU64(input, context))\n      }\n\n      def beF32(input: MSZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(beU32(input, context))\n      }\n\n      def beF64(input: MSZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(beU64(input, context))\n      }\n\n      // Slang script gen:\n      /*\n      for (i <- 9 to 15) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U16.toU$i(conversions.U8.toU16(bleU8(input, context)))\n              |        r = r | (conversions.U16.toU$i(conversions.U${i - 8}.toU16(bleU${i - 8}(input, context))) << u$i\"8\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 17 to 24) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 16}.toU32(bleU${i - 16}(input, context))) << u$i\"16\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 25 to 31) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context)))\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U32.toU$i(conversions.U8.toU32(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U32.toU$i(conversions.U${i - 24}.toU32(bleU${i - 24}(input, context))) << u$i\"24\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 33 to 40) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 32}.toU64(bleU${i - 32}(input, context))) << u$i\"32\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 41 to 48) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 40}.toU64(bleU${i - 40}(input, context))) << u$i\"40\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        ret
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f8$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #750                // String urn r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 49 to 56) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 48}.toU64(bleU${i - 48}(input, context))) << u$i\"48\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n      for (i <- 57 to 63) {\n        println(\n          st\"\"\"      def leU$i(input: MSZ[B], context: Context): U$i = {\n              |        var r = u$i\"0\"\n              |        r = r | conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context)))\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"8\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"16\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"24\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"32\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"40\")\n              |        r = r | (conversions.U64.toU$i(conversions.U8.toU64(bleU8(input, context))) << u$i\"48\")\n              |        r = r | (conversions.U64.toU$i(conversions.U${i - 56}.toU64(bleU${i - 56}(input, context))) << u$i\"56\")\n              |        if (context.hasError) {\n              |          return u$i\"0\"\n              |        }\n              |        return r\n              |      }\n              |\"\"\".render\n        )\n      }\n\n       */\n\n      def leU9(input: MSZ[B], context: Context): U9 = {\n        var r = u9\"0\"\n        r = r | conversions.U16.toU9(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU9(conversions.U1.toU16(bleU1(input, context))) << u9\"8\")\n        if (context.hasError) {\n          return u9\"0\"\n        }\n        return r\n      }\n\n      def leU10(input: MSZ[B], context: Context): U10 = {\n        var r = u10\"0\"\n        r = r | conversions.U16.toU10(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU10(conversions.U2.toU16(bleU2(input, context))) << u10\"8\")\n        if (context.hasError) {\n          return u10\"0\"\n        }\n        return r\n      }\n\n      def leU11(input: MSZ[B], context: Context): U11 = {\n        var r = u11\"0\"\n        r = r | conversions.U16.toU11(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU11(conversions.U3.toU16(bleU3(input, context))) << u11\"8\")\n        if (context.hasError) {\n          return u11\"0\"\n        }\n        return r\n      }\n\n      def leU12(input: MSZ[B], context: Context): U12 = {\n        var r = u12\"0\"\n        r = r | conversions.U16.toU12(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU12(conversions.U4.toU16(bleU4(input, context))) << u12\"8\")\n        if (context.hasError) {\n          return u12\"0\"\n        }\n        return r\n      }\n\n      def leU13(input: MSZ[B], context: Context): U13 = {\n        var r = u13\"0\"\n        r = r | conversions.U16.toU13(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU13(conversions.U5.toU16(bleU5(input, context))) << u13\"8\")\n        if (context.hasError) {\n          return u13\"0\"\n        }\n        return r\n      }\n\n      def leU14(input: MSZ[B], context: Context): U14 = {\n        var r = u14\"0\"\n        r = r | conversions.U16.toU14(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU14(conversions.U6.toU16(bleU6(input, context))) << u14\"8\")\n        if (context.hasError) {\n          return u14\"0\"\n        }\n        return r\n      }\n\n      def leU15(input: MSZ[B], context: Context): U15 = {\n        var r = u15\"0\"\n        r = r | conversions.U16.toU15(conversions.U8.toU16(bleU8(input, context)))\n        r = r | (conversions.U16.toU15(conversions.U7.toU16(bleU7(input, context))) << u15\"8\")\n        if (context.hasError) {\n          return u15\"0\"\n        }\n        return r\n      }\n\n      def leU16(input: MSZ[B], context: Context): U16 = {\n        val r = conversions.U8.toU16(bleU8(input, context)) |\n          (conversions.U8.toU16(bleU8(input, context)) << u16\"8\")\n        if (context.hasError) {\n          return u16\"0\"\n        }\n        return r\n      }\n\n      def leS16(input: MSZ[B], context: Context): S16 = {\n        return conversions.U16.toRawS16(leU16(input, context))\n      }\n\n      def leU17(input: MSZ[B], context: Context): U17 = {\n        var r = u17\"0\"\n        r = r | conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU17(conversions.U8.toU32(bleU8(input, context))) << u17\"8\")\n        r = r | (conversions.U32.toU17(conversions.U1.toU32(bleU1(input, context))) << u17\"16\")\n        if (context.hasError) {\n          return u17\"0\"\n        }\n        return r\n      }\n\n      def leU18(input: MSZ[B], context: Context): U18 = {\n        var r = u18\"0\"\n        r = r | conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU18(conversions.U8.toU32(bleU8(input, context))) << u18\"8\")\n        r = r | (conversions.U32.toU18(conversions.U2.toU32(bleU2(input, context))) << u18\"16\")\n        if (context.hasError) {\n          return u18\"0\"\n        }\n        return r\n      }\n\n      def leU19(input: MSZ[B], context: Context): U19 = {\n        var r = u19\"0\"\n        r = r | conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU19(conversions.U8.toU32(bleU8(input, context))) << u19\"8\")\n        r = r | (conversions.U32.toU19(conversions.U3.toU32(bleU3(input, context))) << u19\"16\")\n        if (context.hasError) {\n          return u19\"0\"\n        }\n        return r\n      }\n\n      def leU20(input: MSZ[B], context: Context): U20 = {\n        var r = u20\"0\"\n        r = r | conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU20(conversions.U8.toU32(bleU8(input, context))) << u20\"8\")\n        r = r | (conversions.U32.toU20(conversions.U4.toU32(bleU4(input, context))) << u20\"16\")\n        if (context.hasError) {\n          return u20\"0\"\n        }\n        return r\n      }\n\n      def leU21(input: MSZ[B], context: Context): U21 = {\n        var r = u21\"0\"\n        r = r | conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU21(conversions.U8.toU32(bleU8(input, context))) << u21\"8\")\n        r = r | (conversions.U32.toU21(conversions.U5.toU32(bleU5(input, context))) << u21\"16\")\n        if (context.hasError) {\n          return u21\"0\"\n        }\n        return r\n      }\n\n      def leU22(input: MSZ[B], context: Context): U22 = {\n        var r = u22\"0\"\n        r = r | conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU22(conversions.U8.toU32(bleU8(input, context))) << u22\"8\")\n        r = r | (conversions.U32.toU22(conversions.U6.toU32(bleU6(input, context))) << u22\"16\")\n        if (context.hasError) {\n          return u22\"0\"\n        }\n        return r\n      }\n\n      def leU23(input: MSZ[B], context: Context): U23 = {\n        var r = u23\"0\"\n        r = r | conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU23(conversions.U8.toU32(bleU8(input, context))) << u23\"8\")\n        r = r | (conversions.U32.toU23(conversions.U7.toU32(bleU7(input, context))) << u23\"16\")\n        if (context.hasError) {\n          return u23\"0\"\n        }\n        return r\n      }\n\n      def leU24(input: MSZ[B], context: Context): U24 = {\n        var r = u24\"0\"\n        r = r | conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"8\")\n        r = r | (conversions.U32.toU24(conversions.U8.toU32(bleU8(input, context))) << u24\"16\")\n        if (context.hasError) {\n          return u24\"0\"\n        }\n        return r\n      }\n\n      def leU25(input: MSZ[B], context: Context): U25 = {\n        var r = u25\"0\"\n        r = r | conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"8\")\n        r = r | (conversions.U32.toU25(conversions.U8.toU32(bleU8(input, context))) << u25\"16\")\n        r = r | (conversions.U32.toU25(conversions.U1.toU32(bleU1(input, context))) << u25\"24\")\n        if (context.hasError) {\n          return u25\"0\"\n        }\n        return r\n      }\n\n      def leU26(input: MSZ[B], context: Context): U26 = {\n        var r = u26\"0\"\n        r = r | conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"8\")\n        r = r | (conversions.U32.toU26(conversions.U8.toU32(bleU8(input, context))) << u26\"16\")\n        r = r | (conversions.U32.toU26(conversions.U2.toU32(bleU2(input, context))) << u26\"24\")\n        if (context.hasError) {\n          return u26\"0\"\n        }\n        return r\n      }\n\n      def leU27(input: MSZ[B], context: Context): U27 = {\n        var r = u27\"0\"\n        r = r | conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"8\")\n        r = r | (conversions.U32.toU27(conversions.U8.toU32(bleU8(input, context))) << u27\"16\")\n        r = r | (conversions.U32.toU27(conversions.U3.toU32(bleU3(input, context))) << u27\"24\")\n        if (context.hasError) {\n          return u27\"0\"\n        }\n        return r\n      }\n\n      def leU28(input: MSZ[B], context: Context): U28 = {\n        var r = u28\"0\"\n        r = r | conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"8\")\n        r = r | (conversions.U32.toU28(conversions.U8.toU32(bleU8(input, context))) << u28\"16\")\n        r = r | (conversions.U32.toU28(conversions.U4.toU32(bleU4(input, context))) << u28\"24\")\n        if (context.hasError) {\n          return u28\"0\"\n        }\n        return r\n      }\n\n      def leU29(input: MSZ[B], context: Context): U29 = {\n        var r = u29\"0\"\n        r = r | conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"8\")\n        r = r | (conversions.U32.toU29(conversions.U8.toU32(bleU8(input, context))) << u29\"16\")\n        r = r | (conversions.U32.toU29(conversions.U5.toU32(bleU5(input, context))) << u29\"24\")\n        if (context.hasError) {\n          return u29\"0\"\n        }\n        return r\n      }\n\n      def leU30(input: MSZ[B], context: Context): U30 = {\n        var r = u30\"0\"\n        r = r | conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"8\")\n        r = r | (conversions.U32.toU30(conversions.U8.toU32(bleU8(input, context))) << u30\"16\")\n        r = r | (conversions.U32.toU30(conversions.U6.toU32(bleU6(input, context))) << u30\"24\")\n        if (context.hasError) {\n          return u30\"0\"\n        }\n        return r\n      }\n\n      def leU31(input: MSZ[B], context: Context): U31 = {\n        var r = u31\"0\"\n        r = r | conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context)))\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"8\")\n        r = r | (conversions.U32.toU31(conversions.U8.toU32(bleU8(input, context))) << u31\"16\")\n        r = r | (conversions.U32.toU31(conversions.U7.toU32(bleU7(input, context))) << u31\"24\")\n        if (context.hasError) {\n          return u31\"0\"\n        }\n        return r\n      }\n\n      def leU32(input: MSZ[B], context: Context): U32 = {\n        val r = conversions.U8.toU32(bleU8(input, context)) |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"8\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"16\") |\n          (conversions.U8.toU32(bleU8(input, context)) << u32\"24\")\n        if (context.hasError) {\n          return u32\"0\"\n        }\n        return r\n      }\n\n      def leS32(input: MSZ[B], context: Context): S32 = {\n        return conversions.U32.toRawS32(leU32(input, context))\n      }\n\n      def leU33(input: MSZ[B], context: Context): U33 = {\n        var r = u33\"0\"\n        r = r | conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"8\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"16\")\n        r = r | (conversions.U64.toU33(conversions.U8.toU64(bleU8(input, context))) << u33\"24\")\n        r = r | (conversions.U64.toU33(conversions.U1.toU64(bleU1(input, context))) << u33\"32\")\n        if (context.hasError) {\n          return u33\"0\"\n        }\n        return r\n      }\n\n      def leU34(input: MSZ[B], context: Context): U34 = {\n        var r = u34\"0\"\n        r = r | conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"8\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"16\")\n        r = r | (conversions.U64.toU34(conversions.U8.toU64(bleU8(input, context))) << u34\"24\")\n        r = r | (conversions.U64.toU34(conversions.U2.toU64(bleU2(input, context))) << u34\"32\")\n        if (context.hasError) {\n          return u34\"0\"\n        }\n        return r\n      }\n\n      def leU35(input: MSZ[B], context: Context): U35 = {\n        var r = u35\"0\"\n        r = r | conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"8\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"16\")\n        r = r | (conversions.U64.toU35(conversions.U8.toU64(bleU8(input, context))) << u35\"24\")\n        r = r | (conversions.U64.toU35(conversions.U3.toU64(bleU3(input, context))) << u35\"32\")\n        if (context.hasError) {\n          return u35\"0\"\n        }\n        return r\n      }\n\n      def leU36(input: MSZ[B], context: Context): U36 = {\n        var r = u36\"0\"\n        r = r | conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"8\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"16\")\n        r = r | (conversions.U64.toU36(conversions.U8.toU64(bleU8(input, context))) << u36\"24\")\n        r = r | (conversions.U64.toU36(conversions.U4.toU64(bleU4(input, context))) << u36\"32\")\n        if (context.hasError) {\n          return u36\"0\"\n        }\n        return r\n      }\n\n      def leU37(input: MSZ[B], context: Context): U37 = {\n        var r = u37\"0\"\n        r = r | conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"8\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"16\")\n        r = r | (conversions.U64.toU37(conversions.U8.toU64(bleU8(input, context))) << u37\"24\")\n        r = r | (conversions.U64.toU37(conversions.U5.toU64(bleU5(input, context))) << u37\"32\")\n        if (context.hasError) {\n          return u37\"0\"\n        }\n        return r\n      }\n\n      def leU38(input: MSZ[B], context: Context): U38 = {\n        var r = u38\"0\"\n        r = r | conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"8\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"16\")\n        r = r | (conversions.U64.toU38(conversions.U8.toU64(bleU8(input, context))) << u38\"24\")\n        r = r | (conversions.U64.toU38(conversions.U6.toU64(bleU6(input, context))) << u38\"32\")\n        if (context.hasError) {\n          return u38\"0\"\n        }\n        return r\n      }\n\n      def leU39(input: MSZ[B], context: Context): U39 = {\n        var r = u39\"0\"\n        r = r | conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"8\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"16\")\n        r = r | (conversions.U64.toU39(conversions.U8.toU64(bleU8(input, context))) << u39\"24\")\n        r = r | (conversions.U64.toU39(conversions.U7.toU64(bleU7(input, context))) << u39\"32\")\n        if (context.hasError) {\n          return u39\"0\"\n        }\n        return r\n      }\n\n      def leU40(input: MSZ[B], context: Context): U40 = {\n        var r = u40\"0\"\n        r = r | conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"8\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"16\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"24\")\n        r = r | (conversions.U64.toU40(conversions.U8.toU64(bleU8(input, context))) << u40\"32\")\n        if (context.hasError) {\n          return u40\"0\"\n        }\n        return r\n      }\n\n      def leU41(input: MSZ[B], context: Context): U41 = {\n        var r = u41\"0\"\n        r = r | conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"8\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"16\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"24\")\n        r = r | (conversions.U64.toU41(conversions.U8.toU64(bleU8(input, context))) << u41\"32\")\n        r = r | (conversions.U64.toU41(conversions.U1.toU64(bleU1(input, context))) << u41\"40\")\n        if (context.hasError) {\n          return u41\"0\"\n        }\n        return r\n      }\n\n      def leU42(input: MSZ[B], context: Context): U42 = {\n        var r = u42\"0\"\n        r = r | conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"8\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"16\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"24\")\n        r = r | (conversions.U64.toU42(conversions.U8.toU64(bleU8(input, context))) << u42\"32\")\n        r = r | (conversions.U64.toU42(conversions.U2.toU64(bleU2(input, context))) << u42\"40\")\n        if (context.hasError) {\n          return u42\"0\"\n        }\n        return r\n      }\n\n      def leU43(input: MSZ[B], context: Context): U43 = {\n        var r = u43\"0\"\n        r = r | conversions.U64.toU43(conversions.U8.toU64(bleU8(inp
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f9$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #752                // String ut, context)))\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"8\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"16\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"24\")\n        r = r | (conversions.U64.toU43(conversions.U8.toU64(bleU8(input, context))) << u43\"32\")\n        r = r | (conversions.U64.toU43(conversions.U3.toU64(bleU3(input, context))) << u43\"40\")\n        if (context.hasError) {\n          return u43\"0\"\n        }\n        return r\n      }\n\n      def leU44(input: MSZ[B], context: Context): U44 = {\n        var r = u44\"0\"\n        r = r | conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"8\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"16\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"24\")\n        r = r | (conversions.U64.toU44(conversions.U8.toU64(bleU8(input, context))) << u44\"32\")\n        r = r | (conversions.U64.toU44(conversions.U4.toU64(bleU4(input, context))) << u44\"40\")\n        if (context.hasError) {\n          return u44\"0\"\n        }\n        return r\n      }\n\n      def leU45(input: MSZ[B], context: Context): U45 = {\n        var r = u45\"0\"\n        r = r | conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"8\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"16\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"24\")\n        r = r | (conversions.U64.toU45(conversions.U8.toU64(bleU8(input, context))) << u45\"32\")\n        r = r | (conversions.U64.toU45(conversions.U5.toU64(bleU5(input, context))) << u45\"40\")\n        if (context.hasError) {\n          return u45\"0\"\n        }\n        return r\n      }\n\n      def leU46(input: MSZ[B], context: Context): U46 = {\n        var r = u46\"0\"\n        r = r | conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"8\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"16\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"24\")\n        r = r | (conversions.U64.toU46(conversions.U8.toU64(bleU8(input, context))) << u46\"32\")\n        r = r | (conversions.U64.toU46(conversions.U6.toU64(bleU6(input, context))) << u46\"40\")\n        if (context.hasError) {\n          return u46\"0\"\n        }\n        return r\n      }\n\n      def leU47(input: MSZ[B], context: Context): U47 = {\n        var r = u47\"0\"\n        r = r | conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"8\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"16\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"24\")\n        r = r | (conversions.U64.toU47(conversions.U8.toU64(bleU8(input, context))) << u47\"32\")\n        r = r | (conversions.U64.toU47(conversions.U7.toU64(bleU7(input, context))) << u47\"40\")\n        if (context.hasError) {\n          return u47\"0\"\n        }\n        return r\n      }\n\n      def leU48(input: MSZ[B], context: Context): U48 = {\n        var r = u48\"0\"\n        r = r | conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"8\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"16\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"24\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"32\")\n        r = r | (conversions.U64.toU48(conversions.U8.toU64(bleU8(input, context))) << u48\"40\")\n        if (context.hasError) {\n          return u48\"0\"\n        }\n        return r\n      }\n\n      def leU49(input: MSZ[B], context: Context): U49 = {\n        var r = u49\"0\"\n        r = r | conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"8\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"16\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"24\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"32\")\n        r = r | (conversions.U64.toU49(conversions.U8.toU64(bleU8(input, context))) << u49\"40\")\n        r = r | (conversions.U64.toU49(conversions.U1.toU64(bleU1(input, context))) << u49\"48\")\n        if (context.hasError) {\n          return u49\"0\"\n        }\n        return r\n      }\n\n      def leU50(input: MSZ[B], context: Context): U50 = {\n        var r = u50\"0\"\n        r = r | conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"8\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"16\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"24\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"32\")\n        r = r | (conversions.U64.toU50(conversions.U8.toU64(bleU8(input, context))) << u50\"40\")\n        r = r | (conversions.U64.toU50(conversions.U2.toU64(bleU2(input, context))) << u50\"48\")\n        if (context.hasError) {\n          return u50\"0\"\n        }\n        return r\n      }\n\n      def leU51(input: MSZ[B], context: Context): U51 = {\n        var r = u51\"0\"\n        r = r | conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"8\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"16\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"24\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"32\")\n        r = r | (conversions.U64.toU51(conversions.U8.toU64(bleU8(input, context))) << u51\"40\")\n        r = r | (conversions.U64.toU51(conversions.U3.toU64(bleU3(input, context))) << u51\"48\")\n        if (context.hasError) {\n          return u51\"0\"\n        }\n        return r\n      }\n\n      def leU52(input: MSZ[B], context: Context): U52 = {\n        var r = u52\"0\"\n        r = r | conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"8\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"16\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"24\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"32\")\n        r = r | (conversions.U64.toU52(conversions.U8.toU64(bleU8(input, context))) << u52\"40\")\n        r = r | (conversions.U64.toU52(conversions.U4.toU64(bleU4(input, context))) << u52\"48\")\n        if (context.hasError) {\n          return u52\"0\"\n        }\n        return r\n      }\n\n      def leU53(input: MSZ[B], context: Context): U53 = {\n        var r = u53\"0\"\n        r = r | conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"8\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"16\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"24\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"32\")\n        r = r | (conversions.U64.toU53(conversions.U8.toU64(bleU8(input, context))) << u53\"40\")\n        r = r | (conversions.U64.toU53(conversions.U5.toU64(bleU5(input, context))) << u53\"48\")\n        if (context.hasError) {\n          return u53\"0\"\n        }\n        return r\n      }\n\n      def leU54(input: MSZ[B], context: Context): U54 = {\n        var r = u54\"0\"\n        r = r | conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"8\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"16\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"24\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"32\")\n        r = r | (conversions.U64.toU54(conversions.U8.toU64(bleU8(input, context))) << u54\"40\")\n        r = r | (conversions.U64.toU54(conversions.U6.toU64(bleU6(input, context))) << u54\"48\")\n        if (context.hasError) {\n          return u54\"0\"\n        }\n        return r\n      }\n\n      def leU55(input: MSZ[B], context: Context): U55 = {\n        var r = u55\"0\"\n        r = r | conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"8\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"16\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"24\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"32\")\n        r = r | (conversions.U64.toU55(conversions.U8.toU64(bleU8(input, context))) << u55\"40\")\n        r = r | (conversions.U64.toU55(conversions.U7.toU64(bleU7(input, context))) << u55\"48\")\n        if (context.hasError) {\n          return u55\"0\"\n        }\n        return r\n      }\n\n      def leU56(input: MSZ[B], context: Context): U56 = {\n        var r = u56\"0\"\n        r = r | conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"8\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"16\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"24\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"32\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"40\")\n        r = r | (conversions.U64.toU56(conversions.U8.toU64(bleU8(input, context))) << u56\"48\")\n        if (context.hasError) {\n          return u56\"0\"\n        }\n        return r\n      }\n\n      def leU57(input: MSZ[B], context: Context): U57 = {\n        var r = u57\"0\"\n        r = r | conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"8\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"16\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"24\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"32\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"40\")\n        r = r | (conversions.U64.toU57(conversions.U8.toU64(bleU8(input, context))) << u57\"48\")\n        r = r | (conversions.U64.toU57(conversions.U1.toU64(bleU1(input, context))) << u57\"56\")\n        if (context.hasError) {\n          return u57\"0\"\n        }\n        return r\n      }\n\n      def leU58(input: MSZ[B], context: Context): U58 = {\n        var r = u58\"0\"\n        r = r | conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"8\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"16\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"24\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"32\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"40\")\n        r = r | (conversions.U64.toU58(conversions.U8.toU64(bleU8(input, context))) << u58\"48\")\n        r = r | (conversions.U64.toU58(conversions.U2.toU64(bleU2(input, context))) << u58\"56\")\n        if (context.hasError) {\n          return u58\"0\"\n        }\n        return r\n      }\n\n      def leU59(input: MSZ[B], context: Context): U59 = {\n        var r = u59\"0\"\n        r = r | conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"8\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"16\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"24\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"32\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"40\")\n        r = r | (conversions.U64.toU59(conversions.U8.toU64(bleU8(input, context))) << u59\"48\")\n        r = r | (conversions.U64.toU59(conversions.U3.toU64(bleU3(input, context))) << u59\"56\")\n        if (context.hasError) {\n          return u59\"0\"\n        }\n        return r\n      }\n\n      def leU60(input: MSZ[B], context: Context): U60 = {\n        var r = u60\"0\"\n        r = r | conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"8\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"16\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"24\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"32\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"40\")\n        r = r | (conversions.U64.toU60(conversions.U8.toU64(bleU8(input, context))) << u60\"48\")\n        r = r | (conversions.U64.toU60(conversions.U4.toU64(bleU4(input, context))) << u60\"56\")\n        if (context.hasError) {\n          return u60\"0\"\n        }\n        return r\n      }\n\n      def leU61(input: MSZ[B], context: Context): U61 = {\n        var r = u61\"0\"\n        r = r | conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"8\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"16\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"24\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"32\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"40\")\n        r = r | (conversions.U64.toU61(conversions.U8.toU64(bleU8(input, context))) << u61\"48\")\n        r = r | (conversions.U64.toU61(conversions.U5.toU64(bleU5(input, context))) << u61\"56\")\n        if (context.hasError) {\n          return u61\"0\"\n        }\n        return r\n      }\n\n      def leU62(input: MSZ[B], context: Context): U62 = {\n        var r = u62\"0\"\n        r = r | conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"8\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"16\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"24\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"32\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"40\")\n        r = r | (conversions.U64.toU62(conversions.U8.toU64(bleU8(input, context))) << u62\"48\")\n        r = r | (conversions.U64.toU62(conversions.U6.toU64(bleU6(input, context))) << u62\"56\")\n        if (context.hasError) {\n          return u62\"0\"\n        }\n        return r\n      }\n\n      def leU63(input: MSZ[B], context: Context): U63 = {\n        var r = u63\"0\"\n        r = r | conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context)))\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"8\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"16\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"24\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"32\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"40\")\n        r = r | (conversions.U64.toU63(conversions.U8.toU64(bleU8(input, context))) << u63\"48\")\n        r = r | (conversions.U64.toU63(conversions.U7.toU64(bleU7(input, context))) << u63\"56\")\n        if (context.hasError) {\n          return u63\"0\"\n        }\n        return r\n      }\n\n      def leU64(input: MSZ[B], context: Context): U64 = {\n        val r = conversions.U8.toU64(bleU8(input, context)) |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"8\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"16\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"24\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"32\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"40\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"48\") |\n          (conversions.U8.toU64(bleU8(input, context)) << u64\"56\")\n        if (context.hasError) {\n          return u64\"0\"\n        }\n        return r\n      }\n\n      def leS64(input: MSZ[B], context: Context): S64 = {\n        return conversions.U64.toRawS64(leU64(input, context))\n      }\n\n      def leF32(input: MSZ[B], context: Context): F32 = {\n        return conversions.U32.toRawF32(leU32(input, context))\n      }\n\n      def leF64(input: MSZ[B], context: Context): F64 = {\n        return conversions.U64.toRawF64(leU64(input, context))\n      }\n    }  }\n\n  object Writer {\n    val INSUFFICIENT_BUFFER_SIZE: Z = 1\n\n    def resultIS(output: ISZ[B], context: Context): ISZ[B] = {\n      return ops.ISZOps(output).slice(0, context.offset)\n    }\n\n    def resultMS(output: MSZ[B], context: Context): MSZ[B] = {\n      return ops.MSZOps(output).slice(0, context.offset)\n    }\n\n    def bleB(output: MSZ[B], context: Context, v: B): Unit = {\n      val offset = context.offset\n      if (offset + 1 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      output(offset) = v\n      context.offset = offset + 1\n    }\n\n    def beBS(output: MSZ[B], context: Context, v: MSZ[B]): Unit = {\n      bleRaw(output, context, v, v.size)\n    }\n\n    def leBS(output: MSZ[B], context: Context, v: MSZ[B]): Unit = {\n      bleRaw(output, context, v, v.size)\n    }\n\n    def bleRaw(output: MSZ[B], context: Context, v: MSZ[B], size: Z): Unit = {\n      val offset = context.offset\n      if (offset + size > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleB(output, context, v(i))\n      }\n    }\n\n    def bleU1(output: MSZ[B], context: Context, v: U1): Unit = {\n      val offset = context.offset\n      if (offset + 1 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      output(offset) = v == u1\"1\"\n      contex
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f10$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #754                // String t.offset = offset + 1\n    }\n\n    def bleU2(output: MSZ[B], context: Context, v: U2): Unit = {\n      val offset = context.offset\n      if (offset + 2 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u2\"1\"\n      for (i <- 0 until 1) {\n        if ((v & mask) != u2\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u2\"1\"\n      }\n      if ((v & mask) != u2\"0\") {\n        output(offset + 1) = T\n      } else {\n        output(offset + 1) = F\n      }\n      context.offset = offset + 2\n    }\n\n    def bleU3(output: MSZ[B], context: Context, v: U3): Unit = {\n      val offset = context.offset\n      if (offset + 3 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u3\"1\"\n      for (i <- 0 until 2) {\n        if ((v & mask) != u3\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u3\"1\"\n      }\n      if ((v & mask) != u3\"0\") {\n        output(offset + 2) = T\n      } else {\n        output(offset + 2) = F\n      }\n      context.offset = offset + 3\n    }\n\n    def bleU4(output: MSZ[B], context: Context, v: U4): Unit = {\n      val offset = context.offset\n      if (offset + 4 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u4\"1\"\n      for (i <- 0 until 3) {\n        if ((v & mask) != u4\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u4\"1\"\n      }\n      if ((v & mask) != u4\"0\") {\n        output(offset + 3) = T\n      } else {\n        output(offset + 3) = F\n      }\n      context.offset = offset + 4\n    }\n\n    def bleU5(output: MSZ[B], context: Context, v: U5): Unit = {\n      val offset = context.offset\n      if (offset + 5 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u5\"1\"\n      for (i <- 0 until 4) {\n        if ((v & mask) != u5\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u5\"1\"\n      }\n      if ((v & mask) != u5\"0\") {\n        output(offset + 4) = T\n      } else {\n        output(offset + 4) = F\n      }\n      context.offset = offset + 5\n    }\n\n    def bleU6(output: MSZ[B], context: Context, v: U6): Unit = {\n      val offset = context.offset\n      if (offset + 6 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u6\"1\"\n      for (i <- 0 until 5) {\n        if ((v & mask) != u6\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u6\"1\"\n      }\n      if ((v & mask) != u6\"0\") {\n        output(offset + 5) = T\n      } else {\n        output(offset + 5) = F\n      }\n      context.offset = offset + 6\n    }\n\n    def bleU7(output: MSZ[B], context: Context, v: U7): Unit = {\n      val offset = context.offset\n      if (offset + 7 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u7\"1\"\n      for (i <- 0 until 6) {\n        if ((v & mask) != u7\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u7\"1\"\n      }\n      if ((v & mask) != u7\"0\") {\n        output(offset + 6) = T\n      } else {\n        output(offset + 6) = F\n      }\n      context.offset = offset + 7\n    }\n\n    def bleU8(output: MSZ[B], context: Context, v: U8): Unit = {\n      val offset = context.offset\n      if (offset + 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      var mask = u8\"1\"\n      for (i <- 0 until 7) {\n        if ((v & mask) != u8\"0\") {\n          output(offset + i) = T\n        } else {\n          output(offset + i) = F\n        }\n        mask = mask << u8\"1\"\n      }\n      if ((v & mask) != u8\"0\") {\n        output(offset + 7) = T\n      } else {\n        output(offset + 7) = F\n      }\n      context.offset = offset + 8\n    }\n\n    def bleS8(output: MSZ[B], context: Context, v: S8): Unit = {\n      bleU8(output, context, conversions.S8.toRawU8(v))\n    }\n\n    def beU8S(output: MSZ[B], context: Context, v: MSZ[U8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleU8(output, context, v(i))\n      }\n    }\n\n    def beS8S(output: MSZ[B], context: Context, v: MSZ[S8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleS8(output, context, v(i))\n      }\n    }\n\n    def beU16S(output: MSZ[B], context: Context, v: MSZ[U16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU16(output, context, v(i))\n      }\n    }\n\n    def beS16S(output: MSZ[B], context: Context, v: MSZ[S16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS16(output, context, v(i))\n      }\n    }\n\n    def beU32S(output: MSZ[B], context: Context, v: MSZ[U32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU32(output, context, v(i))\n      }\n    }\n\n    def beS32S(output: MSZ[B], context: Context, v: MSZ[S32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS32(output, context, v(i))\n      }\n    }\n\n    def beU64S(output: MSZ[B], context: Context, v: MSZ[U64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beU64(output, context, v(i))\n      }\n    }\n\n    def beS64S(output: MSZ[B], context: Context, v: MSZ[S64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beS64(output, context, v(i))\n      }\n    }\n\n    def beF32S(output: MSZ[B], context: Context, v: MSZ[F32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beF32(output, context, v(i))\n      }\n    }\n\n    def beF64S(output: MSZ[B], context: Context, v: MSZ[F64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        beF64(output, context, v(i))\n      }\n    }\n\n    def leU8S(output: MSZ[B], context: Context, v: MSZ[U8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleU8(output, context, v(i))\n      }\n    }\n\n    def leS8S(output: MSZ[B], context: Context, v: MSZ[S8]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 8 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        bleS8(output, context, v(i))\n      }\n    }\n\n    def leU16S(output: MSZ[B], context: Context, v: MSZ[U16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU16(output, context, v(i))\n      }\n    }\n\n    def leS16S(output: MSZ[B], context: Context, v: MSZ[S16]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 16 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS16(output, context, v(i))\n      }\n    }\n\n    def leU32S(output: MSZ[B], context: Context, v: MSZ[U32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU32(output, context, v(i))\n      }\n    }\n\n    def leS32S(output: MSZ[B], context: Context, v: MSZ[S32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS32(output, context, v(i))\n      }\n    }\n\n    def leU64S(output: MSZ[B], context: Context, v: MSZ[U64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leU64(output, context, v(i))\n      }\n    }\n\n    def leS64S(output: MSZ[B], context: Context, v: MSZ[S64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leS64(output, context, v(i))\n      }\n    }\n\n    def leF32S(output: MSZ[B], context: Context, v: MSZ[F32]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 32 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leF32(output, context, v(i))\n      }\n    }\n\n    def leF64S(output: MSZ[B], context: Context, v: MSZ[F64]): Unit = {\n      val size = v.size\n      val offset = context.offset\n      if (offset + size * 64 > output.size) {\n        context.signalError(INSUFFICIENT_BUFFER_SIZE)\n      }\n      if (context.hasError) {\n        return\n      }\n      for (i <- 0 until size) {\n        leF64(output, context, v(i))\n      }\n    }\n\n    // Slang script gen:\n    /*\n    for (i <- 9 to 15) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 8}(output, context, conversions.U8.toU${i - 16}(conversions.U16.toU8(conversions.U$i.toU16(v >> u$i\"8\"))))\n            |  bleU8(output, context, conversions.U16.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 17 to 24) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 16}(output, context, conversions.U8.toU${i - 16}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"16\"))))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 25 to 31) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 24}(output, context, conversions.U8.toU${i - 24}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"24\"))))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 33 to 40) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 32}(output, context, conversions.U8.toU${i - 32}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"32\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 41 to 48) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 40}(output, context, conversions.U8.toU${i - 40}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"40\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 49 to 56) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 48}(output, context, conversions.U8.toU${i - 48}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"48\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 57 to 63) {\n      println(\n        st\"\"\"def beU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU${i - 56}(output, context, conversions.U8.toU${i - 56}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"56\"))))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"48\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |}\n            |\"\"\".render)\n    }\n    */\n    def beU9(output: MSZ[B], context: Context, v: U9): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U16.toU8(conversions.U9.toU16(v >> u9\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U9.toU16(v & u9\"0xFF\")))\n    }\n\n    def beU10(output: MSZ[B], context: Context, v: U10): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U16.toU8(conversions.U10.toU16(v >> u10\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U10.toU16(v & u10\"0xFF\")))\n    }\n\n    def beU11(output: MSZ[B], context: Context, v: U11): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U16.toU8(conversions.U11.toU16(v >> u11\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U11.toU16(v & u11\"0xFF\")))\n    }\n\n    def beU12(output: MSZ[B], context: Context, v: U12): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U16.toU8(conversions.U12.toU16(v >> u12\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U12.toU16(v & u12\"0xFF\")))\n    }\n\n    def beU13(output: MSZ[B], context: Context, v: U13): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U16.toU8(conversions.U13.toU16(v >> u13\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U13.toU16(v & u13\"0xFF\")))\n    }\n\n    def beU14(output: MSZ[B], context: Context, v: U14): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U16.toU8(conversions.U14.toU16(v >> u14\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U14.toU16(v & u14\"0xFF\")))\n    }\n\n    def beU15(output: MSZ[B], context: Context, v: U15): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U16.toU8(conversions.U15.toU16(v >> u15\"8\"))))\n      bleU8(output, context, conversions.U16.toU8(conversions.U15.toU16(v & u15\"0xFF\")))\n    }\n\n    def beU16(output: MSZ[B], context: Context, v: U16): Unit = {\n      bleU8(output, context, conversions.U16.toU8(v >> u16\"8\"))\n      bleU8(output, context, conversions.U16.toU8(v & u16\"0xFF\"))\n    }\n\n    def beS16(output: MSZ[B], context: Context, v: S16): Unit = {\n      beU16(output, context, conversions.S16.toRawU16(v))\n    }\n\n    def beU17(output: MSZ[B], context: Context, v: U17): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U17.toU32(v >> u17\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32((v >> u17\"8\") & u17\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32(v & u17\"0xFF\")))\n    }\n\n    def beU18(output: MSZ[B], context: Context, v: U18): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U18.toU32(v >> u18\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f11$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #756                // String 32((v >> u18\"8\") & u18\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32(v & u18\"0xFF\")))\n    }\n\n    def beU19(output: MSZ[B], context: Context, v: U19): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U19.toU32(v >> u19\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32((v >> u19\"8\") & u19\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32(v & u19\"0xFF\")))\n    }\n\n    def beU20(output: MSZ[B], context: Context, v: U20): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U20.toU32(v >> u20\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32((v >> u20\"8\") & u20\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32(v & u20\"0xFF\")))\n    }\n\n    def beU21(output: MSZ[B], context: Context, v: U21): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U21.toU32(v >> u21\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32((v >> u21\"8\") & u21\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32(v & u21\"0xFF\")))\n    }\n\n    def beU22(output: MSZ[B], context: Context, v: U22): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U22.toU32(v >> u22\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32((v >> u22\"8\") & u22\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32(v & u22\"0xFF\")))\n    }\n\n    def beU23(output: MSZ[B], context: Context, v: U23): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U23.toU32(v >> u23\"16\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32((v >> u23\"8\") & u23\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32(v & u23\"0xFF\")))\n    }\n\n    def beU24(output: MSZ[B], context: Context, v: U24): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v >> u24\"16\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32((v >> u24\"8\") & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v & u24\"0xFF\")))\n    }\n\n    def beU25(output: MSZ[B], context: Context, v: U25): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U25.toU32(v >> u25\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"16\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"8\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32(v & u25\"0xFF\")))\n    }\n\n    def beU26(output: MSZ[B], context: Context, v: U26): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U26.toU32(v >> u26\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"16\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"8\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32(v & u26\"0xFF\")))\n    }\n\n    def beU27(output: MSZ[B], context: Context, v: U27): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U27.toU32(v >> u27\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"16\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"8\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32(v & u27\"0xFF\")))\n    }\n\n    def beU28(output: MSZ[B], context: Context, v: U28): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U28.toU32(v >> u28\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"16\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"8\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32(v & u28\"0xFF\")))\n    }\n\n    def beU29(output: MSZ[B], context: Context, v: U29): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U29.toU32(v >> u29\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"16\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"8\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32(v & u29\"0xFF\")))\n    }\n\n    def beU30(output: MSZ[B], context: Context, v: U30): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U30.toU32(v >> u30\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"16\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"8\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32(v & u30\"0xFF\")))\n    }\n\n    def beU31(output: MSZ[B], context: Context, v: U31): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U31.toU32(v >> u31\"24\"))))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"16\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"8\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32(v & u31\"0xFF\")))\n    }\n\n    def beU32(output: MSZ[B], context: Context, v: U32): Unit = {\n      bleU8(output, context, conversions.U32.toU8(v >> u32\"24\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"16\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"8\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8(v & u32\"0xFF\"))\n    }\n\n    def beS32(output: MSZ[B], context: Context, v: S32): Unit = {\n      beU32(output, context, conversions.S32.toRawU32(v))\n    }\n\n    def beU33(output: MSZ[B], context: Context, v: U33): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U33.toU64(v >> u33\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"24\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"16\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"8\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64(v & u33\"0xFF\")))\n    }\n\n    def beU34(output: MSZ[B], context: Context, v: U34): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U34.toU64(v >> u34\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"24\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"16\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"8\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64(v & u34\"0xFF\")))\n    }\n\n    def beU35(output: MSZ[B], context: Context, v: U35): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U35.toU64(v >> u35\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"24\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"16\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"8\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64(v & u35\"0xFF\")))\n    }\n\n    def beU36(output: MSZ[B], context: Context, v: U36): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U36.toU64(v >> u36\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"24\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"16\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"8\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64(v & u36\"0xFF\")))\n    }\n\n    def beU37(output: MSZ[B], context: Context, v: U37): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U37.toU64(v >> u37\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"24\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"16\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"8\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64(v & u37\"0xFF\")))\n    }\n\n    def beU38(output: MSZ[B], context: Context, v: U38): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U38.toU64(v >> u38\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"24\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"16\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"8\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64(v & u38\"0xFF\")))\n    }\n\n    def beU39(output: MSZ[B], context: Context, v: U39): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U39.toU64(v >> u39\"32\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"24\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"16\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"8\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64(v & u39\"0xFF\")))\n    }\n\n    def beU40(output: MSZ[B], context: Context, v: U40): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v >> u40\"32\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"24\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"16\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"8\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v & u40\"0xFF\")))\n    }\n\n    def beU41(output: MSZ[B], context: Context, v: U41): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U41.toU64(v >> u41\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"32\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"24\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"16\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"8\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64(v & u41\"0xFF\")))\n    }\n\n    def beU42(output: MSZ[B], context: Context, v: U42): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U42.toU64(v >> u42\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"32\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"24\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"16\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"8\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64(v & u42\"0xFF\")))\n    }\n\n    def beU43(output: MSZ[B], context: Context, v: U43): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U43.toU64(v >> u43\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"32\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"24\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"16\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"8\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64(v & u43\"0xFF\")))\n    }\n\n    def beU44(output: MSZ[B], context: Context, v: U44): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U44.toU64(v >> u44\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"32\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"24\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"16\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"8\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64(v & u44\"0xFF\")))\n    }\n\n    def beU45(output: MSZ[B], context: Context, v: U45): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U45.toU64(v >> u45\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"32\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"24\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"16\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"8\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64(v & u45\"0xFF\")))\n    }\n\n    def beU46(output: MSZ[B], context: Context, v: U46): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U46.toU64(v >> u46\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"32\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"24\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"16\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"8\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64(v & u46\"0xFF\")))\n    }\n\n    def beU47(output: MSZ[B], context: Context, v: U47): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U47.toU64(v >> u47\"40\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"32\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"24\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"16\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"8\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64(v & u47\"0xFF\")))\n    }\n\n    def beU48(output: MSZ[B], context: Context, v: U48): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v >> u48\"40\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"32\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"24\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"16\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"8\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v & u48\"0xFF\")))\n    }\n\n    def beU49(output: MSZ[B], context: Context, v: U49): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U49.toU64(v >> u49\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"40\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"32\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"24\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"16\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"8\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64(v & u49\"0xFF\")))\n    }\n\n    def beU50(output: MSZ[B], context: Context, v: U50): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U50.toU64(v >> u50\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"40\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"32\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"24\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"16\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"8\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64(v & u50\"0xFF\")))\n    }\n\n    def beU51(output: MSZ[B], context: Context, v: U51): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U51.toU64(v >> u51\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"40\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"32\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"24\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"16\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"8\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64(v & u51\"0xFF\")))\n    }\n\n    def beU52(output: MSZ[B], context: Context, v: U52): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U52.toU64(v >> u52\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"40\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"32\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"24\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"16\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"8\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64(v & u52\"0xFF\")))\n    }\n\n    def beU53(output: MSZ[B], context: Context, v: U53): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U53.toU64(v >> u53\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"40\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"32\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"24\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"16\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"8\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(convers
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f12$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #758                // String ions.U53.toU64(v & u53\"0xFF\")))\n    }\n\n    def beU54(output: MSZ[B], context: Context, v: U54): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U54.toU64(v >> u54\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"40\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"32\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"24\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"16\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"8\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64(v & u54\"0xFF\")))\n    }\n\n    def beU55(output: MSZ[B], context: Context, v: U55): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U55.toU64(v >> u55\"48\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"40\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"32\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"24\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"16\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"8\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64(v & u55\"0xFF\")))\n    }\n\n    def beU56(output: MSZ[B], context: Context, v: U56): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v >> u56\"48\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"40\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"32\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"24\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"16\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"8\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v & u56\"0xFF\")))\n    }\n\n    def beU57(output: MSZ[B], context: Context, v: U57): Unit = {\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U57.toU64(v >> u57\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"48\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"40\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"32\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"24\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"16\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"8\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64(v & u57\"0xFF\")))\n    }\n\n    def beU58(output: MSZ[B], context: Context, v: U58): Unit = {\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U58.toU64(v >> u58\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"48\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"40\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"32\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"24\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"16\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"8\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64(v & u58\"0xFF\")))\n    }\n\n    def beU59(output: MSZ[B], context: Context, v: U59): Unit = {\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U59.toU64(v >> u59\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"48\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"40\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"32\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"24\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"16\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"8\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64(v & u59\"0xFF\")))\n    }\n\n    def beU60(output: MSZ[B], context: Context, v: U60): Unit = {\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U60.toU64(v >> u60\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"48\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"40\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"32\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"24\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"16\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"8\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64(v & u60\"0xFF\")))\n    }\n\n    def beU61(output: MSZ[B], context: Context, v: U61): Unit = {\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U61.toU64(v >> u61\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"48\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"40\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"32\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"24\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"16\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"8\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64(v & u61\"0xFF\")))\n    }\n\n    def beU62(output: MSZ[B], context: Context, v: U62): Unit = {\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U62.toU64(v >> u62\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"48\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"40\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"32\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"24\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"16\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"8\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64(v & u62\"0xFF\")))\n    }\n\n    def beU63(output: MSZ[B], context: Context, v: U63): Unit = {\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U63.toU64(v >> u63\"56\"))))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"48\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"40\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"32\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"24\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"16\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"8\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64(v & u63\"0xFF\")))\n    }\n\n    def beU64(output: MSZ[B], context: Context, v: U64): Unit = {\n      bleU8(output, context, conversions.U64.toU8(v >> u64\"56\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"48\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"40\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"32\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"24\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"16\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"8\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8(v & u64\"0xFF\"))\n    }\n\n    def beS64(output: MSZ[B], context: Context, v: S64): Unit = {\n      beU64(output, context, conversions.S64.toRawU64(v))\n    }\n\n    def beF32(output: MSZ[B], context: Context, v: F32): Unit = {\n      beU32(output, context, conversions.F32.toRawU32(v))\n    }\n\n    def beF64(output: MSZ[B], context: Context, v: F64): Unit = {\n      beU64(output, context, conversions.F64.toRawU64(v))\n    }\n\n    // Slang script gen:\n    /*\n    for (i <- 9 to 15) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U16.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU${i - 8}(output, context, conversions.U8.toU${i - 16}(conversions.U16.toU8(conversions.U$i.toU16(v >> u$i\"8\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 17 to 24) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU${i - 16}(output, context, conversions.U8.toU${i - 16}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"16\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 25 to 31) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U32.toU8(conversions.U$i.toU32((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU${i - 24}(output, context, conversions.U8.toU${i - 24}(conversions.U32.toU8(conversions.U$i.toU32(v >> u$i\"24\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 33 to 40) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU${i - 32}(output, context, conversions.U8.toU${i - 32}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"32\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 41 to 48) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU${i - 40}(output, context, conversions.U8.toU${i - 40}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"40\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 49 to 56) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU${i - 48}(output, context, conversions.U8.toU${i - 48}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"48\"))))\n            |}\n            |\"\"\".render)\n    }\n\n    for (i <- 57 to 63) {\n      println(\n        st\"\"\"def leU$i(output: MSZ[B], context: Context, v: U$i): Unit = {\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64(v & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"8\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"16\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"24\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"32\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"40\") & u$i\"0xFF\")))\n            |  bleU8(output, context, conversions.U64.toU8(conversions.U$i.toU64((v >> u$i\"48\") & u$i\"0xFF\")))\n            |  bleU${i - 56}(output, context, conversions.U8.toU${i - 56}(conversions.U64.toU8(conversions.U$i.toU64(v >> u$i\"56\"))))\n            |}\n            |\"\"\".render)\n    }\n     */\n    def leU9(output: MSZ[B], context: Context, v: U9): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U9.toU16(v & u9\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U16.toU8(conversions.U9.toU16(v >> u9\"8\"))))\n    }\n\n    def leU10(output: MSZ[B], context: Context, v: U10): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U10.toU16(v & u10\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U16.toU8(conversions.U10.toU16(v >> u10\"8\"))))\n    }\n\n    def leU11(output: MSZ[B], context: Context, v: U11): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U11.toU16(v & u11\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U16.toU8(conversions.U11.toU16(v >> u11\"8\"))))\n    }\n\n    def leU12(output: MSZ[B], context: Context, v: U12): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U12.toU16(v & u12\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U16.toU8(conversions.U12.toU16(v >> u12\"8\"))))\n    }\n\n    def leU13(output: MSZ[B], context: Context, v: U13): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U13.toU16(v & u13\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U16.toU8(conversions.U13.toU16(v >> u13\"8\"))))\n    }\n\n    def leU14(output: MSZ[B], context: Context, v: U14): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U14.toU16(v & u14\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U16.toU8(conversions.U14.toU16(v >> u14\"8\"))))\n    }\n\n    def leU15(output: MSZ[B], context: Context, v: U15): Unit = {\n      bleU8(output, context, conversions.U16.toU8(conversions.U15.toU16(v & u15\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U16.toU8(conversions.U15.toU16(v >> u15\"8\"))))\n    }\n\n    def leU16(output: MSZ[B], context: Context, v: U16): Unit = {\n      bleU8(output, context, conversions.U16.toU8(v & u16\"0xFF\"))\n      bleU8(output, context, conversions.U16.toU8(v >> u16\"8\"))\n    }\n\n    def leS16(output: MSZ[B], context: Context, v: S16): Unit = {\n      leU16(output, context, conversions.S16.toRawU16(v))\n    }\n\n    def leU17(output: MSZ[B], context: Context, v: U17): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32(v & u17\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U17.toU32((v >> u17\"8\") & u17\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U17.toU32(v >> u17\"16\"))))\n    }\n\n    def leU18(output: MSZ[B], context: Context, v: U18): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32(v & u18\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U18.toU32((v >> u18\"8\") & u18\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U18.toU32(v >> u18\"16\"))))\n    }\n\n    def leU19(output: MSZ[B], context: Context, v: U19): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32(v & u19\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U19.toU32((v >> u19\"8\") & u19\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U19.toU32(v >> u19\"16\"))))\n    }\n\n    def leU20(output: MSZ[B], context: Context, v: U20): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32(v & u20\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U20.toU32((v >> u20\"8\") & u20\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U20.toU32(v >> u20\"16\"))))\n    }\n\n    def leU21(output: MSZ[B], context: Context, v: U21): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32(v & u21\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U21.toU32((v >> u21\"8\") & u21\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U21.toU32(v >> u21\"16\"))))\n    }\n\n    def leU22(output: MSZ[B], context: Context, v: U22): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32(v & u22\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U22.toU32((v >> u22\"8\") & u22\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U22.toU32(v >> u22\"16\"))))\n    }\n\n    def leU23(output: MSZ[B], context: Context, v: U23): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32(v & u23\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U23.toU32((v >> u23\"8\") & u23\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U23.toU32(v >> u23\"16\"))))\n    }\n\n    def leU24(output: MSZ[B], context: Context, v: U24): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32((v >> u24\"8\") & u24\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U24.toU32(v >> u24\"16\")))\n    }\n\n    def leU25(output: MSZ[B], context: Context, v: U25): Unit = {\n      bleU8(output, context, conv
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f13$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #760                // String ersions.U32.toU8(conversions.U25.toU32(v & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"8\") & u25\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U25.toU32((v >> u25\"16\") & u25\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U32.toU8(conversions.U25.toU32(v >> u25\"24\"))))\n    }\n\n    def leU26(output: MSZ[B], context: Context, v: U26): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32(v & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"8\") & u26\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U26.toU32((v >> u26\"16\") & u26\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U32.toU8(conversions.U26.toU32(v >> u26\"24\"))))\n    }\n\n    def leU27(output: MSZ[B], context: Context, v: U27): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32(v & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"8\") & u27\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U27.toU32((v >> u27\"16\") & u27\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U32.toU8(conversions.U27.toU32(v >> u27\"24\"))))\n    }\n\n    def leU28(output: MSZ[B], context: Context, v: U28): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32(v & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"8\") & u28\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U28.toU32((v >> u28\"16\") & u28\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U32.toU8(conversions.U28.toU32(v >> u28\"24\"))))\n    }\n\n    def leU29(output: MSZ[B], context: Context, v: U29): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32(v & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"8\") & u29\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U29.toU32((v >> u29\"16\") & u29\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U32.toU8(conversions.U29.toU32(v >> u29\"24\"))))\n    }\n\n    def leU30(output: MSZ[B], context: Context, v: U30): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32(v & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"8\") & u30\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U30.toU32((v >> u30\"16\") & u30\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U32.toU8(conversions.U30.toU32(v >> u30\"24\"))))\n    }\n\n    def leU31(output: MSZ[B], context: Context, v: U31): Unit = {\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32(v & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"8\") & u31\"0xFF\")))\n      bleU8(output, context, conversions.U32.toU8(conversions.U31.toU32((v >> u31\"16\") & u31\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U32.toU8(conversions.U31.toU32(v >> u31\"24\"))))\n    }\n\n    def leU32(output: MSZ[B], context: Context, v: U32): Unit = {\n      bleU8(output, context, conversions.U32.toU8(v & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"8\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8((v >> u32\"16\") & u32\"0xFF\"))\n      bleU8(output, context, conversions.U32.toU8(v >> u32\"24\"))\n    }\n\n    def leS32(output: MSZ[B], context: Context, v: S32): Unit = {\n      leU32(output, context, conversions.S32.toRawU32(v))\n    }\n\n    def leU33(output: MSZ[B], context: Context, v: U33): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64(v & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"8\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"16\") & u33\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U33.toU64((v >> u33\"24\") & u33\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U33.toU64(v >> u33\"32\"))))\n    }\n\n    def leU34(output: MSZ[B], context: Context, v: U34): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64(v & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"8\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"16\") & u34\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U34.toU64((v >> u34\"24\") & u34\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U34.toU64(v >> u34\"32\"))))\n    }\n\n    def leU35(output: MSZ[B], context: Context, v: U35): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64(v & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"8\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"16\") & u35\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U35.toU64((v >> u35\"24\") & u35\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U35.toU64(v >> u35\"32\"))))\n    }\n\n    def leU36(output: MSZ[B], context: Context, v: U36): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64(v & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"8\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"16\") & u36\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U36.toU64((v >> u36\"24\") & u36\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U36.toU64(v >> u36\"32\"))))\n    }\n\n    def leU37(output: MSZ[B], context: Context, v: U37): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64(v & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"8\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"16\") & u37\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U37.toU64((v >> u37\"24\") & u37\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U37.toU64(v >> u37\"32\"))))\n    }\n\n    def leU38(output: MSZ[B], context: Context, v: U38): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64(v & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"8\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"16\") & u38\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U38.toU64((v >> u38\"24\") & u38\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U38.toU64(v >> u38\"32\"))))\n    }\n\n    def leU39(output: MSZ[B], context: Context, v: U39): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64(v & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"8\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"16\") & u39\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U39.toU64((v >> u39\"24\") & u39\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U39.toU64(v >> u39\"32\"))))\n    }\n\n    def leU40(output: MSZ[B], context: Context, v: U40): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"8\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"16\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64((v >> u40\"24\") & u40\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U40.toU64(v >> u40\"32\")))\n    }\n\n    def leU41(output: MSZ[B], context: Context, v: U41): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64(v & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"8\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"16\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"24\") & u41\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U41.toU64((v >> u41\"32\") & u41\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U41.toU64(v >> u41\"40\"))))\n    }\n\n    def leU42(output: MSZ[B], context: Context, v: U42): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64(v & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"8\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"16\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"24\") & u42\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U42.toU64((v >> u42\"32\") & u42\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U42.toU64(v >> u42\"40\"))))\n    }\n\n    def leU43(output: MSZ[B], context: Context, v: U43): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64(v & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"8\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"16\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"24\") & u43\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U43.toU64((v >> u43\"32\") & u43\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U43.toU64(v >> u43\"40\"))))\n    }\n\n    def leU44(output: MSZ[B], context: Context, v: U44): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64(v & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"8\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"16\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"24\") & u44\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U44.toU64((v >> u44\"32\") & u44\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U44.toU64(v >> u44\"40\"))))\n    }\n\n    def leU45(output: MSZ[B], context: Context, v: U45): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64(v & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"8\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"16\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"24\") & u45\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U45.toU64((v >> u45\"32\") & u45\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U45.toU64(v >> u45\"40\"))))\n    }\n\n    def leU46(output: MSZ[B], context: Context, v: U46): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64(v & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"8\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"16\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"24\") & u46\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U46.toU64((v >> u46\"32\") & u46\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U46.toU64(v >> u46\"40\"))))\n    }\n\n    def leU47(output: MSZ[B], context: Context, v: U47): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64(v & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"8\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"16\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"24\") & u47\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U47.toU64((v >> u47\"32\") & u47\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U47.toU64(v >> u47\"40\"))))\n    }\n\n    def leU48(output: MSZ[B], context: Context, v: U48): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"8\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"16\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"24\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64((v >> u48\"32\") & u48\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U48.toU64(v >> u48\"40\")))\n    }\n\n    def leU49(output: MSZ[B], context: Context, v: U49): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64(v & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"8\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"16\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"24\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"32\") & u49\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U49.toU64((v >> u49\"40\") & u49\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U49.toU64(v >> u49\"48\"))))\n    }\n\n    def leU50(output: MSZ[B], context: Context, v: U50): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64(v & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"8\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"16\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"24\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"32\") & u50\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U50.toU64((v >> u50\"40\") & u50\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U50.toU64(v >> u50\"48\"))))\n    }\n\n    def leU51(output: MSZ[B], context: Context, v: U51): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64(v & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"8\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"16\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"24\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"32\") & u51\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U51.toU64((v >> u51\"40\") & u51\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U51.toU64(v >> u51\"48\"))))\n    }\n\n    def leU52(output: MSZ[B], context: Context, v: U52): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64(v & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"8\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"16\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"24\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"32\") & u52\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U52.toU64((v >> u52\"40\") & u52\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U52.toU64(v >> u52\"48\"))))\n    }\n\n    def leU53(output: MSZ[B], context: Context, v: U53): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64(v & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"8\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"16\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"24\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"32\") & u53\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U53.toU64((v >> u53\"40\") & u53\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U53.toU64(v >> u53\"48\"))))\n    }\n\n    def leU54(output: MSZ[B], context: Context, v: U54): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64(v & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"8\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"16\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"24\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"32\") & u54\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U54.toU64((v >> u54\"40\") & u54\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U54.toU64(v >> u54\"48\"))))\n    }\n\n    def leU55(output: MSZ[B], context: Context, v: U55): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64(v & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"8\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"16\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"24\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"32\") & u55\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U55.toU64((v >> u55\"40\") & u55\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U55.toU64(v >> u55\"48\"))))\n    }\n\n    def leU56(output: MSZ[B], context: Context, v: U56): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"8\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"16\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"24\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"32\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64((v >> u56\"40\") & u56\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U56.toU64(v >> u56\"48\")))\n    }\n\n    def leU57(output: MSZ[B], context: Context, v: U57): Unit = {\n      bleU8(ou
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f14$1();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #762                // String tput, context, conversions.U64.toU8(conversions.U57.toU64(v & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"8\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"16\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"24\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"32\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"40\") & u57\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U57.toU64((v >> u57\"48\") & u57\"0xFF\")))\n      bleU1(output, context, conversions.U8.toU1(conversions.U64.toU8(conversions.U57.toU64(v >> u57\"56\"))))\n    }\n\n    def leU58(output: MSZ[B], context: Context, v: U58): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64(v & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"8\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"16\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"24\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"32\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"40\") & u58\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U58.toU64((v >> u58\"48\") & u58\"0xFF\")))\n      bleU2(output, context, conversions.U8.toU2(conversions.U64.toU8(conversions.U58.toU64(v >> u58\"56\"))))\n    }\n\n    def leU59(output: MSZ[B], context: Context, v: U59): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64(v & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"8\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"16\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"24\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"32\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"40\") & u59\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U59.toU64((v >> u59\"48\") & u59\"0xFF\")))\n      bleU3(output, context, conversions.U8.toU3(conversions.U64.toU8(conversions.U59.toU64(v >> u59\"56\"))))\n    }\n\n    def leU60(output: MSZ[B], context: Context, v: U60): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64(v & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"8\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"16\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"24\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"32\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"40\") & u60\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U60.toU64((v >> u60\"48\") & u60\"0xFF\")))\n      bleU4(output, context, conversions.U8.toU4(conversions.U64.toU8(conversions.U60.toU64(v >> u60\"56\"))))\n    }\n\n    def leU61(output: MSZ[B], context: Context, v: U61): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64(v & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"8\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"16\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"24\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"32\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"40\") & u61\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U61.toU64((v >> u61\"48\") & u61\"0xFF\")))\n      bleU5(output, context, conversions.U8.toU5(conversions.U64.toU8(conversions.U61.toU64(v >> u61\"56\"))))\n    }\n\n    def leU62(output: MSZ[B], context: Context, v: U62): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64(v & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"8\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"16\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"24\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"32\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"40\") & u62\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U62.toU64((v >> u62\"48\") & u62\"0xFF\")))\n      bleU6(output, context, conversions.U8.toU6(conversions.U64.toU8(conversions.U62.toU64(v >> u62\"56\"))))\n    }\n\n    def leU63(output: MSZ[B], context: Context, v: U63): Unit = {\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64(v & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"8\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"16\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"24\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"32\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"40\") & u63\"0xFF\")))\n      bleU8(output, context, conversions.U64.toU8(conversions.U63.toU64((v >> u63\"48\") & u63\"0xFF\")))\n      bleU7(output, context, conversions.U8.toU7(conversions.U64.toU8(conversions.U63.toU64(v >> u63\"56\"))))\n    }\n\n    def leU64(output: MSZ[B], context: Context, v: U64): Unit = {\n      bleU8(output, context, conversions.U64.toU8(v & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"8\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"16\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"24\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"32\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"40\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8((v >> u64\"48\") & u64\"0xFF\"))\n      bleU8(output, context, conversions.U64.toU8(v >> u64\"56\"))\n    }\n\n    def leS64(output: MSZ[B], context: Context, v: S64): Unit = {\n      leU64(output, context, conversions.S64.toRawU64(v))\n    }\n\n    def leF32(output: MSZ[B], context: Context, v: F32): Unit = {\n      leU32(output, context, conversions.F32.toRawU32(v))\n    }\n\n    def leF64(output: MSZ[B], context: Context, v: F64): Unit = {\n      leU64(output, context, conversions.F64.toRawU64(v))\n    }\n  }\n\n  def hex2u8(n: U8): Option[U8] = {\n    if (u8\"48\" <= n && n <= u8\"57\") { // \'0\' .. \'9\'\n      return Some(n - u8\"48\")\n    }\n    if (u8\"65\" <= n && n <= u8\"70\") { // \'A\' .. \'F\'\n      return Some(n - u8\"55\")\n    }\n    if (u8\"97\" <= n && n <= u8\"102\") { // \'a\' .. \'f\'\n      return Some(n - u8\"87\")\n    }\n    return None()\n  }\n\n  def fromHexString(s: String): ISZ[B] = {\n    assert(s.size % 2 == 0)\n    val ms = MSZ.create(s.size * 4, F)\n    var i = 0\n    val sz = s.size\n    val u8s = conversions.String.toU8is(s)\n    val ctx = Bits.Context.create\n    while (i < sz) {\n      val b1Opt = hex2u8(u8s(i))\n      i = i + 1\n      val b2Opt = hex2u8(u8s(i))\n      i = i + 1\n      (b1Opt, b2Opt) match {\n        case (Some(b1), Some(b2)) =>\n          val b = b1 << u8\"4\" | b2\n          Bits.Writer.bleU8(ms, ctx, b)\n        case (_, _) =>\n          halt(s\"Invalid hex input string at offset: ${i - (if (b1Opt.isEmpty) 2 else 1)}\")\n      }\n    }\n    assert(ctx.errorCode == 0)\n    return Bits.Writer.resultMS(ms, ctx).toIS\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$52();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #764                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.justification.Premise\n\nobject Map {\n\n  @strictpure def empty[K, T]: Map[K, T] = Map[K, T](ISZ())\n\n  @strictpure def of[K, T]: Map[K, T] = Map.empty\n\n  @strictpure def ++[K, T, I](s: IS[I, (K, T)]): Map[K, T] = Map.empty[K, T] ++ s\n\n  @strictpure def entriesOf[K, T](m: Map[K, T]): ISZ[(K, T)] = m.entries\n\n  object Entries {\n\n    @strictpure def uniqueKeys[K, T](entries: ISZ[(K, T)]): B =\n      ∀(entries.indices)(i => ∀(entries.indices)(j => (i != j) ->: (entries(i)._1 != entries(j)._1)))\n\n    @strictpure def contain[K, T](entries: ISZ[(K, T)], kv: (K, T)): B = ∃(entries.indices)(j => kv == entries(j))\n\n    @strictpure def containKey[K, T](entries: ISZ[(K, T)], key: K): B = ∃(entries.indices)(j => key == entries(j)._1)\n\n    @strictpure def containValue[K, T](entries: ISZ[(K, T)], value: T): B = ∃(entries.indices)(j => value == entries(j)._2)\n\n    @strictpure def keyIndexOfFrom[K, T](entries: ISZ[(K, T)], key: K, from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)._1 == key) from\n      else keyIndexOfFrom(entries, key, from + 1)\n\n    @strictpure def valueIndexOfFrom[K, T](entries: ISZ[(K, T)], value: T, from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)._2 == value) from\n      else valueIndexOfFrom(entries, value, from + 1)\n\n    @strictpure def indexOfFrom[K, T](entries: ISZ[(K, T)], kv: (K, T), from: Z): Z =\n      if (from < 0 | from >= entries.size) -1\n      else if (entries(from)== kv) from\n      else indexOfFrom(entries, kv, from + 1)\n\n  }\n\n}\n\n@datatype class Map[K, T](val entries: ISZ[(K, T)]) {\n\n  @spec def uniqueKeys = Invariant(Map.Entries.uniqueKeys(entries))\n\n  @pure def keys: ISZ[K] = {\n    Contract(\n      Ensures(\n        SeqUtil.IS.pair1Eq(entries, Res),\n        SeqUtil.IS.unique(Res),\n      )\n    )\n    var r = ISZ[K]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(r, i),\n        0 <= i,\n        i <= entries.size,\n        i == r.size,\n        ∀(0 until i)(j => r(j) == entries(j)._1)\n      )\n      r = r :+ entries(i)._1\n      i = i + 1\n    }\n    return r\n  }\n\n  @pure def values: ISZ[T] = {\n    Contract(Ensures(SeqUtil.IS.pair2Eq(entries, Res)))\n    var r = ISZ[T]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(r, i),\n        0 <= i,\n        i <= entries.size,\n        i == r.size,\n        ∀(0 until i)(j => r(j) == entries(j)._2)\n      )\n      r = r :+ entries(i)._2\n      i = i + 1\n    }\n    return r\n  }\n\n  @strictpure def keySet: Set[K] = Set.empty[K] ++ keys\n\n  @strictpure def valueSet: Set[T] =  Set.empty[T] ++ values\n\n  @pure def +(p: (K, T)): Map[K, T] = {\n    Contract(\n      Ensures(\n        Map.entriesOf(Res).size == entries.size | Map.entriesOf(Res).size == entries.size + 1,\n        Map.Entries.contain(Map.entriesOf(Res), p),\n        ∀(Map.entriesOf(Res).indices)(j =>\n          (Map.entriesOf(Res)(j) != p) ->: Map.Entries.contain(entries, Map.entriesOf(Res)(j))),\n        ∀(entries.indices)(j =>\n          (entries(j)._1 != p._1) ->: Map.Entries.contain(Map.entriesOf(Res), entries(j))),\n      )\n    )\n    val (key, value) = p\n    val index = indexOf(key)\n    val newEntries: ISZ[(K, T)] = if (index < 0) {\n      val r = entries :+ ((key, value))\n      Deduce(\n        //@formatter:off\n        1 #> (r(r.size - 1) == p)                                                           by Premise,\n        2 #> Map.Entries.contain(r, p)                                                      by Premise,\n        3 #> Map.Entries.uniqueKeys(r)                                                      by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != p) ->: Map.Entries.contain(entries, r(j)))          by Premise,\n        5 #> ∀(entries.indices)(j => Map.Entries.contain(r, entries(j)))                    by Premise,\n        //@formatter:on\n      )\n      r\n    } else {\n      val r = entries(index ~> p)\n      Deduce(\n        //@formatter:off\n        1 #> (r(index) == p)                                                                by Premise,\n        2 #> Map.Entries.contain(r, p)                                                      by Premise,\n        3 #> Map.Entries.uniqueKeys(r)                                                      by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != p) ->: Map.Entries.contain(entries, r(j)))          by Premise,\n        5 #> ∀(entries.indices)(j => (index != j) ->: Map.Entries.contain(r, entries(j)))   by Premise,\n        //@formatter:on\n      )\n      r\n    }\n    return Map(newEntries)\n  }\n\n  @pure def ++[I](kvs: IS[I, (K, T)]): Map[K, T] = {\n    var r = this\n    for (kv <- kvs) {\n      r = r + kv\n    }\n    return r\n  }\n\n  @pure def get(key: K): Option[T] = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(∃(entries.indices)(j => (key == entries(j)._1) & (Res == Some(entries(j)._2))))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == None[T]())\n      )\n    )\n    val index = indexOf(key)\n    val r: Option[T] = if (index < 0) None[T]() else Some(entries(index)._2)\n    return r\n  }\n\n  @pure def getOrElse(key: K, default: => T): T = {\n    val index = indexOf(key)\n    return if (index < 0) default else entries(index)._2\n  }\n\n  @pure def getOrElseEager(key: K, default: T): T = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(Map.Entries.containValue(entries, Res))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == default)\n      )\n    )\n    val index = indexOf(key)\n    return if (index < 0) default else entries(index)._2\n  }\n\n  @pure def entry(key: K): Option[(K, T)] = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(∃(entries.indices)(j => Res == Some(entries(j))))\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res == None[(K, T)]())\n      )\n    )\n    val index = indexOf(key)\n    val r: Option[(K, T)] = if (index < 0) None[(K, T)]() else Some(entries(index))\n    return r\n  }\n\n  @pure def indexOf(key: K): Z = {\n    Contract(\n      Case(\n        \"Mapped\",\n        Requires(Map.Entries.containKey(entries, key)),\n        Ensures(\n          0 <= Res[Z],\n          Res[Z] < entries.size,\n          entries(Res[Z])._1 == key\n        )\n      ),\n      Case(\n        \"Unmapped\",\n        Requires(!Map.Entries.containKey(entries, key)),\n        Ensures(Res[Z] == -1)\n      )\n    )\n    var index: Z = -1\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(index, i),\n        0 <= i,\n        i <= entries.size,\n        (index != -1) ->: (0 <= index & index < entries.size & entries(index)._1 == key),\n        (index == -1) ->: ∀(0 until i)(j => key != entries(j)._1)\n      )\n      if (entries(i)._1 == key) {\n        index = i\n        i = entries.size - 1\n      }\n      i = i + 1\n    }\n    return index\n  }\n\n  @pure def --[I](keys: IS[I, K]): Map[K, T] = {\n    var deletedMappings = ISZ[(K, T)]()\n    for (key <- keys) {\n      get(key) match {\n        case Some(value) => deletedMappings = deletedMappings :+ ((key, value))\n        case _ =>\n      }\n    }\n    if (deletedMappings.nonEmpty) {\n      return Map(entries -- deletedMappings)\n    } else {\n      return this\n    }\n  }\n\n  @pure def -(p: (K, T)): Map[K, T] = {\n    Contract(\n      Ensures(\n        Map.entriesOf(Res).size == entries.size | Map.entriesOf(Res).size == entries.size - 1,\n        ∀(Map.entriesOf(Res).indices)(j =>\n          Map.entriesOf(Res)(j) != p & Map.Entries.contain(entries, Map.entriesOf(Res)(j))),\n        ∀(entries.indices)(j =>\n          (entries(j) != p) ->: Map.Entries.contain(Map.entriesOf(Res), entries(j))),\n      )\n    )\n    var newEntries = ISZ[(K, T)]()\n    var i: Z = 0\n    while (i < entries.size) {\n      Invariant(\n        Modifies(i, newEntries),\n        0 <= i,\n        i <= entries.size,\n        ∀(newEntries.indices)(j => ∀(i until entries.size)(k => newEntries(j)._1 != entries(k)._1)),\n        ∀(newEntries.indices)(j => newEntries(j) != p & Map.Entries.contain(entries, newEntries(j))),\n        ∃(0 until i)(j => p == entries(j)) ->: (newEntries.size == i - 1),\n        ∀(0 until i)(j => p != entries(j)) ->: (newEntries.size == i),\n        ∀(0 until i)(j => (p != entries(j)) ->: Map.Entries.contain(newEntries, entries(j))),\n        Map.Entries.uniqueKeys(newEntries),\n      )\n      val kv = entries(i)\n      if (kv != p) {\n        newEntries = newEntries :+ kv\n        Deduce(\n          1 #> ∀(0 to i)(j => (p != entries(j)) ->: Map.Entries.contain(newEntries, entries(j)))  by Premise\n        )\n      }\n      i = i + 1\n    }\n    val r = Map(newEntries)\n    return r\n  }\n\n  @pure def contains(key: K): B = {\n    Contract(Ensures(Res == Map.Entries.containKey(entries, key)))\n    return indexOf(key) >= 0\n  }\n\n  @pure def isEmpty: B = {\n    Contract(Ensures(Res == (entries.size == 0)))\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    Contract(Ensures(Res != (entries.size == 0)))\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    Contract(Ensures(Res == entries.size))\n    return entries.size\n  }\n\n  @pure override def string: String = {\n    val r = st\"\"\"{\n    |  ${(for (e <- entries) yield st\"${e._1} -> ${e._2}\", \",\\n\")}\n    |}\"\"\"\n    return r.render\n  }\n\n  @pure override def hash: Z = {\n    return entries.size\n  }\n\n  @pure def isEqual(other: Map[K, T]): B = {\n    Contract(\n      Case(\n        \"Equal\",\n        Requires(\n          entries.size == other.entries.size,\n          ∀(entries.indices)(j => Map.Entries.contain(other.entries, entries(j))),\n        ),\n        Ensures(Res[B])\n      ),\n      Case(\n        \"Inequal-diff-key\",\n        Requires(\n          entries.size == other.entries.size,\n          ∃(entries.indices)(j => !Map.Entries.containKey(other.entries, entries(j)._1)),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-diff-value\",\n        Requires(\n          entries.size == other.entries.size,\n          ∃(entries.indices)(j => ∀(other.entries.indices)(k => entries(j) != other.entries(k))),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-size\",\n        Requires(entries.size != other.entries.size),\n        Ensures(!Res[B])\n      )\n    )\n    val sz = size\n    var r = T\n    if (sz != other.size) {\n      r = F\n    } else {\n      var i: Z = 0\n      while (r & i < sz) {\n        Invariant(\n          Modifies(i, r),\n          0 <= i,\n          i <= sz,\n          r ->: ∀(0 until i)(j => Map.Entries.contain(other.entries, entries(j))),\n          !r ->: ∃(entries.indices)(j =>\n            !Map.Entries.containKey(other.entries, entries(j)._1) |\n              !Map.Entries.contain(other.entries, entries(j)))\n        )\n        val (key, v) = entries(i)\n        val v2Opt = other.get(key)\n        v2Opt match {\n          case Some(v2) =>\n            if (v2 != v) {\n              r = F\n            }\n          case _ =>\n            r = F\n        }\n        i = i + 1\n      }\n    }\n    return r\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$53();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #766                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject HashSBag {\n\n  @pure def empty[T]: HashSBag[T] = {\n    return HashSBag(HashSMap.empty)\n  }\n\n  @pure def emptyInit[T](initialCapacity: Z): HashSBag[T] = {\n    return HashSBag(HashSMap.emptyInit(initialCapacity))\n  }\n\n  @pure def ++[I, T](s: IS[I, T]): HashSBag[T] = {\n    return HashSBag.empty[T] ++ s\n  }\n\n}\n\n@datatype class HashSBag[T](val map: HashSMap[T, Z]) {\n\n  @pure def size: Z = {\n    var r = z\"0\"\n    for (n <- map.values) {\n      r = r + n\n    }\n    return r\n  }\n\n  @pure def elements: ISZ[T] = {\n    var r = ISZ[T]()\n    for (entry <- entries) {\n      val (e, size) = entry\n      r = r ++ (for (_ <- z\"0\" until size) yield e)\n    }\n    return r\n  }\n\n  @pure def isEmpty: B = {\n    return size == 0\n  }\n\n  @pure def nonEmpty: B = {\n    return !isEmpty\n  }\n\n  @pure def count(e: T): Z = {\n    map.get(e) match {\n      case Some(n) => return n\n      case _ => return 0\n    }\n  }\n\n  @pure def contains(e: T): B = {\n    return count(e) > 0\n  }\n\n  @pure def +(e: T): HashSBag[T] = {\n    return addN(e, 1)\n  }\n\n  @pure def +#(p: (T, Z)): HashSBag[T] = {\n    return addN(p._1, p._2)\n  }\n\n  @pure def addN(e: T, n: Z): HashSBag[T] = {\n    if (n <= 0) {\n      return this\n    }\n    return this(map + e ~> (count(e) + n))\n  }\n\n  @pure def ++[I](es: IS[I, T]): HashSBag[T] = {\n    var r = this\n    for (e <- es) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): HashSBag[T] = {\n    return removeN(e, 1)\n  }\n\n  @pure def --[I](s: IS[I, T]): HashSBag[T] = {\n    var r = this\n    for (e <- s) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def -#(p: (T, Z)): HashSBag[T] = {\n    return removeN(p._1, p._2)\n  }\n\n  @pure def removeN(e: T, n: Z): HashSBag[T] = {\n    val current = count(e)\n    val newN = current - n\n    if (newN <= 0) {\n      return this(map - e ~> current)\n    } else {\n      return this(map + e ~> newN)\n    }\n  }\n\n  @pure def \\(other: HashSBag[T]): HashSBag[T] = {\n    return this -- other.elements\n  }\n\n  @pure def entries: ISZ[(T, Z)] = {\n    return map.entries\n  }\n\n  @pure def union(other: HashSBag[T]): HashSBag[T] = {\n    return this ∪ other\n  }\n\n  @pure def ∪(other: HashSBag[T]): HashSBag[T] = {\n    return this ++ other.elements\n  }\n\n  @pure def intersect(other: HashSBag[T]): HashSBag[T] = {\n    return this ∩ other\n  }\n\n  @pure def ∩(other: HashSBag[T]): HashSBag[T] = {\n    var r = HashSBag.empty[T]\n    for (e <- entries) {\n      val n = e._2\n      val m = other.count(e._1)\n      if (n < m) {\n        r = r.addN(e._1, n)\n      } else {\n        r = r.addN(e._1, m)\n      }\n    }\n    return r\n  }\n\n  @pure override def string: String = {\n    return map.string\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$54();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #768                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject OsProto {\n\n  @sig trait Path\n\n  object Proc {\n    @sig trait Result {\n      def ok: B = {\n        return exitCode == 0\n      }\n      def out: String\n      def err: String\n      def exitCode: Z\n    }\n  }\n\n  @sig trait Proc {\n\n    @pure def commands(cs: ISZ[String]): Proc\n\n    @pure def at(dir: Path): Proc\n\n    @pure def env(m: ISZ[(String, String)]): Proc\n\n    @pure def input(content: String): Proc\n\n    @pure def timeout(millis: Z): Proc\n\n    @pure def dontInheritEnv: Proc\n\n    @pure def redirectErr: Proc\n\n    @pure def bufferErr: Proc\n\n    @pure def console: Proc\n\n    @pure def echoEnv: Proc\n\n    @pure def echo: Proc\n\n    @pure def standard: Proc\n\n    @pure def script: Proc\n\n    @pure def outLineAction(f: String => B): Proc\n\n    @pure def errLineAction(f: String => B): Proc\n\n    def run(): Proc.Result\n\n    def runCheck(): Proc.Result\n  }\n\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$55();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #770                // String // #Sireum #Logika\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nimport org.sireum.justification.Premise\n\nobject Set {\n\n  @strictpure def empty[T]: Set[T] = Set[T](ISZ())\n\n  @strictpure def ++[I, T](s: IS[I, T]): Set[T] = empty[T] ++ s\n\n  @strictpure def elementsOf[T](s: Set[T]): ISZ[T] = s.elements\n\n  object Elements {\n\n    @strictpure def unique[T](elements: ISZ[T]): B =\n      ∀(elements.indices)(i => ∀(elements.indices)(j => (i != j) ->: (elements(i) != elements(j))))\n\n    @strictpure def contain[T](elements: ISZ[T], e: T): B = ∃(elements.indices)(j => e == elements(j))\n\n    @strictpure def indexOfFrom[T](elements: ISZ[T], e: T, from: Z): Z =\n      if (from < 0 | from >= elements.size) -1\n      else if (elements(from)== e) from\n      else indexOfFrom(elements, e, from + 1)\n\n  }\n}\n\n@datatype class Set[T](val elements: ISZ[T]) {\n\n  @spec def uniqueElements = Invariant(Set.Elements.unique(elements))\n\n  @pure def +(e: T): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size == elements.size | Set.elementsOf(Res).size == elements.size + 1,\n        Set.Elements.contain(Set.elementsOf(Res), e),\n        ∀(Set.elementsOf(Res).indices)(j =>\n          (Set.elementsOf(Res)(j) != e) ->: Set.Elements.contain(elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          (elements(j) != e) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j)))\n      )\n    )\n    val index = indexOf(e)\n    val newElements: ISZ[T] = if (index < 0) {\n      val r = elements :+ e\n      Deduce(\n        //@formatter:off\n        1 #> (r(r.size - 1) == e)                                                           by Premise,\n        2 #> Set.Elements.contain(r, e)                                                     by Premise,\n        3 #> SeqUtil.IS.unique(r)                                                           by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != e) ->: Set.Elements.contain(elements, r(j)))        by Premise,\n        5 #> ∀(elements.indices)(j => Set.Elements.contain(r, elements(j)))                 by Premise,\n        //@formatter:on\n      )\n      r\n    } else {\n      val r = elements(index ~> e)\n      Deduce(\n        //@formatter:off\n        1 #> (r(index) == e)                                                                by Premise,\n        2 #> Set.Elements.contain(r, e)                                                     by Premise,\n        3 #> SeqUtil.IS.unique(r)                                                           by Premise,\n        4 #> ∀(r.indices)(j => (r(j) != e) ->: Set.Elements.contain(elements, r(j)))        by Premise,\n        5 #> ∀(elements.indices)(j => Set.Elements.contain(r, elements(j)))                 by Premise,\n        //@formatter:on\n      )\n      r\n    }\n    return Set(newElements)\n  }\n\n  @pure def ++[I](is: IS[I, T]): Set[T] = {\n    var r = this\n    for (e <- is) {\n      r = r + e\n    }\n    return r\n  }\n\n  @pure def -(e: T): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size == elements.size | Set.elementsOf(Res).size == elements.size - 1,\n        ∀(Set.elementsOf(Res).indices)(j => Set.elementsOf(Res)(j) != e & Set.Elements.contain(elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => (elements(j) != e) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(newElements.indices)(j => newElements(j) != e & Set.Elements.contain(elements, newElements(j))),\n        ∃(0 until i)(j => e == elements(j)) ->: (newElements.size == i - 1),\n        ∀(0 until i)(j => e != elements(j)) ->: (newElements.size == i),\n        ∀(0 until i)(j => (e != elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val kv = elements(i)\n      if (kv != e) {\n        newElements = newElements :+ kv\n      }\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def --[I](is: IS[I, T]): Set[T] = {\n    var r = this\n    for (e <- is) {\n      r = r - e\n    }\n    return r\n  }\n\n  @pure def contains(e: T): B = {\n    Contract(Ensures(Res == Set.Elements.contain(elements, e)))\n    return indexOf(e) >= 0\n  }\n\n  @pure def union(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size >= elements.size,\n        Set.elementsOf(Res).size <= elements.size + other.elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) |\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => elements(j) == Set.elementsOf(Res)(j)),\n        ∀(other.elements.indices)(j => Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = elements\n    var i: Z = 0\n    while (i < other.elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= other.elements.size,\n        newElements.size >= elements.size,\n        newElements.size <= elements.size + i,\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j)) |\n          Set.Elements.contain(other.elements, newElements(j))),\n        ∀(elements.indices)(j => elements(j) == newElements(j)),\n        ∀(elements.size until newElements.size)(j =>\n          ∀(i until other.elements.size)(k => newElements(j) != other.elements(k))),\n        ∀(0 until i)(j => Set.Elements.contain(newElements, other.elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val e = other.elements(i)\n      if (!contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          1 #> ∀(0 to i)(j => Set.Elements.contain(newElements, other.elements(j)))         by Premise,\n        )\n      } else {\n        Deduce(\n          1 #> ∀(0 to i)(j => Set.Elements.contain(newElements, other.elements(j)))         by Premise,\n        )\n      }\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def ∪(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size >= elements.size,\n        Set.elementsOf(Res).size <= elements.size + other.elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) |\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j => elements(j) == Set.elementsOf(Res)(j)),\n        ∀(other.elements.indices)(j => Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    return union(other)\n  }\n\n  @pure def intersect(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j =>\n          Set.Elements.contain(elements, other.elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        newElements.size <= i,\n        ∀(newElements.indices)(j => Set.Elements.contain(other.elements, newElements(j))),\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j))),\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(0 until i)(j => Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements)\n      )\n      val e = elements(i)\n      if (other.contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          //@formatter:off\n          1 #> ∀(0 to i)(j => Set.Elements.contain(other.elements, elements(j)) ->:\n            Set.Elements.contain(newElements, elements(j)))                                 by Premise,\n          2 #> Set.Elements.unique(newElements)                                             by Premise\n          //@formatter:on\n        )\n      }\n\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def ∩(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j =>\n          Set.Elements.contain(elements, other.elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    return intersect(other)\n  }\n\n  @pure def \\(other: Set[T]): Set[T] = {\n    Contract(\n      Ensures(\n        Set.elementsOf(Res).size <= elements.size,\n        ∀(Set.elementsOf(Res).indices)(j =>\n          Set.Elements.contain(elements, Set.elementsOf(Res)(j)) &\n            !Set.Elements.contain(other.elements, Set.elementsOf(Res)(j))),\n        ∀(elements.indices)(j =>\n          !Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(Set.elementsOf(Res), elements(j))),\n        ∀(other.elements.indices)(j => !Set.Elements.contain(Set.elementsOf(Res), other.elements(j)))\n      )\n    )\n    var newElements = ISZ[T]()\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(i, newElements),\n        0 <= i,\n        i <= elements.size,\n        newElements.size <= i,\n        ∀(newElements.indices)(j => !Set.Elements.contain(other.elements, newElements(j))),\n        ∀(newElements.indices)(j => Set.Elements.contain(elements, newElements(j))),\n        ∀(newElements.indices)(j => ∀(i until elements.size)(k => newElements(j) != elements(k))),\n        ∀(0 until i)(j => !Set.Elements.contain(other.elements, elements(j)) ->: Set.Elements.contain(newElements, elements(j))),\n        Set.Elements.unique(newElements),\n      )\n      val e = elements(i)\n      if (!other.contains(e)) {\n        newElements = newElements :+ e\n        Deduce(\n          //@formatter:off\n          1 #> ∀(0 to i)(j => !Set.Elements.contain(other.elements, elements(j)) ->:\n            Set.Elements.contain(newElements, elements(j)))                                 by Premise,\n          2 #> Set.Elements.unique(newElements)                                             by Premise\n          //@formatter:on\n        )\n      }\n\n      i = i + 1\n    }\n    return Set(newElements)\n  }\n\n  @pure def isEqual(other: Set[T]): B = {\n    Contract(\n      Case(\n        \"Equal\",\n        Requires(\n          elements. size == other.elements.size,\n          ∀(elements.indices)(j => Set.Elements.contain(other.elements, elements(j))),\n        ),\n        Ensures(Res[B])\n      ),\n      Case(\n        \"Inequal-diff\",\n        Requires(\n          elements.size == other.elements.size,\n          ∃(elements.indices)(j => !Set.Elements.contain(other.elements, elements(j))),\n        ),\n        Ensures(!Res[B])\n      ),\n      Case(\n        \"Inequal-size\",\n        Requires(elements.size != other.elements.size),\n        Ensures(!Res[B])\n      )\n    )\n    val sz = size\n    if (sz != other.size) {\n      return F\n    } else {\n      var i: Z = 0\n      var r = T\n      while (r & i < sz) {\n        Invariant(\n          Modifies(i, r),\n          0 <= i,\n          i <= sz,\n          r ->: ∀(0 until i)(j => Set.Elements.contain(other.elements, elements(j))),\n          !r ->: ∃(elements.indices)(j => !Set.Elements.contain(other.elements, elements(j)))\n        )\n        if (!other.contains(elements(i))) {\n          r = F\n        }\n        i = i + 1\n      }\n\n      return r\n    }\n  }\n\n  @pure override def hash: Z = {\n    return elements.hash\n  }\n\n  @pure def isEmpty: B = {\n    Contract(Ensures(Res == (elements.size == 0)))\n    return size == z\"0\"\n  }\n\n  @pure def nonEmpty: B = {\n    Contract(Ensures(Res == (elements.size != 0)))\n    return size != z\"0\"\n  }\n\n  @pure def size: Z = {\n    Contract(Ensures(Res == elements.size))\n    return elements.size\n  }\n\n  @pure def indexOf(e: T): Z = {\n    Contract(\n      Case(\n        \"In\",\n        Requires(Set.Elements.contain(elements, e)),\n        Ensures(\n          0 <= Res[Z],\n          Res[Z] < elements.size,\n          elements(Res[Z]) == e\n        )\n      ),\n      Case(\n        \"Not-in\",\n        Requires(!Set.Elements.contain(elements, e)),\n        Ensures(Res[Z] == -1)\n      )\n    )\n    var index: Z = -1\n    var i: Z = 0\n    while (i < elements.size) {\n      Invariant(\n        Modifies(index, i),\n        0 <= i,\n        i <= elements.size,\n        (index != -1) ->: (0 <= index & index < elements.size & elements(index) == e),\n        (index == -1) ->: ∀(0 until i)(j => e != elements(j))\n      )\n      if (elements(i) == e) {\n        index = i\n        i = elements.size - 1\n      }\n      i = i + 1\n    }\n    return index\n  }\n\n  @pure override def string: String = {\n    val r =\n      st\"\"\"{\n      |  ${(elements, \",\\n\")}\n      |}\"\"\"\n    return r.render\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$56();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #772                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject ContractUtil {\n\n  @strictpure def modPos(n: Z, m: Z): Z = if (n < m) n else n - m\n\n  @strictpure def modNeg(n: Z, m: Z): Z = if (n < 0) n + m else n\n\n  @strictpure def isEqualExcept[I, T](s1: IS[I, T], s2: IS[I, T], i: I): B =\n    s1.size == s2.size & All(s1.indices)(j => (j != i) ->: (s1(j) == s2(j)))\n\n  @strictpure def isEqualExcept2[I, T](s1: IS[I, T], s2: IS[I, T], i1: I, i2: I): B =\n    s1.size == s2.size & All(s1.indices)(j => ((j != i1) & (j != i2)) ->: (s1(j) == s2(j)))\n\n  @strictpure def msEqualExcept[I, T](s1: MS[I, T], s2: MS[I, T], i: I): B =\n    s1.size == s2.size & All(s1.indices)(j => (j != i) ->: (s1(j) == s2(j)))\n\n  @strictpure def msEqualExcept2[I, T](s1: MS[I, T], s2: MS[I, T], i1: I, i2: I): B =\n    s1.size == s2.size & All(s1.indices)(j => ((j != i1) & (j != i2)) ->: (s1(j) == s2(j)))\n\n  @strictpure def isAllIS[I, T](s: IS[I, T], e: T): B = All(s.indices)(i => s(i) == e)\n\n  @strictpure def isAllMS[I, T](s: MS[I, T], e: T): B = All(s.indices)(i => s(i) == e)\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$57();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #774                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum\n\nobject Poset {\n\n  type Index = Z\n\n  object Internal {\n\n    val emptySet: HashSSet[Poset.Index] = HashSSet.empty\n\n    @pure def addNode[T](poset: Poset[T], node: T): (Poset[T], Index) = {\n      poset.nodes.get(node) match {\n        case Some(n) => return (poset, n)\n        case _ =>\n          val n = poset.nodes.size\n          return (\n            poset(\n              nodes = poset.nodes + node ~> n,\n              nodesInverse = poset.nodesInverse :+ node,\n              parents = poset.parents + n ~> emptySet,\n              children = poset.children + n ~> emptySet\n            ),\n            n\n          )\n      }\n    }\n\n    @pure def addNodes[T](poset: Poset[T], nodes: ISZ[T]): (Poset[T], ISZ[Index]) = {\n      var r = poset\n      val s = ZS.create(nodes.size, 0)\n      var i = 0\n      for (nd <- nodes) {\n        val p = addNode(r, nd)\n        r = p._1\n        s(i) = p._2\n        i = i + 1\n      }\n      return (r, s.toIS)\n    }\n\n    @pure def addParents[T](poset: Poset[T], n: Index, ns: ISZ[Index]): Poset[T] = {\n      var changed = F\n      val newParents: HashSMap[Index, HashSSet[Index]] = {\n        val s = poset.parents.get(n).get\n        val newS = s ++ ns\n        if (newS.size != s.size) {\n          changed = T\n          poset.parents + n ~> newS\n        } else {\n          poset.parents\n        }\n      }\n      var newChildren: HashSMap[Index, HashSSet[Index]] = poset.children\n      for (c <- ns) {\n        newChildren = {\n          val s = newChildren.get(c).get\n          val newS = s + n\n          if (newS.size != s.size) {\n            changed = T\n            newChildren + c ~> newS\n          } else {\n            newChildren\n          }\n        }\n      }\n      return if (changed) poset(parents = newParents, children = newChildren) else poset\n    }\n\n    @pure def removeParent[T](poset: Poset[T], n: Index, parent: Index): Poset[T] = {\n      poset.parents.get(n) match {\n        case Some(s) =>\n          return poset(\n            parents = poset.parents + n ~> (s - parent),\n            children = poset.children + parent ~> (poset.children.get(parent).get - n)\n          )\n        case _ => return poset\n      }\n    }\n\n    @pure def addChildren[T](poset: Poset[T], n: Index, ns: ISZ[Index]): Poset[T] = {\n      var changed = F\n      val newChildren: HashSMap[Index, HashSSet[Index]] = {\n        val s = poset.children.get(n).get\n        val newS = s ++ ns\n        if (newS.size != s.size) {\n          changed = T\n          poset.children + n ~> newS\n        } else {\n          poset.children\n        }\n      }\n      var newParents: HashSMap[Index, HashSSet[Index]] = poset.parents\n      for (c <- ns) {\n        newParents = {\n          val s = newParents.get(c).get\n          val newS = s + n\n          if (newS.size != s.size) {\n            changed = T\n            newParents + c ~> newS\n          } else {\n            newParents\n          }\n        }\n      }\n      return if (changed) poset(parents = newParents, children = newChildren) else poset\n    }\n\n    @pure def childrenOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      poset.children.get(n) match {\n        case Some(s) => return s\n        case _ => return emptySet\n      }\n    }\n\n    @pure def parentsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      poset.parents.get(n) match {\n        case Some(s) => return s\n        case _ => return emptySet\n      }\n    }\n\n    @pure def ancestorsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      return ancestorsCache[T](poset, n, HashSMap.empty)._1\n    }\n\n    @pure def ancestorsCache[T](\n      poset: Poset[T],\n      n: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): (HashSSet[Index], HashSMap[Index, HashSSet[Index]]) = {\n      var mAcc = acc\n      var r = emptySet\n      for (nParent <- parentsOf(poset, n).elements) {\n        mAcc = ancestorsRec(poset, nParent, mAcc)\n        r = (r + nParent) ∪ mAcc.get(nParent).getOrElse(emptySet)\n      }\n      return (r, mAcc)\n    }\n\n    @pure def ancestorsRec[T](\n      poset: Poset[T],\n      m: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): HashSMap[Index, HashSSet[Index]] = {\n      if (acc.contains(m)) {\n        return acc\n      }\n      val p = ancestorsCache(poset, m, acc + m ~> emptySet)\n      val mAncestors = p._1\n      val mAcc = p._2\n      return mAcc + m ~> mAncestors\n    }\n\n    @pure def lub[T](poset: Poset[T], ns: ISZ[Index]): Option[Index] = {\n      ns.size match {\n        case z\"0\" => return None()\n        case z\"1\" => return Some(ns(0))\n        case _ =>\n      }\n      if ((HashSSet ++ ns).size == 1) {\n        return Some(ns(0))\n      }\n      val p0 = ancestorsCache[T](poset, ns(0), HashSMap.empty)\n      var commons = p0._1 + ns(0)\n      var acc = p0._2\n      for (i <- z\"1\" until ns.size) {\n        val p = ancestorsCache(poset, ns(i), acc)\n        acc = p._2\n        commons = commons ∩ (p._1 + ns(i))\n      }\n      if (commons.isEmpty) {\n        return None()\n      }\n      for (b1 <- commons.elements) {\n        for (b2 <- commons.elements if b1 != b2) {\n          if (ancestorsCache(poset, b1, acc)._1.contains(b2)) {\n            commons = commons - b2\n          }\n        }\n      }\n      if (commons.size == 1) {\n        return Some(commons.elements(0))\n      } else {\n        return None()\n      }\n    }\n\n    @pure def descendantsOf[T](poset: Poset[T], n: Index): HashSSet[Index] = {\n      return descendantsCache[T](poset, n, HashSMap.empty)._1\n    }\n\n    @pure def descendantsCache[T](\n      poset: Poset[T],\n      n: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): (HashSSet[Index], HashSMap[Index, HashSSet[Index]]) = {\n      var mAcc = acc\n      var r = emptySet\n      for (nChild <- childrenOf(poset, n).elements) {\n        mAcc = descendantsRec(poset, nChild, mAcc)\n        r = (r + nChild) ∪ mAcc.get(nChild).getOrElse(emptySet)\n      }\n      return (r, mAcc)\n    }\n\n    @pure def descendantsRec[T](\n      poset: Poset[T],\n      m: Index,\n      acc: HashSMap[Index, HashSSet[Index]]\n    ): HashSMap[Index, HashSSet[Index]] = {\n      if (acc.contains(m)) {\n        return acc\n      }\n      val p = descendantsCache(poset, m, acc + m ~> emptySet)\n      val mDescendants = p._1\n      val mAcc = p._2\n      return mAcc + m ~> mDescendants\n    }\n\n    @pure def glb[T](poset: Poset[T], ns: ISZ[Index]): Option[Index] = {\n      ns.size match {\n        case z\"0\" => return None()\n        case z\"1\" => return Some(ns(0))\n        case _ =>\n      }\n      if ((HashSSet.empty[Index] ++ ns).size == 1) {\n        return Some(ns(0))\n      }\n      val p0 = descendantsCache[T](poset, ns(0), HashSMap.empty)\n      var commons = p0._1 + ns(0)\n      var acc = p0._2\n      for (i <- z\"1\" until ns.size) {\n        val p = descendantsCache(poset, ns(i), acc)\n        acc = p._2\n        commons = commons ∩ (p._1 + ns(i))\n      }\n      if (commons.isEmpty) {\n        return None()\n      }\n      for (b1 <- commons.elements) {\n        for (b2 <- commons.elements if b1 != b2) {\n          if (descendantsCache(poset, b1, acc)._1.contains(b2)) {\n            commons = commons - b2\n          }\n        }\n      }\n      if (commons.size == 1) {\n        return Some(commons.elements(0))\n      } else {\n        return None()\n      }\n    }\n  }\n\n  def empty[T]: Poset[T] = {\n    return Poset[T](HashSMap.empty, ISZ(), HashSMap.empty, HashSMap.empty)\n  }\n}\n\nimport Poset._\n\n@datatype class Poset[T](\n  val nodes: HashSMap[T, Poset.Index],\n  val nodesInverse: IS[Poset.Index, T],\n  val parents: HashSMap[Poset.Index, HashSSet[Poset.Index]],\n  val children: HashSMap[Poset.Index, HashSSet[Poset.Index]]\n) {\n\n  val emptySet: HashSSet[T] = HashSSet.empty\n\n  @pure def size: Z = {\n    return nodes.size\n  }\n\n  @pure override def hash: Z = {\n    return size\n  }\n\n  @pure def isEqual(other: Poset[T]): B = {\n    if (nodesInverse != other.nodesInverse) {\n      return F\n    }\n    for (node <- nodes.keys) {\n      val n = nodes.get(node).get\n      val m = other.nodes.get(node).get\n      val nParents = HashSSet ++ parents.get(n).get.elements.map[T](np => nodesInverse(np))\n      val mParents = HashSSet ++ other.parents.get(m).get.elements.map[T](mp => other.nodesInverse(mp))\n      if (nParents != mParents) {\n        return F\n      }\n    }\n    return T\n  }\n\n  @pure def addNode(node: T): Poset[T] = {\n    return Poset.Internal.addNode(this, node)._1\n  }\n\n  @pure def rootNodes: ISZ[T] = {\n    return for (e <- parents.entries if e._2.isEmpty) yield nodesInverse(e._1)\n  }\n\n  @pure def addParents(node: T, nds: ISZ[T]): Poset[T] = {\n    var r = this\n    val n: Index = {\n      val p = Poset.Internal.addNode(r, node)\n      r = p._1\n      p._2\n    }\n    val ns: ISZ[Index] = {\n      val p = Poset.Internal.addNodes(r, nds)\n      r = p._1\n      p._2\n    }\n    return Poset.Internal.addParents(r, n, ns)\n  }\n\n  @pure def removeParent(node: T, parent: T): Poset[T] = {\n    (nodes.get(node), nodes.get(parent)) match {\n      case (Some(n), Some(p)) => return Poset.Internal.removeParent(this, n, p)\n      case _ => return this\n    }\n  }\n\n  @pure def removeChild(n: T, child: T): Poset[T] = {\n    return removeParent(child, n)\n  }\n\n  @pure def addChildren(node: T, nds: ISZ[T]): Poset[T] = {\n    var r = this\n    val n: Index = {\n      val p = Poset.Internal.addNode(r, node)\n      r = p._1\n      p._2\n    }\n    val ns: ISZ[Index] = {\n      val p = Poset.Internal.addNodes(r, nds)\n      r = p._1\n      p._2\n    }\n    return Poset.Internal.addChildren(r, n, ns)\n  }\n\n  @pure def childrenOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.childrenOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def isChildOf(node1: T, node2: T): B = {\n    (nodes.get(node1), nodes.get(node2)) match {\n      case (Some(n1), Some(n2)) => return Poset.Internal.childrenOf(this, n1).contains(n2)\n      case _ => return F\n    }\n  }\n\n  @pure def parentsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.parentsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def isParentOf(node1: T, node2: T): B = {\n    return isChildOf(node2, node1)\n  }\n\n  @pure def ancestorsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.ancestorsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def lub(nds: ISZ[T]): Option[T] = {\n    val ns: ISZ[Index] = for (node <- nds; n <- nodes.get(node).toIS) yield n\n    return Poset.Internal.lub(this, ns).map(n => nodesInverse(n))\n  }\n\n  @pure def descendantsOf(node: T): HashSSet[T] = {\n    nodes.get(node) match {\n      case Some(n) => HashSSet ++ Poset.Internal.descendantsOf(this, n).elements.map[T](n => nodesInverse(n))\n      case _ => return emptySet\n    }\n  }\n\n  @pure def glb(nds: ISZ[T]): Option[T] = {\n    val ns: ISZ[Index] = for (node <- nds; n <- nodes.get(node).toIS) yield n\n    return Poset.Internal.glb(this, ns).map(n => nodesInverse(n))\n  }\n\n  @pure def toST(f: T => ST): ST = {\n    val nodes: ISZ[ST] = for (e <- this.nodes.entries) yield st\"n${e._2} ${f(e._1)}\"\n    val edges: ISZ[ST] = for (entry <- parents.entries; parent <- entry._2.elements) yield st\"n${entry._1} -> n$parent\"\n    val r =\n      st\"\"\"digraph G {\n      |  rankdir=\"BT\"\n      |\n      |  ${(nodes, \"\\n\")}\n      |\n      |  ${(edges, \"\\n\")}\n      |}\"\"\"\n    return r\n  }\n\n  @pure override def string: String = {\n    return toST(node => st\"\"\"[label=\"$node\"]\"\"\").render\n  }\n}\n
         3: areturn
      LineNumberTable:
        line 31: 0

  private static final java.lang.String f0$58();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #776                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n@ext object Asm {\n  def eraseNonNative(path: Os.Path): Unit = $\n  def rewriteReleaseFence(path: Os.Path): Unit = $\n  def rewriteSetSecurityManager(path: Os.Path): Unit = $\n}\n
         3: areturn
      LineNumberTable:
        line 42: 0

  private static final java.lang.String f0$59();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #778                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.project\n\nimport org.sireum._\nimport org.sireum.project.PublishInfo._\n\nobject ProjectUtil {\n\n  val sharedSuffix: String = \"shared\"\n  val jvmSuffix: String = \"jvm\"\n  val jsSuffix: String = \"js\"\n\n  val bsd2License: License = License(\n    name = \"BSD 2-Clause\",\n    url = \"https://github.com/sireum/kekinian/blob/master/license.txt\",\n    distribution = \"repo\"\n  )\n  val bsd2: ISZ[License] = ISZ(bsd2License)\n\n  val robby: Developer = Developer(id = \"robby-phd\", name = \"Robby\")\n  val johnHatcliff: Developer = Developer(id = \"John-Hatcliff\", name = \"John Hatcliff\")\n  val jasonBelt: Developer = Developer(id = \"jasonbelt\", name = \"Jason Belt\")\n  val thari: Developer = Developer(id = \"thari\", name = \"Hariharan Thiagarajan\")\n  val matthewWeis: Developer = Developer(id = \"matthewweis\", name = \"Matthew Weis\")\n\n  @strictpure def id(baseId: String): ISZ[String] = ISZ(baseId)\n\n  @strictpure def sharedId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$sharedSuffix\")\n\n  @strictpure def jvmId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$jvmSuffix\")\n\n  @strictpure def jsId(baseId: String): ISZ[String] = ISZ(s\"$baseId-$jsSuffix\")\n\n  @strictpure def sharedJvmId(baseId: String): ISZ[String] = sharedId(baseId) ++ jvmId(baseId)\n\n  @strictpure def sharedJsId(baseId: String): ISZ[String] = sharedId(baseId) ++ jsId(baseId)\n\n  def dirs(base: Os.Path, segss: ISZ[ISZ[String]]): ISZ[String] = {\n    var r = ISZ[String]()\n    for (segs <- segss) {\n      r = r :+ st\"${(segs, Os.fileSep)}\".render\n    }\n    return r\n  }\n\n  def mavenSourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(\n      ISZ(\"src\", \"main\", \"java\"),\n      ISZ(\"src\", \"main\", \"scala\")))\n  }\n\n  def mavenTestSourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(\n      ISZ(\"src\", \"test\", \"java\"),\n      ISZ(\"src\", \"test\", \"scala\")))\n  }\n\n  def mavenResourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(ISZ(\"src\", \"main\", \"resources\")))\n  }\n\n  def mavenTestResourceDirs(base: Os.Path): ISZ[String] = {\n    return dirs(base, ISZ(ISZ(\"src\", \"test\", \"resources\")))\n  }\n\n  @pure def moduleSharedPub(id: String,\n                            baseDir: Os.Path,\n                            sharedDeps: ISZ[String],\n                            sharedIvyDeps: ISZ[String],\n                            pubOpt: Option[PublishInfo]): Module = {\n    val sharedDir = baseDir / sharedSuffix\n    val shared = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$sharedSuffix\"),\n      deps = sharedDeps,\n      targets = Module.allTargets,\n      ivyDeps = sharedIvyDeps,\n      sources = mavenSourceDirs(sharedDir),\n      resources = mavenResourceDirs(sharedDir),\n      testSources = mavenTestSourceDirs(sharedDir),\n      testResources = mavenTestResourceDirs(sharedDir),\n      publishInfoOpt = pubOpt\n    )\n    return shared\n  }\n\n  @strictpure def moduleShared(id: String,\n                               baseDir: Os.Path,\n                               sharedDeps: ISZ[String],\n                               sharedIvyDeps: ISZ[String]): Module =\n    moduleSharedPub(\n      id = id,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleJvmPub(id: String,\n                         baseDir: Os.Path,\n                         jvmDeps: ISZ[String],\n                         jvmIvyDeps: ISZ[String],\n                         pubOpt: Option[PublishInfo]): Module = {\n    val jvmDir = baseDir / jvmSuffix\n    val jvm = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$jvmSuffix\"),\n      deps = jvmDeps,\n      targets = ISZ(Target.Jvm),\n      ivyDeps = jvmIvyDeps,\n      sources = mavenSourceDirs(jvmDir),\n      resources = mavenResourceDirs(jvmDir),\n      testSources = mavenTestSourceDirs(jvmDir),\n      testResources = mavenTestResourceDirs(jvmDir),\n      publishInfoOpt = pubOpt\n    )\n    return jvm\n  }\n\n  @strictpure def moduleJvm(id: String,\n                            baseDir: Os.Path,\n                            jvmDeps: ISZ[String],\n                            jvmIvyDeps: ISZ[String]): Module =\n    moduleJvmPub(id, baseDir, jvmDeps, jvmIvyDeps, None())\n\n  @pure def moduleJsPub(id: String,\n                        baseDir: Os.Path,\n                        jsDeps: ISZ[String],\n                        jsIvyDeps: ISZ[String],\n                        pubOpt: Option[PublishInfo]): Module = {\n    val jsDir = baseDir / jsSuffix\n    val js = Module(\n      id = id,\n      basePath = baseDir.string,\n      subPathOpt = Some(s\"${Os.fileSep}$jsSuffix\"),\n      deps = jsDeps,\n      targets = ISZ(Target.Js),\n      ivyDeps = jsIvyDeps,\n      sources = mavenSourceDirs(jsDir),\n      resources = mavenResourceDirs(jsDir),\n      testSources = mavenTestSourceDirs(jsDir),\n      testResources = mavenTestResourceDirs(jsDir),\n      publishInfoOpt = pubOpt\n    )\n    return js\n  }\n\n  @strictpure def moduleJs(id: String,\n                           baseDir: Os.Path,\n                           jsDeps: ISZ[String],\n                           jsIvyDeps: ISZ[String]): Module =\n    moduleJsPub(\n      id = id,\n      baseDir = baseDir,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleSharedJvmPub(baseId: String,\n                               baseDir: Os.Path,\n                               sharedDeps: ISZ[String],\n                               sharedIvyDeps: ISZ[String],\n                               jvmDeps: ISZ[String],\n                               jvmIvyDeps: ISZ[String],\n                               pubOpt: Option[PublishInfo]): (Module, Module) = {\n    val shared = moduleSharedPub(s\"$baseId-$sharedSuffix\", baseDir, sharedDeps, sharedIvyDeps, pubOpt)\n    val jvm = moduleJvmPub(baseId, baseDir, jvmDeps :+ shared.id, jvmIvyDeps, pubOpt)\n    return (shared, jvm)\n  }\n\n  @strictpure def moduleSharedJvm(baseId: String,\n                                  baseDir: Os.Path,\n                                  sharedDeps: ISZ[String],\n                                  sharedIvyDeps: ISZ[String],\n                                  jvmDeps: ISZ[String],\n                                  jvmIvyDeps: ISZ[String]): (Module, Module) =\n    moduleSharedJvmPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jvmDeps = jvmDeps,\n      jvmIvyDeps = jvmIvyDeps,\n      pubOpt = None()\n    )\n\n\n  @pure def moduleSharedJsPub(baseId: String,\n                              baseDir: Os.Path,\n                              sharedDeps: ISZ[String],\n                              sharedIvyDeps: ISZ[String],\n                              jsDeps: ISZ[String],\n                              jsIvyDeps: ISZ[String],\n                              pubOpt: Option[PublishInfo]): (Module, Module) = {\n    val shared = moduleSharedPub(s\"$baseId-$sharedSuffix\", baseDir, sharedDeps, sharedIvyDeps, pubOpt)\n    val js = moduleJsPub(baseId, baseDir, jsDeps :+ shared.id, jsIvyDeps, pubOpt)\n    return (shared, js)\n  }\n\n  @strictpure def moduleSharedJs(baseId: String,\n                                 baseDir: Os.Path,\n                                 sharedDeps: ISZ[String],\n                                 sharedIvyDeps: ISZ[String],\n                                 jsDeps: ISZ[String],\n                                 jsIvyDeps: ISZ[String]): (Module, Module) =\n    moduleSharedJsPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @pure def moduleSharedJvmJsPub(baseId: String,\n                                 baseDir: Os.Path,\n                                 sharedDeps: ISZ[String],\n                                 sharedIvyDeps: ISZ[String],\n                                 jvmDeps: ISZ[String],\n                                 jvmIvyDeps: ISZ[String],\n                                 jsDeps: ISZ[String],\n                                 jsIvyDeps: ISZ[String],\n                                 pubOpt: Option[PublishInfo]): (Module, Module, Module) = {\n    val (shared, js) = moduleSharedJsPub(baseId, baseDir, sharedDeps, sharedIvyDeps, jsDeps, jsIvyDeps, pubOpt)\n    val jvm = moduleJvmPub(baseId, baseDir, jvmDeps :+ shared.id, jvmIvyDeps, pubOpt)\n    return (shared, jvm, js(id = s\"$baseId-$jsSuffix\"))\n  }\n\n  @strictpure def moduleSharedJvmJs(baseId: String,\n                                    baseDir: Os.Path,\n                                    sharedDeps: ISZ[String],\n                                    sharedIvyDeps: ISZ[String],\n                                    jvmDeps: ISZ[String],\n                                    jvmIvyDeps: ISZ[String],\n                                    jsDeps: ISZ[String],\n                                    jsIvyDeps: ISZ[String]): (Module, Module, Module) =\n    moduleSharedJvmJsPub(\n      baseId = baseId,\n      baseDir = baseDir,\n      sharedDeps = sharedDeps,\n      sharedIvyDeps = sharedIvyDeps,\n      jvmDeps = jvmDeps,\n      jvmIvyDeps = jvmIvyDeps,\n      jsDeps = jsDeps,\n      jsIvyDeps = jsIvyDeps,\n      pubOpt = None()\n    )\n\n  @strictpure def pub(desc: String,\n                      url: String,\n                      licenses: ISZ[PublishInfo.License],\n                      devs: ISZ[PublishInfo.Developer]): Option[PublishInfo] =\n    Some(\n      PublishInfo(\n        description = desc,\n        url = url,\n        licenses = licenses,\n        developers = devs\n      )\n    )\n\n  @pure def toDot(p: Project): String = {\n    @pure def node2st(name: String): ST = {\n      p.modules.get(name) match {\n        case Some(m) =>\n          val targets = HashSet.empty[Target.Type] ++ m.targets\n          if (targets.contains(Target.Jvm) && targets.contains(Target.Js)) {\n            return st\"\"\"[shape = \"rect\", label=\"$name\"]\"\"\"\n          } else if (targets.contains(Target.Jvm)) {\n            return st\"\"\"[shape = \"trapezium\", label=\"$name\"]\"\"\"\n          } else {\n            return st\"\"\"[shape = \"invtrapezium\", label=\"$name\"]\"\"\"\n          }\n        case _ => return st\"\"\"[shape = \"octagon\", label=\"$name\"]\"\"\"\n      }\n    }\n\n    return p.poset.toST(node2st _).render\n  }\n\n  def projectCli(args: ISZ[String], project: Project): Unit = {\n\n    def usage(): Unit = {\n      println(\"Usage: [ json ]\")\n    }\n\n    var isDot = T\n\n    args match {\n      case ISZ(string\"json\") => isDot = F\n      case ISZ(string\"-h\") =>\n        usage()\n        Os.exit(0)\n      case ISZ() =>\n      case _ =>\n        usage()\n        Os.exit(-1)\n    }\n\n    if (isDot) {\n      println(toDot(project))\n    } else {\n      println(JSON.fromProject(project, T))\n    }\n  }\n\n  @pure def projectJsonLine(text: String): Option[String] = {\n    val prefix = \"{  \\\"type\\\" : \\\"Project\\\"\"\n    for (line <- ops.StringOps(text).split((c: C) => c === \'\\n\')) {\n      var first = 0\n      var last = line.size - 1\n      val lineCis = conversions.String.toCis(line)\n      while (first < line.size && lineCis(first) != \'{\') {\n        first = first + 1\n      }\n      while (last >= 0 && lineCis(last) != \'}\') {\n        last = last - 1\n      }\n      val slicedLine: String =\n        if (first == 0 && last == line.size) line\n        else conversions.String.fromCis(ops.ISZOps(lineCis).slice(first, last + 1))\n      if (ops.StringOps(slicedLine).startsWith(prefix)) {\n        return Some(line)\n      }\n    }\n    return None()\n  }\n\n  def loadFromBaseDirs(baseDirs: ISZ[Os.Path]): Option[Project] = {\n    var r = Project.empty\n    for (baseDir <- baseDirs) {\n      val pJsonFile = baseDir / \"project.json\"\n      val cmdFile = baseDir / \"bin\" / \"project.cmd\"\n      var loaded = F\n      if (pJsonFile.exists && cmdFile.exists && cmdFile.lastModified < pJsonFile.lastModified) {\n        load(pJsonFile) match {\n          case Some(prj) =>\n            println(s\"Loading from $pJsonFile ...\")\n            r = r ++ prj\n            loaded = T\n          case _ =>\n        }\n      }\n      if (!loaded) {\n        println(s\"Loading from $cmdFile ...\")\n        val pr = proc\"$cmdFile json\".redirectErr.run()\n        if (pr.ok) {\n          projectJsonLine(pr.out) match {\n            case Some(line) => JSON.toProject(line) match {\n              case Either.Left(prj) =>\n                r = r ++ prj\n                loaded = T\n                store(pJsonFile, prj)\n                println(s\"Wrote $pJsonFile\")\n              case _ =>\n            }\n            case _ =>\n          }\n        } else {\n          eprintln(s\"Failed to load from $cmdFile\")\n          println(pr.out)\n          eprintln(pr.err)\n        }\n      }\n      if (!loaded) {\n        return None()\n      }\n    }\n    return Some(r)\n  }\n\n  def load(path: Os.Path): Option[Project] = {\n    if (!path.isFile) {\n      return None()\n    }\n    val parser = org.sireum.project.JSON.Parser(path.read)\n    val p = parser.parseProject()\n    if (parser.errorOpt.nonEmpty) {\n      return None()\n    }\n    var r = Project.empty(mavenRepoUrls = p.mavenRepoUrls)\n    for (m <- p.modules.values) {\n      r = r + m\n    }\n    return Some(r)\n  }\n\n  def store(path: Os.Path, prj: Project): Unit = {\n    path.writeOver(org.sireum.project.JSON.fromProject(prj(poset = Poset.empty), F))\n  }\n\n  @strictpure def pathSep(base: Os.Path, sub: String): Os.Path =\n    if (ops.StringOps(sub).startsWith(Os.fileSep)) Os.path(s\"$base$sub\")\n    else base / sub\n\n  @strictpure def moduleBasePath(m: Module): Os.Path = m.subPathOpt match {\n    case Some(sp) => pathSep(Os.path(m.basePath), sp)\n    case _ => Os.path(m.basePath)\n  }\n\n  @strictpure def moduleSources(m: Module): ISZ[Os.Path] =\n    for (p <- for (source <- m.sources) yield pathSep(moduleBasePath(m), source) if p.exists) yield p\n\n  @strictpure def moduleResources(m: Module): ISZ[Os.Path] =\n    for (p <- for (resource <- m.resources) yield pathSep(moduleBasePath(m), resource) if p.exists) yield p\n\n  @strictpure def moduleTestSources(m: Module): ISZ[Os.Path] =\n    for (p <- for (testSource <- m.testSources) yield pathSep(moduleBasePath(m), testSource) if p.exists) yield p\n\n  @strictpure def moduleTestResources(m: Module): ISZ[Os.Path] =\n    for (p <- for (testResource <- m.testResources) yield pathSep(moduleBasePath(m), testResource) if p.exists) yield p\n}\n
         3: areturn
      LineNumberTable:
        line 42: 0

  private static final java.lang.String f0$60();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #780                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.sireum.project\n\nimport org.sireum._\n\nobject DependencyManager {\n  @datatype class Lib(val name: String,\n                      val org: String,\n                      val module: String,\n                      val version: String,\n                      val main: String,\n                      val sourcesOpt: Option[String],\n                      val javadocOpt: Option[String])\n\n  val javaKey: String = \"org.sireum.version.zulu\"\n  val jbrKey: String = \"org.sireum.version.jbr\"\n  val scalacPluginKey: String = \"org.sireum::scalac-plugin:\"\n  val scalaKey: String = \"org.scala-lang:scala-library:\"\n  val scalaJsKey: String = \"org.scala-js:::scalajs-compiler:\"\n  val scalaTestKey: String = \"org.scalatest::scalatest::\"\n  val macrosKey: String = \"org.sireum.kekinian::macros:\"\n  val testKey: String = \"org.sireum.kekinian::test:\"\n  val libraryKey: String = \"org.sireum.kekinian::library:\"\n  val librarySharedKey: String = \"org.sireum.kekinian::library-shared:\"\n\n  val jarSuffix: String = \".jar\"\n  val sourceJarSuffix: String = \"-sources.jar\"\n  val docJarSuffix: String = \"-javadoc.jar\"\n\n  val ignoredLibraryNames: HashSet[String] = HashSet ++ ISZ[String](\n    \"org.scala-lang.scala-library\", \"org.scala-lang.scala-reflect\", \"org.scala-lang.scala-compiler\"\n  )\n\n  @pure def buildClassifiers(withSource: B, withDoc: B): ISZ[CoursierClassifier.Type] = {\n    var classifiers = ISZ[CoursierClassifier.Type](CoursierClassifier.Default)\n    if (withSource) {\n      classifiers = classifiers :+ CoursierClassifier.Sources\n    }\n    if (withDoc) {\n      classifiers = classifiers :+ CoursierClassifier.Javadoc\n    }\n    return classifiers\n  }\n\n  @strictpure def libName(cif: CoursierFileInfo): String = s\"${cif.org}.${cif.module}\"\n}\n\nimport DependencyManager._\n\n@record class DependencyManager(val project: Project,\n                                val versions: HashSMap[String, String],\n                                val isJs: B,\n                                val withSource: B,\n                                val withDoc: B,\n                                val javaHome: Os.Path,\n                                val scalaHome: Os.Path,\n                                val sireumHome: Os.Path,\n                                val cacheOpt: Option[Os.Path]) {\n\n  val sireumJar: Os.Path = sireumHome / \"bin\" / \"sireum.jar\"\n\n  val _scalacPlugin: Os.Path = sireumHome / \"lib\" / s\"scalac-plugin-${versions.get(scalacPluginKey).get}.jar\"\n\n  def scalacPlugin: Os.Path = {\n    if (_scalacPlugin.exists) {\n      return _scalacPlugin\n    }\n    val version = versions.get(scalacPluginKey).get\n    val url = s\"https://github.com/sireum/scalac-plugin/releases/download/$version/scalac-plugin-$version.jar\"\n    val cacheDir: Os.Path = Os.env(\"SIREUM_CACHE\") match {\n      case Some(v) => Os.path(v)\n      case _ => Os.home / \"Downloads\" / \"sireum\"\n    }\n    cacheDir.mkdirAll()\n    _scalacPlugin.up.mkdirAll()\n    val pluginCache = cacheDir / _scalacPlugin.name\n    if (!pluginCache.exists) {\n      println(s\"Please wait while downloading Slang scalac plugin $version ...\")\n      pluginCache.downloadFrom(url)\n      println()\n    }\n    pluginCache.copyOverTo(_scalacPlugin)\n    return _scalacPlugin\n  }\n\n  val javaVersion: String = versions.get(DependencyManager.javaKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Java version (key: ${DependencyManager.javaKey})\")\n  }\n\n  val scalaVersion: String = versions.get(DependencyManager.scalaKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Scala version (key: ${DependencyManager.scalaKey})\")\n  }\n\n  val scalaMajorVersion: String = {\n    val verOps = ops.StringOps(scalaVersion)\n    val i = verOps.indexOf(\'.\')\n    val j = verOps.indexOfFrom(\'.\', i + 1)\n    verOps.substring(0, j)\n  }\n\n  val scalaJsVersion: String = versions.get(DependencyManager.scalaJsKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find Scala.js version (key: ${DependencyManager.scalaJsKey})\")\n  }\n\n  val sjsSuffix: String = {\n    val verOps = ops.StringOps(scalaJsVersion)\n    val i = verOps.indexOf(\'.\')\n    s\"_sjs${verOps.substring(0, i)}\"\n  }\n\n  val scalaTestVersion: String = versions.get(DependencyManager.scalaTestKey) match {\n    case Some(v) => v\n    case _ => halt(s\"Could not find ScalaTest version (key: ${DependencyManager.scalaTestKey})\")\n  }\n\n  val ivyDeps: HashSMap[String, String] = {\n    var r = HashSMap.empty[String, String]\n    for (m <- project.modules.values) {\n      for (ivyDep <- m.ivyDeps) {\n        val v = getVersion(ivyDep)\n        val ivyDepOps = ops.StringOps(ivyDep)\n        if (isJs && ivyDepOps.endsWith(\"::\")) {\n          val dep = s\"${ivyDepOps.substring(0, ivyDep.size - 2)}$sjsSuffix:\"\n          r = r + ivyDep ~> s\"$dep$v\"\n        } else {\n          r = r + ivyDep ~> s\"$ivyDep$v\"\n        }\n      }\n    }\n    r\n  }\n\n  var _libMap: HashSMap[String, Lib] = HashSMap.empty\n\n  def libMap: HashSMap[String, Lib] = {\n    if (_libMap.isEmpty) {\n      var r = HashSMap.empty[String, Lib]\n      for (cif <- fetchClassifiers(ivyDeps.values, buildClassifiers(withSource, withDoc))) {\n        val name = libName(cif)\n        val p = cif.path\n        val pNameOps = ops.StringOps(p.string)\n        if (!ignoredLibraryNames.contains(name)) {\n          var lib: Lib = r.get(name) match {\n            case Some(l) => l\n            case _ => Lib(name, cif.org, cif.module, cif.version, \"\", None(), None())\n          }\n          if (pNameOps.endsWith(sourceJarSuffix)) {\n            lib = lib(sourcesOpt = Some(p.string))\n          } else if (pNameOps.endsWith(docJarSuffix)) {\n            lib = lib(javadocOpt = Some(p.string))\n          } else if (pNameOps.endsWith(jarSuffix)) {\n            lib = lib(main = p.string)\n          } else {\n            halt(s\"Expecting a file with .jar extension but found \'$p\'\")\n          }\n          r = r + name ~> lib\n        }\n      }\n      _libMap = r\n    }\n    return _libMap\n  }\n\n  var tLibMap: HashMap[String, ISZ[Lib]] = HashMap.empty\n\n  var dLibMap: HashMap[String, ISZ[Lib]] = HashMap.empty\n\n  @pure def getVersion(ivyDep: String): String = {\n    versions.get(ivyDep) match {\n      case Some(v) => return v\n      case _ => halt(s\"Could not find version information for \'$ivyDep\' in $versions\")\n    }\n  }\n\n  @pure def getModule(id: String): Module = {\n    project.modules.get(id) match {\n      case Some(m) => return m\n      case _ => halt(s\"Could not find module with ID \'$id\'\")\n    }\n  }\n\n  @memoize def computeTransitiveDeps(m: Module): ISZ[String] = {\n    var r = HashSSet.empty[String]\n    for (mDep <- m.deps) {\n      r = r + mDep ++ computeTransitiveDeps(getModule(mDep))\n    }\n    return r.elements\n  }\n\n  @memoize def computeTransitiveIvyDeps(m: Module): ISZ[String] = {\n    var r = HashSSet.empty[String]\n    for (mid <- m.deps) {\n      r = r ++ computeTransitiveIvyDeps(project.modules.get(mid).get)\n    }\n    for (id <- m.ivyDeps) {\n      r = r + ivyDeps.get(id).get\n    }\n    return r.elements\n  }\n\n  def fetchTransitiveLibs(m: Module): ISZ[Lib] = {\n    tLibMap.get(m.id) match {\n      case Some(libs) => return libs\n      case _ =>\n    }\n    val r: ISZ[Lib] =\n      for (cif <- fetch(computeTransitiveIvyDeps(m)) if !ignoredLibraryNames.contains(libName(cif))) yield libMap.get(libName(cif)).get\n    tLibMap = tLibMap + m.id ~> r\n    return r\n  }\n\n  def fetchDiffLibs(m: Module): ISZ[Lib] = {\n    dLibMap.get(m.id) match {\n      case Some(libs) => return libs\n      case _ =>\n    }\n    var s = HashSSet ++ fetchTransitiveLibs(m)\n    for (mDep <- m.deps) {\n      s = s -- fetchTransitiveLibs(getModule(mDep))\n    }\n    val r = s.elements\n    dLibMap = dLibMap + m.id ~> r\n    return r\n  }\n\n  def fetch(ivyDeps: ISZ[String]): ISZ[CoursierFileInfo] = {\n    return fetchClassifiers(ivyDeps, ISZ(CoursierClassifier.Default))\n  }\n\n  def fetchClassifiers(ivyDeps: ISZ[String], classifiers: ISZ[CoursierClassifier.Type]): ISZ[CoursierFileInfo] = {\n    val oldScalaVersion = Coursier.scalaVersion\n    val oldCacheOpt = Coursier.cacheOpt\n    val oldRepoUrls = Coursier.mavenRepoUrls\n    Coursier.addMavenRepositories(project.mavenRepoUrls)\n    Coursier.setCache(cacheOpt)\n    val r = Coursier.fetchClassifiers(ivyDeps, classifiers)\n    Coursier.setScalaVersion(oldScalaVersion)\n    Coursier.setCache(oldCacheOpt)\n    Coursier.setMavenRepositories(oldRepoUrls)\n    return r\n  }\n}\n\n
         3: areturn
      LineNumberTable:
        line 42: 0

  private static final java.lang.String f0$61();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #782                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject GitHub {\n\n  @datatype trait Credential\n\n  @datatype class Repository(connection: Option[Credential],\n                             owner: String,\n                             name: String) {\n    def latestRelease: Release = {\n      return Ext.latestRelease(this)\n    }\n\n    def releases: Jen[Release] = {\n      return Ext.releases(this)\n    }\n  }\n\n  @datatype class Release(repo: Repository,\n                          id: Z,\n                          name: String,\n                          publishedTime: Z,\n                          isDraft: B,\n                          isPrerelease: B,\n                          tagName: String,\n                          commit: String,\n                          tarUrl: String,\n                          zipUrl: String) {\n    def assets: Jen[Asset] = {\n      return Ext.assets(this)\n    }\n  }\n\n  @datatype class Asset(release: Release,\n                        id: Z,\n                        name: String,\n                        label: String,\n                        state: String,\n                        size: Z,\n                        contentType: String,\n                        url: String,\n                        downloadCount: Z) {\n\n  }\n\n  @strictpure def repo(owner: String, repo: String): Repository = Repository(None(), owner, repo)\n\n  @ext(\"GitHub_Ext\") object Ext {\n\n    def latestRelease(repo: Repository): Release = $\n\n    def releases(repo: Repository): Jen[Release] = $\n\n    def assets(release: Release): Jen[Asset] = $\n  }\n}\n\n
         3: areturn
      LineNumberTable:
        line 42: 0

  private static final java.lang.String f0$62();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #784                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\nobject Os {\n\n  @pure def cliArgs: ISZ[String] = {\n    return Ext.cliArgs\n  }\n\n  @memoize def cwd: Path = {\n    return Path.Impl(Ext.cwd)\n  }\n\n  def exit(code: Z): Unit = {\n    Ext.exit(code)\n  }\n\n  def env(name: String): Option[String] = {\n    return Ext.env(name)\n  }\n\n  def envs: Map[String, String] = {\n    return Ext.envs\n  }\n\n  @pure def fileSep: String = {\n    return Ext.fileSep\n  }\n\n  @pure def uriToPath(uri: String): Os.Path = {\n    return Path.Impl(Ext.fromUri(uri))\n  }\n\n  @memoize def home: Path = {\n    return Path.Impl(Ext.home)\n  }\n\n  @pure def isLinux: B = {\n    return kind == Kind.Linux\n  }\n\n  @pure def isMac: B = {\n    return kind == Kind.Mac\n  }\n\n  @pure def isWin: B = {\n    return kind == Kind.Win\n  }\n\n  @pure def pathSep: String = {\n    return Ext.pathSep\n  }\n\n  @pure def lineSep: String = {\n    return Ext.lineSep\n  }\n\n  @pure def pathSepChar: C = {\n    return Ext.pathSepChar\n  }\n\n  @pure def kind: Kind.Type = {\n    return Ext.os\n  }\n\n  @pure def readIndexableCFrom(url: String): Indexable.Pos[C] = {\n    return Ext.readIndexableCUrl(url)\n  }\n\n  @pure def path(value: String): Path = {\n    if (isWin) {\n      val sOps = ops.StringOps(value)\n      val cygPrefix: String = \"/cygdrive/\"\n      if (sOps.startsWith(cygPrefix)) {\n        return Path.Impl(\n          ops.StringOps(s\"${sOps.substring(cygPrefix.size, cygPrefix.size + 1)}:${sOps.substring(cygPrefix.size + 1, value.size)}\").replaceAllChars(\'/\', \'\\\\\'))\n\n      } else if (sOps.startsWith(\"/\") && env(\"OSTYPE\") == Some(\"msys\")) {\n        return Path.Impl(ops.StringOps(s\"${sOps.substring(1, 2)}:${sOps.substring(2, value.size)}\").\n          replaceAllChars(\'/\', \'\\\\\'))\n      }\n    }\n    return Path.Impl(Ext.norm(value))\n  }\n\n  @pure def proc(commands: ISZ[String]): Proc = {\n    return Proc(commands, cwd, Map.empty, T, None(), F, F, F, F, F, 0, F, F, None(), None())\n  }\n\n  @pure def procs(commands: String): Proc = {\n    val cmds: ISZ[String] = for (cmd <- ops.StringOps(commands).split((c: C) => c == \' \')) yield\n      ops.StringOps(cmd).replaceAllChars(\'␣\', \' \')\n    return proc(cmds)\n  }\n\n  @memoize def roots: ISZ[Path] = {\n    return for (root <- Ext.roots) yield Path.Impl(root)\n  }\n\n  def slashDir: Os.Path = {\n    return Os.path(Ext.slashDir)\n  }\n\n  def temp(): Path = {\n    val r = tempFix(\"\", \"\")\n    return r\n  }\n\n  def tempFix(prefix: String, suffix: String): Path = {\n    val r = Ext.temp(prefix, suffix)\n    return Path.Impl(r)\n  }\n\n  def tempDir(): Path = {\n    val r = tempDirFix(\"\")\n    return r\n  }\n\n  def tempDirFix(prefix: String): Path = {\n    val r = Ext.tempDir(prefix)\n    return Path.Impl(r)\n  }\n\n\n  @enum object Kind {\n    \'Mac\n    \'Linux\n    \'LinuxArm\n    \'Win\n    \'Unsupported\n  }\n\n  object Path {\n\n    @enum object Kind {\n      \'Dir\n      \'File\n      \'SymLink\n      \'Other\n    }\n\n    @enum object WriteMode {\n      \'Regular\n      \'Over\n      \'Append\n    }\n\n    @datatype class Impl(val value: String) extends Path {\n      override def string: String = {\n        return value\n      }\n    }\n\n    @sig trait Jen[T] extends org.sireum.Jen[T] {\n      def path: Path\n      override def string: String = {\n        return s\"Jen($path)\"\n      }\n    }\n\n    @msig trait MJen[T] extends org.sireum.MJen[T] {\n      def path: Path\n      override def string: String = {\n        return s\"MJen($path)\"\n      }\n    }\n\n    def overlay(isMove: B, path: Os.Path, target: Os.Path, includeDir: B, followLink: B,\n                pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      var r = HashSMap.empty[Os.Path, Os.Path]\n      val files = ops.ISZOps(walk(path, includeDir, T, pred)).reverse\n      for (p <- files) {\n        val t = target / path.relativize(p).string\n        p.kind match {\n          case Kind.Dir =>\n            t.mkdirAll()\n            if (isMove) {\n              p.remove()\n            }\n            if (report) {\n              r = r + p ~> t\n            }\n          case Kind.File =>\n            t.up.mkdirAll()\n            if (isMove) {\n              p.moveOverTo(t)\n            } else {\n              p.copyOverTo(t)\n            }\n            if (report) {\n              r = r + p ~> t\n            }\n          case Kind.SymLink if isMove =>\n            p.remove()\n          case _ =>\n        }\n      }\n      return r\n    }\n\n    def walk(path: Os.Path, includeDir: B, followLink: B, pred: Os.Path => B @pure): ISZ[Os.Path] = {\n      var rSet = HashSSet.empty[Os.Path]\n      var rIS = ISZ[Os.Path]()\n      def add(p: Os.Path): Unit = {\n        val pCanon = p.canon\n        if (followLink) {\n          rSet = rSet + pCanon\n        } else {\n          rIS = rIS :+ pCanon\n        }\n      }\n      def rec(p: Os.Path): Unit = {\n        if (!followLink && rSet.contains(p.canon)) {\n          return\n        }\n        p.kind match {\n          case Os.Path.Kind.Dir =>\n            if (includeDir && pred(p)) {\n              add(p)\n            }\n            for (p2 <- p.list) {\n              rec(p2)\n            }\n          case Os.Path.Kind.File if pred(p) => add(p)\n          case Os.Path.Kind.SymLink if followLink =>\n            if (pred(p)) {\n              add(p)\n            }\n            val tOpt = p.readSymLink\n            tOpt match {\n              case Some(t) => rec(t)\n              case _ =>\n            }\n          case _ =>\n        }\n      }\n      rec(path)\n      return if (followLink) rSet.map.keys else rIS\n    }\n\n  }\n\n  object Proc {\n\n    @sig sealed trait Result extends OsProto.Proc.Result\n\n    object Result {\n\n      @datatype class Normal(val exitCode: Z, val out: String, val err: String) extends Result\n\n      @datatype class Exception(val err: String) extends Result {\n        def out: String = {\n          return \"\"\n        }\n        def exitCode: Z = {\n          return -100\n        }\n      }\n\n      @datatype class Timeout(val out: String, val err: String) extends Result {\n        def exitCode: Z = {\n          return -101\n        }\n      }\n\n    }\n  }\n\n  @datatype class Proc(val cmds: ISZ[String],\n                       val wd: Path,\n                       val envMap: Map[String, String],\n                       val shouldAddEnv: B,\n                       val in: Option[String],\n                       val isErrAsOut: B,\n                       val shouldOutputConsole: B,\n                       val isErrBuffered: B,\n                       val shouldPrintEnv: B,\n                       val shouldPrintCommands: B,\n                       val timeoutInMillis: Z,\n                       val shouldUseStandardLib: B,\n                       val isScript: B,\n                       val outLineActionOpt: Option[String => B],\n                       val errLineActionOpt: Option[String => B]) extends OsProto.Proc {\n\n    @pure def commands(cs: ISZ[String]): Proc = {\n      val thisL = this\n      return thisL(cmds = cmds ++ cs)\n    }\n\n    @pure def at(dir: OsProto.Path): Proc = {\n      val thisL = this\n      return thisL(wd = Os.Path.Impl(dir.string))\n    }\n\n    @pure def env(m: ISZ[(String, String)]): Proc = {\n      val thisL = this\n      return thisL(envMap = this.envMap ++ m)\n    }\n\n    @pure def input(content: String): Proc = {\n      val thisL = this\n      return thisL(in = Some(content))\n    }\n\n    @pure def timeout(millis: Z): Proc = {\n      val thisL = this\n      return thisL(timeoutInMillis = millis)\n    }\n\n    @pure def dontInheritEnv: Proc = {\n      val thisL = this\n      return thisL(shouldAddEnv = F)\n    }\n\n    @pure def redirectErr: Proc = {\n      val thisL = this\n      return thisL(isErrAsOut = T)\n    }\n\n    @pure def bufferErr: Proc = {\n      val thisL = this\n      return thisL(isErrBuffered = T)\n    }\n\n    @pure def console: Proc = {\n      val thisL = this\n      return thisL(shouldOutputConsole = T)\n    }\n\n    @pure def echoEnv: Proc = {\n      val thisL = this\n      return thisL(shouldPrintEnv = T)\n    }\n\n    @pure def echo: Proc = {\n      val thisL = this\n      return thisL(shouldPrintCommands = T)\n    }\n\n    @pure def standard: Proc = {\n      val thisL = this\n      return thisL(shouldUseStandardLib = T)\n    }\n\n    @pure def script: Proc = {\n      val thisL = this\n      return thisL(isScript = T)\n    }\n\n    @pure def outLineAction(f: String => B): Proc = {\n      val thisL = this\n      return thisL(outLineActionOpt = Some(f))\n    }\n\n    @pure def errLineAction(f: String => B): Proc = {\n      val thisL = this\n      return thisL(errLineActionOpt = Some(f))\n    }\n\n    def run(): Proc.Result = {\n      val r = Ext.proc(this)\n      return r\n    }\n\n    def runCheck(): Proc.Result = {\n      val r = run()\n      if (!r.ok) {\n        eprintln(\n          st\"\"\"Error encountered when running: ${(cmds, \" \")}, exit code: ${r.exitCode}\n              |${r.err}\"\"\".render)\n        Os.exit(-1)\n      }\n      return r\n    }\n  }\n\n  @sig sealed trait Path extends OsProto.Path {\n\n    @pure def value: String\n\n    @strictpure def procString: String = ops.StringOps(value).replaceAllChars(\' \', \'␣\')\n\n    @pure def /(name: String): Path = {\n      return Path.Impl(s\"$value$fileSep$name\")\n    }\n\n    @pure def /+(names: ISZ[String]): Path = {\n      return Path.Impl(st\"$value$fileSep${(names, fileSep)}\".render)\n    }\n\n    def call(args: ISZ[String]): Os.Proc = {\n      return Os.proc(((if (Os.isWin) ISZ[String](\"cmd\", \"/c\") else ISZ[String](\"sh\")) :+ string) ++ args)\n    }\n\n    def canon: Path = {\n      val p = Ext.canon(value)\n      return if (p == value) this else Path.Impl(p)\n    }\n\n    def abs: Path = {\n      val p = Ext.abs(value)\n      return if (p == value) this else Path.Impl(p)\n    }\n\n    def chmod(mask: String): Unit = {\n      Ext.chmod(value, mask, F)\n    }\n\n    def chmodAll(mask: String): Unit = {\n      Ext.chmod(value, mask, T)\n    }\n\n    def copyTo(target: Path): Unit = {\n      Ext.copy(value, target.value, F)\n    }\n\n    def copyOverTo(target: Path): Unit = {\n      Ext.copy(value, target.value, T)\n    }\n\n    def downloadFrom(url: String): B = {\n      return Ext.download(value, url)\n    }\n\n    def exists: B = {\n      return Ext.exists(value)\n    }\n\n    @pure def ext: String = {\n      val nameOps = ops.StringOps(name)\n      val i = nameOps.lastIndexOf(\'.\')\n      return if (i >= 0) nameOps.substring(i + 1, name.size) else \"\"\n    }\n\n    def isAbs: B = {\n      return Ext.isAbs(value)\n    }\n\n    def isDir: B = {\n      return Ext.isDir(value)\n    }\n\n    def isFile: B = {\n      return Ext.isFile(value)\n    }\n\n    def isSymLink: B = {\n      return Ext.isSymLink(value)\n    }\n\n    def kind: Path.Kind.Type = {\n      return Ext.kind(value)\n    }\n\n    def lastModified: Z = {\n      return Ext.lastModified(value)\n    }\n\n    def length: Z = {\n      return Ext.length(value)\n    }\n\n    def list: ISZ[Path] = {\n      return for (filename <- Ext.list(value)) yield this / filename\n    }\n\n    def mergeFrom(sources: ISZ[Os.Path]): Unit = {\n      Ext.mergeFrom(value, for (p <- sources) yield p.value)\n    }\n\n    def md5: String = {\n      return Ext.md5(value)\n    }\n\n    def moveTo(target: Path): Unit = {\n      Ext.move(value, target.value, F)\n    }\n\n    def moveOverTo(target: Path): Unit = {\n      Ext.move(value, target.value, T)\n    }\n\n    def mkdir(): Unit = {\n      Ext.mkdir(value, F)\n    }\n\n    def mkdirAll(): Unit = {\n      Ext.mkdir(value, T)\n    }\n\n    def mklink(target: Path): Unit = {\n      Ext.mklink(value, target.value)\n    }\n\n    @pure def name: String = {\n      return Ext.name(value)\n    }\n\n    def overlayCopy(target: Os.Path, includeDir: B, followLink: B,\n                    pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      return Path.overlay(F, this, target, includeDir, followLink, pred, report)\n    }\n\n    def overlayMove(target: Os.Path, includeDir: B, followLink: B,\n                    pred: Os.Path => B @pure, report: B): HashSMap[Os.Path, Os.Path] = {\n      return Path.overlay(T, this, target, includeDir, followLink, pred, report)\n    }\n\n    def properties: Map[String, String] = {\n      return Ext.properties(value)\n    }\n\n    def readSymLink: Option[Path] = {\n      val r = Ext.readSymLink(value)\n      return r.map(o => Path.Impl(o))\n    }\n\n    @pure def relativize(other: Path): Path = {\n      return Path.Impl(Ext.relativize(value, other.value))\n    }\n\n    def read: String = {\n      return Ext.read(value)\n    }\n\n    def readLines: ISZ[String] = {\n      return Ext.readLineStream(value).toISZ\n    }\n\n    def readLineStream: Jen[String] = {\n      return Ext.readLineStream(value)\n    }\n\n    def readLineMStream: MJen[String] = {\n      return Ext.readLineMStream(value)\n    }\n\n    def readU8s: ISZ[U8] = {\n      return Ext.readU8s(value)\n    }\n\n    def readU8ms: MSZ[U8] = {\n      return Ext.readU8ms(value)\n    }\n\n    def readU8Stream: Jen[U8] = {\n      return Ext.readU8Stream(value)\n    }\n\n    def readU8MStream: MJen[U8] = {\n      return Ext.readU8MStream(value)\n    }\n\n    def readCStream: Jen[C] = {\n      return Ext.readCStream(value)\n    }\n\n    def readIndexableC: Indexable.Pos[C] = {\n      return Ext.readIndexableCPath(value)\n    }\n\n    def readCMStream: MJen[C] = {\n      return Ext.readCMStream(value)\n    }\n\n    def remove(): Unit = {\n      Ext.remove(value)\n    }\n\n    def removeAll(): Unit = {\n      Ext.removeAll(value)\n    }\n\n    def removeOnExit(): Unit = {\n      Ext.removeOnExit(value)\n    }\n\n    def sha1: String = {\n      return Ext.sha1(value)\n    }\n\n    def size: Z = {\n      return Ext.size(value)\n    }\n\n    def slash(args: ISZ[String]): Unit = {\n      val nativ = this / \".com\"\n      if (nativ.exists && this.lastModified < nativ.lastModified) {\n        Os.proc(string +: args).console.runCheck()\n      } else {\n        nativ.removeAll()\n        proc(string +: args).script.console.runCheck()\n      }\n    }\n\n    def toUri: String = {\n      return Ext.toUri(value)\n    }\n\n    def write(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOver(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppend(content: String): Unit = {\n      Ext.write(value, content, Path.WriteMode.Append)\n    }\n\n    def writeLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendLineStream(content: Jen[String]): Unit = {\n      Ext.writeLineStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendLineMStream(content: MJen[String]): Unit = {\n      Ext.writeLineMStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Regular)\n    }\n\n    def writeU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Over)\n    }\n\n    def writeOverU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8s(content: ISZ[U8]): Unit = {\n      Ext.writeU8s(value, content, 0, content.size, Path.WriteMode.Append)\n    }\n\n    def writeAppendU8Parts(content: ISZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8s(value, content, offset, len, Path.WriteMode.Append)\n    }\n\n    def writeU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Regular)\n    }\n\n    def writeU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Over)\n    }\n\n    def writeOverU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8ms(content: MSZ[U8]): Unit = {\n      Ext.writeU8ms(value, content, 0, content.size, Path.WriteMode.Append)\n    }\n\n    def writeAppendU8Partms(content: MSZ[U8], offset: Z, len: Z): Unit = {\n      Ext.writeU8ms(value, content, offset, len, Path.WriteMode.Append)\n    }\n\n    def writeU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8Stream(content: Jen[U8]): Unit = {\n      Ext.writeU8Stream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendU8MStream(content: MJen[U8]): Unit = {\n      Ext.writeU8MStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendCStream(content: Jen[C]): Unit = {\n      Ext.writeCStream(value, content, Path.WriteMode.Append)\n    }\n\n    def writeCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Regular)\n    }\n\n    def writeOverCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Over)\n    }\n\n    def writeAppendCMStream(content: MJen[C]): Unit = {\n      Ext.writeCMStream(value, content, Path.WriteMode.Append)\n    }\n\n    def zipTo(target: Os.Path): Unit = {\n      Ext.zip(value, target.value)\n    }\n\n    def unzipTo(target: Os.Path): Unit = {\n      Ext.unzip(value, target.value)\n    }\n\n    @pure def up: Path = {\n      return Path.Impl(Ext.parent(value))\n    }\n  }\n\n  @ext(\"Os_Ext\") object Ext {\n\n    @pure def cliArgs: ISZ[String] = $\n\n    @pure def cwd: String = $\n\n    @pure def fileSep: String = $\n\n    @pure def home: String = $\n\n    @pure def lineSep: String = $\n\n    @pure def pathSep: String = $\n\n    @pure def pathSepChar: C = $\n\n    @pure def os: Kind.Type = $\n\n    def roots: ISZ[String] = $\n\n    def abs(path: String): String = $\n\n    def canon(path: String): String = $\n\n    def chm
         3: areturn
      LineNumberTable:
        line 42: 0

  private static final java.lang.String f1$9();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #786                // String od(path: String, mask: String, all: B): Unit = $\n\n    def copy(path: String, target: String, over: B): Unit = $\n\n    def download(path: String, url: String): B = $\n\n    def env(name: String): Option[String] = $\n\n    def envs: Map[String, String] = $\n\n    def exists(path: String): B = $\n\n    def exit(code: Z): Unit = $\n\n    def fromUri(uri: String): String = $\n\n    @pure def isAbs(path: String): B = $\n\n    def isDir(path: String): B = $\n\n    def isFile(path: String): B = $\n\n    def isSymLink(path: String): B = $\n\n    def kind(path: String): Path.Kind.Type = $\n\n    def lastModified(path: String): Z = $\n\n    def length(path: String): Z = $\n\n    def list(path: String): ISZ[String] = $\n\n    def mergeFrom(path: String, sources: ISZ[String]): Unit = $\n\n    def md5(path: String): String = $\n\n    def move(path: String, target: String, over: B): Unit = $\n\n    def mkdir(path: String, all: B): Unit = $\n\n    def mklink(path: String, target: String): Unit = $\n\n    @pure def name(path: String): String = $\n\n    @pure def norm(path: String): String = $\n\n    def properties(path: String): Map[String, String] = $\n\n    def readSymLink(path: String): Option[String] = $\n\n    @pure def relativize(path: String, other: String): String = $\n\n    def read(path: String): String = $\n\n    def readU8s(path: String): ISZ[U8] = $\n\n    def readU8ms(path: String): MSZ[U8] = $\n\n    def readLineStream(path: String): Path.Jen[String] = $\n\n    def readU8Stream(path: String): Path.Jen[U8] = $\n\n    def readCStream(path: String): Path.Jen[C] = $\n\n    def readIndexableCPath(path: String): Indexable.Pos[C] = $\n\n    def readIndexableCUrl(url: String): Indexable.Pos[C] = $\n\n    def readLineMStream(path: String): Path.MJen[String] = $\n\n    def readCMStream(path: String): Path.MJen[C] = $\n\n    def readU8MStream(path: String): Path.MJen[U8] = $\n\n    def remove(path: String): Unit = $\n\n    def removeAll(path: String): Unit = $\n\n    def removeOnExit(path: String): Unit = $\n\n    def sha1(path: String): String = $\n\n    def slashDir: String = $\n\n    def size(path: String): Z = $\n\n    def temp(prefix: String, suffix: String): String = $\n\n    def tempDir(prefix: String): String = $\n\n    def toUri(path: String): String = $\n\n    def write(path: String, content: String, mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8s(path: String, u8s: ISZ[U8], offset: Z, len: Z, mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8ms(path: String, u8s: MSZ[U8], offset: Z, len: Z, mode: Path.WriteMode.Type): Unit = $\n\n    def writeLineStream(path: String, lines: Jen[String], mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8Stream(path: String, u8s: Jen[U8], mode: Path.WriteMode.Type): Unit = $\n\n    def writeCStream(path: String, cs: Jen[C], mode: Path.WriteMode.Type): Unit = $\n\n    def writeLineMStream(path: String, lines: MJen[String], mode: Path.WriteMode.Type): Unit = $\n\n    def writeU8MStream(path: String, u8s: MJen[U8], mode: Path.WriteMode.Type): Unit = $\n\n    def writeCMStream(path: String, cs: MJen[C], mode: Path.WriteMode.Type): Unit = $\n\n    def zip(path: String, target: String): Unit = $\n\n    def unzip(path: String, target: String): Unit = $\n\n    @pure def parent(path: String): String = $\n\n    def proc(e: Proc): Proc.Result = $\n\n  }\n\n}\n\n
         3: areturn
      LineNumberTable:
        line 42: 0

  private static final java.lang.String f0$63();
    descriptor: ()Ljava/lang/String;
    flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=0, args_size=0
         0: ldc_w         #788                // String // #Sireum\n/*\n Copyright (c) 2017-2022, Robby, Kansas State University\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.sireum\n\n\n@enum object CoursierClassifier {\n  \'Default\n  \'Javadoc\n  \'Sources\n  \'Tests\n}\n\n@datatype class CoursierFileInfo(val org: String,\n                                 val module: String,\n                                 val version: String,\n                                 val path: Os.Path)\n\n@ext object Coursier {\n\n  def cacheOpt: Option[Os.Path] = $\n\n  def scalaVersion: String = $\n\n  def setScalaVersion(version: String): Unit = $\n\n  def setCache(pathOpt: Option[Os.Path]): Unit = $\n\n  def addMavenRepositories(urls: ISZ[String]): Unit = $\n\n  def setMavenRepositories(urls: ISZ[String]): Unit = $\n\n  def mavenRepoUrls: ISZ[String] = $\n\n  def fetch(deps: ISZ[String]): ISZ[CoursierFileInfo] = $\n\n  def fetchClassifiers(deps: ISZ[String], cls: ISZ[CoursierClassifier.Type]): ISZ[CoursierFileInfo] = $\n\n  def isRuntimePublishedLocally(version: String): B = $\n}\n
         3: areturn
      LineNumberTable:
        line 42: 0

  public static final scala.Tuple2 $anonfun$sharedFiles$1(scala.Tuple2);
    descriptor: (Lscala/Tuple2;)Lscala/Tuple2;
    flags: (0x1019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC
    Code:
      stack=8, locals=1, args_size=1
         0: new           #44                 // class scala/Tuple2
         3: dup
         4: getstatic     #794                // Field org/sireum/Some$.MODULE$:Lorg/sireum/Some$;
         7: new           #796                // class org/sireum/String
        10: dup
        11: getstatic     #801                // Field org/sireum/String$.MODULE$:Lorg/sireum/String$;
        14: aload_0
        15: invokevirtual #805                // Method scala/Tuple2._1:()Ljava/lang/Object;
        18: checkcast     #807                // class scala/collection/IterableOnceOps
        21: ldc_w         #809                // String /
        24: invokeinterface #813,  2          // InterfaceMethod scala/collection/IterableOnceOps.mkString:(Ljava/lang/String;)Ljava/lang/String;
        29: invokevirtual #815                // Method org/sireum/String$.apply:(Ljava/lang/String;)Ljava/lang/String;
        32: invokespecial #818                // Method org/sireum/String."<init>":(Ljava/lang/String;)V
        35: invokevirtual #821                // Method org/sireum/Some$.apply:(Ljava/lang/Object;)Lorg/sireum/Some;
        38: new           #796                // class org/sireum/String
        41: dup
        42: getstatic     #801                // Field org/sireum/String$.MODULE$:Lorg/sireum/String$;
        45: aload_0
        46: invokevirtual #824                // Method scala/Tuple2._2:()Ljava/lang/Object;
        49: checkcast     #55                 // class java/lang/String
        52: invokevirtual #815                // Method org/sireum/String$.apply:(Ljava/lang/String;)Ljava/lang/String;
        55: invokespecial #818                // Method org/sireum/String."<init>":(Ljava/lang/String;)V
        58: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
        61: areturn
      LineNumberTable:
        line 57: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      62     0     p   Lscala/Tuple2;
    MethodParameters:
      Name                           Flags
      p                              final

  public static final scala.Tuple2 $anonfun$jvmFiles$1(scala.Tuple2);
    descriptor: (Lscala/Tuple2;)Lscala/Tuple2;
    flags: (0x1019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC
    Code:
      stack=8, locals=1, args_size=1
         0: new           #44                 // class scala/Tuple2
         3: dup
         4: getstatic     #794                // Field org/sireum/Some$.MODULE$:Lorg/sireum/Some$;
         7: new           #796                // class org/sireum/String
        10: dup
        11: getstatic     #801                // Field org/sireum/String$.MODULE$:Lorg/sireum/String$;
        14: aload_0
        15: invokevirtual #805                // Method scala/Tuple2._1:()Ljava/lang/Object;
        18: checkcast     #807                // class scala/collection/IterableOnceOps
        21: ldc_w         #809                // String /
        24: invokeinterface #813,  2          // InterfaceMethod scala/collection/IterableOnceOps.mkString:(Ljava/lang/String;)Ljava/lang/String;
        29: invokevirtual #815                // Method org/sireum/String$.apply:(Ljava/lang/String;)Ljava/lang/String;
        32: invokespecial #818                // Method org/sireum/String."<init>":(Ljava/lang/String;)V
        35: invokevirtual #821                // Method org/sireum/Some$.apply:(Ljava/lang/Object;)Lorg/sireum/Some;
        38: new           #796                // class org/sireum/String
        41: dup
        42: getstatic     #801                // Field org/sireum/String$.MODULE$:Lorg/sireum/String$;
        45: aload_0
        46: invokevirtual #824                // Method scala/Tuple2._2:()Ljava/lang/Object;
        49: checkcast     #55                 // class java/lang/String
        52: invokevirtual #815                // Method org/sireum/String$.apply:(Ljava/lang/String;)Ljava/lang/String;
        55: invokespecial #818                // Method org/sireum/String."<init>":(Ljava/lang/String;)V
        58: invokespecial #80                 // Method scala/Tuple2."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
        61: areturn
      LineNumberTable:
        line 61: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      62     0     p   Lscala/Tuple2;
    MethodParameters:
      Name                           Flags
      p                              final

  private org.sireum.Library_Ext$();
    descriptor: ()V
    flags: (0x0002) ACC_PRIVATE
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #826                // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 30: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lorg/sireum/Library_Ext$;

  private static java.lang.Object $deserializeLambda$(java.lang.invoke.SerializedLambda);
    descriptor: (Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokedynamic #838,  0            // InvokeDynamic #2:lambdaDeserialize:(Ljava/lang/invoke/SerializedLambda;)Ljava/lang/Object;
         6: areturn
}
InnerClasses:
  public static final #10= #7 of #9;      // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles
  public #15= #12 of #14;                 // ISZ$=class org/sireum/$internal/PackageTrait$ISZ$ of class org/sireum/$internal/PackageTrait
  public static #20= #17 of #19;          // Node=class org/sireum/$internal/Trie$Node of class org/sireum/$internal/Trie
SourceFile: "Library_Ext.scala"
BootstrapMethods:
  0: #572 REF_invokeStatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #557 (Ljava/lang/Object;)Ljava/lang/Object;
      #562 REF_invokeStatic org/sireum/Library_Ext$.$anonfun$sharedFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
      #563 (Lscala/Tuple2;)Lscala/Tuple2;
      #564 5
      #565 1
      #563 (Lscala/Tuple2;)Lscala/Tuple2;
  1: #572 REF_invokeStatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #557 (Ljava/lang/Object;)Ljava/lang/Object;
      #589 REF_invokeStatic org/sireum/Library_Ext$.$anonfun$jvmFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
      #563 (Lscala/Tuple2;)Lscala/Tuple2;
      #564 5
      #565 1
      #563 (Lscala/Tuple2;)Lscala/Tuple2;
  2: #835 REF_invokeStatic scala/runtime/LambdaDeserialize.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #589 REF_invokeStatic org/sireum/Library_Ext$.$anonfun$jvmFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
      #562 REF_invokeStatic org/sireum/Library_Ext$.$anonfun$sharedFiles$1:(Lscala/Tuple2;)Lscala/Tuple2;
  ScalaInlineInfo: length = 0x207 (unknown attribute)
   01 01 00 67 02 4A 02 2F 01 02 2E 02 2F 01 00 19
   00 18 01 00 4A 00 4B 01 00 7F 00 4B 01 00 84 00
   4B 01 00 89 00 4B 01 00 8E 00 4B 01 00 93 00 4B
   01 00 98 00 4B 01 00 9F 00 4B 01 00 AA 00 4B 01
   00 C5 00 4B 01 00 CA 00 4B 01 00 53 00 4B 01 00
   CF 00 4B 01 00 D4 00 4B 01 00 D9 00 4B 01 00 E0
   00 4B 01 00 E5 00 4B 01 00 EA 00 4B 01 00 F1 00
   4B 01 00 F9 00 4B 01 00 FE 00 4B 01 01 05 00 4B
   01 00 58 00 4B 01 01 0A 00 4B 01 01 12 00 4B 01
   01 20 00 4B 01 01 25 00 4B 01 01 2A 00 4B 01 01
   2F 00 4B 01 01 34 00 4B 01 01 39 00 4B 01 01 3E
   00 4B 01 01 43 00 4B 01 00 5F 00 4B 01 01 51 00
   4B 01 01 56 00 4B 01 01 5B 00 4B 01 01 60 00 4B
   01 01 65 00 4B 01 01 6C 00 4B 01 01 71 00 4B 01
   01 7B 00 4B 01 01 80 00 4B 01 01 85 00 4B 01 00
   64 00 4B 01 01 8A 00 4B 01 01 95 00 4B 01 01 C4
   00 4B 01 01 C9 00 4B 01 01 CE 00 4B 01 01 D3 00
   4B 01 01 D8 00 4B 01 01 DD 00 4B 01 01 E7 00 4B
   01 01 EC 00 4B 01 00 69 00 4B 01 01 F1 00 4B 01
   01 F6 00 4B 01 01 FB 00 4B 01 02 03 00 4B 01 00
   6E 00 4B 01 00 73 00 4B 01 00 7A 00 4B 01 00 B1
   00 4B 01 00 F4 00 4B 01 01 0D 00 4B 01 01 15 00
   4B 01 01 46 00 4B 01 01 74 00 4B 01 01 8D 00 4B
   01 01 98 00 4B 01 01 FE 00 4B 01 01 B3 00 4B 01
   01 B6 00 4B 01 01 B9 00 4B 01 01 BC 00 4B 01 01
   BF 00 4B 01 00 B4 00 4B 01 01 18 00 4B 01 01 49
   00 4B 01 01 90 00 4B 01 01 9B 00 4B 01 00 B7 00
   4B 01 01 1B 00 4B 01 01 4C 00 4B 01 01 9E 00 4B
   01 00 BA 00 4B 01 01 A1 00 4B 01 00 BD 00 4B 01
   01 A4 00 4B 01 01 A7 00 4B 01 01 AA 00 4B 01 01
   AD 00 4B 01 01 B0 00 4B 01 02 4F 02 1D 01 02 49
   02 1D 01 01 E4 00 1F 01 02 1C 02 1D 01 00 1E 00
   1F 01 02 06 02 07 01
  Scala: length = 0x0 (unknown attribute)

